! function (t) {
    function e(e) {
        for (var i, a, o = e[0], l = e[1], c = e[2], u = 0, d = []; u < o.length; u++) a = o[u], Object.prototype.hasOwnProperty.call(r, a) && r[a] && d.push(r[a][0]), r[a] = 0;
        for (i in l) Object.prototype.hasOwnProperty.call(l, i) && (t[i] = l[i]);
        for (h && h(e); d.length;) d.shift()();
        return s.push.apply(s, c || []), n()
    }

    function n() {
        for (var t, e = 0; e < s.length; e++) {
            for (var n = s[e], i = !0, o = 1; o < n.length; o++) {
                var l = n[o];
                0 !== r[l] && (i = !1)
            }
            i && (s.splice(e--, 1), t = a(a.s = n[0]))
        }
        return t
    }
    var i = {},
        r = {
            0: 0
        },
        s = [];

    function a(e) {
        if (i[e]) return i[e].exports;
        var n = i[e] = {
            i: e,
            l: !1,
            exports: {}
        };
        return t[e].call(n.exports, n, n.exports, a), n.l = !0, n.exports
    }
    a.m = t, a.c = i, a.d = function (t, e, n) {
        a.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: n
        })
    }, a.r = function (t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, a.t = function (t, e) {
        if (1 & e && (t = a(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var n = Object.create(null);
        if (a.r(n), Object.defineProperty(n, "default", {
            enumerable: !0,
            value: t
        }), 2 & e && "string" != typeof t)
            for (var i in t) a.d(n, i, function (e) {
                return t[e]
            }.bind(null, i));
        return n
    }, a.n = function (t) {
        var e = t && t.__esModule ? function () {
            return t.default
        } : function () {
            return t
        };
        return a.d(e, "a", e), e
    }, a.o = function (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, a.p = "";
    var o = window.webpackJsonp = window.webpackJsonp || [],
        l = o.push.bind(o);
    o.push = e, o = o.slice();
    for (var c = 0; c < o.length; c++) e(o[c]);
    var h = l;
    n()
}([function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return S
    })), n.d(e, "b", (function () {
        return h
    })), n.d(e, "c", (function () {
        return d
    })), n.d(e, "d", (function () {
        return Ya
    })), n.d(e, "e", (function () {
        return o
    })), n.d(e, "f", (function () {
        return H
    })), n.d(e, "g", (function () {
        return Ut
    })), n.d(e, "h", (function () {
        return an
    })), n.d(e, "i", (function () {
        return vn
    })), n.d(e, "j", (function () {
        return jn
    })), n.d(e, "k", (function () {
        return ra
    })), n.d(e, "l", (function () {
        return w
    })), n.d(e, "m", (function () {
        return E
    })), n.d(e, "n", (function () {
        return Za
    })), n.d(e, "o", (function () {
        return tn
    })), n.d(e, "p", (function () {
        return Ua
    })), n.d(e, "q", (function () {
        return sa
    })), n.d(e, "r", (function () {
        return aa
    })), n.d(e, "s", (function () {
        return Ot
    })), n.d(e, "t", (function () {
        return $s
    })), n.d(e, "u", (function () {
        return N
    })), n.d(e, "v", (function () {
        return U
    })), n.d(e, "w", (function () {
        return Rs
    })), n.d(e, "x", (function () {
        return l
    })), n.d(e, "y", (function () {
        return m
    })), n.d(e, "z", (function () {
        return W
    })), n.d(e, "A", (function () {
        return ka
    })), n.d(e, "B", (function () {
        return cn
    })), n.d(e, "C", (function () {
        return L
    })), n.d(e, "D", (function () {
        return ks
    })), n.d(e, "E", (function () {
        return a
    })), n.d(e, "F", (function () {
        return v
    })), n.d(e, "G", (function () {
        return g
    })), n.d(e, "H", (function () {
        return Ts
    })), n.d(e, "I", (function () {
        return O
    })), n.d(e, "J", (function () {
        return Ka
    })), n.d(e, "K", (function () {
        return so
    })), n.d(e, "L", (function () {
        return Fs
    })), n.d(e, "M", (function () {
        return _e
    })), n.d(e, "N", (function () {
        return p
    })), n.d(e, "O", (function () {
        return f
    })), n.d(e, "P", (function () {
        return po
    })), n.d(e, "Q", (function () {
        return Bs
    })), n.d(e, "R", (function () {
        return Ks
    })), n.d(e, "S", (function () {
        return $
    })), n.d(e, "T", (function () {
        return C
    })), n.d(e, "U", (function () {
        return A
    })), n.d(e, "V", (function () {
        return G
    })), n.d(e, "W", (function () {
        return x
    })), n.d(e, "X", (function () {
        return Oa
    })), n.d(e, "Y", (function () {
        return Pa
    })), n.d(e, "Z", (function () {
        return k
    })), n.d(e, "ab", (function () {
        return r
    })), n.d(e, "bb", (function () {
        return Ye
    })), n.d(e, "cb", (function () {
        return at
    })), n.d(e, "db", (function () {
        return he
    })), n.d(e, "eb", (function () {
        return kn
    })), n.d(e, "fb", (function () {
        return nn
    })), n.d(e, "gb", (function () {
        return bs
    })), n.d(e, "hb", (function () {
        return pa
    })), n.d(e, "ib", (function () {
        return da
    })), n.d(e, "jb", (function () {
        return ua
    })), n.d(e, "kb", (function () {
        return T
    })), n.d(e, "lb", (function () {
        return u
    })), n.d(e, "mb", (function () {
        return c
    })), n.d(e, "nb", (function () {
        return b
    })), n.d(e, "ob", (function () {
        return y
    })), n.d(e, "pb", (function () {
        return ke
    })), n.d(e, "qb", (function () {
        return fi
    })), n.d(e, "rb", (function () {
        return Vn
    })), n.d(e, "sb", (function () {
        return Zn
    })), n.d(e, "tb", (function () {
        return ii
    })), n.d(e, "ub", (function () {
        return Xa
    })), n.d(e, "vb", (function () {
        return fo
    })), n.d(e, "wb", (function () {
        return na
    })), n.d(e, "xb", (function () {
        return Zs
    })), n.d(e, "yb", (function () {
        return Dt
    })), n.d(e, "zb", (function () {
        return i
    })), n.d(e, "Ab", (function () {
        return j
    })), n.d(e, "Bb", (function () {
        return I
    })), n.d(e, "Cb", (function () {
        return F
    })), n.d(e, "Db", (function () {
        return ha
    })), n.d(e, "Eb", (function () {
        return ce
    })), n.d(e, "Fb", (function () {
        return ao
    })), n.d(e, "Gb", (function () {
        return z
    })), n.d(e, "Hb", (function () {
        return _
    })), n.d(e, "Ib", (function () {
        return M
    })), n.d(e, "Jb", (function () {
        return V
    })), n.d(e, "Kb", (function () {
        return Ns
    })), n.d(e, "Lb", (function () {
        return ri
    })), n.d(e, "Mb", (function () {
        return ai
    })), n.d(e, "Nb", (function () {
        return Hn
    })), n.d(e, "Ob", (function () {
        return ee
    })), n.d(e, "Pb", (function () {
        return co
    })), n.d(e, "Qb", (function () {
        return s
    })), n.d(e, "Rb", (function () {
        return Ct
    })), n.d(e, "Sb", (function () {
        return za
    })), n.d(e, "Tb", (function () {
        return ro
    })), n.d(e, "Ub", (function () {
        return si
    })), n.d(e, "Vb", (function () {
        return Bn
    })), n.d(e, "Wb", (function () {
        return R
    })), n.d(e, "Xb", (function () {
        return D
    })), n.d(e, "Yb", (function () {
        return P
    })), n.d(e, "Zb", (function () {
        return ot
    })), n.d(e, "ac", (function () {
        return It
    })), n.d(e, "bc", (function () {
        return At
    })), n.d(e, "cc", (function () {
        return Pt
    })), n.d(e, "dc", (function () {
        return Is
    })), n.d(e, "ec", (function () {
        return la
    })), n.d(e, "fc", (function () {
        return B
    }));
    /**
     * @license
     * Copyright 2010-2023 Three.js Authors
     * SPDX-License-Identifier: MIT
     */
    const i = "155",
        r = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2
        },
        s = {
            ROTATE: 0,
            PAN: 1,
            DOLLY_PAN: 2,
            DOLLY_ROTATE: 3
        },
        a = 0,
        o = 1,
        l = 2,
        c = 0,
        h = 2,
        u = 0,
        d = 1,
        p = 2,
        f = 3,
        m = 4,
        g = 5,
        v = 6,
        y = 7,
        b = 0,
        x = 1,
        _ = 2,
        w = 3,
        S = 4,
        M = 1e3,
        E = 1001,
        T = 1003,
        C = 1006,
        A = 1008,
        R = 1009,
        P = 1014,
        L = 1015,
        O = 1016,
        D = 1020,
        I = 1023,
        k = 1024,
        N = 1026,
        U = 1027,
        z = 1028,
        F = 1030,
        $ = 3e3,
        B = 3001,
        H = 3200,
        j = 3201,
        V = "srgb",
        G = "srgb-linear";
    class W {
        addEventListener(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
        }
        hasEventListener(t, e) {
            if (void 0 === this._listeners) return !1;
            const n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e)
        }
        removeEventListener(t, e) {
            if (void 0 === this._listeners) return;
            const n = this._listeners[t];
            if (void 0 !== n) {
                const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
            }
        }
        dispatchEvent(t) {
            if (void 0 === this._listeners) return;
            const e = this._listeners[t.type];
            if (void 0 !== e) {
                t.target = this;
                const n = e.slice(0);
                for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
                t.target = null
            }
        }
    }
    const q = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
    let X = 1234567;
    const Y = Math.PI / 180,
        K = 180 / Math.PI;

    function Z() {
        const t = 4294967295 * Math.random() | 0,
            e = 4294967295 * Math.random() | 0,
            n = 4294967295 * Math.random() | 0,
            i = 4294967295 * Math.random() | 0;
        return (q[255 & t] + q[t >> 8 & 255] + q[t >> 16 & 255] + q[t >> 24 & 255] + "-" + q[255 & e] + q[e >> 8 & 255] + "-" + q[e >> 16 & 15 | 64] + q[e >> 24 & 255] + "-" + q[63 & n | 128] + q[n >> 8 & 255] + "-" + q[n >> 16 & 255] + q[n >> 24 & 255] + q[255 & i] + q[i >> 8 & 255] + q[i >> 16 & 255] + q[i >> 24 & 255]).toLowerCase()
    }

    function J(t, e, n) {
        return Math.max(e, Math.min(n, t))
    }

    function Q(t, e) {
        return (t % e + e) % e
    }

    function tt(t, e, n) {
        return (1 - n) * t + n * e
    }

    function et(t) {
        return 0 == (t & t - 1) && 0 !== t
    }

    function nt(t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
    }

    function it(t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
    }

    function rt(t, e) {
        switch (e.constructor) {
            case Float32Array:
                return t;
            case Uint32Array:
                return t / 4294967295;
            case Uint16Array:
                return t / 65535;
            case Uint8Array:
                return t / 255;
            case Int32Array:
                return Math.max(t / 2147483647, -1);
            case Int16Array:
                return Math.max(t / 32767, -1);
            case Int8Array:
                return Math.max(t / 127, -1);
            default:
                throw new Error("Invalid component type.")
        }
    }

    function st(t, e) {
        switch (e.constructor) {
            case Float32Array:
                return t;
            case Uint32Array:
                return Math.round(4294967295 * t);
            case Uint16Array:
                return Math.round(65535 * t);
            case Uint8Array:
                return Math.round(255 * t);
            case Int32Array:
                return Math.round(2147483647 * t);
            case Int16Array:
                return Math.round(32767 * t);
            case Int8Array:
                return Math.round(127 * t);
            default:
                throw new Error("Invalid component type.")
        }
    }
    const at = {
        DEG2RAD: Y,
        RAD2DEG: K,
        generateUUID: Z,
        clamp: J,
        euclideanModulo: Q,
        mapLinear: function (t, e, n, i, r) {
            return i + (t - e) * (r - i) / (n - e)
        },
        inverseLerp: function (t, e, n) {
            return t !== e ? (n - t) / (e - t) : 0
        },
        lerp: tt,
        damp: function (t, e, n, i) {
            return tt(t, e, 1 - Math.exp(-n * i))
        },
        pingpong: function (t, e = 1) {
            return e - Math.abs(Q(t, 2 * e) - e)
        },
        smoothstep: function (t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
        },
        smootherstep: function (t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
        },
        randInt: function (t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        },
        randFloat: function (t, e) {
            return t + Math.random() * (e - t)
        },
        randFloatSpread: function (t) {
            return t * (.5 - Math.random())
        },
        seededRandom: function (t) {
            void 0 !== t && (X = t);
            let e = X += 1831565813;
            return e = Math.imul(e ^ e >>> 15, 1 | e), e ^= e + Math.imul(e ^ e >>> 7, 61 | e), ((e ^ e >>> 14) >>> 0) / 4294967296
        },
        degToRad: function (t) {
            return t * Y
        },
        radToDeg: function (t) {
            return t * K
        },
        isPowerOfTwo: et,
        ceilPowerOfTwo: nt,
        floorPowerOfTwo: it,
        setQuaternionFromProperEuler: function (t, e, n, i, r) {
            const s = Math.cos,
                a = Math.sin,
                o = s(n / 2),
                l = a(n / 2),
                c = s((e + i) / 2),
                h = a((e + i) / 2),
                u = s((e - i) / 2),
                d = a((e - i) / 2),
                p = s((i - e) / 2),
                f = a((i - e) / 2);
            switch (r) {
                case "XYX":
                    t.set(o * h, l * u, l * d, o * c);
                    break;
                case "YZY":
                    t.set(l * d, o * h, l * u, o * c);
                    break;
                case "ZXZ":
                    t.set(l * u, l * d, o * h, o * c);
                    break;
                case "XZX":
                    t.set(o * h, l * f, l * p, o * c);
                    break;
                case "YXY":
                    t.set(l * p, o * h, l * f, o * c);
                    break;
                case "ZYZ":
                    t.set(l * f, l * p, o * h, o * c);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
            }
        },
        normalize: st,
        denormalize: rt
    };
    class ot {
        constructor(t = 0, e = 0) {
            ot.prototype.isVector2 = !0, this.x = t, this.y = e
        }
        get width() {
            return this.x
        }
        set width(t) {
            this.x = t
        }
        get height() {
            return this.y
        }
        set height(t) {
            this.y = t
        }
        set(t, e) {
            return this.x = t, this.y = e, this
        }
        setScalar(t) {
            return this.x = t, this.y = t, this
        }
        setX(t) {
            return this.x = t, this
        }
        setY(t) {
            return this.y = t, this
        }
        setComponent(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y)
        }
        copy(t) {
            return this.x = t.x, this.y = t.y, this
        }
        add(t) {
            return this.x += t.x, this.y += t.y, this
        }
        addScalar(t) {
            return this.x += t, this.y += t, this
        }
        addVectors(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this
        }
        addScaledVector(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this
        }
        sub(t) {
            return this.x -= t.x, this.y -= t.y, this
        }
        subScalar(t) {
            return this.x -= t, this.y -= t, this
        }
        subVectors(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this
        }
        multiply(t) {
            return this.x *= t.x, this.y *= t.y, this
        }
        multiplyScalar(t) {
            return this.x *= t, this.y *= t, this
        }
        divide(t) {
            return this.x /= t.x, this.y /= t.y, this
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t)
        }
        applyMatrix3(t) {
            const e = this.x,
                n = this.y,
                i = t.elements;
            return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
        }
        min(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
        }
        max(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
        }
        clamp(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
        }
        clampScalar(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
        }
        clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y
        }
        cross(t) {
            return this.x * t.y - this.y * t.x
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }
        angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(J(n, -1, 1))
        }
        distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t) {
            const e = this.x - t.x,
                n = this.y - t.y;
            return e * e + n * n
        }
        manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
        }
        lerpVectors(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
        }
        equals(t) {
            return t.x === this.x && t.y === this.y
        }
        fromArray(t, e = 0) {
            return this.x = t[e], this.y = t[e + 1], this
        }
        toArray(t = [], e = 0) {
            return t[e] = this.x, t[e + 1] = this.y, t
        }
        fromBufferAttribute(t, e) {
            return this.x = t.getX(e), this.y = t.getY(e), this
        }
        rotateAround(t, e) {
            const n = Math.cos(e),
                i = Math.sin(e),
                r = this.x - t.x,
                s = this.y - t.y;
            return this.x = r * n - s * i + t.x, this.y = r * i + s * n + t.y, this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this
        } *[Symbol.iterator]() {
            yield this.x, yield this.y
        }
    }
    class lt {
        constructor(t, e, n, i, r, s, a, o, l) {
            lt.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, i, r, s, a, o, l)
        }
        set(t, e, n, i, r, s, a, o, l) {
            const c = this.elements;
            return c[0] = t, c[1] = i, c[2] = a, c[3] = e, c[4] = r, c[5] = o, c[6] = n, c[7] = s, c[8] = l, this
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        }
        copy(t) {
            const e = this.elements,
                n = t.elements;
            return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
        }
        extractBasis(t, e, n) {
            return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
        }
        setFromMatrix4(t) {
            const e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        }
        multiply(t) {
            return this.multiplyMatrices(this, t)
        }
        premultiply(t) {
            return this.multiplyMatrices(t, this)
        }
        multiplyMatrices(t, e) {
            const n = t.elements,
                i = e.elements,
                r = this.elements,
                s = n[0],
                a = n[3],
                o = n[6],
                l = n[1],
                c = n[4],
                h = n[7],
                u = n[2],
                d = n[5],
                p = n[8],
                f = i[0],
                m = i[3],
                g = i[6],
                v = i[1],
                y = i[4],
                b = i[7],
                x = i[2],
                _ = i[5],
                w = i[8];
            return r[0] = s * f + a * v + o * x, r[3] = s * m + a * y + o * _, r[6] = s * g + a * b + o * w, r[1] = l * f + c * v + h * x, r[4] = l * m + c * y + h * _, r[7] = l * g + c * b + h * w, r[2] = u * f + d * v + p * x, r[5] = u * m + d * y + p * _, r[8] = u * g + d * b + p * w, this
        }
        multiplyScalar(t) {
            const e = this.elements;
            return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
        }
        determinant() {
            const t = this.elements,
                e = t[0],
                n = t[1],
                i = t[2],
                r = t[3],
                s = t[4],
                a = t[5],
                o = t[6],
                l = t[7],
                c = t[8];
            return e * s * c - e * a * l - n * r * c + n * a * o + i * r * l - i * s * o
        }
        invert() {
            const t = this.elements,
                e = t[0],
                n = t[1],
                i = t[2],
                r = t[3],
                s = t[4],
                a = t[5],
                o = t[6],
                l = t[7],
                c = t[8],
                h = c * s - a * l,
                u = a * o - c * r,
                d = l * r - s * o,
                p = e * h + n * u + i * d;
            if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const f = 1 / p;
            return t[0] = h * f, t[1] = (i * l - c * n) * f, t[2] = (a * n - i * s) * f, t[3] = u * f, t[4] = (c * e - i * o) * f, t[5] = (i * r - a * e) * f, t[6] = d * f, t[7] = (n * o - l * e) * f, t[8] = (s * e - n * r) * f, this
        }
        transpose() {
            let t;
            const e = this.elements;
            return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
        }
        getNormalMatrix(t) {
            return this.setFromMatrix4(t).invert().transpose()
        }
        transposeIntoArray(t) {
            const e = this.elements;
            return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
        }
        setUvTransform(t, e, n, i, r, s, a) {
            const o = Math.cos(r),
                l = Math.sin(r);
            return this.set(n * o, n * l, -n * (o * s + l * a) + s + t, -i * l, i * o, -i * (-l * s + o * a) + a + e, 0, 0, 1), this
        }
        scale(t, e) {
            return this.premultiply(ct.makeScale(t, e)), this
        }
        rotate(t) {
            return this.premultiply(ct.makeRotation(-t)), this
        }
        translate(t, e) {
            return this.premultiply(ct.makeTranslation(t, e)), this
        }
        makeTranslation(t, e) {
            return t.isVector2 ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1) : this.set(1, 0, t, 0, 1, e, 0, 0, 1), this
        }
        makeRotation(t) {
            const e = Math.cos(t),
                n = Math.sin(t);
            return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this
        }
        makeScale(t, e) {
            return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
        }
        equals(t) {
            const e = this.elements,
                n = t.elements;
            for (let t = 0; t < 9; t++)
                if (e[t] !== n[t]) return !1;
            return !0
        }
        fromArray(t, e = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
            return this
        }
        toArray(t = [], e = 0) {
            const n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
        }
        clone() {
            return (new this.constructor).fromArray(this.elements)
        }
    }
    const ct = new lt;

    function ht(t) {
        for (let e = t.length - 1; e >= 0; --e)
            if (t[e] >= 65535) return !0;
        return !1
    }
    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;

    function ut(t) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", t)
    }
    const dt = {};

    function pt(t) {
        t in dt || (dt[t] = !0, console.warn(t))
    }

    function ft(t) {
        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
    }

    function mt(t) {
        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
    }
    const gt = (new lt).fromArray([.8224621, .0331941, .0170827, .177538, .9668058, .0723974, -1e-7, 1e-7, .9105199]),
        vt = (new lt).fromArray([1.2249401, -.0420569, -.0196376, -.2249404, 1.0420571, -.0786361, 1e-7, 0, 1.0982735]);
    const yt = {
        [G]: t => t,
        [V]: t => t.convertSRGBToLinear(),
        "display-p3": function (t) {
            return t.convertSRGBToLinear().applyMatrix3(vt)
        }
    },
        bt = {
            [G]: t => t,
            [V]: t => t.convertLinearToSRGB(),
            "display-p3": function (t) {
                return t.applyMatrix3(gt).convertLinearToSRGB()
            }
        },
        xt = {
            enabled: !0,
            get legacyMode() {
                return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled
            },
            set legacyMode(t) {
                console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !t
            },
            get workingColorSpace() {
                return G
            },
            set workingColorSpace(t) {
                console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
            },
            convert: function (t, e, n) {
                if (!1 === this.enabled || e === n || !e || !n) return t;
                const i = yt[e],
                    r = bt[n];
                if (void 0 === i || void 0 === r) throw new Error(`Unsupported color space conversion, "${e}" to "${n}".`);
                return r(i(t))
            },
            fromWorkingColorSpace: function (t, e) {
                return this.convert(t, this.workingColorSpace, e)
            },
            toWorkingColorSpace: function (t, e) {
                return this.convert(t, e, this.workingColorSpace)
            }
        };
    let _t;
    class wt {
        static getDataURL(t) {
            if (/^data:/i.test(t.src)) return t.src;
            if ("undefined" == typeof HTMLCanvasElement) return t.src;
            let e;
            if (t instanceof HTMLCanvasElement) e = t;
            else {
                void 0 === _t && (_t = ut("canvas")), _t.width = t.width, _t.height = t.height;
                const n = _t.getContext("2d");
                t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = _t
            }
            return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
        }
        static sRGBToLinear(t) {
            if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                const e = ut("canvas");
                e.width = t.width, e.height = t.height;
                const n = e.getContext("2d");
                n.drawImage(t, 0, 0, t.width, t.height);
                const i = n.getImageData(0, 0, t.width, t.height),
                    r = i.data;
                for (let t = 0; t < r.length; t++) r[t] = 255 * ft(r[t] / 255);
                return n.putImageData(i, 0, 0), e
            }
            if (t.data) {
                const e = t.data.slice(0);
                for (let t = 0; t < e.length; t++) e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[t] = Math.floor(255 * ft(e[t] / 255)) : e[t] = ft(e[t]);
                return {
                    data: e,
                    width: t.width,
                    height: t.height
                }
            }
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t
        }
    }
    let St = 0;
    class Mt {
        constructor(t = null) {
            this.isSource = !0, Object.defineProperty(this, "id", {
                value: St++
            }), this.uuid = Z(), this.data = t, this.version = 0
        }
        set needsUpdate(t) {
            !0 === t && this.version++
        }
        toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
            const n = {
                uuid: this.uuid,
                url: ""
            },
                i = this.data;
            if (null !== i) {
                let t;
                if (Array.isArray(i)) {
                    t = [];
                    for (let e = 0, n = i.length; e < n; e++) i[e].isDataTexture ? t.push(Et(i[e].image)) : t.push(Et(i[e]))
                } else t = Et(i);
                n.url = t
            }
            return e || (t.images[this.uuid] = n), n
        }
    }

    function Et(t) {
        return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? wt.getDataURL(t) : t.data ? {
            data: Array.from(t.data),
            width: t.width,
            height: t.height,
            type: t.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
    }
    let Tt = 0;
    class Ct extends W {
        constructor(t = Ct.DEFAULT_IMAGE, e = Ct.DEFAULT_MAPPING, n = E, i = E, r = C, s = A, a = I, o = R, l = Ct.DEFAULT_ANISOTROPY, c = "") {
            super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                value: Tt++
            }), this.uuid = Z(), this.name = "", this.source = new Mt(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = o, this.offset = new ot(0, 0), this.repeat = new ot(1, 1), this.center = new ot(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new lt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, "string" == typeof c ? this.colorSpace = c : (pt("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = c === B ? V : ""), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
        }
        get image() {
            return this.source.data
        }
        set image(t = null) {
            this.source.data = t
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this
        }
        toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
            const n = {
                metadata: {
                    version: 4.6,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                image: this.source.toJSON(t).uuid,
                mapping: this.mapping,
                channel: this.channel,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                internalFormat: this.internalFormat,
                type: this.type,
                colorSpace: this.colorSpace,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                generateMipmaps: this.generateMipmaps,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        transformUv(t) {
            if (300 !== this.mapping) return t;
            if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                case M:
                    t.x = t.x - Math.floor(t.x);
                    break;
                case E:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                case 1002:
                    1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
            }
            if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                case M:
                    t.y = t.y - Math.floor(t.y);
                    break;
                case E:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                case 1002:
                    1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
            }
            return this.flipY && (t.y = 1 - t.y), t
        }
        set needsUpdate(t) {
            !0 === t && (this.version++, this.source.needsUpdate = !0)
        }
        get encoding() {
            return pt("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === V ? B : $
        }
        set encoding(t) {
            pt("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = t === B ? V : ""
        }
    }
    Ct.DEFAULT_IMAGE = null, Ct.DEFAULT_MAPPING = 300, Ct.DEFAULT_ANISOTROPY = 1;
    class At {
        constructor(t = 0, e = 0, n = 0, i = 1) {
            At.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = i
        }
        get width() {
            return this.z
        }
        set width(t) {
            this.z = t
        }
        get height() {
            return this.w
        }
        set height(t) {
            this.w = t
        }
        set(t, e, n, i) {
            return this.x = t, this.y = e, this.z = n, this.w = i, this
        }
        setScalar(t) {
            return this.x = t, this.y = t, this.z = t, this.w = t, this
        }
        setX(t) {
            return this.x = t, this
        }
        setY(t) {
            return this.y = t, this
        }
        setZ(t) {
            return this.z = t, this
        }
        setW(t) {
            return this.w = t, this
        }
        setComponent(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + t)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        }
        copy(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
        }
        add(t) {
            return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this
        }
        addScalar(t) {
            return this.x += t, this.y += t, this.z += t, this.w += t, this
        }
        addVectors(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
        }
        addScaledVector(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
        }
        sub(t) {
            return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this
        }
        subScalar(t) {
            return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
        }
        subVectors(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
        }
        multiply(t) {
            return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
        }
        multiplyScalar(t) {
            return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
        }
        applyMatrix4(t) {
            const e = this.x,
                n = this.y,
                i = this.z,
                r = this.w,
                s = t.elements;
            return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r, this
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t)
        }
        setAxisAngleFromQuaternion(t) {
            this.w = 2 * Math.acos(t.w);
            const e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
        }
        setAxisAngleFromRotationMatrix(t) {
            let e, n, i, r;
            const s = t.elements,
                a = s[0],
                o = s[4],
                l = s[8],
                c = s[1],
                h = s[5],
                u = s[9],
                d = s[2],
                p = s[6],
                f = s[10];
            if (Math.abs(o - c) < .01 && Math.abs(l - d) < .01 && Math.abs(u - p) < .01) {
                if (Math.abs(o + c) < .1 && Math.abs(l + d) < .1 && Math.abs(u + p) < .1 && Math.abs(a + h + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                e = Math.PI;
                const t = (a + 1) / 2,
                    s = (h + 1) / 2,
                    m = (f + 1) / 2,
                    g = (o + c) / 4,
                    v = (l + d) / 4,
                    y = (u + p) / 4;
                return t > s && t > m ? t < .01 ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = g / n, r = v / n) : s > m ? s < .01 ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(s), n = g / i, r = y / i) : m < .01 ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(m), n = v / r, i = y / r), this.set(n, i, r, e), this
            }
            let m = Math.sqrt((p - u) * (p - u) + (l - d) * (l - d) + (c - o) * (c - o));
            return Math.abs(m) < .001 && (m = 1), this.x = (p - u) / m, this.y = (l - d) / m, this.z = (c - o) / m, this.w = Math.acos((a + h + f - 1) / 2), this
        }
        min(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
        }
        max(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
        }
        clamp(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
        }
        clampScalar(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
        }
        clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
        }
        lerpVectors(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
        }
        equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        }
        fromArray(t, e = 0) {
            return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
        }
        toArray(t = [], e = 0) {
            return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
        }
        fromBufferAttribute(t, e) {
            return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
        } *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z, yield this.w
        }
    }
    class Rt extends W {
        constructor(t = 1, e = 1, n = {}) {
            super(), this.isRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new At(0, 0, t, e), this.scissorTest = !1, this.viewport = new At(0, 0, t, e);
            const i = {
                width: t,
                height: e,
                depth: 1
            };
            void 0 !== n.encoding && (pt("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), n.colorSpace = n.encoding === B ? V : ""), this.texture = new Ct(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : C, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null, this.samples = void 0 !== n.samples ? n.samples : 0
        }
        setSize(t, e, n = 1) {
            this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0;
            const e = Object.assign({}, t.texture.image);
            return this.texture.source = new Mt(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    class Pt extends Rt {
        constructor(t = 1, e = 1, n = {}) {
            super(t, e, n), this.isWebGLRenderTarget = !0
        }
    }
    class Lt extends Ct {
        constructor(t = null, e = 1, n = 1, i = 1) {
            super(null), this.isDataArrayTexture = !0, this.image = {
                data: t,
                width: e,
                height: n,
                depth: i
            }, this.magFilter = T, this.minFilter = T, this.wrapR = E, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
        }
    }
    class Ot extends Ct {
        constructor(t = null, e = 1, n = 1, i = 1) {
            super(null), this.isData3DTexture = !0, this.image = {
                data: t,
                width: e,
                height: n,
                depth: i
            }, this.magFilter = T, this.minFilter = T, this.wrapR = E, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
        }
    }
    class Dt {
        constructor(t = 0, e = 0, n = 0, i = 1) {
            this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = i
        }
        static slerpFlat(t, e, n, i, r, s, a) {
            let o = n[i + 0],
                l = n[i + 1],
                c = n[i + 2],
                h = n[i + 3];
            const u = r[s + 0],
                d = r[s + 1],
                p = r[s + 2],
                f = r[s + 3];
            if (0 === a) return t[e + 0] = o, t[e + 1] = l, t[e + 2] = c, void (t[e + 3] = h);
            if (1 === a) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = p, void (t[e + 3] = f);
            if (h !== f || o !== u || l !== d || c !== p) {
                let t = 1 - a;
                const e = o * u + l * d + c * p + h * f,
                    n = e >= 0 ? 1 : -1,
                    i = 1 - e * e;
                if (i > Number.EPSILON) {
                    const r = Math.sqrt(i),
                        s = Math.atan2(r, e * n);
                    t = Math.sin(t * s) / r, a = Math.sin(a * s) / r
                }
                const r = a * n;
                if (o = o * t + u * r, l = l * t + d * r, c = c * t + p * r, h = h * t + f * r, t === 1 - a) {
                    const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                    o *= t, l *= t, c *= t, h *= t
                }
            }
            t[e] = o, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h
        }
        static multiplyQuaternionsFlat(t, e, n, i, r, s) {
            const a = n[i],
                o = n[i + 1],
                l = n[i + 2],
                c = n[i + 3],
                h = r[s],
                u = r[s + 1],
                d = r[s + 2],
                p = r[s + 3];
            return t[e] = a * p + c * h + o * d - l * u, t[e + 1] = o * p + c * u + l * h - a * d, t[e + 2] = l * p + c * d + a * u - o * h, t[e + 3] = c * p - a * h - o * u - l * d, t
        }
        get x() {
            return this._x
        }
        set x(t) {
            this._x = t, this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(t) {
            this._y = t, this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(t) {
            this._z = t, this._onChangeCallback()
        }
        get w() {
            return this._w
        }
        set w(t) {
            this._w = t, this._onChangeCallback()
        }
        set(t, e, n, i) {
            return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        }
        copy(t) {
            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
        }
        setFromEuler(t, e) {
            const n = t._x,
                i = t._y,
                r = t._z,
                s = t._order,
                a = Math.cos,
                o = Math.sin,
                l = a(n / 2),
                c = a(i / 2),
                h = a(r / 2),
                u = o(n / 2),
                d = o(i / 2),
                p = o(r / 2);
            switch (s) {
                case "XYZ":
                    this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "YXZ":
                    this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                    break;
                case "ZXY":
                    this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "ZYX":
                    this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                    break;
                case "YZX":
                    this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "XZY":
                    this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
            }
            return !1 !== e && this._onChangeCallback(), this
        }
        setFromAxisAngle(t, e) {
            const n = e / 2,
                i = Math.sin(n);
            return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
        }
        setFromRotationMatrix(t) {
            const e = t.elements,
                n = e[0],
                i = e[4],
                r = e[8],
                s = e[1],
                a = e[5],
                o = e[9],
                l = e[2],
                c = e[6],
                h = e[10],
                u = n + a + h;
            if (u > 0) {
                const t = .5 / Math.sqrt(u + 1);
                this._w = .25 / t, this._x = (c - o) * t, this._y = (r - l) * t, this._z = (s - i) * t
            } else if (n > a && n > h) {
                const t = 2 * Math.sqrt(1 + n - a - h);
                this._w = (c - o) / t, this._x = .25 * t, this._y = (i + s) / t, this._z = (r + l) / t
            } else if (a > h) {
                const t = 2 * Math.sqrt(1 + a - n - h);
                this._w = (r - l) / t, this._x = (i + s) / t, this._y = .25 * t, this._z = (o + c) / t
            } else {
                const t = 2 * Math.sqrt(1 + h - n - a);
                this._w = (s - i) / t, this._x = (r + l) / t, this._y = (o + c) / t, this._z = .25 * t
            }
            return this._onChangeCallback(), this
        }
        setFromUnitVectors(t, e) {
            let n = t.dot(e) + 1;
            return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
        }
        angleTo(t) {
            return 2 * Math.acos(Math.abs(J(this.dot(t), -1, 1)))
        }
        rotateTowards(t, e) {
            const n = this.angleTo(t);
            if (0 === n) return this;
            const i = Math.min(1, e / n);
            return this.slerp(t, i), this
        }
        identity() {
            return this.set(0, 0, 0, 1)
        }
        invert() {
            return this.conjugate()
        }
        conjugate() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
        }
        dot(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
        normalize() {
            let t = this.length();
            return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
        }
        multiply(t) {
            return this.multiplyQuaternions(this, t)
        }
        premultiply(t) {
            return this.multiplyQuaternions(t, this)
        }
        multiplyQuaternions(t, e) {
            const n = t._x,
                i = t._y,
                r = t._z,
                s = t._w,
                a = e._x,
                o = e._y,
                l = e._z,
                c = e._w;
            return this._x = n * c + s * a + i * l - r * o, this._y = i * c + s * o + r * a - n * l, this._z = r * c + s * l + n * o - i * a, this._w = s * c - n * a - i * o - r * l, this._onChangeCallback(), this
        }
        slerp(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            const n = this._x,
                i = this._y,
                r = this._z,
                s = this._w;
            let a = s * t._w + n * t._x + i * t._y + r * t._z;
            if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
            const o = 1 - a * a;
            if (o <= Number.EPSILON) {
                const t = 1 - e;
                return this._w = t * s + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this
            }
            const l = Math.sqrt(o),
                c = Math.atan2(l, a),
                h = Math.sin((1 - e) * c) / l,
                u = Math.sin(e * c) / l;
            return this._w = s * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this
        }
        slerpQuaternions(t, e, n) {
            return this.copy(t).slerp(e, n)
        }
        random() {
            const t = Math.random(),
                e = Math.sqrt(1 - t),
                n = Math.sqrt(t),
                i = 2 * Math.PI * Math.random(),
                r = 2 * Math.PI * Math.random();
            return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i))
        }
        equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        }
        fromArray(t, e = 0) {
            return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
        }
        toArray(t = [], e = 0) {
            return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
        }
        fromBufferAttribute(t, e) {
            return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
        }
        toJSON() {
            return this.toArray()
        }
        _onChange(t) {
            return this._onChangeCallback = t, this
        }
        _onChangeCallback() { } *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w
        }
    }
    class It {
        constructor(t = 0, e = 0, n = 0) {
            It.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n
        }
        set(t, e, n) {
            return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
        }
        setScalar(t) {
            return this.x = t, this.y = t, this.z = t, this
        }
        setX(t) {
            return this.x = t, this
        }
        setY(t) {
            return this.y = t, this
        }
        setZ(t) {
            return this.z = t, this
        }
        setComponent(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z)
        }
        copy(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this
        }
        add(t) {
            return this.x += t.x, this.y += t.y, this.z += t.z, this
        }
        addScalar(t) {
            return this.x += t, this.y += t, this.z += t, this
        }
        addVectors(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
        }
        addScaledVector(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
        }
        sub(t) {
            return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
        }
        subScalar(t) {
            return this.x -= t, this.y -= t, this.z -= t, this
        }
        subVectors(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
        }
        multiply(t) {
            return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
        }
        multiplyScalar(t) {
            return this.x *= t, this.y *= t, this.z *= t, this
        }
        multiplyVectors(t, e) {
            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
        }
        applyEuler(t) {
            return this.applyQuaternion(Nt.setFromEuler(t))
        }
        applyAxisAngle(t, e) {
            return this.applyQuaternion(Nt.setFromAxisAngle(t, e))
        }
        applyMatrix3(t) {
            const e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements;
            return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
        }
        applyNormalMatrix(t) {
            return this.applyMatrix3(t).normalize()
        }
        applyMatrix4(t) {
            const e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements,
                s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s, this
        }
        applyQuaternion(t) {
            const e = this.x,
                n = this.y,
                i = this.z,
                r = t.x,
                s = t.y,
                a = t.z,
                o = t.w,
                l = o * e + s * i - a * n,
                c = o * n + a * e - r * i,
                h = o * i + r * n - s * e,
                u = -r * e - s * n - a * i;
            return this.x = l * o + u * -r + c * -a - h * -s, this.y = c * o + u * -s + h * -r - l * -a, this.z = h * o + u * -a + l * -s - c * -r, this
        }
        project(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
        }
        unproject(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
        }
        transformDirection(t) {
            const e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements;
            return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
        }
        divide(t) {
            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t)
        }
        min(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
        }
        max(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
        }
        clamp(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
        }
        clampScalar(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
        }
        clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
        }
        lerpVectors(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
        }
        cross(t) {
            return this.crossVectors(this, t)
        }
        crossVectors(t, e) {
            const n = t.x,
                i = t.y,
                r = t.z,
                s = e.x,
                a = e.y,
                o = e.z;
            return this.x = i * o - r * a, this.y = r * s - n * o, this.z = n * a - i * s, this
        }
        projectOnVector(t) {
            const e = t.lengthSq();
            if (0 === e) return this.set(0, 0, 0);
            const n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n)
        }
        projectOnPlane(t) {
            return kt.copy(this).projectOnVector(t), this.sub(kt)
        }
        reflect(t) {
            return this.sub(kt.copy(t).multiplyScalar(2 * this.dot(t)))
        }
        angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(J(n, -1, 1))
        }
        distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t) {
            const e = this.x - t.x,
                n = this.y - t.y,
                i = this.z - t.z;
            return e * e + n * n + i * i
        }
        manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        }
        setFromSpherical(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        }
        setFromSphericalCoords(t, e, n) {
            const i = Math.sin(e) * t;
            return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
        }
        setFromCylindrical(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        }
        setFromCylindricalCoords(t, e, n) {
            return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
        }
        setFromMatrixPosition(t) {
            const e = t.elements;
            return this.x = e[12], this.y = e[13], this.z = e[14], this
        }
        setFromMatrixScale(t) {
            const e = this.setFromMatrixColumn(t, 0).length(),
                n = this.setFromMatrixColumn(t, 1).length(),
                i = this.setFromMatrixColumn(t, 2).length();
            return this.x = e, this.y = n, this.z = i, this
        }
        setFromMatrixColumn(t, e) {
            return this.fromArray(t.elements, 4 * e)
        }
        setFromMatrix3Column(t, e) {
            return this.fromArray(t.elements, 3 * e)
        }
        setFromEuler(t) {
            return this.x = t._x, this.y = t._y, this.z = t._z, this
        }
        setFromColor(t) {
            return this.x = t.r, this.y = t.g, this.z = t.b, this
        }
        equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        }
        fromArray(t, e = 0) {
            return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
        }
        toArray(t = [], e = 0) {
            return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
        }
        fromBufferAttribute(t, e) {
            return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
        }
        randomDirection() {
            const t = 2 * (Math.random() - .5),
                e = Math.random() * Math.PI * 2,
                n = Math.sqrt(1 - t ** 2);
            return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
        } *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z
        }
    }
    const kt = new It,
        Nt = new Dt;
    class Ut {
        constructor(t = new It(1 / 0, 1 / 0, 1 / 0), e = new It(-1 / 0, -1 / 0, -1 / 0)) {
            this.isBox3 = !0, this.min = t, this.max = e
        }
        set(t, e) {
            return this.min.copy(t), this.max.copy(e), this
        }
        setFromArray(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e += 3) this.expandByPoint(Ft.fromArray(t, e));
            return this
        }
        setFromBufferAttribute(t) {
            this.makeEmpty();
            for (let e = 0, n = t.count; e < n; e++) this.expandByPoint(Ft.fromBufferAttribute(t, e));
            return this
        }
        setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this
        }
        setFromCenterAndSize(t, e) {
            const n = Ft.copy(e).multiplyScalar(.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
        }
        setFromObject(t, e = !1) {
            return this.makeEmpty(), this.expandByObject(t, e)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        }
        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }
        getCenter(t) {
            return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        }
        getSize(t) {
            return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        }
        expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this
        }
        expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this
        }
        expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        }
        expandByObject(t, e = !1) {
            if (t.updateWorldMatrix(!1, !1), void 0 !== t.boundingBox) null === t.boundingBox && t.computeBoundingBox(), $t.copy(t.boundingBox), $t.applyMatrix4(t.matrixWorld), this.union($t);
            else {
                const n = t.geometry;
                if (void 0 !== n)
                    if (e && void 0 !== n.attributes && void 0 !== n.attributes.position) {
                        const e = n.attributes.position;
                        for (let n = 0, i = e.count; n < i; n++) Ft.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld), this.expandByPoint(Ft)
                    } else null === n.boundingBox && n.computeBoundingBox(), $t.copy(n.boundingBox), $t.applyMatrix4(t.matrixWorld), this.union($t)
            }
            const n = t.children;
            for (let t = 0, i = n.length; t < i; t++) this.expandByObject(n[t], e);
            return this
        }
        containsPoint(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        }
        containsBox(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        }
        getParameter(t, e) {
            return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        }
        intersectsBox(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        }
        intersectsSphere(t) {
            return this.clampPoint(t.center, Ft), Ft.distanceToSquared(t.center) <= t.radius * t.radius
        }
        intersectsPlane(t) {
            let e, n;
            return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
        }
        intersectsTriangle(t) {
            if (this.isEmpty()) return !1;
            this.getCenter(qt), Xt.subVectors(this.max, qt), Bt.subVectors(t.a, qt), Ht.subVectors(t.b, qt), jt.subVectors(t.c, qt), Vt.subVectors(Ht, Bt), Gt.subVectors(jt, Ht), Wt.subVectors(Bt, jt);
            let e = [0, -Vt.z, Vt.y, 0, -Gt.z, Gt.y, 0, -Wt.z, Wt.y, Vt.z, 0, -Vt.x, Gt.z, 0, -Gt.x, Wt.z, 0, -Wt.x, -Vt.y, Vt.x, 0, -Gt.y, Gt.x, 0, -Wt.y, Wt.x, 0];
            return !!Zt(e, Bt, Ht, jt, Xt) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Zt(e, Bt, Ht, jt, Xt) && (Yt.crossVectors(Vt, Gt), e = [Yt.x, Yt.y, Yt.z], Zt(e, Bt, Ht, jt, Xt)))
        }
        clampPoint(t, e) {
            return e.copy(t).clamp(this.min, this.max)
        }
        distanceToPoint(t) {
            return this.clampPoint(t, Ft).distanceTo(t)
        }
        getBoundingSphere(t) {
            return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = .5 * this.getSize(Ft).length()), t
        }
        intersect(t) {
            return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
        }
        union(t) {
            return this.min.min(t.min), this.max.max(t.max), this
        }
        applyMatrix4(t) {
            return this.isEmpty() || (zt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), zt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), zt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), zt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), zt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), zt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), zt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), zt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(zt)), this
        }
        translate(t) {
            return this.min.add(t), this.max.add(t), this
        }
        equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }
    const zt = [new It, new It, new It, new It, new It, new It, new It, new It],
        Ft = new It,
        $t = new Ut,
        Bt = new It,
        Ht = new It,
        jt = new It,
        Vt = new It,
        Gt = new It,
        Wt = new It,
        qt = new It,
        Xt = new It,
        Yt = new It,
        Kt = new It;

    function Zt(t, e, n, i, r) {
        for (let s = 0, a = t.length - 3; s <= a; s += 3) {
            Kt.fromArray(t, s);
            const a = r.x * Math.abs(Kt.x) + r.y * Math.abs(Kt.y) + r.z * Math.abs(Kt.z),
                o = e.dot(Kt),
                l = n.dot(Kt),
                c = i.dot(Kt);
            if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1
        }
        return !0
    }
    const Jt = new Ut,
        Qt = new It,
        te = new It;
    class ee {
        constructor(t = new It, e = -1) {
            this.center = t, this.radius = e
        }
        set(t, e) {
            return this.center.copy(t), this.radius = e, this
        }
        setFromPoints(t, e) {
            const n = this.center;
            void 0 !== e ? n.copy(e) : Jt.setFromPoints(t).getCenter(n);
            let i = 0;
            for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
            return this.radius = Math.sqrt(i), this
        }
        copy(t) {
            return this.center.copy(t.center), this.radius = t.radius, this
        }
        isEmpty() {
            return this.radius < 0
        }
        makeEmpty() {
            return this.center.set(0, 0, 0), this.radius = -1, this
        }
        containsPoint(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        }
        distanceToPoint(t) {
            return t.distanceTo(this.center) - this.radius
        }
        intersectsSphere(t) {
            const e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        }
        intersectsBox(t) {
            return t.intersectsSphere(this)
        }
        intersectsPlane(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        }
        clampPoint(t, e) {
            const n = this.center.distanceToSquared(t);
            return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
        }
        getBoundingBox(t) {
            return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
        }
        applyMatrix4(t) {
            return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
        }
        translate(t) {
            return this.center.add(t), this
        }
        expandByPoint(t) {
            if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this;
            Qt.subVectors(t, this.center);
            const e = Qt.lengthSq();
            if (e > this.radius * this.radius) {
                const t = Math.sqrt(e),
                    n = .5 * (t - this.radius);
                this.center.addScaledVector(Qt, n / t), this.radius += n
            }
            return this
        }
        union(t) {
            return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (!0 === this.center.equals(t.center) ? this.radius = Math.max(this.radius, t.radius) : (te.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(Qt.copy(t.center).add(te)), this.expandByPoint(Qt.copy(t.center).sub(te))), this)
        }
        equals(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    const ne = new It,
        ie = new It,
        re = new It,
        se = new It,
        ae = new It,
        oe = new It,
        le = new It;
    class ce {
        constructor(t = new It, e = new It(0, 0, -1)) {
            this.origin = t, this.direction = e
        }
        set(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this
        }
        copy(t) {
            return this.origin.copy(t.origin), this.direction.copy(t.direction), this
        }
        at(t, e) {
            return e.copy(this.origin).addScaledVector(this.direction, t)
        }
        lookAt(t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this
        }
        recast(t) {
            return this.origin.copy(this.at(t, ne)), this
        }
        closestPointToPoint(t, e) {
            e.subVectors(t, this.origin);
            const n = e.dot(this.direction);
            return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n)
        }
        distanceToPoint(t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        }
        distanceSqToPoint(t) {
            const e = ne.subVectors(t, this.origin).dot(this.direction);
            return e < 0 ? this.origin.distanceToSquared(t) : (ne.copy(this.origin).addScaledVector(this.direction, e), ne.distanceToSquared(t))
        }
        distanceSqToSegment(t, e, n, i) {
            ie.copy(t).add(e).multiplyScalar(.5), re.copy(e).sub(t).normalize(), se.copy(this.origin).sub(ie);
            const r = .5 * t.distanceTo(e),
                s = -this.direction.dot(re),
                a = se.dot(this.direction),
                o = -se.dot(re),
                l = se.lengthSq(),
                c = Math.abs(1 - s * s);
            let h, u, d, p;
            if (c > 0)
                if (h = s * o - a, u = s * a - o, p = r * c, h >= 0)
                    if (u >= -p)
                        if (u <= p) {
                            const t = 1 / c;
                            h *= t, u *= t, d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l
                        } else u = r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
                    else u = -r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
                else u <= -p ? (h = Math.max(0, -(-s * r + a)), u = h > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-r, -o), r), d = u * (u + 2 * o) + l) : (h = Math.max(0, -(s * r + a)), u = h > 0 ? r : Math.min(Math.max(-r, -o), r), d = -h * h + u * (u + 2 * o) + l);
            else u = s > 0 ? -r : r, h = Math.max(0, -(s * u + a)), d = -h * h + u * (u + 2 * o) + l;
            return n && n.copy(this.origin).addScaledVector(this.direction, h), i && i.copy(ie).addScaledVector(re, u), d
        }
        intersectSphere(t, e) {
            ne.subVectors(t.center, this.origin);
            const n = ne.dot(this.direction),
                i = ne.dot(ne) - n * n,
                r = t.radius * t.radius;
            if (i > r) return null;
            const s = Math.sqrt(r - i),
                a = n - s,
                o = n + s;
            return o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e)
        }
        intersectsSphere(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius
        }
        distanceToPlane(t) {
            const e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null
        }
        intersectPlane(t, e) {
            const n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e)
        }
        intersectsPlane(t) {
            const e = t.distanceToPoint(this.origin);
            if (0 === e) return !0;
            return t.normal.dot(this.direction) * e < 0
        }
        intersectBox(t, e) {
            let n, i, r, s, a, o;
            const l = 1 / this.direction.x,
                c = 1 / this.direction.y,
                h = 1 / this.direction.z,
                u = this.origin;
            return l >= 0 ? (n = (t.min.x - u.x) * l, i = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, i = (t.min.x - u.x) * l), c >= 0 ? (r = (t.min.y - u.y) * c, s = (t.max.y - u.y) * c) : (r = (t.max.y - u.y) * c, s = (t.min.y - u.y) * c), n > s || r > i ? null : ((r > n || isNaN(n)) && (n = r), (s < i || isNaN(i)) && (i = s), h >= 0 ? (a = (t.min.z - u.z) * h, o = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h, o = (t.min.z - u.z) * h), n > o || a > i ? null : ((a > n || n != n) && (n = a), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
        }
        intersectsBox(t) {
            return null !== this.intersectBox(t, ne)
        }
        intersectTriangle(t, e, n, i, r) {
            ae.subVectors(e, t), oe.subVectors(n, t), le.crossVectors(ae, oe);
            let s, a = this.direction.dot(le);
            if (a > 0) {
                if (i) return null;
                s = 1
            } else {
                if (!(a < 0)) return null;
                s = -1, a = -a
            }
            se.subVectors(this.origin, t);
            const o = s * this.direction.dot(oe.crossVectors(se, oe));
            if (o < 0) return null;
            const l = s * this.direction.dot(ae.cross(se));
            if (l < 0) return null;
            if (o + l > a) return null;
            const c = -s * se.dot(le);
            return c < 0 ? null : this.at(c / a, r)
        }
        applyMatrix4(t) {
            return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
        }
        equals(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    class he {
        constructor(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m) {
            he.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m)
        }
        set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m) {
            const g = this.elements;
            return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        clone() {
            return (new he).fromArray(this.elements)
        }
        copy(t) {
            const e = this.elements,
                n = t.elements;
            return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
        }
        copyPosition(t) {
            const e = this.elements,
                n = t.elements;
            return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
        }
        setFromMatrix3(t) {
            const e = t.elements;
            return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
        }
        extractBasis(t, e, n) {
            return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
        }
        makeBasis(t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
        }
        extractRotation(t) {
            const e = this.elements,
                n = t.elements,
                i = 1 / ue.setFromMatrixColumn(t, 0).length(),
                r = 1 / ue.setFromMatrixColumn(t, 1).length(),
                s = 1 / ue.setFromMatrixColumn(t, 2).length();
            return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        }
        makeRotationFromEuler(t) {
            const e = this.elements,
                n = t.x,
                i = t.y,
                r = t.z,
                s = Math.cos(n),
                a = Math.sin(n),
                o = Math.cos(i),
                l = Math.sin(i),
                c = Math.cos(r),
                h = Math.sin(r);
            if ("XYZ" === t.order) {
                const t = s * c,
                    n = s * h,
                    i = a * c,
                    r = a * h;
                e[0] = o * c, e[4] = -o * h, e[8] = l, e[1] = n + i * l, e[5] = t - r * l, e[9] = -a * o, e[2] = r - t * l, e[6] = i + n * l, e[10] = s * o
            } else if ("YXZ" === t.order) {
                const t = o * c,
                    n = o * h,
                    i = l * c,
                    r = l * h;
                e[0] = t + r * a, e[4] = i * a - n, e[8] = s * l, e[1] = s * h, e[5] = s * c, e[9] = -a, e[2] = n * a - i, e[6] = r + t * a, e[10] = s * o
            } else if ("ZXY" === t.order) {
                const t = o * c,
                    n = o * h,
                    i = l * c,
                    r = l * h;
                e[0] = t - r * a, e[4] = -s * h, e[8] = i + n * a, e[1] = n + i * a, e[5] = s * c, e[9] = r - t * a, e[2] = -s * l, e[6] = a, e[10] = s * o
            } else if ("ZYX" === t.order) {
                const t = s * c,
                    n = s * h,
                    i = a * c,
                    r = a * h;
                e[0] = o * c, e[4] = i * l - n, e[8] = t * l + r, e[1] = o * h, e[5] = r * l + t, e[9] = n * l - i, e[2] = -l, e[6] = a * o, e[10] = s * o
            } else if ("YZX" === t.order) {
                const t = s * o,
                    n = s * l,
                    i = a * o,
                    r = a * l;
                e[0] = o * c, e[4] = r - t * h, e[8] = i * h + n, e[1] = h, e[5] = s * c, e[9] = -a * c, e[2] = -l * c, e[6] = n * h + i, e[10] = t - r * h
            } else if ("XZY" === t.order) {
                const t = s * o,
                    n = s * l,
                    i = a * o,
                    r = a * l;
                e[0] = o * c, e[4] = -h, e[8] = l * c, e[1] = t * h + r, e[5] = s * c, e[9] = n * h - i, e[2] = i * h - n, e[6] = a * c, e[10] = r * h + t
            }
            return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        }
        makeRotationFromQuaternion(t) {
            return this.compose(pe, t, fe)
        }
        lookAt(t, e, n) {
            const i = this.elements;
            return ve.subVectors(t, e), 0 === ve.lengthSq() && (ve.z = 1), ve.normalize(), me.crossVectors(n, ve), 0 === me.lengthSq() && (1 === Math.abs(n.z) ? ve.x += 1e-4 : ve.z += 1e-4, ve.normalize(), me.crossVectors(n, ve)), me.normalize(), ge.crossVectors(ve, me), i[0] = me.x, i[4] = ge.x, i[8] = ve.x, i[1] = me.y, i[5] = ge.y, i[9] = ve.y, i[2] = me.z, i[6] = ge.z, i[10] = ve.z, this
        }
        multiply(t) {
            return this.multiplyMatrices(this, t)
        }
        premultiply(t) {
            return this.multiplyMatrices(t, this)
        }
        multiplyMatrices(t, e) {
            const n = t.elements,
                i = e.elements,
                r = this.elements,
                s = n[0],
                a = n[4],
                o = n[8],
                l = n[12],
                c = n[1],
                h = n[5],
                u = n[9],
                d = n[13],
                p = n[2],
                f = n[6],
                m = n[10],
                g = n[14],
                v = n[3],
                y = n[7],
                b = n[11],
                x = n[15],
                _ = i[0],
                w = i[4],
                S = i[8],
                M = i[12],
                E = i[1],
                T = i[5],
                C = i[9],
                A = i[13],
                R = i[2],
                P = i[6],
                L = i[10],
                O = i[14],
                D = i[3],
                I = i[7],
                k = i[11],
                N = i[15];
            return r[0] = s * _ + a * E + o * R + l * D, r[4] = s * w + a * T + o * P + l * I, r[8] = s * S + a * C + o * L + l * k, r[12] = s * M + a * A + o * O + l * N, r[1] = c * _ + h * E + u * R + d * D, r[5] = c * w + h * T + u * P + d * I, r[9] = c * S + h * C + u * L + d * k, r[13] = c * M + h * A + u * O + d * N, r[2] = p * _ + f * E + m * R + g * D, r[6] = p * w + f * T + m * P + g * I, r[10] = p * S + f * C + m * L + g * k, r[14] = p * M + f * A + m * O + g * N, r[3] = v * _ + y * E + b * R + x * D, r[7] = v * w + y * T + b * P + x * I, r[11] = v * S + y * C + b * L + x * k, r[15] = v * M + y * A + b * O + x * N, this
        }
        multiplyScalar(t) {
            const e = this.elements;
            return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
        }
        determinant() {
            const t = this.elements,
                e = t[0],
                n = t[4],
                i = t[8],
                r = t[12],
                s = t[1],
                a = t[5],
                o = t[9],
                l = t[13],
                c = t[2],
                h = t[6],
                u = t[10],
                d = t[14];
            return t[3] * (+r * o * h - i * l * h - r * a * u + n * l * u + i * a * d - n * o * d) + t[7] * (+e * o * d - e * l * u + r * s * u - i * s * d + i * l * c - r * o * c) + t[11] * (+e * l * h - e * a * d - r * s * h + n * s * d + r * a * c - n * l * c) + t[15] * (-i * a * c - e * o * h + e * a * u + i * s * h - n * s * u + n * o * c)
        }
        transpose() {
            const t = this.elements;
            let e;
            return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
        }
        setPosition(t, e, n) {
            const i = this.elements;
            return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
        }
        invert() {
            const t = this.elements,
                e = t[0],
                n = t[1],
                i = t[2],
                r = t[3],
                s = t[4],
                a = t[5],
                o = t[6],
                l = t[7],
                c = t[8],
                h = t[9],
                u = t[10],
                d = t[11],
                p = t[12],
                f = t[13],
                m = t[14],
                g = t[15],
                v = h * m * l - f * u * l + f * o * d - a * m * d - h * o * g + a * u * g,
                y = p * u * l - c * m * l - p * o * d + s * m * d + c * o * g - s * u * g,
                b = c * f * l - p * h * l + p * a * d - s * f * d - c * a * g + s * h * g,
                x = p * h * o - c * f * o - p * a * u + s * f * u + c * a * m - s * h * m,
                _ = e * v + n * y + i * b + r * x;
            if (0 === _) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const w = 1 / _;
            return t[0] = v * w, t[1] = (f * u * r - h * m * r - f * i * d + n * m * d + h * i * g - n * u * g) * w, t[2] = (a * m * r - f * o * r + f * i * l - n * m * l - a * i * g + n * o * g) * w, t[3] = (h * o * r - a * u * r - h * i * l + n * u * l + a * i * d - n * o * d) * w, t[4] = y * w, t[5] = (c * m * r - p * u * r + p * i * d - e * m * d - c * i * g + e * u * g) * w, t[6] = (p * o * r - s * m * r - p * i * l + e * m * l + s * i * g - e * o * g) * w, t[7] = (s * u * r - c * o * r + c * i * l - e * u * l - s * i * d + e * o * d) * w, t[8] = b * w, t[9] = (p * h * r - c * f * r - p * n * d + e * f * d + c * n * g - e * h * g) * w, t[10] = (s * f * r - p * a * r + p * n * l - e * f * l - s * n * g + e * a * g) * w, t[11] = (c * a * r - s * h * r - c * n * l + e * h * l + s * n * d - e * a * d) * w, t[12] = x * w, t[13] = (c * f * i - p * h * i + p * n * u - e * f * u - c * n * m + e * h * m) * w, t[14] = (p * a * i - s * f * i - p * n * o + e * f * o + s * n * m - e * a * m) * w, t[15] = (s * h * i - c * a * i + c * n * o - e * h * o - s * n * u + e * a * u) * w, this
        }
        scale(t) {
            const e = this.elements,
                n = t.x,
                i = t.y,
                r = t.z;
            return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
        }
        getMaxScaleOnAxis() {
            const t = this.elements,
                e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, i))
        }
        makeTranslation(t, e, n) {
            return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
        }
        makeRotationX(t) {
            const e = Math.cos(t),
                n = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
        }
        makeRotationY(t) {
            const e = Math.cos(t),
                n = Math.sin(t);
            return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
        }
        makeRotationZ(t) {
            const e = Math.cos(t),
                n = Math.sin(t);
            return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        makeRotationAxis(t, e) {
            const n = Math.cos(e),
                i = Math.sin(e),
                r = 1 - n,
                s = t.x,
                a = t.y,
                o = t.z,
                l = r * s,
                c = r * a;
            return this.set(l * s + n, l * a - i * o, l * o + i * a, 0, l * a + i * o, c * a + n, c * o - i * s, 0, l * o - i * a, c * o + i * s, r * o * o + n, 0, 0, 0, 0, 1), this
        }
        makeScale(t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        }
        makeShear(t, e, n, i, r, s) {
            return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this
        }
        compose(t, e, n) {
            const i = this.elements,
                r = e._x,
                s = e._y,
                a = e._z,
                o = e._w,
                l = r + r,
                c = s + s,
                h = a + a,
                u = r * l,
                d = r * c,
                p = r * h,
                f = s * c,
                m = s * h,
                g = a * h,
                v = o * l,
                y = o * c,
                b = o * h,
                x = n.x,
                _ = n.y,
                w = n.z;
            return i[0] = (1 - (f + g)) * x, i[1] = (d + b) * x, i[2] = (p - y) * x, i[3] = 0, i[4] = (d - b) * _, i[5] = (1 - (u + g)) * _, i[6] = (m + v) * _, i[7] = 0, i[8] = (p + y) * w, i[9] = (m - v) * w, i[10] = (1 - (u + f)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
        }
        decompose(t, e, n) {
            const i = this.elements;
            let r = ue.set(i[0], i[1], i[2]).length();
            const s = ue.set(i[4], i[5], i[6]).length(),
                a = ue.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], de.copy(this);
            const o = 1 / r,
                l = 1 / s,
                c = 1 / a;
            return de.elements[0] *= o, de.elements[1] *= o, de.elements[2] *= o, de.elements[4] *= l, de.elements[5] *= l, de.elements[6] *= l, de.elements[8] *= c, de.elements[9] *= c, de.elements[10] *= c, e.setFromRotationMatrix(de), n.x = r, n.y = s, n.z = a, this
        }
        makePerspective(t, e, n, i, r, s, a = 2e3) {
            const o = this.elements,
                l = 2 * r / (e - t),
                c = 2 * r / (n - i),
                h = (e + t) / (e - t),
                u = (n + i) / (n - i);
            let d, p;
            if (2e3 === a) d = -(s + r) / (s - r), p = -2 * s * r / (s - r);
            else {
                if (2001 !== a) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
                d = -s / (s - r), p = -s * r / (s - r)
            }
            return o[0] = l, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = c, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = d, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
        }
        makeOrthographic(t, e, n, i, r, s, a = 2e3) {
            const o = this.elements,
                l = 1 / (e - t),
                c = 1 / (n - i),
                h = 1 / (s - r),
                u = (e + t) * l,
                d = (n + i) * c;
            let p, f;
            if (2e3 === a) p = (s + r) * h, f = -2 * h;
            else {
                if (2001 !== a) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
                p = r * h, f = -1 * h
            }
            return o[0] = 2 * l, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -d, o[2] = 0, o[6] = 0, o[10] = f, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
        }
        equals(t) {
            const e = this.elements,
                n = t.elements;
            for (let t = 0; t < 16; t++)
                if (e[t] !== n[t]) return !1;
            return !0
        }
        fromArray(t, e = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
            return this
        }
        toArray(t = [], e = 0) {
            const n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
        }
    }
    const ue = new It,
        de = new he,
        pe = new It(0, 0, 0),
        fe = new It(1, 1, 1),
        me = new It,
        ge = new It,
        ve = new It,
        ye = new he,
        be = new Dt;
    class xe {
        constructor(t = 0, e = 0, n = 0, i = xe.DEFAULT_ORDER) {
            this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = i
        }
        get x() {
            return this._x
        }
        set x(t) {
            this._x = t, this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(t) {
            this._y = t, this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(t) {
            this._z = t, this._onChangeCallback()
        }
        get order() {
            return this._order
        }
        set order(t) {
            this._order = t, this._onChangeCallback()
        }
        set(t, e, n, i = this._order) {
            return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._order)
        }
        copy(t) {
            return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
        }
        setFromRotationMatrix(t, e = this._order, n = !0) {
            const i = t.elements,
                r = i[0],
                s = i[4],
                a = i[8],
                o = i[1],
                l = i[5],
                c = i[9],
                h = i[2],
                u = i[6],
                d = i[10];
            switch (e) {
                case "XYZ":
                    this._y = Math.asin(J(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l), this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-J(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r), this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(J(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                    break;
                case "ZYX":
                    this._y = Math.asin(-J(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-s, l));
                    break;
                case "YZX":
                    this._z = Math.asin(J(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, r)) : (this._x = 0, this._y = Math.atan2(a, d));
                    break;
                case "XZY":
                    this._z = Math.asin(-J(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
            }
            return this._order = e, !0 === n && this._onChangeCallback(), this
        }
        setFromQuaternion(t, e, n) {
            return ye.makeRotationFromQuaternion(t), this.setFromRotationMatrix(ye, e, n)
        }
        setFromVector3(t, e = this._order) {
            return this.set(t.x, t.y, t.z, e)
        }
        reorder(t) {
            return be.setFromEuler(this), this.setFromQuaternion(be, t)
        }
        equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        }
        fromArray(t) {
            return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
        }
        toArray(t = [], e = 0) {
            return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
        }
        _onChange(t) {
            return this._onChangeCallback = t, this
        }
        _onChangeCallback() { } *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._order
        }
    }
    xe.DEFAULT_ORDER = "XYZ";
    class _e {
        constructor() {
            this.mask = 1
        }
        set(t) {
            this.mask = (1 << t | 0) >>> 0
        }
        enable(t) {
            this.mask |= 1 << t | 0
        }
        enableAll() {
            this.mask = -1
        }
        toggle(t) {
            this.mask ^= 1 << t | 0
        }
        disable(t) {
            this.mask &= ~(1 << t | 0)
        }
        disableAll() {
            this.mask = 0
        }
        test(t) {
            return 0 != (this.mask & t.mask)
        }
        isEnabled(t) {
            return 0 != (this.mask & (1 << t | 0))
        }
    }
    let we = 0;
    const Se = new It,
        Me = new Dt,
        Ee = new he,
        Te = new It,
        Ce = new It,
        Ae = new It,
        Re = new Dt,
        Pe = new It(1, 0, 0),
        Le = new It(0, 1, 0),
        Oe = new It(0, 0, 1),
        De = {
            type: "added"
        },
        Ie = {
            type: "removed"
        };
    class ke extends W {
        constructor() {
            super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                value: we++
            }), this.uuid = Z(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ke.DEFAULT_UP.clone();
            const t = new It,
                e = new xe,
                n = new Dt,
                i = new It(1, 1, 1);
            e._onChange((function () {
                n.setFromEuler(e, !1)
            })), n._onChange((function () {
                e.setFromQuaternion(n, void 0, !1)
            })), Object.defineProperties(this, {
                position: {
                    configurable: !0,
                    enumerable: !0,
                    value: t
                },
                rotation: {
                    configurable: !0,
                    enumerable: !0,
                    value: e
                },
                quaternion: {
                    configurable: !0,
                    enumerable: !0,
                    value: n
                },
                scale: {
                    configurable: !0,
                    enumerable: !0,
                    value: i
                },
                modelViewMatrix: {
                    value: new he
                },
                normalMatrix: {
                    value: new lt
                }
            }), this.matrix = new he, this.matrixWorld = new he, this.matrixAutoUpdate = ke.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = ke.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new _e, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
        }
        onBeforeRender() { }
        onAfterRender() { }
        applyMatrix4(t) {
            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
        }
        applyQuaternion(t) {
            return this.quaternion.premultiply(t), this
        }
        setRotationFromAxisAngle(t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        }
        setRotationFromEuler(t) {
            this.quaternion.setFromEuler(t, !0)
        }
        setRotationFromMatrix(t) {
            this.quaternion.setFromRotationMatrix(t)
        }
        setRotationFromQuaternion(t) {
            this.quaternion.copy(t)
        }
        rotateOnAxis(t, e) {
            return Me.setFromAxisAngle(t, e), this.quaternion.multiply(Me), this
        }
        rotateOnWorldAxis(t, e) {
            return Me.setFromAxisAngle(t, e), this.quaternion.premultiply(Me), this
        }
        rotateX(t) {
            return this.rotateOnAxis(Pe, t)
        }
        rotateY(t) {
            return this.rotateOnAxis(Le, t)
        }
        rotateZ(t) {
            return this.rotateOnAxis(Oe, t)
        }
        translateOnAxis(t, e) {
            return Se.copy(t).applyQuaternion(this.quaternion), this.position.add(Se.multiplyScalar(e)), this
        }
        translateX(t) {
            return this.translateOnAxis(Pe, t)
        }
        translateY(t) {
            return this.translateOnAxis(Le, t)
        }
        translateZ(t) {
            return this.translateOnAxis(Oe, t)
        }
        localToWorld(t) {
            return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
        }
        worldToLocal(t) {
            return this.updateWorldMatrix(!0, !1), t.applyMatrix4(Ee.copy(this.matrixWorld).invert())
        }
        lookAt(t, e, n) {
            t.isVector3 ? Te.copy(t) : Te.set(t, e, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1), Ce.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ee.lookAt(Ce, Te, this.up) : Ee.lookAt(Te, Ce, this.up), this.quaternion.setFromRotationMatrix(Ee), i && (Ee.extractRotation(i.matrixWorld), Me.setFromRotationMatrix(Ee), this.quaternion.premultiply(Me.invert()))
        }
        add(t) {
            if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(De)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
        }
        remove(t) {
            if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                return this
            }
            const e = this.children.indexOf(t);
            return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Ie)), this
        }
        removeFromParent() {
            const t = this.parent;
            return null !== t && t.remove(this), this
        }
        clear() {
            for (let t = 0; t < this.children.length; t++) {
                const e = this.children[t];
                e.parent = null, e.dispatchEvent(Ie)
            }
            return this.children.length = 0, this
        }
        attach(t) {
            return this.updateWorldMatrix(!0, !1), Ee.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Ee.multiply(t.parent.matrixWorld)), t.applyMatrix4(Ee), this.add(t), t.updateWorldMatrix(!1, !0), this
        }
        getObjectById(t) {
            return this.getObjectByProperty("id", t)
        }
        getObjectByName(t) {
            return this.getObjectByProperty("name", t)
        }
        getObjectByProperty(t, e) {
            if (this[t] === e) return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
                const i = this.children[n].getObjectByProperty(t, e);
                if (void 0 !== i) return i
            }
        }
        getObjectsByProperty(t, e) {
            let n = [];
            this[t] === e && n.push(this);
            for (let i = 0, r = this.children.length; i < r; i++) {
                const r = this.children[i].getObjectsByProperty(t, e);
                r.length > 0 && (n = n.concat(r))
            }
            return n
        }
        getWorldPosition(t) {
            return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
        }
        getWorldQuaternion(t) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ce, t, Ae), t
        }
        getWorldScale(t) {
            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ce, Re, t), t
        }
        getWorldDirection(t) {
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize()
        }
        raycast() { }
        traverse(t) {
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
        }
        traverseVisible(t) {
            if (!1 === this.visible) return;
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
        }
        traverseAncestors(t) {
            const e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t))
        }
        updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        }
        updateMatrixWorld(t) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) {
                const i = e[n];
                !0 !== i.matrixWorldAutoUpdate && !0 !== t || i.updateMatrixWorld(t)
            }
        }
        updateWorldMatrix(t, e) {
            const n = this.parent;
            if (!0 === t && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                const t = this.children;
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e];
                    !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
                }
            }
        }
        toJSON(t) {
            const e = void 0 === t || "string" == typeof t,
                n = {};
            e && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
                nodes: {}
            }, n.metadata = {
                version: 4.6,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            const i = {};

            function r(e, n) {
                return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
            }
            if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(t).uuid);
            else if (this.isMesh || this.isLine || this.isPoints) {
                i.geometry = r(t.geometries, this.geometry);
                const e = this.geometry.parameters;
                if (void 0 !== e && void 0 !== e.shapes) {
                    const n = e.shapes;
                    if (Array.isArray(n))
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            r(t.shapes, i)
                        } else r(t.shapes, n)
                }
            }
            if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    const e = [];
                    for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));
                    i.material = e
                } else i.material = r(t.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object)
            }
            if (this.animations.length > 0) {
                i.animations = [];
                for (let e = 0; e < this.animations.length; e++) {
                    const n = this.animations[e];
                    i.animations.push(r(t.animations, n))
                }
            }
            if (e) {
                const e = s(t.geometries),
                    i = s(t.materials),
                    r = s(t.textures),
                    a = s(t.images),
                    o = s(t.shapes),
                    l = s(t.skeletons),
                    c = s(t.animations),
                    h = s(t.nodes);
                e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), a.length > 0 && (n.images = a), o.length > 0 && (n.shapes = o), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), h.length > 0 && (n.nodes = h)
            }
            return n.object = i, n;

            function s(t) {
                const e = [];
                for (const n in t) {
                    const i = t[n];
                    delete i.metadata, e.push(i)
                }
                return e
            }
        }
        clone(t) {
            return (new this.constructor).copy(this, t)
        }
        copy(t, e = !0) {
            if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                for (let e = 0; e < t.children.length; e++) {
                    const n = t.children[e];
                    this.add(n.clone())
                }
            return this
        }
    }
    ke.DEFAULT_UP = new It(0, 1, 0), ke.DEFAULT_MATRIX_AUTO_UPDATE = !0, ke.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
    const Ne = new It,
        Ue = new It,
        ze = new It,
        Fe = new It,
        $e = new It,
        Be = new It,
        He = new It,
        je = new It,
        Ve = new It,
        Ge = new It;
    let We = !1;
    class qe {
        constructor(t = new It, e = new It, n = new It) {
            this.a = t, this.b = e, this.c = n
        }
        static getNormal(t, e, n, i) {
            i.subVectors(n, e), Ne.subVectors(t, e), i.cross(Ne);
            const r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
        }
        static getBarycoord(t, e, n, i, r) {
            Ne.subVectors(i, e), Ue.subVectors(n, e), ze.subVectors(t, e);
            const s = Ne.dot(Ne),
                a = Ne.dot(Ue),
                o = Ne.dot(ze),
                l = Ue.dot(Ue),
                c = Ue.dot(ze),
                h = s * l - a * a;
            if (0 === h) return r.set(-2, -1, -1);
            const u = 1 / h,
                d = (l * o - a * c) * u,
                p = (s * c - a * o) * u;
            return r.set(1 - d - p, p, d)
        }
        static containsPoint(t, e, n, i) {
            return this.getBarycoord(t, e, n, i, Fe), Fe.x >= 0 && Fe.y >= 0 && Fe.x + Fe.y <= 1
        }
        static getUV(t, e, n, i, r, s, a, o) {
            return !1 === We && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), We = !0), this.getInterpolation(t, e, n, i, r, s, a, o)
        }
        static getInterpolation(t, e, n, i, r, s, a, o) {
            return this.getBarycoord(t, e, n, i, Fe), o.setScalar(0), o.addScaledVector(r, Fe.x), o.addScaledVector(s, Fe.y), o.addScaledVector(a, Fe.z), o
        }
        static isFrontFacing(t, e, n, i) {
            return Ne.subVectors(n, e), Ue.subVectors(t, e), Ne.cross(Ue).dot(i) < 0
        }
        set(t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
        }
        setFromPointsAndIndices(t, e, n, i) {
            return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
        }
        setFromAttributeAndIndices(t, e, n, i) {
            return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, i), this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
        }
        getArea() {
            return Ne.subVectors(this.c, this.b), Ue.subVectors(this.a, this.b), .5 * Ne.cross(Ue).length()
        }
        getMidpoint(t) {
            return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }
        getNormal(t) {
            return qe.getNormal(this.a, this.b, this.c, t)
        }
        getPlane(t) {
            return t.setFromCoplanarPoints(this.a, this.b, this.c)
        }
        getBarycoord(t, e) {
            return qe.getBarycoord(t, this.a, this.b, this.c, e)
        }
        getUV(t, e, n, i, r) {
            return !1 === We && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), We = !0), qe.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
        }
        getInterpolation(t, e, n, i, r) {
            return qe.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
        }
        containsPoint(t) {
            return qe.containsPoint(t, this.a, this.b, this.c)
        }
        isFrontFacing(t) {
            return qe.isFrontFacing(this.a, this.b, this.c, t)
        }
        intersectsBox(t) {
            return t.intersectsTriangle(this)
        }
        closestPointToPoint(t, e) {
            const n = this.a,
                i = this.b,
                r = this.c;
            let s, a;
            $e.subVectors(i, n), Be.subVectors(r, n), je.subVectors(t, n);
            const o = $e.dot(je),
                l = Be.dot(je);
            if (o <= 0 && l <= 0) return e.copy(n);
            Ve.subVectors(t, i);
            const c = $e.dot(Ve),
                h = Be.dot(Ve);
            if (c >= 0 && h <= c) return e.copy(i);
            const u = o * h - c * l;
            if (u <= 0 && o >= 0 && c <= 0) return s = o / (o - c), e.copy(n).addScaledVector($e, s);
            Ge.subVectors(t, r);
            const d = $e.dot(Ge),
                p = Be.dot(Ge);
            if (p >= 0 && d <= p) return e.copy(r);
            const f = d * l - o * p;
            if (f <= 0 && l >= 0 && p <= 0) return a = l / (l - p), e.copy(n).addScaledVector(Be, a);
            const m = c * p - d * h;
            if (m <= 0 && h - c >= 0 && d - p >= 0) return He.subVectors(r, i), a = (h - c) / (h - c + (d - p)), e.copy(i).addScaledVector(He, a);
            const g = 1 / (m + f + u);
            return s = f * g, a = u * g, e.copy(n).addScaledVector($e, s).addScaledVector(Be, a)
        }
        equals(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    }
    let Xe = 0;
    class Ye extends W {
        constructor() {
            super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                value: Xe++
            }), this.uuid = Z(), this.name = "", this.type = "Material", this.blending = 1, this.side = a, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = f, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
        }
        get alphaTest() {
            return this._alphaTest
        }
        set alphaTest(t) {
            this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
        }
        onBuild() { }
        onBeforeRender() { }
        onBeforeCompile() { }
        customProgramCacheKey() {
            return this.onBeforeCompile.toString()
        }
        setValues(t) {
            if (void 0 !== t)
                for (const e in t) {
                    const n = t[e];
                    if (void 0 === n) {
                        console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
                        continue
                    }
                    const i = this[e];
                    void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`)
                }
        }
        toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            e && (t = {
                textures: {},
                images: {}
            });
            const n = {
                metadata: {
                    version: 4.6,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };

            function i(t) {
                const e = [];
                for (const n in t) {
                    const i = t[n];
                    delete i.metadata, e.push(i)
                }
                return e
            }
            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), this.side !== a && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = this.alphaHash), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.forceSinglePass && (n.forceSinglePass = this.forceSinglePass), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), e) {
                const e = i(t.textures),
                    r = i(t.images);
                e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
            }
            return n
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
            const e = t.clippingPlanes;
            let n = null;
            if (null !== e) {
                const t = e.length;
                n = new Array(t);
                for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
            }
            return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        set needsUpdate(t) {
            !0 === t && this.version++
        }
    }
    const Ke = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    },
        Ze = {
            h: 0,
            s: 0,
            l: 0
        },
        Je = {
            h: 0,
            s: 0,
            l: 0
        };

    function Qe(t, e, n) {
        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
    }
    class tn {
        constructor(t, e, n) {
            return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, n)
        }
        set(t, e, n) {
            if (void 0 === e && void 0 === n) {
                const e = t;
                e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e)
            } else this.setRGB(t, e, n);
            return this
        }
        setScalar(t) {
            return this.r = t, this.g = t, this.b = t, this
        }
        setHex(t, e = V) {
            return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, xt.toWorkingColorSpace(this, e), this
        }
        setRGB(t, e, n, i = xt.workingColorSpace) {
            return this.r = t, this.g = e, this.b = n, xt.toWorkingColorSpace(this, i), this
        }
        setHSL(t, e, n, i = xt.workingColorSpace) {
            if (t = Q(t, 1), e = J(e, 0, 1), n = J(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
            else {
                const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                    r = 2 * n - i;
                this.r = Qe(r, i, t + 1 / 3), this.g = Qe(r, i, t), this.b = Qe(r, i, t - 1 / 3)
            }
            return xt.toWorkingColorSpace(this, i), this
        }
        setStyle(t, e = V) {
            function n(e) {
                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }
            let i;
            if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
                let r;
                const s = i[1],
                    a = i[2];
                switch (s) {
                    case "rgb":
                    case "rgba":
                        if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, e);
                        if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, e);
                        break;
                    case "hsl":
                    case "hsla":
                        if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, e);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + t)
                }
            } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                const n = i[1],
                    r = n.length;
                if (3 === r) return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, e);
                if (6 === r) return this.setHex(parseInt(n, 16), e);
                console.warn("THREE.Color: Invalid hex color " + t)
            } else if (t && t.length > 0) return this.setColorName(t, e);
            return this
        }
        setColorName(t, e = V) {
            const n = Ke[t.toLowerCase()];
            return void 0 !== n ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this
        }
        clone() {
            return new this.constructor(this.r, this.g, this.b)
        }
        copy(t) {
            return this.r = t.r, this.g = t.g, this.b = t.b, this
        }
        copySRGBToLinear(t) {
            return this.r = ft(t.r), this.g = ft(t.g), this.b = ft(t.b), this
        }
        copyLinearToSRGB(t) {
            return this.r = mt(t.r), this.g = mt(t.g), this.b = mt(t.b), this
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this
        }
        getHex(t = V) {
            return xt.fromWorkingColorSpace(en.copy(this), t), 65536 * Math.round(J(255 * en.r, 0, 255)) + 256 * Math.round(J(255 * en.g, 0, 255)) + Math.round(J(255 * en.b, 0, 255))
        }
        getHexString(t = V) {
            return ("000000" + this.getHex(t).toString(16)).slice(-6)
        }
        getHSL(t, e = xt.workingColorSpace) {
            xt.fromWorkingColorSpace(en.copy(this), e);
            const n = en.r,
                i = en.g,
                r = en.b,
                s = Math.max(n, i, r),
                a = Math.min(n, i, r);
            let o, l;
            const c = (a + s) / 2;
            if (a === s) o = 0, l = 0;
            else {
                const t = s - a;
                switch (l = c <= .5 ? t / (s + a) : t / (2 - s - a), s) {
                    case n:
                        o = (i - r) / t + (i < r ? 6 : 0);
                        break;
                    case i:
                        o = (r - n) / t + 2;
                        break;
                    case r:
                        o = (n - i) / t + 4
                }
                o /= 6
            }
            return t.h = o, t.s = l, t.l = c, t
        }
        getRGB(t, e = xt.workingColorSpace) {
            return xt.fromWorkingColorSpace(en.copy(this), e), t.r = en.r, t.g = en.g, t.b = en.b, t
        }
        getStyle(t = V) {
            xt.fromWorkingColorSpace(en.copy(this), t);
            const e = en.r,
                n = en.g,
                i = en.b;
            return t !== V ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(255 * i)})`
        }
        offsetHSL(t, e, n) {
            return this.getHSL(Ze), Ze.h += t, Ze.s += e, Ze.l += n, this.setHSL(Ze.h, Ze.s, Ze.l), this
        }
        add(t) {
            return this.r += t.r, this.g += t.g, this.b += t.b, this
        }
        addColors(t, e) {
            return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
        }
        addScalar(t) {
            return this.r += t, this.g += t, this.b += t, this
        }
        sub(t) {
            return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
        }
        multiply(t) {
            return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
        }
        multiplyScalar(t) {
            return this.r *= t, this.g *= t, this.b *= t, this
        }
        lerp(t, e) {
            return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
        }
        lerpColors(t, e, n) {
            return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
        }
        lerpHSL(t, e) {
            this.getHSL(Ze), t.getHSL(Je);
            const n = tt(Ze.h, Je.h, e),
                i = tt(Ze.s, Je.s, e),
                r = tt(Ze.l, Je.l, e);
            return this.setHSL(n, i, r), this
        }
        setFromVector3(t) {
            return this.r = t.x, this.g = t.y, this.b = t.z, this
        }
        applyMatrix3(t) {
            const e = this.r,
                n = this.g,
                i = this.b,
                r = t.elements;
            return this.r = r[0] * e + r[3] * n + r[6] * i, this.g = r[1] * e + r[4] * n + r[7] * i, this.b = r[2] * e + r[5] * n + r[8] * i, this
        }
        equals(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        }
        fromArray(t, e = 0) {
            return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
        }
        toArray(t = [], e = 0) {
            return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
        }
        fromBufferAttribute(t, e) {
            return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this
        }
        toJSON() {
            return this.getHex()
        } *[Symbol.iterator]() {
            yield this.r, yield this.g, yield this.b
        }
    }
    const en = new tn;
    tn.NAMES = Ke;
    class nn extends Ye {
        constructor(t) {
            super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new tn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t)
        }
        copy(t) {
            return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this
        }
    }
    const rn = new It,
        sn = new ot;
    class an {
        constructor(t, e, n = !1) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = n, this.usage = 35044, this.updateRange = {
                offset: 0,
                count: -1
            }, this.gpuType = L, this.version = 0
        }
        onUploadCallback() { }
        set needsUpdate(t) {
            !0 === t && this.version++
        }
        setUsage(t) {
            return this.usage = t, this
        }
        copy(t) {
            return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this
        }
        copyAt(t, e, n) {
            t *= this.itemSize, n *= e.itemSize;
            for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
            return this
        }
        copyArray(t) {
            return this.array.set(t), this
        }
        applyMatrix3(t) {
            if (2 === this.itemSize)
                for (let e = 0, n = this.count; e < n; e++) sn.fromBufferAttribute(this, e), sn.applyMatrix3(t), this.setXY(e, sn.x, sn.y);
            else if (3 === this.itemSize)
                for (let e = 0, n = this.count; e < n; e++) rn.fromBufferAttribute(this, e), rn.applyMatrix3(t), this.setXYZ(e, rn.x, rn.y, rn.z);
            return this
        }
        applyMatrix4(t) {
            for (let e = 0, n = this.count; e < n; e++) rn.fromBufferAttribute(this, e), rn.applyMatrix4(t), this.setXYZ(e, rn.x, rn.y, rn.z);
            return this
        }
        applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++) rn.fromBufferAttribute(this, e), rn.applyNormalMatrix(t), this.setXYZ(e, rn.x, rn.y, rn.z);
            return this
        }
        transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++) rn.fromBufferAttribute(this, e), rn.transformDirection(t), this.setXYZ(e, rn.x, rn.y, rn.z);
            return this
        }
        set(t, e = 0) {
            return this.array.set(t, e), this
        }
        getComponent(t, e) {
            let n = this.array[t * this.itemSize + e];
            return this.normalized && (n = rt(n, this.array)), n
        }
        setComponent(t, e, n) {
            return this.normalized && (n = st(n, this.array)), this.array[t * this.itemSize + e] = n, this
        }
        getX(t) {
            let e = this.array[t * this.itemSize];
            return this.normalized && (e = rt(e, this.array)), e
        }
        setX(t, e) {
            return this.normalized && (e = st(e, this.array)), this.array[t * this.itemSize] = e, this
        }
        getY(t) {
            let e = this.array[t * this.itemSize + 1];
            return this.normalized && (e = rt(e, this.array)), e
        }
        setY(t, e) {
            return this.normalized && (e = st(e, this.array)), this.array[t * this.itemSize + 1] = e, this
        }
        getZ(t) {
            let e = this.array[t * this.itemSize + 2];
            return this.normalized && (e = rt(e, this.array)), e
        }
        setZ(t, e) {
            return this.normalized && (e = st(e, this.array)), this.array[t * this.itemSize + 2] = e, this
        }
        getW(t) {
            let e = this.array[t * this.itemSize + 3];
            return this.normalized && (e = rt(e, this.array)), e
        }
        setW(t, e) {
            return this.normalized && (e = st(e, this.array)), this.array[t * this.itemSize + 3] = e, this
        }
        setXY(t, e, n) {
            return t *= this.itemSize, this.normalized && (e = st(e, this.array), n = st(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this
        }
        setXYZ(t, e, n, i) {
            return t *= this.itemSize, this.normalized && (e = st(e, this.array), n = st(n, this.array), i = st(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
        }
        setXYZW(t, e, n, i, r) {
            return t *= this.itemSize, this.normalized && (e = st(e, this.array), n = st(n, this.array), i = st(i, this.array), r = st(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
        }
        onUpload(t) {
            return this.onUploadCallback = t, this
        }
        clone() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        }
        toJSON() {
            const t = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.from(this.array),
                normalized: this.normalized
            };
            return "" !== this.name && (t.name = this.name), 35044 !== this.usage && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
        }
    }
    class on extends an {
        constructor(t, e, n) {
            super(new Uint16Array(t), e, n)
        }
    }
    class ln extends an {
        constructor(t, e, n) {
            super(new Uint32Array(t), e, n)
        }
    }
    class cn extends an {
        constructor(t, e, n) {
            super(new Float32Array(t), e, n)
        }
    }
    let hn = 0;
    const un = new he,
        dn = new ke,
        pn = new It,
        fn = new Ut,
        mn = new Ut,
        gn = new It;
    class vn extends W {
        constructor() {
            super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                value: hn++
            }), this.uuid = Z(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }, this.userData = {}
        }
        getIndex() {
            return this.index
        }
        setIndex(t) {
            return Array.isArray(t) ? this.index = new (ht(t) ? ln : on)(t, 1) : this.index = t, this
        }
        getAttribute(t) {
            return this.attributes[t]
        }
        setAttribute(t, e) {
            return this.attributes[t] = e, this
        }
        deleteAttribute(t) {
            return delete this.attributes[t], this
        }
        hasAttribute(t) {
            return void 0 !== this.attributes[t]
        }
        addGroup(t, e, n = 0) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: n
            })
        }
        clearGroups() {
            this.groups = []
        }
        setDrawRange(t, e) {
            this.drawRange.start = t, this.drawRange.count = e
        }
        applyMatrix4(t) {
            const e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
            const n = this.attributes.normal;
            if (void 0 !== n) {
                const e = (new lt).getNormalMatrix(t);
                n.applyNormalMatrix(e), n.needsUpdate = !0
            }
            const i = this.attributes.tangent;
            return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        }
        applyQuaternion(t) {
            return un.makeRotationFromQuaternion(t), this.applyMatrix4(un), this
        }
        rotateX(t) {
            return un.makeRotationX(t), this.applyMatrix4(un), this
        }
        rotateY(t) {
            return un.makeRotationY(t), this.applyMatrix4(un), this
        }
        rotateZ(t) {
            return un.makeRotationZ(t), this.applyMatrix4(un), this
        }
        translate(t, e, n) {
            return un.makeTranslation(t, e, n), this.applyMatrix4(un), this
        }
        scale(t, e, n) {
            return un.makeScale(t, e, n), this.applyMatrix4(un), this
        }
        lookAt(t) {
            return dn.lookAt(t), dn.updateMatrix(), this.applyMatrix4(dn.matrix), this
        }
        center() {
            return this.computeBoundingBox(), this.boundingBox.getCenter(pn).negate(), this.translate(pn.x, pn.y, pn.z), this
        }
        setFromPoints(t) {
            const e = [];
            for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n];
                e.push(i.x, i.y, i.z || 0)
            }
            return this.setAttribute("position", new cn(e, 3)), this
        }
        computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new Ut);
            const t = this.attributes.position,
                e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new It(-1 / 0, -1 / 0, -1 / 0), new It(1 / 0, 1 / 0, 1 / 0));
            if (void 0 !== t) {
                if (this.boundingBox.setFromBufferAttribute(t), e)
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        fn.setFromBufferAttribute(n), this.morphTargetsRelative ? (gn.addVectors(this.boundingBox.min, fn.min), this.boundingBox.expandByPoint(gn), gn.addVectors(this.boundingBox.max, fn.max), this.boundingBox.expandByPoint(gn)) : (this.boundingBox.expandByPoint(fn.min), this.boundingBox.expandByPoint(fn.max))
                    }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        }
        computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new ee);
            const t = this.attributes.position,
                e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new It, 1 / 0);
            if (t) {
                const n = this.boundingSphere.center;
                if (fn.setFromBufferAttribute(t), e)
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        mn.setFromBufferAttribute(n), this.morphTargetsRelative ? (gn.addVectors(fn.min, mn.min), fn.expandByPoint(gn), gn.addVectors(fn.max, mn.max), fn.expandByPoint(gn)) : (fn.expandByPoint(mn.min), fn.expandByPoint(mn.max))
                    }
                fn.getCenter(n);
                let i = 0;
                for (let e = 0, r = t.count; e < r; e++) gn.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(gn));
                if (e)
                    for (let r = 0, s = e.length; r < s; r++) {
                        const s = e[r],
                            a = this.morphTargetsRelative;
                        for (let e = 0, r = s.count; e < r; e++) gn.fromBufferAttribute(s, e), a && (pn.fromBufferAttribute(t, e), gn.add(pn)), i = Math.max(i, n.distanceToSquared(gn))
                    }
                this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }
        computeTangents() {
            const t = this.index,
                e = this.attributes;
            if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            const n = t.array,
                i = e.position.array,
                r = e.normal.array,
                s = e.uv.array,
                a = i.length / 3;
            !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new an(new Float32Array(4 * a), 4));
            const o = this.getAttribute("tangent").array,
                l = [],
                c = [];
            for (let t = 0; t < a; t++) l[t] = new It, c[t] = new It;
            const h = new It,
                u = new It,
                d = new It,
                p = new ot,
                f = new ot,
                m = new ot,
                g = new It,
                v = new It;

            function y(t, e, n) {
                h.fromArray(i, 3 * t), u.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(s, 2 * t), f.fromArray(s, 2 * e), m.fromArray(s, 2 * n), u.sub(h), d.sub(h), f.sub(p), m.sub(p);
                const r = 1 / (f.x * m.y - m.x * f.y);
                isFinite(r) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r), v.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(v), c[e].add(v), c[n].add(v))
            }
            let b = this.groups;
            0 === b.length && (b = [{
                start: 0,
                count: n.length
            }]);
            for (let t = 0, e = b.length; t < e; ++t) {
                const e = b[t],
                    i = e.start;
                for (let t = i, r = i + e.count; t < r; t += 3) y(n[t + 0], n[t + 1], n[t + 2])
            }
            const x = new It,
                _ = new It,
                w = new It,
                S = new It;

            function M(t) {
                w.fromArray(r, 3 * t), S.copy(w);
                const e = l[t];
                x.copy(e), x.sub(w.multiplyScalar(w.dot(e))).normalize(), _.crossVectors(S, e);
                const n = _.dot(c[t]) < 0 ? -1 : 1;
                o[4 * t] = x.x, o[4 * t + 1] = x.y, o[4 * t + 2] = x.z, o[4 * t + 3] = n
            }
            for (let t = 0, e = b.length; t < e; ++t) {
                const e = b[t],
                    i = e.start;
                for (let t = i, r = i + e.count; t < r; t += 3) M(n[t + 0]), M(n[t + 1]), M(n[t + 2])
            }
        }
        computeVertexNormals() {
            const t = this.index,
                e = this.getAttribute("position");
            if (void 0 !== e) {
                let n = this.getAttribute("normal");
                if (void 0 === n) n = new an(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                else
                    for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                const i = new It,
                    r = new It,
                    s = new It,
                    a = new It,
                    o = new It,
                    l = new It,
                    c = new It,
                    h = new It;
                if (t)
                    for (let u = 0, d = t.count; u < d; u += 3) {
                        const d = t.getX(u + 0),
                            p = t.getX(u + 1),
                            f = t.getX(u + 2);
                        i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, f), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), a.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), a.add(c), o.add(c), l.add(c), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(f, l.x, l.y, l.z)
                    } else
                    for (let t = 0, a = e.count; t < a; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), c.subVectors(s, r), h.subVectors(i, r), c.cross(h), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z);
                this.normalizeNormals(), n.needsUpdate = !0
            }
        }
        normalizeNormals() {
            const t = this.attributes.normal;
            for (let e = 0, n = t.count; e < n; e++) gn.fromBufferAttribute(t, e), gn.normalize(), t.setXYZ(e, gn.x, gn.y, gn.z)
        }
        toNonIndexed() {
            function t(t, e) {
                const n = t.array,
                    i = t.itemSize,
                    r = t.normalized,
                    s = new n.constructor(e.length * i);
                let a = 0,
                    o = 0;
                for (let r = 0, l = e.length; r < l; r++) {
                    a = t.isInterleavedBufferAttribute ? e[r] * t.data.stride + t.offset : e[r] * i;
                    for (let t = 0; t < i; t++) s[o++] = n[a++]
                }
                return new an(s, i, r)
            }
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
            const e = new vn,
                n = this.index.array,
                i = this.attributes;
            for (const r in i) {
                const s = t(i[r], n);
                e.setAttribute(r, s)
            }
            const r = this.morphAttributes;
            for (const i in r) {
                const s = [],
                    a = r[i];
                for (let e = 0, i = a.length; e < i; e++) {
                    const i = t(a[e], n);
                    s.push(i)
                }
                e.morphAttributes[i] = s
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            const s = this.groups;
            for (let t = 0, n = s.length; t < n; t++) {
                const n = s[t];
                e.addGroup(n.start, n.count, n.materialIndex)
            }
            return e
        }
        toJSON() {
            const t = {
                metadata: {
                    version: 4.6,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                const e = this.parameters;
                for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            t.data = {
                attributes: {}
            };
            const e = this.index;
            null !== e && (t.data.index = {
                type: e.array.constructor.name,
                array: Array.prototype.slice.call(e.array)
            });
            const n = this.attributes;
            for (const e in n) {
                const i = n[e];
                t.data.attributes[e] = i.toJSON(t.data)
            }
            const i = {};
            let r = !1;
            for (const e in this.morphAttributes) {
                const n = this.morphAttributes[e],
                    s = [];
                for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    s.push(i.toJSON(t.data))
                }
                s.length > 0 && (i[e] = s, r = !0)
            }
            r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
            const s = this.groups;
            s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
            const a = this.boundingSphere;
            return null !== a && (t.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius
            }), t
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
            const e = {};
            this.name = t.name;
            const n = t.index;
            null !== n && this.setIndex(n.clone(e));
            const i = t.attributes;
            for (const t in i) {
                const n = i[t];
                this.setAttribute(t, n.clone(e))
            }
            const r = t.morphAttributes;
            for (const t in r) {
                const n = [],
                    i = r[t];
                for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
                this.morphAttributes[t] = n
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            const s = t.groups;
            for (let t = 0, e = s.length; t < e; t++) {
                const e = s[t];
                this.addGroup(e.start, e.count, e.materialIndex)
            }
            const a = t.boundingBox;
            null !== a && (this.boundingBox = a.clone());
            const o = t.boundingSphere;
            return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    const yn = new he,
        bn = new ce,
        xn = new ee,
        _n = new It,
        wn = new It,
        Sn = new It,
        Mn = new It,
        En = new It,
        Tn = new It,
        Cn = new ot,
        An = new ot,
        Rn = new ot,
        Pn = new It,
        Ln = new It,
        On = new It,
        Dn = new It,
        In = new It;
    class kn extends ke {
        constructor(t = new vn, e = new nn) {
            super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
        }
        copy(t, e) {
            return super.copy(t, e), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes,
                e = Object.keys(t);
            if (e.length > 0) {
                const n = t[e[0]];
                if (void 0 !== n) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let t = 0, e = n.length; t < e; t++) {
                        const e = n[t].name || String(t);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                    }
                }
            }
        }
        getVertexPosition(t, e) {
            const n = this.geometry,
                i = n.attributes.position,
                r = n.morphAttributes.position,
                s = n.morphTargetsRelative;
            e.fromBufferAttribute(i, t);
            const a = this.morphTargetInfluences;
            if (r && a) {
                Tn.set(0, 0, 0);
                for (let n = 0, i = r.length; n < i; n++) {
                    const i = a[n],
                        o = r[n];
                    0 !== i && (En.fromBufferAttribute(o, t), s ? Tn.addScaledVector(En, i) : Tn.addScaledVector(En.sub(e), i))
                }
                e.add(Tn)
            }
            return e
        }
        raycast(t, e) {
            const n = this.geometry,
                i = this.material,
                r = this.matrixWorld;
            if (void 0 !== i) {
                if (null === n.boundingSphere && n.computeBoundingSphere(), xn.copy(n.boundingSphere), xn.applyMatrix4(r), bn.copy(t.ray).recast(t.near), !1 === xn.containsPoint(bn.origin)) {
                    if (null === bn.intersectSphere(xn, _n)) return;
                    if (bn.origin.distanceToSquared(_n) > (t.far - t.near) ** 2) return
                }
                yn.copy(r).invert(), bn.copy(t.ray).applyMatrix4(yn), null !== n.boundingBox && !1 === bn.intersectsBox(n.boundingBox) || this._computeIntersections(t, e, bn)
            }
        }
        _computeIntersections(t, e, n) {
            let i;
            const r = this.geometry,
                s = this.material,
                a = r.index,
                o = r.attributes.position,
                l = r.attributes.uv,
                c = r.attributes.uv1,
                h = r.attributes.normal,
                u = r.groups,
                d = r.drawRange;
            if (null !== a)
                if (Array.isArray(s))
                    for (let r = 0, o = u.length; r < o; r++) {
                        const o = u[r],
                            p = s[o.materialIndex];
                        for (let r = Math.max(o.start, d.start), s = Math.min(a.count, Math.min(o.start + o.count, d.start + d.count)); r < s; r += 3) {
                            i = Nn(this, p, t, n, l, c, h, a.getX(r), a.getX(r + 1), a.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = o.materialIndex, e.push(i))
                        }
                    } else {
                    for (let r = Math.max(0, d.start), o = Math.min(a.count, d.start + d.count); r < o; r += 3) {
                        i = Nn(this, s, t, n, l, c, h, a.getX(r), a.getX(r + 1), a.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), e.push(i))
                    }
                } else if (void 0 !== o)
                if (Array.isArray(s))
                    for (let r = 0, a = u.length; r < a; r++) {
                        const a = u[r],
                            p = s[a.materialIndex];
                        for (let r = Math.max(a.start, d.start), s = Math.min(o.count, Math.min(a.start + a.count, d.start + d.count)); r < s; r += 3) {
                            i = Nn(this, p, t, n, l, c, h, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = a.materialIndex, e.push(i))
                        }
                    } else {
                    for (let r = Math.max(0, d.start), a = Math.min(o.count, d.start + d.count); r < a; r += 3) {
                        i = Nn(this, s, t, n, l, c, h, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), e.push(i))
                    }
                }
        }
    }

    function Nn(t, e, n, i, r, s, l, c, h, u) {
        t.getVertexPosition(c, wn), t.getVertexPosition(h, Sn), t.getVertexPosition(u, Mn);
        const d = function (t, e, n, i, r, s, l, c) {
            let h;
            if (h = e.side === o ? i.intersectTriangle(l, s, r, !0, c) : i.intersectTriangle(r, s, l, e.side === a, c), null === h) return null;
            In.copy(c), In.applyMatrix4(t.matrixWorld);
            const u = n.ray.origin.distanceTo(In);
            return u < n.near || u > n.far ? null : {
                distance: u,
                point: In.clone(),
                object: t
            }
        }(t, e, n, i, wn, Sn, Mn, Dn);
        if (d) {
            r && (Cn.fromBufferAttribute(r, c), An.fromBufferAttribute(r, h), Rn.fromBufferAttribute(r, u), d.uv = qe.getInterpolation(Dn, wn, Sn, Mn, Cn, An, Rn, new ot)), s && (Cn.fromBufferAttribute(s, c), An.fromBufferAttribute(s, h), Rn.fromBufferAttribute(s, u), d.uv1 = qe.getInterpolation(Dn, wn, Sn, Mn, Cn, An, Rn, new ot), d.uv2 = d.uv1), l && (Pn.fromBufferAttribute(l, c), Ln.fromBufferAttribute(l, h), On.fromBufferAttribute(l, u), d.normal = qe.getInterpolation(Dn, wn, Sn, Mn, Pn, Ln, On, new It), d.normal.dot(i.direction) > 0 && d.normal.multiplyScalar(-1));
            const t = {
                a: c,
                b: h,
                c: u,
                normal: new It,
                materialIndex: 0
            };
            qe.getNormal(wn, Sn, Mn, t.normal), d.face = t
        }
        return d
    }
    class Un extends vn {
        constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
            super(), this.type = "BoxGeometry", this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: s
            };
            const a = this;
            i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
            const o = [],
                l = [],
                c = [],
                h = [];
            let u = 0,
                d = 0;

            function p(t, e, n, i, r, s, p, f, m, g, v) {
                const y = s / m,
                    b = p / g,
                    x = s / 2,
                    _ = p / 2,
                    w = f / 2,
                    S = m + 1,
                    M = g + 1;
                let E = 0,
                    T = 0;
                const C = new It;
                for (let s = 0; s < M; s++) {
                    const a = s * b - _;
                    for (let o = 0; o < S; o++) {
                        const u = o * y - x;
                        C[t] = u * i, C[e] = a * r, C[n] = w, l.push(C.x, C.y, C.z), C[t] = 0, C[e] = 0, C[n] = f > 0 ? 1 : -1, c.push(C.x, C.y, C.z), h.push(o / m), h.push(1 - s / g), E += 1
                    }
                }
                for (let t = 0; t < g; t++)
                    for (let e = 0; e < m; e++) {
                        const n = u + e + S * t,
                            i = u + e + S * (t + 1),
                            r = u + (e + 1) + S * (t + 1),
                            s = u + (e + 1) + S * t;
                        o.push(n, i, s), o.push(i, r, s), T += 6
                    }
                a.addGroup(d, T, v), d += T, u += E
            }
            p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new cn(l, 3)), this.setAttribute("normal", new cn(c, 3)), this.setAttribute("uv", new cn(h, 2))
        }
        copy(t) {
            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
        }
        static fromJSON(t) {
            return new Un(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments)
        }
    }

    function zn(t) {
        const e = {};
        for (const n in t) {
            e[n] = {};
            for (const i in t[n]) {
                const r = t[n][i];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[n][i] = null) : e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
            }
        }
        return e
    }

    function Fn(t) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const i = zn(t[n]);
            for (const t in i) e[t] = i[t]
        }
        return e
    }

    function $n(t) {
        return null === t.getRenderTarget() ? t.outputColorSpace : G
    }
    const Bn = {
        clone: zn,
        merge: Fn
    };
    class Hn extends Ye {
        constructor(t) {
            super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv1: [0, 0]
            }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && this.setValues(t)
        }
        copy(t) {
            return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = zn(t.uniforms), this.uniformsGroups = function (t) {
                const e = [];
                for (let n = 0; n < t.length; n++) e.push(t[n].clone());
                return e
            }(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            e.glslVersion = this.glslVersion, e.uniforms = {};
            for (const n in this.uniforms) {
                const i = this.uniforms[n].value;
                i && i.isTexture ? e.uniforms[n] = {
                    type: "t",
                    value: i.toJSON(t).uuid
                } : i && i.isColor ? e.uniforms[n] = {
                    type: "c",
                    value: i.getHex()
                } : i && i.isVector2 ? e.uniforms[n] = {
                    type: "v2",
                    value: i.toArray()
                } : i && i.isVector3 ? e.uniforms[n] = {
                    type: "v3",
                    value: i.toArray()
                } : i && i.isVector4 ? e.uniforms[n] = {
                    type: "v4",
                    value: i.toArray()
                } : i && i.isMatrix3 ? e.uniforms[n] = {
                    type: "m3",
                    value: i.toArray()
                } : i && i.isMatrix4 ? e.uniforms[n] = {
                    type: "m4",
                    value: i.toArray()
                } : e.uniforms[n] = {
                    value: i
                }
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
            const n = {};
            for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
            return Object.keys(n).length > 0 && (e.extensions = n), e
        }
    }
    class jn extends ke {
        constructor() {
            super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new he, this.projectionMatrix = new he, this.projectionMatrixInverse = new he, this.coordinateSystem = 2e3
        }
        copy(t, e) {
            return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this
        }
        getWorldDirection(t) {
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize()
        }
        updateMatrixWorld(t) {
            super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        updateWorldMatrix(t, e) {
            super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    class Vn extends jn {
        constructor(t = 50, e = 1, n = .1, i = 2e3) {
            super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }
        copy(t, e) {
            return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
        }
        setFocalLength(t) {
            const e = .5 * this.getFilmHeight() / t;
            this.fov = 2 * K * Math.atan(e), this.updateProjectionMatrix()
        }
        getFocalLength() {
            const t = Math.tan(.5 * Y * this.fov);
            return .5 * this.getFilmHeight() / t
        }
        getEffectiveFOV() {
            return 2 * K * Math.atan(Math.tan(.5 * Y * this.fov) / this.zoom)
        }
        getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1)
        }
        getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1)
        }
        setViewOffset(t, e, n, i, r, s) {
            this.aspect = t / e, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
        }
        clearViewOffset() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const t = this.near;
            let e = t * Math.tan(.5 * Y * this.fov) / this.zoom,
                n = 2 * e,
                i = this.aspect * n,
                r = -.5 * i;
            const s = this.view;
            if (null !== this.view && this.view.enabled) {
                const t = s.fullWidth,
                    a = s.fullHeight;
                r += s.offsetX * i / t, e -= s.offsetY * n / a, i *= s.width / t, n *= s.height / a
            }
            const a = this.filmOffset;
            0 !== a && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
        }
    }
    class Gn extends ke {
        constructor(t, e, n) {
            super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null;
            const i = new Vn(-90, 1, t, e);
            i.layers = this.layers, this.add(i);
            const r = new Vn(-90, 1, t, e);
            r.layers = this.layers, this.add(r);
            const s = new Vn(-90, 1, t, e);
            s.layers = this.layers, this.add(s);
            const a = new Vn(-90, 1, t, e);
            a.layers = this.layers, this.add(a);
            const o = new Vn(-90, 1, t, e);
            o.layers = this.layers, this.add(o);
            const l = new Vn(-90, 1, t, e);
            l.layers = this.layers, this.add(l)
        }
        updateCoordinateSystem() {
            const t = this.coordinateSystem,
                e = this.children.concat(),
                [n, i, r, s, a, o] = e;
            for (const t of e) this.remove(t);
            if (2e3 === t) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), s.up.set(0, 0, 1), s.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), o.up.set(0, 1, 0), o.lookAt(0, 0, -1);
            else {
                if (2001 !== t) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
                n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), s.up.set(0, 0, -1), s.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), o.up.set(0, -1, 0), o.lookAt(0, 0, -1)
            }
            for (const t of e) this.add(t), t.updateMatrixWorld()
        }
        update(t, e) {
            null === this.parent && this.updateMatrixWorld();
            const n = this.renderTarget;
            this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
            const [i, r, s, a, o, l] = this.children, c = t.getRenderTarget(), h = t.xr.enabled;
            t.xr.enabled = !1;
            const u = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, a), t.setRenderTarget(n, 4), t.render(e, o), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(c), t.xr.enabled = h, n.texture.needsPMREMUpdate = !0
        }
    }
    class Wn extends Ct {
        constructor(t, e, n, i, r, s, a, o, l, c) {
            super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : 301, n, i, r, s, a, o, l, c), this.isCubeTexture = !0, this.flipY = !1
        }
        get images() {
            return this.image
        }
        set images(t) {
            this.image = t
        }
    }
    class qn extends Pt {
        constructor(t = 1, e = {}) {
            super(t, t, e), this.isWebGLCubeRenderTarget = !0;
            const n = {
                width: t,
                height: t,
                depth: 1
            },
                i = [n, n, n, n, n, n];
            void 0 !== e.encoding && (pt("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), e.colorSpace = e.encoding === B ? V : ""), this.texture = new Wn(i, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : C
        }
        fromEquirectangularTexture(t, e) {
            this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
            const n = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
            },
                i = new Un(5, 5, 5),
                r = new Hn({
                    name: "CubemapFromEquirect",
                    uniforms: zn(n.uniforms),
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader,
                    side: o,
                    blending: c
                });
            r.uniforms.tEquirect.value = e;
            const s = new kn(i, r),
                a = e.minFilter;
            e.minFilter === A && (e.minFilter = C);
            return new Gn(1, 10, this).update(t, s), e.minFilter = a, s.geometry.dispose(), s.material.dispose(), this
        }
        clear(t, e, n, i) {
            const r = t.getRenderTarget();
            for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
            t.setRenderTarget(r)
        }
    }
    const Xn = new It,
        Yn = new It,
        Kn = new lt;
    class Zn {
        constructor(t = new It(1, 0, 0), e = 0) {
            this.isPlane = !0, this.normal = t, this.constant = e
        }
        set(t, e) {
            return this.normal.copy(t), this.constant = e, this
        }
        setComponents(t, e, n, i) {
            return this.normal.set(t, e, n), this.constant = i, this
        }
        setFromNormalAndCoplanarPoint(t, e) {
            return this.normal.copy(t), this.constant = -e.dot(this.normal), this
        }
        setFromCoplanarPoints(t, e, n) {
            const i = Xn.subVectors(n, e).cross(Yn.subVectors(t, e)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, t), this
        }
        copy(t) {
            return this.normal.copy(t.normal), this.constant = t.constant, this
        }
        normalize() {
            const t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), this.constant *= t, this
        }
        negate() {
            return this.constant *= -1, this.normal.negate(), this
        }
        distanceToPoint(t) {
            return this.normal.dot(t) + this.constant
        }
        distanceToSphere(t) {
            return this.distanceToPoint(t.center) - t.radius
        }
        projectPoint(t, e) {
            return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
        }
        intersectLine(t, e) {
            const n = t.delta(Xn),
                i = this.normal.dot(n);
            if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
            const r = -(t.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r)
        }
        intersectsLine(t) {
            const e = this.distanceToPoint(t.start),
                n = this.distanceToPoint(t.end);
            return e < 0 && n > 0 || n < 0 && e > 0
        }
        intersectsBox(t) {
            return t.intersectsPlane(this)
        }
        intersectsSphere(t) {
            return t.intersectsPlane(this)
        }
        coplanarPoint(t) {
            return t.copy(this.normal).multiplyScalar(-this.constant)
        }
        applyMatrix4(t, e) {
            const n = e || Kn.getNormalMatrix(t),
                i = this.coplanarPoint(Xn).applyMatrix4(t),
                r = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(r), this
        }
        translate(t) {
            return this.constant -= t.dot(this.normal), this
        }
        equals(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    const Jn = new ee,
        Qn = new It;
    class ti {
        constructor(t = new Zn, e = new Zn, n = new Zn, i = new Zn, r = new Zn, s = new Zn) {
            this.planes = [t, e, n, i, r, s]
        }
        set(t, e, n, i, r, s) {
            const a = this.planes;
            return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(s), this
        }
        copy(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
            return this
        }
        setFromProjectionMatrix(t, e = 2e3) {
            const n = this.planes,
                i = t.elements,
                r = i[0],
                s = i[1],
                a = i[2],
                o = i[3],
                l = i[4],
                c = i[5],
                h = i[6],
                u = i[7],
                d = i[8],
                p = i[9],
                f = i[10],
                m = i[11],
                g = i[12],
                v = i[13],
                y = i[14],
                b = i[15];
            if (n[0].setComponents(o - r, u - l, m - d, b - g).normalize(), n[1].setComponents(o + r, u + l, m + d, b + g).normalize(), n[2].setComponents(o + s, u + c, m + p, b + v).normalize(), n[3].setComponents(o - s, u - c, m - p, b - v).normalize(), n[4].setComponents(o - a, u - h, m - f, b - y).normalize(), 2e3 === e) n[5].setComponents(o + a, u + h, m + f, b + y).normalize();
            else {
                if (2001 !== e) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
                n[5].setComponents(a, h, f, y).normalize()
            }
            return this
        }
        intersectsObject(t) {
            if (void 0 !== t.boundingSphere) null === t.boundingSphere && t.computeBoundingSphere(), Jn.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
            else {
                const e = t.geometry;
                null === e.boundingSphere && e.computeBoundingSphere(), Jn.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
            }
            return this.intersectsSphere(Jn)
        }
        intersectsSprite(t) {
            return Jn.center.set(0, 0, 0), Jn.radius = .7071067811865476, Jn.applyMatrix4(t.matrixWorld), this.intersectsSphere(Jn)
        }
        intersectsSphere(t) {
            const e = this.planes,
                n = t.center,
                i = -t.radius;
            for (let t = 0; t < 6; t++) {
                if (e[t].distanceToPoint(n) < i) return !1
            }
            return !0
        }
        intersectsBox(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) {
                const i = e[n];
                if (Qn.x = i.normal.x > 0 ? t.max.x : t.min.x, Qn.y = i.normal.y > 0 ? t.max.y : t.min.y, Qn.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Qn) < 0) return !1
            }
            return !0
        }
        containsPoint(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++)
                if (e[n].distanceToPoint(t) < 0) return !1;
            return !0
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }

    function ei() {
        let t = null,
            e = !1,
            n = null,
            i = null;

        function r(e, s) {
            n(e, s), i = t.requestAnimationFrame(r)
        }
        return {
            start: function () {
                !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0)
            },
            stop: function () {
                t.cancelAnimationFrame(i), e = !1
            },
            setAnimationLoop: function (t) {
                n = t
            },
            setContext: function (e) {
                t = e
            }
        }
    }

    function ni(t, e) {
        const n = e.isWebGL2,
            i = new WeakMap;
        return {
            get: function (t) {
                return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
            },
            remove: function (e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                const n = i.get(e);
                n && (t.deleteBuffer(n.buffer), i.delete(e))
            },
            update: function (e, r) {
                if (e.isGLBufferAttribute) {
                    const t = i.get(e);
                    return void ((!t || t.version < e.version) && i.set(e, {
                        buffer: e.buffer,
                        type: e.type,
                        bytesPerElement: e.elementSize,
                        version: e.version
                    }))
                }
                e.isInterleavedBufferAttribute && (e = e.data);
                const s = i.get(e);
                void 0 === s ? i.set(e, function (e, i) {
                    const r = e.array,
                        s = e.usage,
                        a = t.createBuffer();
                    let o;
                    if (t.bindBuffer(i, a), t.bufferData(i, r, s), e.onUploadCallback(), r instanceof Float32Array) o = t.FLOAT;
                    else if (r instanceof Uint16Array)
                        if (e.isFloat16BufferAttribute) {
                            if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                            o = t.HALF_FLOAT
                        } else o = t.UNSIGNED_SHORT;
                    else if (r instanceof Int16Array) o = t.SHORT;
                    else if (r instanceof Uint32Array) o = t.UNSIGNED_INT;
                    else if (r instanceof Int32Array) o = t.INT;
                    else if (r instanceof Int8Array) o = t.BYTE;
                    else if (r instanceof Uint8Array) o = t.UNSIGNED_BYTE;
                    else {
                        if (!(r instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r);
                        o = t.UNSIGNED_BYTE
                    }
                    return {
                        buffer: a,
                        type: o,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: e.version
                    }
                }(e, r)) : s.version < e.version && (! function (e, i, r) {
                    const s = i.array,
                        a = i.updateRange;
                    t.bindBuffer(r, e), -1 === a.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : t.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1), i.onUploadCallback()
                }(s.buffer, e, r), s.version = e.version)
            }
        }
    }
    class ii extends vn {
        constructor(t = 1, e = 1, n = 1, i = 1) {
            super(), this.type = "PlaneGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: n,
                heightSegments: i
            };
            const r = t / 2,
                s = e / 2,
                a = Math.floor(n),
                o = Math.floor(i),
                l = a + 1,
                c = o + 1,
                h = t / a,
                u = e / o,
                d = [],
                p = [],
                f = [],
                m = [];
            for (let t = 0; t < c; t++) {
                const e = t * u - s;
                for (let n = 0; n < l; n++) {
                    const i = n * h - r;
                    p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / a), m.push(1 - t / o)
                }
            }
            for (let t = 0; t < o; t++)
                for (let e = 0; e < a; e++) {
                    const n = e + l * t,
                        i = e + l * (t + 1),
                        r = e + 1 + l * (t + 1),
                        s = e + 1 + l * t;
                    d.push(n, i, s), d.push(i, r, s)
                }
            this.setIndex(d), this.setAttribute("position", new cn(p, 3)), this.setAttribute("normal", new cn(f, 3)), this.setAttribute("uv", new cn(m, 2))
        }
        copy(t) {
            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
        }
        static fromJSON(t) {
            return new ii(t.width, t.height, t.widthSegments, t.heightSegments)
        }
    }
    const ri = {
        alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
        alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
        alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
        iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        colorspace_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
        lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, vMapUv );\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
        normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
        normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
        clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
        clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
        iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
        opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
        transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
        uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
        uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
        backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
    },
        si = {
            common: {
                diffuse: {
                    value: new tn(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new lt
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new lt
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                },
                specularMapTransform: {
                    value: new lt
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                },
                aoMapTransform: {
                    value: new lt
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                },
                lightMapTransform: {
                    value: new lt
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpMapTransform: {
                    value: new lt
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalMapTransform: {
                    value: new lt
                },
                normalScale: {
                    value: new ot(1, 1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementMapTransform: {
                    value: new lt
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                },
                emissiveMapTransform: {
                    value: new lt
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                },
                metalnessMapTransform: {
                    value: new lt
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                },
                roughnessMapTransform: {
                    value: new lt
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new tn(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotLightMap: {
                    value: []
                },
                spotShadowMap: {
                    value: []
                },
                spotLightMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new tn(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new lt
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new lt
                }
            },
            sprite: {
                diffuse: {
                    value: new tn(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new ot(.5, .5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new lt
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new lt
                },
                alphaTest: {
                    value: 0
                }
            }
        },
        ai = {
            basic: {
                uniforms: Fn([si.common, si.specularmap, si.envmap, si.aomap, si.lightmap, si.fog]),
                vertexShader: ri.meshbasic_vert,
                fragmentShader: ri.meshbasic_frag
            },
            lambert: {
                uniforms: Fn([si.common, si.specularmap, si.envmap, si.aomap, si.lightmap, si.emissivemap, si.bumpmap, si.normalmap, si.displacementmap, si.fog, si.lights, {
                    emissive: {
                        value: new tn(0)
                    }
                }]),
                vertexShader: ri.meshlambert_vert,
                fragmentShader: ri.meshlambert_frag
            },
            phong: {
                uniforms: Fn([si.common, si.specularmap, si.envmap, si.aomap, si.lightmap, si.emissivemap, si.bumpmap, si.normalmap, si.displacementmap, si.fog, si.lights, {
                    emissive: {
                        value: new tn(0)
                    },
                    specular: {
                        value: new tn(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: ri.meshphong_vert,
                fragmentShader: ri.meshphong_frag
            },
            standard: {
                uniforms: Fn([si.common, si.envmap, si.aomap, si.lightmap, si.emissivemap, si.bumpmap, si.normalmap, si.displacementmap, si.roughnessmap, si.metalnessmap, si.fog, si.lights, {
                    emissive: {
                        value: new tn(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: ri.meshphysical_vert,
                fragmentShader: ri.meshphysical_frag
            },
            toon: {
                uniforms: Fn([si.common, si.aomap, si.lightmap, si.emissivemap, si.bumpmap, si.normalmap, si.displacementmap, si.gradientmap, si.fog, si.lights, {
                    emissive: {
                        value: new tn(0)
                    }
                }]),
                vertexShader: ri.meshtoon_vert,
                fragmentShader: ri.meshtoon_frag
            },
            matcap: {
                uniforms: Fn([si.common, si.bumpmap, si.normalmap, si.displacementmap, si.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: ri.meshmatcap_vert,
                fragmentShader: ri.meshmatcap_frag
            },
            points: {
                uniforms: Fn([si.points, si.fog]),
                vertexShader: ri.points_vert,
                fragmentShader: ri.points_frag
            },
            dashed: {
                uniforms: Fn([si.common, si.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: ri.linedashed_vert,
                fragmentShader: ri.linedashed_frag
            },
            depth: {
                uniforms: Fn([si.common, si.displacementmap]),
                vertexShader: ri.depth_vert,
                fragmentShader: ri.depth_frag
            },
            normal: {
                uniforms: Fn([si.common, si.bumpmap, si.normalmap, si.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: ri.meshnormal_vert,
                fragmentShader: ri.meshnormal_frag
            },
            sprite: {
                uniforms: Fn([si.sprite, si.fog]),
                vertexShader: ri.sprite_vert,
                fragmentShader: ri.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new lt
                    },
                    t2D: {
                        value: null
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: ri.background_vert,
                fragmentShader: ri.background_frag
            },
            backgroundCube: {
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    backgroundBlurriness: {
                        value: 0
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: ri.backgroundCube_vert,
                fragmentShader: ri.backgroundCube_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: ri.cube_vert,
                fragmentShader: ri.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: ri.equirect_vert,
                fragmentShader: ri.equirect_frag
            },
            distanceRGBA: {
                uniforms: Fn([si.common, si.displacementmap, {
                    referencePosition: {
                        value: new It
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: ri.distanceRGBA_vert,
                fragmentShader: ri.distanceRGBA_frag
            },
            shadow: {
                uniforms: Fn([si.lights, si.fog, {
                    color: {
                        value: new tn(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: ri.shadow_vert,
                fragmentShader: ri.shadow_frag
            }
        };
    ai.physical = {
        uniforms: Fn([ai.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatMapTransform: {
                value: new lt
            },
            clearcoatNormalMap: {
                value: null
            },
            clearcoatNormalMapTransform: {
                value: new lt
            },
            clearcoatNormalScale: {
                value: new ot(1, 1)
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatRoughnessMapTransform: {
                value: new lt
            },
            iridescence: {
                value: 0
            },
            iridescenceMap: {
                value: null
            },
            iridescenceMapTransform: {
                value: new lt
            },
            iridescenceIOR: {
                value: 1.3
            },
            iridescenceThicknessMinimum: {
                value: 100
            },
            iridescenceThicknessMaximum: {
                value: 400
            },
            iridescenceThicknessMap: {
                value: null
            },
            iridescenceThicknessMapTransform: {
                value: new lt
            },
            sheen: {
                value: 0
            },
            sheenColor: {
                value: new tn(0)
            },
            sheenColorMap: {
                value: null
            },
            sheenColorMapTransform: {
                value: new lt
            },
            sheenRoughness: {
                value: 1
            },
            sheenRoughnessMap: {
                value: null
            },
            sheenRoughnessMapTransform: {
                value: new lt
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            },
            transmissionMapTransform: {
                value: new lt
            },
            transmissionSamplerSize: {
                value: new ot
            },
            transmissionSamplerMap: {
                value: null
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            thicknessMapTransform: {
                value: new lt
            },
            attenuationDistance: {
                value: 0
            },
            attenuationColor: {
                value: new tn(0)
            },
            specularColor: {
                value: new tn(1, 1, 1)
            },
            specularColorMap: {
                value: null
            },
            specularColorMapTransform: {
                value: new lt
            },
            specularIntensity: {
                value: 1
            },
            specularIntensityMap: {
                value: null
            },
            specularIntensityMapTransform: {
                value: new lt
            },
            anisotropyVector: {
                value: new ot
            },
            anisotropyMap: {
                value: null
            },
            anisotropyMapTransform: {
                value: new lt
            }
        }]),
        vertexShader: ri.meshphysical_vert,
        fragmentShader: ri.meshphysical_frag
    };
    const oi = {
        r: 0,
        b: 0,
        g: 0
    };

    function li(t, e, n, i, r, s, l) {
        const c = new tn(0);
        let h, u, d = !0 === s ? 0 : 1,
            p = null,
            f = 0,
            m = null;

        function g(e, n) {
            e.getRGB(oi, $n(t)), i.buffers.color.setClear(oi.r, oi.g, oi.b, n, l)
        }
        return {
            getClearColor: function () {
                return c
            },
            setClearColor: function (t, e = 1) {
                c.set(t), d = e, g(c, d)
            },
            getClearAlpha: function () {
                return d
            },
            setClearAlpha: function (t) {
                d = t, g(c, d)
            },
            render: function (s, v) {
                let y = !1,
                    b = !0 === v.isScene ? v.background : null;
                if (b && b.isTexture) {
                    b = (v.backgroundBlurriness > 0 ? n : e).get(b)
                }
                switch (null === b ? g(c, d) : b && b.isColor && (g(b, 1), y = !0), t.xr.getEnvironmentBlendMode()) {
                    case "opaque":
                        y = !0;
                        break;
                    case "additive":
                        i.buffers.color.setClear(0, 0, 0, 1, l), y = !0;
                        break;
                    case "alpha-blend":
                        i.buffers.color.setClear(0, 0, 0, 0, l), y = !0
                }(t.autoClear || y) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), b && (b.isCubeTexture || 306 === b.mapping) ? (void 0 === u && (u = new kn(new Un(1, 1, 1), new Hn({
                    name: "BackgroundCubeMaterial",
                    uniforms: zn(ai.backgroundCube.uniforms),
                    vertexShader: ai.backgroundCube.vertexShader,
                    fragmentShader: ai.backgroundCube.fragmentShader,
                    side: o,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function (t, e, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld)
                }, Object.defineProperty(u.material, "envMap", {
                    get: function () {
                        return this.uniforms.envMap.value
                    }
                }), r.update(u)), u.material.uniforms.envMap.value = b, u.material.uniforms.flipEnvMap.value = b.isCubeTexture && !1 === b.isRenderTargetTexture ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = v.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, u.material.toneMapped = b.colorSpace !== V, p === b && f === b.version && m === t.toneMapping || (u.material.needsUpdate = !0, p = b, f = b.version, m = t.toneMapping), u.layers.enableAll(), s.unshift(u, u.geometry, u.material, 0, 0, null)) : b && b.isTexture && (void 0 === h && (h = new kn(new ii(2, 2), new Hn({
                    name: "BackgroundMaterial",
                    uniforms: zn(ai.background.uniforms),
                    vertexShader: ai.background.vertexShader,
                    fragmentShader: ai.background.fragmentShader,
                    side: a,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), h.geometry.deleteAttribute("normal"), Object.defineProperty(h.material, "map", {
                    get: function () {
                        return this.uniforms.t2D.value
                    }
                }), r.update(h)), h.material.uniforms.t2D.value = b, h.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, h.material.toneMapped = b.colorSpace !== V, !0 === b.matrixAutoUpdate && b.updateMatrix(), h.material.uniforms.uvTransform.value.copy(b.matrix), p === b && f === b.version && m === t.toneMapping || (h.material.needsUpdate = !0, p = b, f = b.version, m = t.toneMapping), h.layers.enableAll(), s.unshift(h, h.geometry, h.material, 0, 0, null))
            }
        }
    }

    function ci(t, e, n, i) {
        const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
            a = i.isWebGL2 || null !== s,
            o = {},
            l = p(null);
        let c = l,
            h = !1;

        function u(e) {
            return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
        }

        function d(e) {
            return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
        }

        function p(t) {
            const e = [],
                n = [],
                i = [];
            for (let t = 0; t < r; t++) e[t] = 0, n[t] = 0, i[t] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: e,
                enabledAttributes: n,
                attributeDivisors: i,
                object: t,
                attributes: {},
                index: null
            }
        }

        function f() {
            const t = c.newAttributes;
            for (let e = 0, n = t.length; e < n; e++) t[e] = 0
        }

        function m(t) {
            g(t, 0)
        }

        function g(n, r) {
            const s = c.newAttributes,
                a = c.enabledAttributes,
                o = c.attributeDivisors;
            if (s[n] = 1, 0 === a[n] && (t.enableVertexAttribArray(n), a[n] = 1), o[n] !== r) {
                (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), o[n] = r
            }
        }

        function v() {
            const e = c.newAttributes,
                n = c.enabledAttributes;
            for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
        }

        function y(e, n, i, r, s, a, o) {
            !0 === o ? t.vertexAttribIPointer(e, n, i, s, a) : t.vertexAttribPointer(e, n, i, r, s, a)
        }

        function b() {
            x(), h = !0, c !== l && (c = l, u(c.object))
        }

        function x() {
            l.geometry = null, l.program = null, l.wireframe = !1
        }
        return {
            setup: function (r, l, d, b, x) {
                let _ = !1;
                if (a) {
                    const e = function (e, n, r) {
                        const a = !0 === r.wireframe;
                        let l = o[e.id];
                        void 0 === l && (l = {}, o[e.id] = l);
                        let c = l[n.id];
                        void 0 === c && (c = {}, l[n.id] = c);
                        let h = c[a];
                        void 0 === h && (h = p(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), c[a] = h);
                        return h
                    }(b, d, l);
                    c !== e && (c = e, u(c.object)), _ = function (t, e, n, i) {
                        const r = c.attributes,
                            s = e.attributes;
                        let a = 0;
                        const o = n.getAttributes();
                        for (const e in o) {
                            if (o[e].location >= 0) {
                                const n = r[e];
                                let i = s[e];
                                if (void 0 === i && ("instanceMatrix" === e && t.instanceMatrix && (i = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (i = t.instanceColor)), void 0 === n) return !0;
                                if (n.attribute !== i) return !0;
                                if (i && n.data !== i.data) return !0;
                                a++
                            }
                        }
                        return c.attributesNum !== a || c.index !== i
                    }(r, b, d, x), _ && function (t, e, n, i) {
                        const r = {},
                            s = e.attributes;
                        let a = 0;
                        const o = n.getAttributes();
                        for (const e in o) {
                            if (o[e].location >= 0) {
                                let n = s[e];
                                void 0 === n && ("instanceMatrix" === e && t.instanceMatrix && (n = t.instanceMatrix), "instanceColor" === e && t.instanceColor && (n = t.instanceColor));
                                const i = {};
                                i.attribute = n, n && n.data && (i.data = n.data), r[e] = i, a++
                            }
                        }
                        c.attributes = r, c.attributesNum = a, c.index = i
                    }(r, b, d, x)
                } else {
                    const t = !0 === l.wireframe;
                    c.geometry === b.id && c.program === d.id && c.wireframe === t || (c.geometry = b.id, c.program = d.id, c.wireframe = t, _ = !0)
                }
                null !== x && n.update(x, t.ELEMENT_ARRAY_BUFFER), (_ || h) && (h = !1, function (r, s, a, o) {
                    if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                    f();
                    const l = o.attributes,
                        c = a.getAttributes(),
                        h = s.defaultAttributeValues;
                    for (const e in c) {
                        const s = c[e];
                        if (s.location >= 0) {
                            let a = l[e];
                            if (void 0 === a && ("instanceMatrix" === e && r.instanceMatrix && (a = r.instanceMatrix), "instanceColor" === e && r.instanceColor && (a = r.instanceColor)), void 0 !== a) {
                                const e = a.normalized,
                                    l = a.itemSize,
                                    c = n.get(a);
                                if (void 0 === c) continue;
                                const h = c.buffer,
                                    u = c.type,
                                    d = c.bytesPerElement,
                                    p = !0 === i.isWebGL2 && (u === t.INT || u === t.UNSIGNED_INT || 1013 === a.gpuType);
                                if (a.isInterleavedBufferAttribute) {
                                    const n = a.data,
                                        i = n.stride,
                                        c = a.offset;
                                    if (n.isInstancedInterleavedBuffer) {
                                        for (let t = 0; t < s.locationSize; t++) g(s.location + t, n.meshPerAttribute);
                                        !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count)
                                    } else
                                        for (let t = 0; t < s.locationSize; t++) m(s.location + t);
                                    t.bindBuffer(t.ARRAY_BUFFER, h);
                                    for (let t = 0; t < s.locationSize; t++) y(s.location + t, l / s.locationSize, u, e, i * d, (c + l / s.locationSize * t) * d, p)
                                } else {
                                    if (a.isInstancedBufferAttribute) {
                                        for (let t = 0; t < s.locationSize; t++) g(s.location + t, a.meshPerAttribute);
                                        !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = a.meshPerAttribute * a.count)
                                    } else
                                        for (let t = 0; t < s.locationSize; t++) m(s.location + t);
                                    t.bindBuffer(t.ARRAY_BUFFER, h);
                                    for (let t = 0; t < s.locationSize; t++) y(s.location + t, l / s.locationSize, u, e, l * d, l / s.locationSize * t * d, p)
                                }
                            } else if (void 0 !== h) {
                                const n = h[e];
                                if (void 0 !== n) switch (n.length) {
                                    case 2:
                                        t.vertexAttrib2fv(s.location, n);
                                        break;
                                    case 3:
                                        t.vertexAttrib3fv(s.location, n);
                                        break;
                                    case 4:
                                        t.vertexAttrib4fv(s.location, n);
                                        break;
                                    default:
                                        t.vertexAttrib1fv(s.location, n)
                                }
                            }
                        }
                    }
                    v()
                }(r, l, d, b), null !== x && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(x).buffer))
            },
            reset: b,
            resetDefaultState: x,
            dispose: function () {
                b();
                for (const t in o) {
                    const e = o[t];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n) d(n[t].object), delete n[t];
                        delete e[t]
                    }
                    delete o[t]
                }
            },
            releaseStatesOfGeometry: function (t) {
                if (void 0 === o[t.id]) return;
                const e = o[t.id];
                for (const t in e) {
                    const n = e[t];
                    for (const t in n) d(n[t].object), delete n[t];
                    delete e[t]
                }
                delete o[t.id]
            },
            releaseStatesOfProgram: function (t) {
                for (const e in o) {
                    const n = o[e];
                    if (void 0 === n[t.id]) continue;
                    const i = n[t.id];
                    for (const t in i) d(i[t].object), delete i[t];
                    delete n[t.id]
                }
            },
            initAttributes: f,
            enableAttribute: m,
            disableUnusedAttributes: v
        }
    }

    function hi(t, e, n, i) {
        const r = i.isWebGL2;
        let s;
        this.setMode = function (t) {
            s = t
        }, this.render = function (e, i) {
            t.drawArrays(s, e, i), n.update(i, s, 1)
        }, this.renderInstances = function (i, a, o) {
            if (0 === o) return;
            let l, c;
            if (r) l = t, c = "drawArraysInstanced";
            else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            l[c](s, i, a, o), n.update(a, s, o)
        }
    }

    function ui(t, e, n) {
        let i;

        function r(e) {
            if ("highp" === e) {
                if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                e = "mediump"
            }
            return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
        }
        const s = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === t.constructor.name;
        let a = void 0 !== n.precision ? n.precision : "highp";
        const o = r(a);
        o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."), a = o);
        const l = s || e.has("WEBGL_draw_buffers"),
            c = !0 === n.logarithmicDepthBuffer,
            h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
            u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            d = t.getParameter(t.MAX_TEXTURE_SIZE),
            p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
            f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
            g = t.getParameter(t.MAX_VARYING_VECTORS),
            v = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
            y = u > 0,
            b = s || e.has("OES_texture_float");
        return {
            isWebGL2: s,
            drawBuffers: l,
            getMaxAnisotropy: function () {
                if (void 0 !== i) return i;
                if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                    const n = e.get("EXT_texture_filter_anisotropic");
                    i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                } else i = 0;
                return i
            },
            getMaxPrecision: r,
            precision: a,
            logarithmicDepthBuffer: c,
            maxTextures: h,
            maxVertexTextures: u,
            maxTextureSize: d,
            maxCubemapSize: p,
            maxAttributes: f,
            maxVertexUniforms: m,
            maxVaryings: g,
            maxFragmentUniforms: v,
            vertexTextures: y,
            floatFragmentTextures: b,
            floatVertexTextures: y && b,
            maxSamples: s ? t.getParameter(t.MAX_SAMPLES) : 0
        }
    }

    function di(t) {
        const e = this;
        let n = null,
            i = 0,
            r = !1,
            s = !1;
        const a = new Zn,
            o = new lt,
            l = {
                value: null,
                needsUpdate: !1
            };

        function c(t, n, i, r) {
            const s = null !== t ? t.length : 0;
            let c = null;
            if (0 !== s) {
                if (c = l.value, !0 !== r || null === c) {
                    const e = i + 4 * s,
                        r = n.matrixWorldInverse;
                    o.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
                    for (let e = 0, n = i; e !== s; ++e, n += 4) a.copy(t[e]).applyMatrix4(r, o), a.normal.toArray(c, n), c[n + 3] = a.constant
                }
                l.value = c, l.needsUpdate = !0
            }
            return e.numPlanes = s, e.numIntersection = 0, c
        }
        this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e) {
            const n = 0 !== t.length || e || 0 !== i || r;
            return r = e, i = t.length, n
        }, this.beginShadows = function () {
            s = !0, c(null)
        }, this.endShadows = function () {
            s = !1
        }, this.setGlobalState = function (t, e) {
            n = c(t, e, 0)
        }, this.setState = function (a, o, h) {
            const u = a.clippingPlanes,
                d = a.clipIntersection,
                p = a.clipShadows,
                f = t.get(a);
            if (!r || null === u || 0 === u.length || s && !p) s ? c(null) : function () {
                l.value !== n && (l.value = n, l.needsUpdate = i > 0);
                e.numPlanes = i, e.numIntersection = 0
            }();
            else {
                const t = s ? 0 : i,
                    e = 4 * t;
                let r = f.clippingState || null;
                l.value = r, r = c(u, o, e, h);
                for (let t = 0; t !== e; ++t) r[t] = n[t];
                f.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
            }
        }
    }

    function pi(t) {
        let e = new WeakMap;

        function n(t, e) {
            return 303 === e ? t.mapping = 301 : 304 === e && (t.mapping = 302), t
        }

        function i(t) {
            const n = t.target;
            n.removeEventListener("dispose", i);
            const r = e.get(n);
            void 0 !== r && (e.delete(n), r.dispose())
        }
        return {
            get: function (r) {
                if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                    const s = r.mapping;
                    if (303 === s || 304 === s) {
                        if (e.has(r)) {
                            return n(e.get(r).texture, r.mapping)
                        } {
                            const s = r.image;
                            if (s && s.height > 0) {
                                const a = new qn(s.height / 2);
                                return a.fromEquirectangularTexture(t, r), e.set(r, a), r.addEventListener("dispose", i), n(a.texture, r.mapping)
                            }
                            return null
                        }
                    }
                }
                return r
            },
            dispose: function () {
                e = new WeakMap
            }
        }
    }
    class fi extends jn {
        constructor(t = -1, e = 1, n = 1, i = -1, r = .1, s = 2e3) {
            super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix()
        }
        copy(t, e) {
            return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
        }
        setViewOffset(t, e, n, i, r, s) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
        }
        clearViewOffset() {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const t = (this.right - this.left) / (2 * this.zoom),
                e = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                i = (this.top + this.bottom) / 2;
            let r = n - t,
                s = n + t,
                a = i + e,
                o = i - e;
            if (null !== this.view && this.view.enabled) {
                const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                    e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                r += t * this.view.offsetX, s = r + t * this.view.width, a -= e * this.view.offsetY, o = a - e * this.view.height
            }
            this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
        }
    }
    const mi = [.125, .215, .35, .446, .526, .582],
        gi = new fi,
        vi = new tn;
    let yi = null;
    const bi = (1 + Math.sqrt(5)) / 2,
        xi = 1 / bi,
        _i = [new It(1, 1, 1), new It(-1, 1, 1), new It(1, 1, -1), new It(-1, 1, -1), new It(0, bi, xi), new It(0, bi, -xi), new It(xi, 0, bi), new It(-xi, 0, bi), new It(bi, xi, 0), new It(-bi, xi, 0)];
    class wi {
        constructor(t) {
            this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
        }
        fromScene(t, e = 0, n = .1, i = 100) {
            yi = this._renderer.getRenderTarget(), this._setSize(256);
            const r = this._allocateTargets();
            return r.depthBuffer = !0, this._sceneToCubeUV(t, n, i, r), e > 0 && this._blur(r, 0, 0, e), this._applyPMREM(r), this._cleanup(r), r
        }
        fromEquirectangular(t, e = null) {
            return this._fromTexture(t, e)
        }
        fromCubemap(t, e = null) {
            return this._fromTexture(t, e)
        }
        compileCubemapShader() {
            null === this._cubemapMaterial && (this._cubemapMaterial = Ti(), this._compileMaterial(this._cubemapMaterial))
        }
        compileEquirectangularShader() {
            null === this._equirectMaterial && (this._equirectMaterial = Ei(), this._compileMaterial(this._equirectMaterial))
        }
        dispose() {
            this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
        }
        _setSize(t) {
            this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax)
        }
        _dispose() {
            null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
            for (let t = 0; t < this._lodPlanes.length; t++) this._lodPlanes[t].dispose()
        }
        _cleanup(t) {
            this._renderer.setRenderTarget(yi), t.scissorTest = !1, Mi(t, 0, 0, t.width, t.height)
        }
        _fromTexture(t, e) {
            301 === t.mapping || 302 === t.mapping ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), yi = this._renderer.getRenderTarget();
            const n = e || this._allocateTargets();
            return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
        }
        _allocateTargets() {
            const t = 3 * Math.max(this._cubeSize, 112),
                e = 4 * this._cubeSize,
                n = {
                    magFilter: C,
                    minFilter: C,
                    generateMipmaps: !1,
                    type: O,
                    format: I,
                    colorSpace: G,
                    depthBuffer: !1
                },
                i = Si(t, e, n);
            if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
                null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Si(t, e, n);
                const {
                    _lodMax: i
                } = this;
                ({
                    sizeLods: this._sizeLods,
                    lodPlanes: this._lodPlanes,
                    sigmas: this._sigmas
                } = function (t) {
                    const e = [],
                        n = [],
                        i = [];
                    let r = t;
                    const s = t - 4 + 1 + mi.length;
                    for (let a = 0; a < s; a++) {
                        const s = Math.pow(2, r);
                        n.push(s);
                        let o = 1 / s;
                        a > t - 4 ? o = mi[a - t + 4 - 1] : 0 === a && (o = 0), i.push(o);
                        const l = 1 / (s - 2),
                            c = -l,
                            h = 1 + l,
                            u = [c, c, h, c, h, h, c, c, h, h, c, h],
                            d = 6,
                            p = 6,
                            f = 3,
                            m = 2,
                            g = 1,
                            v = new Float32Array(f * p * d),
                            y = new Float32Array(m * p * d),
                            b = new Float32Array(g * p * d);
                        for (let t = 0; t < d; t++) {
                            const e = t % 3 * 2 / 3 - 1,
                                n = t > 2 ? 0 : -1,
                                i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                            v.set(i, f * p * t), y.set(u, m * p * t);
                            const r = [t, t, t, t, t, t];
                            b.set(r, g * p * t)
                        }
                        const x = new vn;
                        x.setAttribute("position", new an(v, f)), x.setAttribute("uv", new an(y, m)), x.setAttribute("faceIndex", new an(b, g)), e.push(x), r > 4 && r--
                    }
                    return {
                        lodPlanes: e,
                        sizeLods: n,
                        sigmas: i
                    }
                }(i)), this._blurMaterial = function (t, e, n) {
                    const i = new Float32Array(20),
                        r = new It(0, 1, 0);
                    return new Hn({
                        name: "SphericalGaussianBlur",
                        defines: {
                            n: 20,
                            CUBEUV_TEXEL_WIDTH: 1 / e,
                            CUBEUV_TEXEL_HEIGHT: 1 / n,
                            CUBEUV_MAX_MIP: t + ".0"
                        },
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            samples: {
                                value: 1
                            },
                            weights: {
                                value: i
                            },
                            latitudinal: {
                                value: !1
                            },
                            dTheta: {
                                value: 0
                            },
                            mipInt: {
                                value: 0
                            },
                            poleAxis: {
                                value: r
                            }
                        },
                        vertexShader: Ci(),
                        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                        blending: c,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }(i, t, e)
            }
            return i
        }
        _compileMaterial(t) {
            const e = new kn(this._lodPlanes[0], t);
            this._renderer.compile(e, gi)
        }
        _sceneToCubeUV(t, e, n, i) {
            const r = new Vn(90, 1, e, n),
                s = [1, -1, 1, 1, 1, 1],
                a = [1, 1, 1, -1, -1, -1],
                l = this._renderer,
                c = l.autoClear,
                h = l.toneMapping;
            l.getClearColor(vi), l.toneMapping = b, l.autoClear = !1;
            const u = new nn({
                name: "PMREM.Background",
                side: o,
                depthWrite: !1,
                depthTest: !1
            }),
                d = new kn(new Un, u);
            let p = !1;
            const f = t.background;
            f ? f.isColor && (u.color.copy(f), t.background = null, p = !0) : (u.color.copy(vi), p = !0);
            for (let e = 0; e < 6; e++) {
                const n = e % 3;
                0 === n ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0)) : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e]));
                const o = this._cubeSize;
                Mi(i, n * o, e > 2 ? o : 0, o, o), l.setRenderTarget(i), p && l.render(d, r), l.render(t, r)
            }
            d.geometry.dispose(), d.material.dispose(), l.toneMapping = h, l.autoClear = c, t.background = f
        }
        _textureToCubeUV(t, e) {
            const n = this._renderer,
                i = 301 === t.mapping || 302 === t.mapping;
            i ? (null === this._cubemapMaterial && (this._cubemapMaterial = Ti()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Ei());
            const r = i ? this._cubemapMaterial : this._equirectMaterial,
                s = new kn(this._lodPlanes[0], r);
            r.uniforms.envMap.value = t;
            const a = this._cubeSize;
            Mi(e, 0, 0, 3 * a, 2 * a), n.setRenderTarget(e), n.render(s, gi)
        }
        _applyPMREM(t) {
            const e = this._renderer,
                n = e.autoClear;
            e.autoClear = !1;
            for (let e = 1; e < this._lodPlanes.length; e++) {
                const n = Math.sqrt(this._sigmas[e] * this._sigmas[e] - this._sigmas[e - 1] * this._sigmas[e - 1]),
                    i = _i[(e - 1) % _i.length];
                this._blur(t, e - 1, e, n, i)
            }
            e.autoClear = n
        }
        _blur(t, e, n, i, r) {
            const s = this._pingPongRenderTarget;
            this._halfBlur(t, s, e, n, i, "latitudinal", r), this._halfBlur(s, t, n, n, i, "longitudinal", r)
        }
        _halfBlur(t, e, n, i, r, s, a) {
            const o = this._renderer,
                l = this._blurMaterial;
            "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
            const c = new kn(this._lodPlanes[i], l),
                h = l.uniforms,
                u = this._sizeLods[n] - 1,
                d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39,
                p = r / d,
                f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
            f > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
            const m = [];
            let g = 0;
            for (let t = 0; t < 20; ++t) {
                const e = t / p,
                    n = Math.exp(-e * e / 2);
                m.push(n), 0 === t ? g += n : t < f && (g += 2 * n)
            }
            for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
            h.envMap.value = t.texture, h.samples.value = f, h.weights.value = m, h.latitudinal.value = "latitudinal" === s, a && (h.poleAxis.value = a);
            const {
                _lodMax: v
            } = this;
            h.dTheta.value = d, h.mipInt.value = v - n;
            const y = this._sizeLods[i];
            Mi(e, 3 * y * (i > v - 4 ? i - v + 4 : 0), 4 * (this._cubeSize - y), 3 * y, 2 * y), o.setRenderTarget(e), o.render(c, gi)
        }
    }

    function Si(t, e, n) {
        const i = new Pt(t, e, n);
        return i.texture.mapping = 306, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i
    }

    function Mi(t, e, n, i, r) {
        t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r)
    }

    function Ei() {
        return new Hn({
            name: "EquirectangularToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                }
            },
            vertexShader: Ci(),
            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
            blending: c,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function Ti() {
        return new Hn({
            name: "CubemapToCubeUV",
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                }
            },
            vertexShader: Ci(),
            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
            blending: c,
            depthTest: !1,
            depthWrite: !1
        })
    }

    function Ci() {
        return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
    }

    function Ai(t) {
        let e = new WeakMap,
            n = null;

        function i(t) {
            const n = t.target;
            n.removeEventListener("dispose", i);
            const r = e.get(n);
            void 0 !== r && (e.delete(n), r.dispose())
        }
        return {
            get: function (r) {
                if (r && r.isTexture) {
                    const s = r.mapping,
                        a = 303 === s || 304 === s,
                        o = 301 === s || 302 === s;
                    if (a || o) {
                        if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                            r.needsPMREMUpdate = !1;
                            let i = e.get(r);
                            return null === n && (n = new wi(t)), i = a ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i), e.set(r, i), i.texture
                        }
                        if (e.has(r)) return e.get(r).texture;
                        {
                            const s = r.image;
                            if (a && s && s.height > 0 || o && s && function (t) {
                                let e = 0;
                                for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                                return 6 === e
                            }(s)) {
                                null === n && (n = new wi(t));
                                const s = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
                                return e.set(r, s), r.addEventListener("dispose", i), s.texture
                            }
                            return null
                        }
                    }
                }
                return r
            },
            dispose: function () {
                e = new WeakMap, null !== n && (n.dispose(), n = null)
            }
        }
    }

    function Ri(t) {
        const e = {};

        function n(n) {
            if (void 0 !== e[n]) return e[n];
            let i;
            switch (n) {
                case "WEBGL_depth_texture":
                    i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = t.getExtension(n)
            }
            return e[n] = i, i
        }
        return {
            has: function (t) {
                return null !== n(t)
            },
            init: function (t) {
                t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
            },
            get: function (t) {
                const e = n(t);
                return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
            }
        }
    }

    function Pi(t, e, n, i) {
        const r = {},
            s = new WeakMap;

        function a(t) {
            const o = t.target;
            null !== o.index && e.remove(o.index);
            for (const t in o.attributes) e.remove(o.attributes[t]);
            for (const t in o.morphAttributes) {
                const n = o.morphAttributes[t];
                for (let t = 0, i = n.length; t < i; t++) e.remove(n[t])
            }
            o.removeEventListener("dispose", a), delete r[o.id];
            const l = s.get(o);
            l && (e.remove(l), s.delete(o)), i.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--
        }

        function o(t) {
            const n = [],
                i = t.index,
                r = t.attributes.position;
            let a = 0;
            if (null !== i) {
                const t = i.array;
                a = i.version;
                for (let e = 0, i = t.length; e < i; e += 3) {
                    const i = t[e + 0],
                        r = t[e + 1],
                        s = t[e + 2];
                    n.push(i, r, r, s, s, i)
                }
            } else {
                if (void 0 === r) return;
                {
                    const t = r.array;
                    a = r.version;
                    for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                        const t = e + 0,
                            i = e + 1,
                            r = e + 2;
                        n.push(t, i, i, r, r, t)
                    }
                }
            }
            const o = new (ht(n) ? ln : on)(n, 1);
            o.version = a;
            const l = s.get(t);
            l && e.remove(l), s.set(t, o)
        }
        return {
            get: function (t, e) {
                return !0 === r[e.id] || (e.addEventListener("dispose", a), r[e.id] = !0, n.memory.geometries++), e
            },
            update: function (n) {
                const i = n.attributes;
                for (const n in i) e.update(i[n], t.ARRAY_BUFFER);
                const r = n.morphAttributes;
                for (const n in r) {
                    const i = r[n];
                    for (let n = 0, r = i.length; n < r; n++) e.update(i[n], t.ARRAY_BUFFER)
                }
            },
            getWireframeAttribute: function (t) {
                const e = s.get(t);
                if (e) {
                    const n = t.index;
                    null !== n && e.version < n.version && o(t)
                } else o(t);
                return s.get(t)
            }
        }
    }

    function Li(t, e, n, i) {
        const r = i.isWebGL2;
        let s, a, o;
        this.setMode = function (t) {
            s = t
        }, this.setIndex = function (t) {
            a = t.type, o = t.bytesPerElement
        }, this.render = function (e, i) {
            t.drawElements(s, i, a, e * o), n.update(i, s, 1)
        }, this.renderInstances = function (i, l, c) {
            if (0 === c) return;
            let h, u;
            if (r) h = t, u = "drawElementsInstanced";
            else if (h = e.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            h[u](s, l, a, i * o, c), n.update(l, s, c)
        }
    }

    function Oi(t) {
        const e = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function () {
                e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
            },
            update: function (n, i, r) {
                switch (e.calls++, i) {
                    case t.TRIANGLES:
                        e.triangles += r * (n / 3);
                        break;
                    case t.LINES:
                        e.lines += r * (n / 2);
                        break;
                    case t.LINE_STRIP:
                        e.lines += r * (n - 1);
                        break;
                    case t.LINE_LOOP:
                        e.lines += r * n;
                        break;
                    case t.POINTS:
                        e.points += r * n;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                }
            }
        }
    }

    function Di(t, e) {
        return t[0] - e[0]
    }

    function Ii(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }

    function ki(t, e, n) {
        const i = {},
            r = new Float32Array(8),
            s = new WeakMap,
            a = new At,
            o = [];
        for (let t = 0; t < 8; t++) o[t] = [t, 0];
        return {
            update: function (l, c, h) {
                const u = l.morphTargetInfluences;
                if (!0 === e.isWebGL2) {
                    const i = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color,
                        r = void 0 !== i ? i.length : 0;
                    let o = s.get(c);
                    if (void 0 === o || o.count !== r) {
                        void 0 !== o && o.texture.dispose();
                        const t = void 0 !== c.morphAttributes.position,
                            n = void 0 !== c.morphAttributes.normal,
                            i = void 0 !== c.morphAttributes.color,
                            l = c.morphAttributes.position || [],
                            h = c.morphAttributes.normal || [],
                            u = c.morphAttributes.color || [];
                        let d = 0;
                        !0 === t && (d = 1), !0 === n && (d = 2), !0 === i && (d = 3);
                        let p = c.attributes.position.count * d,
                            f = 1;
                        p > e.maxTextureSize && (f = Math.ceil(p / e.maxTextureSize), p = e.maxTextureSize);
                        const m = new Float32Array(p * f * 4 * r),
                            g = new Lt(m, p, f, r);
                        g.type = L, g.needsUpdate = !0;
                        const v = 4 * d;
                        for (let e = 0; e < r; e++) {
                            const r = l[e],
                                s = h[e],
                                o = u[e],
                                c = p * f * 4 * e;
                            for (let e = 0; e < r.count; e++) {
                                const l = e * v;
                                !0 === t && (a.fromBufferAttribute(r, e), m[c + l + 0] = a.x, m[c + l + 1] = a.y, m[c + l + 2] = a.z, m[c + l + 3] = 0), !0 === n && (a.fromBufferAttribute(s, e), m[c + l + 4] = a.x, m[c + l + 5] = a.y, m[c + l + 6] = a.z, m[c + l + 7] = 0), !0 === i && (a.fromBufferAttribute(o, e), m[c + l + 8] = a.x, m[c + l + 9] = a.y, m[c + l + 10] = a.z, m[c + l + 11] = 4 === o.itemSize ? a.w : 1)
                            }
                        }
                        o = {
                            count: r,
                            texture: g,
                            size: new ot(p, f)
                        }, s.set(c, o), c.addEventListener("dispose", (function t() {
                            g.dispose(), s.delete(c), c.removeEventListener("dispose", t)
                        }))
                    }
                    let l = 0;
                    for (let t = 0; t < u.length; t++) l += u[t];
                    const d = c.morphTargetsRelative ? 1 : 1 - l;
                    h.getUniforms().setValue(t, "morphTargetBaseInfluence", d), h.getUniforms().setValue(t, "morphTargetInfluences", u), h.getUniforms().setValue(t, "morphTargetsTexture", o.texture, n), h.getUniforms().setValue(t, "morphTargetsTextureSize", o.size)
                } else {
                    const e = void 0 === u ? 0 : u.length;
                    let n = i[c.id];
                    if (void 0 === n || n.length !== e) {
                        n = [];
                        for (let t = 0; t < e; t++) n[t] = [t, 0];
                        i[c.id] = n
                    }
                    for (let t = 0; t < e; t++) {
                        const e = n[t];
                        e[0] = t, e[1] = u[t]
                    }
                    n.sort(Ii);
                    for (let t = 0; t < 8; t++) t < e && n[t][1] ? (o[t][0] = n[t][0], o[t][1] = n[t][1]) : (o[t][0] = Number.MAX_SAFE_INTEGER, o[t][1] = 0);
                    o.sort(Di);
                    const s = c.morphAttributes.position,
                        a = c.morphAttributes.normal;
                    let l = 0;
                    for (let t = 0; t < 8; t++) {
                        const e = o[t],
                            n = e[0],
                            i = e[1];
                        n !== Number.MAX_SAFE_INTEGER && i ? (s && c.getAttribute("morphTarget" + t) !== s[n] && c.setAttribute("morphTarget" + t, s[n]), a && c.getAttribute("morphNormal" + t) !== a[n] && c.setAttribute("morphNormal" + t, a[n]), r[t] = i, l += i) : (s && !0 === c.hasAttribute("morphTarget" + t) && c.deleteAttribute("morphTarget" + t), a && !0 === c.hasAttribute("morphNormal" + t) && c.deleteAttribute("morphNormal" + t), r[t] = 0)
                    }
                    const d = c.morphTargetsRelative ? 1 : 1 - l;
                    h.getUniforms().setValue(t, "morphTargetBaseInfluence", d), h.getUniforms().setValue(t, "morphTargetInfluences", r)
                }
            }
        }
    }

    function Ni(t, e, n, i) {
        let r = new WeakMap;

        function s(t) {
            const e = t.target;
            e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
        }
        return {
            update: function (a) {
                const o = i.render.frame,
                    l = a.geometry,
                    c = e.get(a, l);
                if (r.get(c) !== o && (e.update(c), r.set(c, o)), a.isInstancedMesh && (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s), r.get(a) !== o && (n.update(a.instanceMatrix, t.ARRAY_BUFFER), null !== a.instanceColor && n.update(a.instanceColor, t.ARRAY_BUFFER), r.set(a, o))), a.isSkinnedMesh) {
                    const t = a.skeleton;
                    r.get(t) !== o && (t.update(), r.set(t, o))
                }
                return c
            },
            dispose: function () {
                r = new WeakMap
            }
        }
    }
    const Ui = new Ct,
        zi = new Lt,
        Fi = new Ot,
        $i = new Wn,
        Bi = [],
        Hi = [],
        ji = new Float32Array(16),
        Vi = new Float32Array(9),
        Gi = new Float32Array(4);

    function Wi(t, e, n) {
        const i = t[0];
        if (i <= 0 || i > 0) return t;
        const r = e * n;
        let s = Bi[r];
        if (void 0 === s && (s = new Float32Array(r), Bi[r] = s), 0 !== e) {
            i.toArray(s, 0);
            for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(s, r)
        }
        return s
    }

    function qi(t, e) {
        if (t.length !== e.length) return !1;
        for (let n = 0, i = t.length; n < i; n++)
            if (t[n] !== e[n]) return !1;
        return !0
    }

    function Xi(t, e) {
        for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
    }

    function Yi(t, e) {
        let n = Hi[e];
        void 0 === n && (n = new Int32Array(e), Hi[e] = n);
        for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
        return n
    }

    function Ki(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
    }

    function Zi(t, e) {
        const n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
        else {
            if (qi(n, e)) return;
            t.uniform2fv(this.addr, e), Xi(n, e)
        }
    }

    function Ji(t, e) {
        const n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
        else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
        else {
            if (qi(n, e)) return;
            t.uniform3fv(this.addr, e), Xi(n, e)
        }
    }

    function Qi(t, e) {
        const n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
        else {
            if (qi(n, e)) return;
            t.uniform4fv(this.addr, e), Xi(n, e)
        }
    }

    function tr(t, e) {
        const n = this.cache,
            i = e.elements;
        if (void 0 === i) {
            if (qi(n, e)) return;
            t.uniformMatrix2fv(this.addr, !1, e), Xi(n, e)
        } else {
            if (qi(n, i)) return;
            Gi.set(i), t.uniformMatrix2fv(this.addr, !1, Gi), Xi(n, i)
        }
    }

    function er(t, e) {
        const n = this.cache,
            i = e.elements;
        if (void 0 === i) {
            if (qi(n, e)) return;
            t.uniformMatrix3fv(this.addr, !1, e), Xi(n, e)
        } else {
            if (qi(n, i)) return;
            Vi.set(i), t.uniformMatrix3fv(this.addr, !1, Vi), Xi(n, i)
        }
    }

    function nr(t, e) {
        const n = this.cache,
            i = e.elements;
        if (void 0 === i) {
            if (qi(n, e)) return;
            t.uniformMatrix4fv(this.addr, !1, e), Xi(n, e)
        } else {
            if (qi(n, i)) return;
            ji.set(i), t.uniformMatrix4fv(this.addr, !1, ji), Xi(n, i)
        }
    }

    function ir(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
    }

    function rr(t, e) {
        const n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
        else {
            if (qi(n, e)) return;
            t.uniform2iv(this.addr, e), Xi(n, e)
        }
    }

    function sr(t, e) {
        const n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
        else {
            if (qi(n, e)) return;
            t.uniform3iv(this.addr, e), Xi(n, e)
        }
    }

    function ar(t, e) {
        const n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
        else {
            if (qi(n, e)) return;
            t.uniform4iv(this.addr, e), Xi(n, e)
        }
    }

    function or(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
    }

    function lr(t, e) {
        const n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
        else {
            if (qi(n, e)) return;
            t.uniform2uiv(this.addr, e), Xi(n, e)
        }
    }

    function cr(t, e) {
        const n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
        else {
            if (qi(n, e)) return;
            t.uniform3uiv(this.addr, e), Xi(n, e)
        }
    }

    function hr(t, e) {
        const n = this.cache;
        if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
        else {
            if (qi(n, e)) return;
            t.uniform4uiv(this.addr, e), Xi(n, e)
        }
    }

    function ur(t, e, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2D(e || Ui, r)
    }

    function dr(t, e, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Fi, r)
    }

    function pr(t, e, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(e || $i, r)
    }

    function fr(t, e, n) {
        const i = this.cache,
            r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || zi, r)
    }

    function mr(t, e) {
        t.uniform1fv(this.addr, e)
    }

    function gr(t, e) {
        const n = Wi(e, this.size, 2);
        t.uniform2fv(this.addr, n)
    }

    function vr(t, e) {
        const n = Wi(e, this.size, 3);
        t.uniform3fv(this.addr, n)
    }

    function yr(t, e) {
        const n = Wi(e, this.size, 4);
        t.uniform4fv(this.addr, n)
    }

    function br(t, e) {
        const n = Wi(e, this.size, 4);
        t.uniformMatrix2fv(this.addr, !1, n)
    }

    function xr(t, e) {
        const n = Wi(e, this.size, 9);
        t.uniformMatrix3fv(this.addr, !1, n)
    }

    function _r(t, e) {
        const n = Wi(e, this.size, 16);
        t.uniformMatrix4fv(this.addr, !1, n)
    }

    function wr(t, e) {
        t.uniform1iv(this.addr, e)
    }

    function Sr(t, e) {
        t.uniform2iv(this.addr, e)
    }

    function Mr(t, e) {
        t.uniform3iv(this.addr, e)
    }

    function Er(t, e) {
        t.uniform4iv(this.addr, e)
    }

    function Tr(t, e) {
        t.uniform1uiv(this.addr, e)
    }

    function Cr(t, e) {
        t.uniform2uiv(this.addr, e)
    }

    function Ar(t, e) {
        t.uniform3uiv(this.addr, e)
    }

    function Rr(t, e) {
        t.uniform4uiv(this.addr, e)
    }

    function Pr(t, e, n) {
        const i = this.cache,
            r = e.length,
            s = Yi(n, r);
        qi(i, s) || (t.uniform1iv(this.addr, s), Xi(i, s));
        for (let t = 0; t !== r; ++t) n.setTexture2D(e[t] || Ui, s[t])
    }

    function Lr(t, e, n) {
        const i = this.cache,
            r = e.length,
            s = Yi(n, r);
        qi(i, s) || (t.uniform1iv(this.addr, s), Xi(i, s));
        for (let t = 0; t !== r; ++t) n.setTexture3D(e[t] || Fi, s[t])
    }

    function Or(t, e, n) {
        const i = this.cache,
            r = e.length,
            s = Yi(n, r);
        qi(i, s) || (t.uniform1iv(this.addr, s), Xi(i, s));
        for (let t = 0; t !== r; ++t) n.setTextureCube(e[t] || $i, s[t])
    }

    function Dr(t, e, n) {
        const i = this.cache,
            r = e.length,
            s = Yi(n, r);
        qi(i, s) || (t.uniform1iv(this.addr, s), Xi(i, s));
        for (let t = 0; t !== r; ++t) n.setTexture2DArray(e[t] || zi, s[t])
    }
    class Ir {
        constructor(t, e, n) {
            this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) {
                switch (t) {
                    case 5126:
                        return Ki;
                    case 35664:
                        return Zi;
                    case 35665:
                        return Ji;
                    case 35666:
                        return Qi;
                    case 35674:
                        return tr;
                    case 35675:
                        return er;
                    case 35676:
                        return nr;
                    case 5124:
                    case 35670:
                        return ir;
                    case 35667:
                    case 35671:
                        return rr;
                    case 35668:
                    case 35672:
                        return sr;
                    case 35669:
                    case 35673:
                        return ar;
                    case 5125:
                        return or;
                    case 36294:
                        return lr;
                    case 36295:
                        return cr;
                    case 36296:
                        return hr;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return ur;
                    case 35679:
                    case 36299:
                    case 36307:
                        return dr;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return pr;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return fr
                }
            }(e.type)
        }
    }
    class kr {
        constructor(t, e, n) {
            this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) {
                switch (t) {
                    case 5126:
                        return mr;
                    case 35664:
                        return gr;
                    case 35665:
                        return vr;
                    case 35666:
                        return yr;
                    case 35674:
                        return br;
                    case 35675:
                        return xr;
                    case 35676:
                        return _r;
                    case 5124:
                    case 35670:
                        return wr;
                    case 35667:
                    case 35671:
                        return Sr;
                    case 35668:
                    case 35672:
                        return Mr;
                    case 35669:
                    case 35673:
                        return Er;
                    case 5125:
                        return Tr;
                    case 36294:
                        return Cr;
                    case 36295:
                        return Ar;
                    case 36296:
                        return Rr;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Pr;
                    case 35679:
                    case 36299:
                    case 36307:
                        return Lr;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Or;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return Dr
                }
            }(e.type)
        }
    }
    class Nr {
        constructor(t) {
            this.id = t, this.seq = [], this.map = {}
        }
        setValue(t, e, n) {
            const i = this.seq;
            for (let r = 0, s = i.length; r !== s; ++r) {
                const s = i[r];
                s.setValue(t, e[s.id], n)
            }
        }
    }
    const Ur = /(\w+)(\])?(\[|\.)?/g;

    function zr(t, e) {
        t.seq.push(e), t.map[e.id] = e
    }

    function Fr(t, e, n) {
        const i = t.name,
            r = i.length;
        for (Ur.lastIndex = 0; ;) {
            const s = Ur.exec(i),
                a = Ur.lastIndex;
            let o = s[1];
            const l = "]" === s[2],
                c = s[3];
            if (l && (o |= 0), void 0 === c || "[" === c && a + 2 === r) {
                zr(n, void 0 === c ? new Ir(o, t, e) : new kr(o, t, e));
                break
            } {
                let t = n.map[o];
                void 0 === t && (t = new Nr(o), zr(n, t)), n = t
            }
        }
    }
    class $r {
        constructor(t, e) {
            this.seq = [], this.map = {};
            const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
            for (let i = 0; i < n; ++i) {
                const n = t.getActiveUniform(e, i);
                Fr(n, t.getUniformLocation(e, n.name), this)
            }
        }
        setValue(t, e, n, i) {
            const r = this.map[e];
            void 0 !== r && r.setValue(t, n, i)
        }
        setOptional(t, e, n) {
            const i = e[n];
            void 0 !== i && this.setValue(t, n, i)
        }
        static upload(t, e, n, i) {
            for (let r = 0, s = e.length; r !== s; ++r) {
                const s = e[r],
                    a = n[s.id];
                !1 !== a.needsUpdate && s.setValue(t, a.value, i)
            }
        }
        static seqWithValue(t, e) {
            const n = [];
            for (let i = 0, r = t.length; i !== r; ++i) {
                const r = t[i];
                r.id in e && n.push(r)
            }
            return n
        }
    }

    function Br(t, e, n) {
        const i = t.createShader(e);
        return t.shaderSource(i, n), t.compileShader(i), i
    }
    let Hr = 0;

    function jr(t, e, n) {
        const i = t.getShaderParameter(e, t.COMPILE_STATUS),
            r = t.getShaderInfoLog(e).trim();
        if (i && "" === r) return "";
        const s = /ERROR: 0:(\d+)/.exec(r);
        if (s) {
            const i = parseInt(s[1]);
            return n.toUpperCase() + "\n\n" + r + "\n\n" + function (t, e) {
                const n = t.split("\n"),
                    i = [],
                    r = Math.max(e - 6, 0),
                    s = Math.min(e + 6, n.length);
                for (let t = r; t < s; t++) {
                    const r = t + 1;
                    i.push(`${r === e ? ">" : " "} ${r}: ${n[t]}`)
                }
                return i.join("\n")
            }(t.getShaderSource(e), i)
        }
        return r
    }

    function Vr(t, e) {
        const n = function (t) {
            switch (t) {
                case G:
                    return ["Linear", "( value )"];
                case V:
                    return ["sRGB", "( value )"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported color space:", t), ["Linear", "( value )"]
            }
        }(e);
        return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
    }

    function Gr(t, e) {
        let n;
        switch (e) {
            case x:
                n = "Linear";
                break;
            case _:
                n = "Reinhard";
                break;
            case w:
                n = "OptimizedCineon";
                break;
            case S:
                n = "ACESFilmic";
                break;
            case 5:
                n = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
        }
        return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }

    function Wr(t) {
        return "" !== t
    }

    function qr(t, e) {
        const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
    }

    function Xr(t, e) {
        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    const Yr = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function Kr(t) {
        return t.replace(Yr, Jr)
    }
    const Zr = new Map([
        ["encodings_fragment", "colorspace_fragment"],
        ["encodings_pars_fragment", "colorspace_pars_fragment"],
        ["output_fragment", "opaque_fragment"]
    ]);

    function Jr(t, e) {
        let n = ri[e];
        if (void 0 === n) {
            const t = Zr.get(e);
            if (void 0 === t) throw new Error("Can not resolve #include <" + e + ">");
            n = ri[t], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, t)
        }
        return Kr(n)
    }
    const Qr = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

    function ts(t) {
        return t.replace(Qr, es)
    }

    function es(t, e, n, i) {
        let r = "";
        for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
        return r
    }

    function ns(t) {
        let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
        return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
    }

    function is(t, e, n, i) {
        const r = t.getContext(),
            s = n.defines;
        let a = n.vertexShader,
            o = n.fragmentShader;
        const l = function (t) {
            let e = "SHADOWMAP_TYPE_BASIC";
            return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
        }(n),
            c = function (t) {
                let e = "ENVMAP_TYPE_CUBE";
                if (t.envMap) switch (t.envMapMode) {
                    case 301:
                    case 302:
                        e = "ENVMAP_TYPE_CUBE";
                        break;
                    case 306:
                        e = "ENVMAP_TYPE_CUBE_UV"
                }
                return e
            }(n),
            h = function (t) {
                let e = "ENVMAP_MODE_REFLECTION";
                if (t.envMap) switch (t.envMapMode) {
                    case 302:
                        e = "ENVMAP_MODE_REFRACTION"
                }
                return e
            }(n),
            u = function (t) {
                let e = "ENVMAP_BLENDING_NONE";
                if (t.envMap) switch (t.combine) {
                    case 0:
                        e = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        e = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        e = "ENVMAP_BLENDING_ADD"
                }
                return e
            }(n),
            d = function (t) {
                const e = t.envMapCubeUVHeight;
                if (null === e) return null;
                const n = Math.log2(e) - 2,
                    i = 1 / e;
                return {
                    texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                    texelHeight: i,
                    maxMip: n
                }
            }(n),
            p = n.isWebGL2 ? "" : function (t) {
                return [t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.normalMapTangentSpace || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Wr).join("\n")
            }(n),
            f = function (t) {
                const e = [];
                for (const n in t) {
                    const i = t[n];
                    !1 !== i && e.push("#define " + n + " " + i)
                }
                return e.join("\n")
            }(s),
            m = r.createProgram();
        let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(Wr).join("\n"), g.length > 0 && (g += "\n"), v = [p, "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f].filter(Wr).join("\n"), v.length > 0 && (v += "\n")) : (g = [ns(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Wr).join("\n"), v = [p, ns(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, f, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== b ? "#define TONE_MAPPING" : "", n.toneMapping !== b ? ri.tonemapping_pars_fragment : "", n.toneMapping !== b ? Gr("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", ri.colorspace_pars_fragment, Vr("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Wr).join("\n")), a = Kr(a), a = qr(a, n), a = Xr(a, n), o = Kr(o), o = qr(o, n), o = Xr(o, n), a = ts(a), o = ts(o), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", "300 es" === n.glslVersion ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", "300 es" === n.glslVersion ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
        const x = y + g + a,
            _ = y + v + o,
            w = Br(r, r.VERTEX_SHADER, x),
            S = Br(r, r.FRAGMENT_SHADER, _);
        if (r.attachShader(m, w), r.attachShader(m, S), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), t.debug.checkShaderErrors) {
            const e = r.getProgramInfoLog(m).trim(),
                n = r.getShaderInfoLog(w).trim(),
                i = r.getShaderInfoLog(S).trim();
            let s = !0,
                a = !0;
            if (!1 === r.getProgramParameter(m, r.LINK_STATUS))
                if (s = !1, "function" == typeof t.debug.onShaderError) t.debug.onShaderError(r, m, w, S);
                else {
                    const t = jr(r, w, "vertex"),
                        n = jr(r, S, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, r.VALIDATE_STATUS) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + n)
                }
            else "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== n && "" !== i || (a = !1);
            a && (this.diagnostics = {
                runnable: s,
                programLog: e,
                vertexShader: {
                    log: n,
                    prefix: g
                },
                fragmentShader: {
                    log: i,
                    prefix: v
                }
            })
        }
        let M, E;
        return r.deleteShader(w), r.deleteShader(S), this.getUniforms = function () {
            return void 0 === M && (M = new $r(r, m)), M
        }, this.getAttributes = function () {
            return void 0 === E && (E = function (t, e) {
                const n = {},
                    i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                for (let r = 0; r < i; r++) {
                    const i = t.getActiveAttrib(e, r),
                        s = i.name;
                    let a = 1;
                    i.type === t.FLOAT_MAT2 && (a = 2), i.type === t.FLOAT_MAT3 && (a = 3), i.type === t.FLOAT_MAT4 && (a = 4), n[s] = {
                        type: i.type,
                        location: t.getAttribLocation(e, s),
                        locationSize: a
                    }
                }
                return n
            }(r, m)), E
        }, this.destroy = function () {
            i.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0
        }, this.type = n.shaderType, this.name = n.shaderName, this.id = Hr++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = w, this.fragmentShader = S, this
    }
    let rs = 0;
    class ss {
        constructor() {
            this.shaderCache = new Map, this.materialCache = new Map
        }
        update(t) {
            const e = t.vertexShader,
                n = t.fragmentShader,
                i = this._getShaderStage(e),
                r = this._getShaderStage(n),
                s = this._getShaderCacheForMaterial(t);
            return !1 === s.has(i) && (s.add(i), i.usedTimes++), !1 === s.has(r) && (s.add(r), r.usedTimes++), this
        }
        remove(t) {
            const e = this.materialCache.get(t);
            for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
            return this.materialCache.delete(t), this
        }
        getVertexShaderID(t) {
            return this._getShaderStage(t.vertexShader).id
        }
        getFragmentShaderID(t) {
            return this._getShaderStage(t.fragmentShader).id
        }
        dispose() {
            this.shaderCache.clear(), this.materialCache.clear()
        }
        _getShaderCacheForMaterial(t) {
            const e = this.materialCache;
            let n = e.get(t);
            return void 0 === n && (n = new Set, e.set(t, n)), n
        }
        _getShaderStage(t) {
            const e = this.shaderCache;
            let n = e.get(t);
            return void 0 === n && (n = new as(t), e.set(t, n)), n
        }
    }
    class as {
        constructor(t) {
            this.id = rs++, this.code = t, this.usedTimes = 0
        }
    }

    function os(t, e, n, i, r, s, a) {
        const c = new _e,
            h = new ss,
            u = [],
            d = r.isWebGL2,
            p = r.logarithmicDepthBuffer,
            f = r.vertexTextures;
        let m = r.precision;
        const g = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        };

        function v(t) {
            return 0 === t ? "uv" : "uv" + t
        }
        return {
            getParameters: function (s, c, u, y, x) {
                const _ = y.fog,
                    w = x.geometry,
                    S = s.isMeshStandardMaterial ? y.environment : null,
                    M = (s.isMeshStandardMaterial ? n : e).get(s.envMap || S),
                    E = M && 306 === M.mapping ? M.image.height : null,
                    T = g[s.type];
                null !== s.precision && (m = r.getMaxPrecision(s.precision), m !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", m, "instead."));
                const C = w.morphAttributes.position || w.morphAttributes.normal || w.morphAttributes.color,
                    A = void 0 !== C ? C.length : 0;
                let R, P, L, O, D = 0;
                if (void 0 !== w.morphAttributes.position && (D = 1), void 0 !== w.morphAttributes.normal && (D = 2), void 0 !== w.morphAttributes.color && (D = 3), T) {
                    const t = ai[T];
                    R = t.vertexShader, P = t.fragmentShader
                } else R = s.vertexShader, P = s.fragmentShader, h.update(s), L = h.getVertexShaderID(s), O = h.getFragmentShaderID(s);
                const I = t.getRenderTarget(),
                    k = !0 === x.isInstancedMesh,
                    N = !!s.map,
                    U = !!s.matcap,
                    z = !!M,
                    F = !!s.aoMap,
                    $ = !!s.lightMap,
                    B = !!s.bumpMap,
                    H = !!s.normalMap,
                    j = !!s.displacementMap,
                    V = !!s.emissiveMap,
                    W = !!s.metalnessMap,
                    q = !!s.roughnessMap,
                    X = s.anisotropy > 0,
                    Y = s.clearcoat > 0,
                    K = s.iridescence > 0,
                    Z = s.sheen > 0,
                    J = s.transmission > 0,
                    Q = X && !!s.anisotropyMap,
                    tt = Y && !!s.clearcoatMap,
                    et = Y && !!s.clearcoatNormalMap,
                    nt = Y && !!s.clearcoatRoughnessMap,
                    it = K && !!s.iridescenceMap,
                    rt = K && !!s.iridescenceThicknessMap,
                    st = Z && !!s.sheenColorMap,
                    at = Z && !!s.sheenRoughnessMap,
                    ot = !!s.specularMap,
                    lt = !!s.specularColorMap,
                    ct = !!s.specularIntensityMap,
                    ht = J && !!s.transmissionMap,
                    ut = J && !!s.thicknessMap,
                    dt = !!s.gradientMap,
                    pt = !!s.alphaMap,
                    ft = s.alphaTest > 0,
                    mt = !!s.alphaHash,
                    gt = !!s.extensions,
                    vt = !!w.attributes.uv1,
                    yt = !!w.attributes.uv2,
                    bt = !!w.attributes.uv3;
                let xt = b;
                return s.toneMapped && (null !== I && !0 !== I.isXRRenderTarget || (xt = t.toneMapping)), {
                    isWebGL2: d,
                    shaderID: T,
                    shaderType: s.type,
                    shaderName: s.name,
                    vertexShader: R,
                    fragmentShader: P,
                    defines: s.defines,
                    customVertexShaderID: L,
                    customFragmentShaderID: O,
                    isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                    glslVersion: s.glslVersion,
                    precision: m,
                    instancing: k,
                    instancingColor: k && null !== x.instanceColor,
                    supportsVertexTextures: f,
                    outputColorSpace: null === I ? t.outputColorSpace : !0 === I.isXRRenderTarget ? I.texture.colorSpace : G,
                    map: N,
                    matcap: U,
                    envMap: z,
                    envMapMode: z && M.mapping,
                    envMapCubeUVHeight: E,
                    aoMap: F,
                    lightMap: $,
                    bumpMap: B,
                    normalMap: H,
                    displacementMap: f && j,
                    emissiveMap: V,
                    normalMapObjectSpace: H && 1 === s.normalMapType,
                    normalMapTangentSpace: H && 0 === s.normalMapType,
                    metalnessMap: W,
                    roughnessMap: q,
                    anisotropy: X,
                    anisotropyMap: Q,
                    clearcoat: Y,
                    clearcoatMap: tt,
                    clearcoatNormalMap: et,
                    clearcoatRoughnessMap: nt,
                    iridescence: K,
                    iridescenceMap: it,
                    iridescenceThicknessMap: rt,
                    sheen: Z,
                    sheenColorMap: st,
                    sheenRoughnessMap: at,
                    specularMap: ot,
                    specularColorMap: lt,
                    specularIntensityMap: ct,
                    transmission: J,
                    transmissionMap: ht,
                    thicknessMap: ut,
                    gradientMap: dt,
                    opaque: !1 === s.transparent && 1 === s.blending,
                    alphaMap: pt,
                    alphaTest: ft,
                    alphaHash: mt,
                    combine: s.combine,
                    mapUv: N && v(s.map.channel),
                    aoMapUv: F && v(s.aoMap.channel),
                    lightMapUv: $ && v(s.lightMap.channel),
                    bumpMapUv: B && v(s.bumpMap.channel),
                    normalMapUv: H && v(s.normalMap.channel),
                    displacementMapUv: j && v(s.displacementMap.channel),
                    emissiveMapUv: V && v(s.emissiveMap.channel),
                    metalnessMapUv: W && v(s.metalnessMap.channel),
                    roughnessMapUv: q && v(s.roughnessMap.channel),
                    anisotropyMapUv: Q && v(s.anisotropyMap.channel),
                    clearcoatMapUv: tt && v(s.clearcoatMap.channel),
                    clearcoatNormalMapUv: et && v(s.clearcoatNormalMap.channel),
                    clearcoatRoughnessMapUv: nt && v(s.clearcoatRoughnessMap.channel),
                    iridescenceMapUv: it && v(s.iridescenceMap.channel),
                    iridescenceThicknessMapUv: rt && v(s.iridescenceThicknessMap.channel),
                    sheenColorMapUv: st && v(s.sheenColorMap.channel),
                    sheenRoughnessMapUv: at && v(s.sheenRoughnessMap.channel),
                    specularMapUv: ot && v(s.specularMap.channel),
                    specularColorMapUv: lt && v(s.specularColorMap.channel),
                    specularIntensityMapUv: ct && v(s.specularIntensityMap.channel),
                    transmissionMapUv: ht && v(s.transmissionMap.channel),
                    thicknessMapUv: ut && v(s.thicknessMap.channel),
                    alphaMapUv: pt && v(s.alphaMap.channel),
                    vertexTangents: !!w.attributes.tangent && (H || X),
                    vertexColors: s.vertexColors,
                    vertexAlphas: !0 === s.vertexColors && !!w.attributes.color && 4 === w.attributes.color.itemSize,
                    vertexUv1s: vt,
                    vertexUv2s: yt,
                    vertexUv3s: bt,
                    pointsUvs: !0 === x.isPoints && !!w.attributes.uv && (N || pt),
                    fog: !!_,
                    useFog: !0 === s.fog,
                    fogExp2: _ && _.isFogExp2,
                    flatShading: !0 === s.flatShading,
                    sizeAttenuation: !0 === s.sizeAttenuation,
                    logarithmicDepthBuffer: p,
                    skinning: !0 === x.isSkinnedMesh,
                    morphTargets: void 0 !== w.morphAttributes.position,
                    morphNormals: void 0 !== w.morphAttributes.normal,
                    morphColors: void 0 !== w.morphAttributes.color,
                    morphTargetsCount: A,
                    morphTextureStride: D,
                    numDirLights: c.directional.length,
                    numPointLights: c.point.length,
                    numSpotLights: c.spot.length,
                    numSpotLightMaps: c.spotLightMap.length,
                    numRectAreaLights: c.rectArea.length,
                    numHemiLights: c.hemi.length,
                    numDirLightShadows: c.directionalShadowMap.length,
                    numPointLightShadows: c.pointShadowMap.length,
                    numSpotLightShadows: c.spotShadowMap.length,
                    numSpotLightShadowsWithMaps: c.numSpotLightShadowsWithMaps,
                    numClippingPlanes: a.numPlanes,
                    numClipIntersection: a.numIntersection,
                    dithering: s.dithering,
                    shadowMapEnabled: t.shadowMap.enabled && u.length > 0,
                    shadowMapType: t.shadowMap.type,
                    toneMapping: xt,
                    useLegacyLights: t._useLegacyLights,
                    premultipliedAlpha: s.premultipliedAlpha,
                    doubleSided: s.side === l,
                    flipSided: s.side === o,
                    useDepthPacking: s.depthPacking >= 0,
                    depthPacking: s.depthPacking || 0,
                    index0AttributeName: s.index0AttributeName,
                    extensionDerivatives: gt && !0 === s.extensions.derivatives,
                    extensionFragDepth: gt && !0 === s.extensions.fragDepth,
                    extensionDrawBuffers: gt && !0 === s.extensions.drawBuffers,
                    extensionShaderTextureLOD: gt && !0 === s.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: d || i.has("EXT_frag_depth"),
                    rendererExtensionDrawBuffers: d || i.has("WEBGL_draw_buffers"),
                    rendererExtensionShaderTextureLod: d || i.has("EXT_shader_texture_lod"),
                    customProgramCacheKey: s.customProgramCacheKey()
                }
            },
            getProgramCacheKey: function (e) {
                const n = [];
                if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)), void 0 !== e.defines)
                    for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                return !1 === e.isRawShaderMaterial && (! function (t, e) {
                    t.push(e.precision), t.push(e.outputColorSpace), t.push(e.envMapMode), t.push(e.envMapCubeUVHeight), t.push(e.mapUv), t.push(e.alphaMapUv), t.push(e.lightMapUv), t.push(e.aoMapUv), t.push(e.bumpMapUv), t.push(e.normalMapUv), t.push(e.displacementMapUv), t.push(e.emissiveMapUv), t.push(e.metalnessMapUv), t.push(e.roughnessMapUv), t.push(e.anisotropyMapUv), t.push(e.clearcoatMapUv), t.push(e.clearcoatNormalMapUv), t.push(e.clearcoatRoughnessMapUv), t.push(e.iridescenceMapUv), t.push(e.iridescenceThicknessMapUv), t.push(e.sheenColorMapUv), t.push(e.sheenRoughnessMapUv), t.push(e.specularMapUv), t.push(e.specularColorMapUv), t.push(e.specularIntensityMapUv), t.push(e.transmissionMapUv), t.push(e.thicknessMapUv), t.push(e.combine), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.morphTargetsCount), t.push(e.morphAttributeCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numSpotLightMaps), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.numSpotLightShadowsWithMaps), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection), t.push(e.depthPacking)
                }(n, e), function (t, e) {
                    c.disableAll(), e.isWebGL2 && c.enable(0);
                    e.supportsVertexTextures && c.enable(1);
                    e.instancing && c.enable(2);
                    e.instancingColor && c.enable(3);
                    e.matcap && c.enable(4);
                    e.envMap && c.enable(5);
                    e.normalMapObjectSpace && c.enable(6);
                    e.normalMapTangentSpace && c.enable(7);
                    e.clearcoat && c.enable(8);
                    e.iridescence && c.enable(9);
                    e.alphaTest && c.enable(10);
                    e.vertexColors && c.enable(11);
                    e.vertexAlphas && c.enable(12);
                    e.vertexUv1s && c.enable(13);
                    e.vertexUv2s && c.enable(14);
                    e.vertexUv3s && c.enable(15);
                    e.vertexTangents && c.enable(16);
                    e.anisotropy && c.enable(17);
                    t.push(c.mask), c.disableAll(), e.fog && c.enable(0);
                    e.useFog && c.enable(1);
                    e.flatShading && c.enable(2);
                    e.logarithmicDepthBuffer && c.enable(3);
                    e.skinning && c.enable(4);
                    e.morphTargets && c.enable(5);
                    e.morphNormals && c.enable(6);
                    e.morphColors && c.enable(7);
                    e.premultipliedAlpha && c.enable(8);
                    e.shadowMapEnabled && c.enable(9);
                    e.useLegacyLights && c.enable(10);
                    e.doubleSided && c.enable(11);
                    e.flipSided && c.enable(12);
                    e.useDepthPacking && c.enable(13);
                    e.dithering && c.enable(14);
                    e.transmission && c.enable(15);
                    e.sheen && c.enable(16);
                    e.opaque && c.enable(17);
                    e.pointsUvs && c.enable(18);
                    t.push(c.mask)
                }(n, e), n.push(t.outputColorSpace)), n.push(e.customProgramCacheKey), n.join()
            },
            getUniforms: function (t) {
                const e = g[t.type];
                let n;
                if (e) {
                    const t = ai[e];
                    n = Bn.clone(t.uniforms)
                } else n = t.uniforms;
                return n
            },
            acquireProgram: function (e, n) {
                let i;
                for (let t = 0, e = u.length; t < e; t++) {
                    const e = u[t];
                    if (e.cacheKey === n) {
                        i = e, ++i.usedTimes;
                        break
                    }
                }
                return void 0 === i && (i = new is(t, n, e, s), u.push(i)), i
            },
            releaseProgram: function (t) {
                if (0 == --t.usedTimes) {
                    const e = u.indexOf(t);
                    u[e] = u[u.length - 1], u.pop(), t.destroy()
                }
            },
            releaseShaderCache: function (t) {
                h.remove(t)
            },
            programs: u,
            dispose: function () {
                h.dispose()
            }
        }
    }

    function ls() {
        let t = new WeakMap;
        return {
            get: function (e) {
                let n = t.get(e);
                return void 0 === n && (n = {}, t.set(e, n)), n
            },
            remove: function (e) {
                t.delete(e)
            },
            update: function (e, n, i) {
                t.get(e)[n] = i
            },
            dispose: function () {
                t = new WeakMap
            }
        }
    }

    function cs(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }

    function hs(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }

    function us() {
        const t = [];
        let e = 0;
        const n = [],
            i = [],
            r = [];

        function s(n, i, r, s, a, o) {
            let l = t[e];
            return void 0 === l ? (l = {
                id: n.id,
                object: n,
                geometry: i,
                material: r,
                groupOrder: s,
                renderOrder: n.renderOrder,
                z: a,
                group: o
            }, t[e] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = r, l.groupOrder = s, l.renderOrder = n.renderOrder, l.z = a, l.group = o), e++, l
        }
        return {
            opaque: n,
            transmissive: i,
            transparent: r,
            init: function () {
                e = 0, n.length = 0, i.length = 0, r.length = 0
            },
            push: function (t, e, a, o, l, c) {
                const h = s(t, e, a, o, l, c);
                a.transmission > 0 ? i.push(h) : !0 === a.transparent ? r.push(h) : n.push(h)
            },
            unshift: function (t, e, a, o, l, c) {
                const h = s(t, e, a, o, l, c);
                a.transmission > 0 ? i.unshift(h) : !0 === a.transparent ? r.unshift(h) : n.unshift(h)
            },
            finish: function () {
                for (let n = e, i = t.length; n < i; n++) {
                    const e = t[n];
                    if (null === e.id) break;
                    e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
                }
            },
            sort: function (t, e) {
                n.length > 1 && n.sort(t || cs), i.length > 1 && i.sort(e || hs), r.length > 1 && r.sort(e || hs)
            }
        }
    }

    function ds() {
        let t = new WeakMap;
        return {
            get: function (e, n) {
                const i = t.get(e);
                let r;
                return void 0 === i ? (r = new us, t.set(e, [r])) : n >= i.length ? (r = new us, i.push(r)) : r = i[n], r
            },
            dispose: function () {
                t = new WeakMap
            }
        }
    }

    function ps() {
        const t = {};
        return {
            get: function (e) {
                if (void 0 !== t[e.id]) return t[e.id];
                let n;
                switch (e.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new It,
                            color: new tn
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new It,
                            direction: new It,
                            color: new tn,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new It,
                            color: new tn,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new It,
                            skyColor: new tn,
                            groundColor: new tn
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new tn,
                            position: new It,
                            halfWidth: new It,
                            halfHeight: new It
                        }
                }
                return t[e.id] = n, n
            }
        }
    }
    let fs = 0;

    function ms(t, e) {
        return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0)
    }

    function gs(t, e) {
        const n = new ps,
            i = function () {
                const t = {};
                return {
                    get: function (e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        let n;
                        switch (e.type) {
                            case "DirectionalLight":
                            case "SpotLight":
                                n = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new ot
                                };
                                break;
                            case "PointLight":
                                n = {
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new ot,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                }
                        }
                        return t[e.id] = n, n
                    }
                }
            }(),
            r = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1,
                    numSpotMaps: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotLightMap: [],
                spotShadow: [],
                spotShadowMap: [],
                spotLightMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numSpotLightShadowsWithMaps: 0
            };
        for (let t = 0; t < 9; t++) r.probe.push(new It);
        const s = new It,
            a = new he,
            o = new he;
        return {
            setup: function (s, a) {
                let o = 0,
                    l = 0,
                    c = 0;
                for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                let h = 0,
                    u = 0,
                    d = 0,
                    p = 0,
                    f = 0,
                    m = 0,
                    g = 0,
                    v = 0,
                    y = 0,
                    b = 0;
                s.sort(ms);
                const x = !0 === a ? Math.PI : 1;
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = s[t],
                        a = e.color,
                        _ = e.intensity,
                        w = e.distance,
                        S = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                    if (e.isAmbientLight) o += a.r * _ * x, l += a.g * _ * x, c += a.b * _ * x;
                    else if (e.isLightProbe)
                        for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], _);
                    else if (e.isDirectionalLight) {
                        const t = n.get(e);
                        if (t.color.copy(e.color).multiplyScalar(e.intensity * x), e.castShadow) {
                            const t = e.shadow,
                                n = i.get(e);
                            n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.directionalShadow[h] = n, r.directionalShadowMap[h] = S, r.directionalShadowMatrix[h] = e.shadow.matrix, m++
                        }
                        r.directional[h] = t, h++
                    } else if (e.isSpotLight) {
                        const t = n.get(e);
                        t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(a).multiplyScalar(_ * x), t.distance = w, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, r.spot[d] = t;
                        const s = e.shadow;
                        if (e.map && (r.spotLightMap[y] = e.map, y++, s.updateMatrices(e), e.castShadow && b++), r.spotLightMatrix[d] = s.matrix, e.castShadow) {
                            const t = i.get(e);
                            t.shadowBias = s.bias, t.shadowNormalBias = s.normalBias, t.shadowRadius = s.radius, t.shadowMapSize = s.mapSize, r.spotShadow[d] = t, r.spotShadowMap[d] = S, v++
                        }
                        d++
                    } else if (e.isRectAreaLight) {
                        const t = n.get(e);
                        t.color.copy(a).multiplyScalar(_), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), r.rectArea[p] = t, p++
                    } else if (e.isPointLight) {
                        const t = n.get(e);
                        if (t.color.copy(e.color).multiplyScalar(e.intensity * x), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                            const t = e.shadow,
                                n = i.get(e);
                            n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, r.pointShadow[u] = n, r.pointShadowMap[u] = S, r.pointShadowMatrix[u] = e.shadow.matrix, g++
                        }
                        r.point[u] = t, u++
                    } else if (e.isHemisphereLight) {
                        const t = n.get(e);
                        t.skyColor.copy(e.color).multiplyScalar(_ * x), t.groundColor.copy(e.groundColor).multiplyScalar(_ * x), r.hemi[f] = t, f++
                    }
                }
                p > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = si.LTC_FLOAT_1, r.rectAreaLTC2 = si.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = si.LTC_HALF_1, r.rectAreaLTC2 = si.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
                const _ = r.hash;
                _.directionalLength === h && _.pointLength === u && _.spotLength === d && _.rectAreaLength === p && _.hemiLength === f && _.numDirectionalShadows === m && _.numPointShadows === g && _.numSpotShadows === v && _.numSpotMaps === y || (r.directional.length = h, r.spot.length = d, r.rectArea.length = p, r.point.length = u, r.hemi.length = f, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = g, r.spotLightMatrix.length = v + y - b, r.spotLightMap.length = y, r.numSpotLightShadowsWithMaps = b, _.directionalLength = h, _.pointLength = u, _.spotLength = d, _.rectAreaLength = p, _.hemiLength = f, _.numDirectionalShadows = m, _.numPointShadows = g, _.numSpotShadows = v, _.numSpotMaps = y, r.version = fs++)
            },
            setupView: function (t, e) {
                let n = 0,
                    i = 0,
                    l = 0,
                    c = 0,
                    h = 0;
                const u = e.matrixWorldInverse;
                for (let e = 0, d = t.length; e < d; e++) {
                    const d = t[e];
                    if (d.isDirectionalLight) {
                        const t = r.directional[n];
                        t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), n++
                    } else if (d.isSpotLight) {
                        const t = r.spot[l];
                        t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), l++
                    } else if (d.isRectAreaLight) {
                        const t = r.rectArea[c];
                        t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), o.identity(), a.copy(d.matrixWorld), a.premultiply(u), o.extractRotation(a), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(o), t.halfHeight.applyMatrix4(o), c++
                    } else if (d.isPointLight) {
                        const t = r.point[i];
                        t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), i++
                    } else if (d.isHemisphereLight) {
                        const t = r.hemi[h];
                        t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(u), h++
                    }
                }
            },
            state: r
        }
    }

    function vs(t, e) {
        const n = new gs(t, e),
            i = [],
            r = [];
        return {
            init: function () {
                i.length = 0, r.length = 0
            },
            state: {
                lightsArray: i,
                shadowsArray: r,
                lights: n
            },
            setupLights: function (t) {
                n.setup(i, t)
            },
            setupLightsView: function (t) {
                n.setupView(i, t)
            },
            pushLight: function (t) {
                i.push(t)
            },
            pushShadow: function (t) {
                r.push(t)
            }
        }
    }

    function ys(t, e) {
        let n = new WeakMap;
        return {
            get: function (i, r = 0) {
                const s = n.get(i);
                let a;
                return void 0 === s ? (a = new vs(t, e), n.set(i, [a])) : r >= s.length ? (a = new vs(t, e), s.push(a)) : a = s[r], a
            },
            dispose: function () {
                n = new WeakMap
            }
        }
    }
    class bs extends Ye {
        constructor(t) {
            super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = H, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t)
        }
        copy(t) {
            return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
        }
    }
    class xs extends Ye {
        constructor(t) {
            super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t)
        }
        copy(t) {
            return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
        }
    }

    function _s(t, e, n) {
        let i = new ti;
        const r = new ot,
            s = new ot,
            h = new At,
            u = new bs({
                depthPacking: j
            }),
            d = new xs,
            p = {},
            f = n.maxTextureSize,
            m = {
                [a]: o,
                [o]: a,
                [l]: l
            },
            g = new Hn({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new ot
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
            }),
            v = g.clone();
        v.defines.HORIZONTAL_PASS = 1;
        const y = new vn;
        y.setAttribute("position", new an(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
        const b = new kn(y, g),
            x = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1;
        let _ = this.type;

        function w(n, i) {
            const s = e.update(b);
            g.defines.VSM_SAMPLES !== n.blurSamples && (g.defines.VSM_SAMPLES = n.blurSamples, v.defines.VSM_SAMPLES = n.blurSamples, g.needsUpdate = !0, v.needsUpdate = !0), null === n.mapPass && (n.mapPass = new Pt(r.x, r.y)), g.uniforms.shadow_pass.value = n.map.texture, g.uniforms.resolution.value = n.mapSize, g.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, s, g, b, null), v.uniforms.shadow_pass.value = n.mapPass.texture, v.uniforms.resolution.value = n.mapSize, v.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, s, v, b, null)
        }

        function S(e, n, i, r) {
            let s = null;
            const a = !0 === i.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
            if (void 0 !== a) s = a;
            else if (s = !0 === i.isPointLight ? d : u, t.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                const t = s.uuid,
                    e = n.uuid;
                let i = p[t];
                void 0 === i && (i = {}, p[t] = i);
                let r = i[e];
                void 0 === r && (r = s.clone(), i[e] = r), s = r
            }
            if (s.visible = n.visible, s.wireframe = n.wireframe, s.side = 3 === r ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : m[n.side], s.alphaMap = n.alphaMap, s.alphaTest = n.alphaTest, s.map = n.map, s.clipShadows = n.clipShadows, s.clippingPlanes = n.clippingPlanes, s.clipIntersection = n.clipIntersection, s.displacementMap = n.displacementMap, s.displacementScale = n.displacementScale, s.displacementBias = n.displacementBias, s.wireframeLinewidth = n.wireframeLinewidth, s.linewidth = n.linewidth, !0 === i.isPointLight && !0 === s.isMeshDistanceMaterial) {
                t.properties.get(s).light = i
            }
            return s
        }

        function M(n, r, s, a, o) {
            if (!1 === n.visible) return;
            if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
                n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                const i = e.update(n),
                    r = n.material;
                if (Array.isArray(r)) {
                    const e = i.groups;
                    for (let l = 0, c = e.length; l < c; l++) {
                        const c = e[l],
                            h = r[c.materialIndex];
                        if (h && h.visible) {
                            const e = S(n, h, a, o);
                            t.renderBufferDirect(s, null, i, e, n, c)
                        }
                    }
                } else if (r.visible) {
                    const e = S(n, r, a, o);
                    t.renderBufferDirect(s, null, i, e, n, null)
                }
            }
            const l = n.children;
            for (let t = 0, e = l.length; t < e; t++) M(l[t], r, s, a, o)
        }
        this.render = function (e, n, a) {
            if (!1 === x.enabled) return;
            if (!1 === x.autoUpdate && !1 === x.needsUpdate) return;
            if (0 === e.length) return;
            const o = t.getRenderTarget(),
                l = t.getActiveCubeFace(),
                u = t.getActiveMipmapLevel(),
                d = t.state;
            d.setBlending(c), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
            const p = 3 !== _ && 3 === this.type,
                m = 3 === _ && 3 !== this.type;
            for (let o = 0, l = e.length; o < l; o++) {
                const l = e[o],
                    c = l.shadow;
                if (void 0 === c) {
                    console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
                    continue
                }
                if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue;
                r.copy(c.mapSize);
                const u = c.getFrameExtents();
                if (r.multiply(u), s.copy(c.mapSize), (r.x > f || r.y > f) && (r.x > f && (s.x = Math.floor(f / u.x), r.x = s.x * u.x, c.mapSize.x = s.x), r.y > f && (s.y = Math.floor(f / u.y), r.y = s.y * u.y, c.mapSize.y = s.y)), null === c.map || !0 === p || !0 === m) {
                    const t = 3 !== this.type ? {
                        minFilter: T,
                        magFilter: T
                    } : {};
                    null !== c.map && c.map.dispose(), c.map = new Pt(r.x, r.y, t), c.map.texture.name = l.name + ".shadowMap", c.camera.updateProjectionMatrix()
                }
                t.setRenderTarget(c.map), t.clear();
                const g = c.getViewportCount();
                for (let t = 0; t < g; t++) {
                    const e = c.getViewport(t);
                    h.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(h), c.updateMatrices(l, t), i = c.getFrustum(), M(n, a, c.camera, l, this.type)
                } !0 !== c.isPointLightShadow && 3 === this.type && w(c, a), c.needsUpdate = !1
            }
            _ = this.type, x.needsUpdate = !1, t.setRenderTarget(o, l, u)
        }
    }

    function ws(t, e, n) {
        const i = n.isWebGL2;
        const r = new function () {
            let e = !1;
            const n = new At;
            let i = null;
            const r = new At(0, 0, 0, 0);
            return {
                setMask: function (n) {
                    i === n || e || (t.colorMask(n, n, n, n), i = n)
                },
                setLocked: function (t) {
                    e = t
                },
                setClear: function (e, i, s, a, o) {
                    !0 === o && (e *= a, i *= a, s *= a), n.set(e, i, s, a), !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n))
                },
                reset: function () {
                    e = !1, i = null, r.set(-1, 0, 0, 0)
                }
            }
        },
            s = new function () {
                let e = !1,
                    n = null,
                    i = null,
                    r = null;
                return {
                    setTest: function (e) {
                        e ? J(t.DEPTH_TEST) : Q(t.DEPTH_TEST)
                    },
                    setMask: function (i) {
                        n === i || e || (t.depthMask(i), n = i)
                    },
                    setFunc: function (e) {
                        if (i !== e) {
                            switch (e) {
                                case u:
                                    t.depthFunc(t.NEVER);
                                    break;
                                case d:
                                    t.depthFunc(t.ALWAYS);
                                    break;
                                case p:
                                    t.depthFunc(t.LESS);
                                    break;
                                case f:
                                    t.depthFunc(t.LEQUAL);
                                    break;
                                case m:
                                    t.depthFunc(t.EQUAL);
                                    break;
                                case g:
                                    t.depthFunc(t.GEQUAL);
                                    break;
                                case v:
                                    t.depthFunc(t.GREATER);
                                    break;
                                case y:
                                    t.depthFunc(t.NOTEQUAL);
                                    break;
                                default:
                                    t.depthFunc(t.LEQUAL)
                            }
                            i = e
                        }
                    },
                    setLocked: function (t) {
                        e = t
                    },
                    setClear: function (e) {
                        r !== e && (t.clearDepth(e), r = e)
                    },
                    reset: function () {
                        e = !1, n = null, i = null, r = null
                    }
                }
            },
            a = new function () {
                let e = !1,
                    n = null,
                    i = null,
                    r = null,
                    s = null,
                    a = null,
                    o = null,
                    l = null,
                    c = null;
                return {
                    setTest: function (n) {
                        e || (n ? J(t.STENCIL_TEST) : Q(t.STENCIL_TEST))
                    },
                    setMask: function (i) {
                        n === i || e || (t.stencilMask(i), n = i)
                    },
                    setFunc: function (e, n, a) {
                        i === e && r === n && s === a || (t.stencilFunc(e, n, a), i = e, r = n, s = a)
                    },
                    setOp: function (e, n, i) {
                        a === e && o === n && l === i || (t.stencilOp(e, n, i), a = e, o = n, l = i)
                    },
                    setLocked: function (t) {
                        e = t
                    },
                    setClear: function (e) {
                        c !== e && (t.clearStencil(e), c = e)
                    },
                    reset: function () {
                        e = !1, n = null, i = null, r = null, s = null, a = null, o = null, l = null, c = null
                    }
                }
            },
            b = new WeakMap,
            x = new WeakMap;
        let _ = {},
            w = {},
            S = new WeakMap,
            M = [],
            E = null,
            T = !1,
            C = null,
            A = null,
            R = null,
            P = null,
            L = null,
            O = null,
            D = null,
            I = !1,
            k = null,
            N = null,
            U = null,
            z = null,
            F = null;
        const $ = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let B = !1,
            H = 0;
        const j = t.getParameter(t.VERSION); - 1 !== j.indexOf("WebGL") ? (H = parseFloat(/^WebGL (\d)/.exec(j)[1]), B = H >= 1) : -1 !== j.indexOf("OpenGL ES") && (H = parseFloat(/^OpenGL ES (\d)/.exec(j)[1]), B = H >= 2);
        let V = null,
            G = {};
        const W = t.getParameter(t.SCISSOR_BOX),
            q = t.getParameter(t.VIEWPORT),
            X = (new At).fromArray(W),
            Y = (new At).fromArray(q);

        function K(e, n, r, s) {
            const a = new Uint8Array(4),
                o = t.createTexture();
            t.bindTexture(e, o), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
            for (let o = 0; o < r; o++) !i || e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY ? t.texImage2D(n + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, a) : t.texImage3D(n, 0, t.RGBA, 1, 1, s, 0, t.RGBA, t.UNSIGNED_BYTE, a);
            return o
        }
        const Z = {};

        function J(e) {
            !0 !== _[e] && (t.enable(e), _[e] = !0)
        }

        function Q(e) {
            !1 !== _[e] && (t.disable(e), _[e] = !1)
        }
        Z[t.TEXTURE_2D] = K(t.TEXTURE_2D, t.TEXTURE_2D, 1), Z[t.TEXTURE_CUBE_MAP] = K(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i && (Z[t.TEXTURE_2D_ARRAY] = K(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1), Z[t.TEXTURE_3D] = K(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1)), r.setClear(0, 0, 0, 1), s.setClear(1), a.setClear(0), J(t.DEPTH_TEST), s.setFunc(f), it(!1), rt(1), J(t.CULL_FACE), nt(c);
        const tt = {
            100: t.FUNC_ADD,
            101: t.FUNC_SUBTRACT,
            102: t.FUNC_REVERSE_SUBTRACT
        };
        if (i) tt[103] = t.MIN, tt[104] = t.MAX;
        else {
            const t = e.get("EXT_blend_minmax");
            null !== t && (tt[103] = t.MIN_EXT, tt[104] = t.MAX_EXT)
        }
        const et = {
            200: t.ZERO,
            201: t.ONE,
            202: t.SRC_COLOR,
            204: t.SRC_ALPHA,
            210: t.SRC_ALPHA_SATURATE,
            208: t.DST_COLOR,
            206: t.DST_ALPHA,
            203: t.ONE_MINUS_SRC_COLOR,
            205: t.ONE_MINUS_SRC_ALPHA,
            209: t.ONE_MINUS_DST_COLOR,
            207: t.ONE_MINUS_DST_ALPHA
        };

        function nt(e, n, i, r, s, a, o, l) {
            if (e !== c) {
                if (!1 === T && (J(t.BLEND), T = !0), 5 === e) s = s || n, a = a || i, o = o || r, n === A && s === L || (t.blendEquationSeparate(tt[n], tt[s]), A = n, L = s), i === R && r === P && a === O && o === D || (t.blendFuncSeparate(et[i], et[r], et[a], et[o]), R = i, P = r, O = a, D = o), C = e, I = !1;
                else if (e !== C || l !== I) {
                    if (100 === A && 100 === L || (t.blendEquation(t.FUNC_ADD), A = 100, L = 100), l) switch (e) {
                        case 1:
                            t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                            break;
                        case h:
                            t.blendFunc(t.ONE, t.ONE);
                            break;
                        case 3:
                            t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                            break;
                        case 4:
                            t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                    } else switch (e) {
                        case 1:
                            t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
                            break;
                        case h:
                            t.blendFunc(t.SRC_ALPHA, t.ONE);
                            break;
                        case 3:
                            t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
                            break;
                        case 4:
                            t.blendFunc(t.ZERO, t.SRC_COLOR);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                    }
                    R = null, P = null, O = null, D = null, C = e, I = l
                }
            } else !0 === T && (Q(t.BLEND), T = !1)
        }

        function it(e) {
            k !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), k = e)
        }

        function rt(e) {
            0 !== e ? (J(t.CULL_FACE), e !== N && (1 === e ? t.cullFace(t.BACK) : 2 === e ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : Q(t.CULL_FACE), N = e
        }

        function st(e, n, i) {
            e ? (J(t.POLYGON_OFFSET_FILL), z === n && F === i || (t.polygonOffset(n, i), z = n, F = i)) : Q(t.POLYGON_OFFSET_FILL)
        }
        return {
            buffers: {
                color: r,
                depth: s,
                stencil: a
            },
            enable: J,
            disable: Q,
            bindFramebuffer: function (e, n) {
                return w[e] !== n && (t.bindFramebuffer(e, n), w[e] = n, i && (e === t.DRAW_FRAMEBUFFER && (w[t.FRAMEBUFFER] = n), e === t.FRAMEBUFFER && (w[t.DRAW_FRAMEBUFFER] = n)), !0)
            },
            drawBuffers: function (i, r) {
                let s = M,
                    a = !1;
                if (i)
                    if (s = S.get(r), void 0 === s && (s = [], S.set(r, s)), i.isWebGLMultipleRenderTargets) {
                        const e = i.texture;
                        if (s.length !== e.length || s[0] !== t.COLOR_ATTACHMENT0) {
                            for (let n = 0, i = e.length; n < i; n++) s[n] = t.COLOR_ATTACHMENT0 + n;
                            s.length = e.length, a = !0
                        }
                    } else s[0] !== t.COLOR_ATTACHMENT0 && (s[0] = t.COLOR_ATTACHMENT0, a = !0);
                else s[0] !== t.BACK && (s[0] = t.BACK, a = !0);
                a && (n.isWebGL2 ? t.drawBuffers(s) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
            },
            useProgram: function (e) {
                return E !== e && (t.useProgram(e), E = e, !0)
            },
            setBlending: nt,
            setMaterial: function (e, n) {
                e.side === l ? Q(t.CULL_FACE) : J(t.CULL_FACE);
                let i = e.side === o;
                n && (i = !i), it(i), 1 === e.blending && !1 === e.transparent ? nt(c) : nt(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), s.setFunc(e.depthFunc), s.setTest(e.depthTest), s.setMask(e.depthWrite), r.setMask(e.colorWrite);
                const h = e.stencilWrite;
                a.setTest(h), h && (a.setMask(e.stencilWriteMask), a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), st(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? J(t.SAMPLE_ALPHA_TO_COVERAGE) : Q(t.SAMPLE_ALPHA_TO_COVERAGE)
            },
            setFlipSided: it,
            setCullFace: rt,
            setLineWidth: function (e) {
                e !== U && (B && t.lineWidth(e), U = e)
            },
            setPolygonOffset: st,
            setScissorTest: function (e) {
                e ? J(t.SCISSOR_TEST) : Q(t.SCISSOR_TEST)
            },
            activeTexture: function (e) {
                void 0 === e && (e = t.TEXTURE0 + $ - 1), V !== e && (t.activeTexture(e), V = e)
            },
            bindTexture: function (e, n, i) {
                void 0 === i && (i = null === V ? t.TEXTURE0 + $ - 1 : V);
                let r = G[i];
                void 0 === r && (r = {
                    type: void 0,
                    texture: void 0
                }, G[i] = r), r.type === e && r.texture === n || (V !== i && (t.activeTexture(i), V = i), t.bindTexture(e, n || Z[e]), r.type = e, r.texture = n)
            },
            unbindTexture: function () {
                const e = G[V];
                void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
            },
            compressedTexImage2D: function () {
                try {
                    t.compressedTexImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            compressedTexImage3D: function () {
                try {
                    t.compressedTexImage3D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage2D: function () {
                try {
                    t.texImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage3D: function () {
                try {
                    t.texImage3D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            updateUBOMapping: function (e, n) {
                let i = x.get(n);
                void 0 === i && (i = new WeakMap, x.set(n, i));
                let r = i.get(e);
                void 0 === r && (r = t.getUniformBlockIndex(n, e.name), i.set(e, r))
            },
            uniformBlockBinding: function (e, n) {
                const i = x.get(n).get(e);
                b.get(n) !== i && (t.uniformBlockBinding(n, i, e.__bindingPointIndex), b.set(n, i))
            },
            texStorage2D: function () {
                try {
                    t.texStorage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texStorage3D: function () {
                try {
                    t.texStorage3D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texSubImage2D: function () {
                try {
                    t.texSubImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texSubImage3D: function () {
                try {
                    t.texSubImage3D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            compressedTexSubImage2D: function () {
                try {
                    t.compressedTexSubImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            compressedTexSubImage3D: function () {
                try {
                    t.compressedTexSubImage3D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            scissor: function (e) {
                !1 === X.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), X.copy(e))
            },
            viewport: function (e) {
                !1 === Y.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), Y.copy(e))
            },
            reset: function () {
                t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), !0 === i && (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), _ = {}, V = null, G = {}, w = {}, S = new WeakMap, M = [], E = null, T = !1, C = null, A = null, R = null, P = null, L = null, O = null, D = null, I = !1, k = null, N = null, U = null, z = null, F = null, X.set(0, 0, t.canvas.width, t.canvas.height), Y.set(0, 0, t.canvas.width, t.canvas.height), r.reset(), s.reset(), a.reset()
            }
        }
    }

    function Ss(t, e, n, i, r, s, a) {
        const o = r.isWebGL2,
            l = r.maxTextures,
            c = r.maxCubemapSize,
            h = r.maxTextureSize,
            u = r.maxSamples,
            d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
            p = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
            f = new WeakMap;
        let m;
        const g = new WeakMap;
        let v = !1;
        try {
            v = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
        } catch (t) { }

        function y(t, e) {
            return v ? new OffscreenCanvas(t, e) : ut("canvas")
        }

        function b(t, e, n, i) {
            let r = 1;
            if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    const i = e ? it : Math.floor,
                        s = i(r * t.width),
                        a = i(r * t.height);
                    void 0 === m && (m = y(s, a));
                    const o = n ? y(s, a) : m;
                    o.width = s, o.height = a;
                    return o.getContext("2d").drawImage(t, 0, 0, s, a), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + a + ")."), o
                }
                return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
            }
            return t
        }

        function x(t) {
            return et(t.width) && et(t.height)
        }

        function _(t, e) {
            return t.generateMipmaps && e && t.minFilter !== T && t.minFilter !== C
        }

        function w(e) {
            t.generateMipmap(e)
        }

        function S(n, i, r, s, a = !1) {
            if (!1 === o) return i;
            if (null !== n) {
                if (void 0 !== t[n]) return t[n];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
            }
            let l = i;
            return i === t.RED && (r === t.FLOAT && (l = t.R32F), r === t.HALF_FLOAT && (l = t.R16F), r === t.UNSIGNED_BYTE && (l = t.R8)), i === t.RED_INTEGER && (r === t.UNSIGNED_BYTE && (l = t.R8UI), r === t.UNSIGNED_SHORT && (l = t.R16UI), r === t.UNSIGNED_INT && (l = t.R32UI), r === t.BYTE && (l = t.R8I), r === t.SHORT && (l = t.R16I), r === t.INT && (l = t.R32I)), i === t.RG && (r === t.FLOAT && (l = t.RG32F), r === t.HALF_FLOAT && (l = t.RG16F), r === t.UNSIGNED_BYTE && (l = t.RG8)), i === t.RGBA && (r === t.FLOAT && (l = t.RGBA32F), r === t.HALF_FLOAT && (l = t.RGBA16F), r === t.UNSIGNED_BYTE && (l = s === V && !1 === a ? t.SRGB8_ALPHA8 : t.RGBA8), r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4), r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1)), l !== t.R16F && l !== t.R32F && l !== t.RG16F && l !== t.RG32F && l !== t.RGBA16F && l !== t.RGBA32F || e.get("EXT_color_buffer_float"), l
        }

        function k(t, e, n) {
            return !0 === _(t, n) || t.isFramebufferTexture && t.minFilter !== T && t.minFilter !== C ? Math.log2(Math.max(e.width, e.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e.mipmaps.length : 1
        }

        function z(e) {
            return e === T || 1004 === e || 1005 === e ? t.NEAREST : t.LINEAR
        }

        function F(t) {
            const e = t.target;
            e.removeEventListener("dispose", F),
                function (t) {
                    const e = i.get(t);
                    if (void 0 === e.__webglInit) return;
                    const n = t.source,
                        r = g.get(n);
                    if (r) {
                        const i = r[e.__cacheKey];
                        i.usedTimes--, 0 === i.usedTimes && B(t), 0 === Object.keys(r).length && g.delete(n)
                    }
                    i.remove(t)
                }(e), e.isVideoTexture && f.delete(e)
        }

        function $(e) {
            const n = e.target;
            n.removeEventListener("dispose", $),
                function (e) {
                    const n = e.texture,
                        r = i.get(e),
                        s = i.get(n);
                    void 0 !== s.__webglTexture && (t.deleteTexture(s.__webglTexture), a.memory.textures--);
                    e.depthTexture && e.depthTexture.dispose();
                    if (e.isWebGLCubeRenderTarget)
                        for (let e = 0; e < 6; e++) {
                            if (Array.isArray(r.__webglFramebuffer[e]))
                                for (let n = 0; n < r.__webglFramebuffer[e].length; n++) t.deleteFramebuffer(r.__webglFramebuffer[e][n]);
                            else t.deleteFramebuffer(r.__webglFramebuffer[e]);
                            r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e])
                        } else {
                        if (Array.isArray(r.__webglFramebuffer))
                            for (let e = 0; e < r.__webglFramebuffer.length; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]);
                        else t.deleteFramebuffer(r.__webglFramebuffer);
                        if (r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer)
                            for (let e = 0; e < r.__webglColorRenderbuffer.length; e++) r.__webglColorRenderbuffer[e] && t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);
                        r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer)
                    }
                    if (e.isWebGLMultipleRenderTargets)
                        for (let e = 0, r = n.length; e < r; e++) {
                            const r = i.get(n[e]);
                            r.__webglTexture && (t.deleteTexture(r.__webglTexture), a.memory.textures--), i.remove(n[e])
                        }
                    i.remove(n), i.remove(e)
                }(n)
        }

        function B(e) {
            const n = i.get(e);
            t.deleteTexture(n.__webglTexture);
            const r = e.source;
            delete g.get(r)[n.__cacheKey], a.memory.textures--
        }
        let H = 0;

        function j(e, r) {
            const s = i.get(e);
            if (e.isVideoTexture && function (t) {
                const e = a.render.frame;
                f.get(t) !== e && (f.set(t, e), t.update())
            }(e), !1 === e.isRenderTargetTexture && e.version > 0 && s.__version !== e.version) {
                const t = e.image;
                if (null === t) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                else {
                    if (!1 !== t.complete) return void Z(s, e, r);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            n.bindTexture(t.TEXTURE_2D, s.__webglTexture, t.TEXTURE0 + r)
        }
        const W = {
            [M]: t.REPEAT,
            [E]: t.CLAMP_TO_EDGE,
            1002: t.MIRRORED_REPEAT
        },
            q = {
                [T]: t.NEAREST,
                1004: t.NEAREST_MIPMAP_NEAREST,
                1005: t.NEAREST_MIPMAP_LINEAR,
                [C]: t.LINEAR,
                1007: t.LINEAR_MIPMAP_NEAREST,
                [A]: t.LINEAR_MIPMAP_LINEAR
            },
            X = {
                512: t.NEVER,
                519: t.ALWAYS,
                513: t.LESS,
                515: t.LEQUAL,
                514: t.EQUAL,
                518: t.GEQUAL,
                516: t.GREATER,
                517: t.NOTEQUAL
            };

        function Y(n, s, a) {
            if (a ? (t.texParameteri(n, t.TEXTURE_WRAP_S, W[s.wrapS]), t.texParameteri(n, t.TEXTURE_WRAP_T, W[s.wrapT]), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, W[s.wrapR]), t.texParameteri(n, t.TEXTURE_MAG_FILTER, q[s.magFilter]), t.texParameteri(n, t.TEXTURE_MIN_FILTER, q[s.minFilter])) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY || t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE), s.wrapS === E && s.wrapT === E || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, t.TEXTURE_MAG_FILTER, z(s.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, z(s.minFilter)), s.minFilter !== T && s.minFilter !== C && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), s.compareFunction && (t.texParameteri(n, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE), t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, X[s.compareFunction])), !0 === e.has("EXT_texture_filter_anisotropic")) {
                const a = e.get("EXT_texture_filter_anisotropic");
                if (s.magFilter === T) return;
                if (1005 !== s.minFilter && s.minFilter !== A) return;
                if (s.type === L && !1 === e.has("OES_texture_float_linear")) return;
                if (!1 === o && s.type === O && !1 === e.has("OES_texture_half_float_linear")) return;
                (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
            }
        }

        function K(e, n) {
            let i = !1;
            void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", F));
            const r = n.source;
            let s = g.get(r);
            void 0 === s && (s = {}, g.set(r, s));
            const o = function (t) {
                const e = [];
                return e.push(t.wrapS), e.push(t.wrapT), e.push(t.wrapR || 0), e.push(t.magFilter), e.push(t.minFilter), e.push(t.anisotropy), e.push(t.internalFormat), e.push(t.format), e.push(t.type), e.push(t.generateMipmaps), e.push(t.premultiplyAlpha), e.push(t.flipY), e.push(t.unpackAlignment), e.push(t.colorSpace), e.join()
            }(n);
            if (o !== e.__cacheKey) {
                void 0 === s[o] && (s[o] = {
                    texture: t.createTexture(),
                    usedTimes: 0
                }, a.memory.textures++, i = !0), s[o].usedTimes++;
                const r = s[e.__cacheKey];
                void 0 !== r && (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && B(n)), e.__cacheKey = o, e.__webglTexture = s[o].texture
            }
            return i
        }

        function Z(e, r, a) {
            let l = t.TEXTURE_2D;
            (r.isDataArrayTexture || r.isCompressedArrayTexture) && (l = t.TEXTURE_2D_ARRAY), r.isData3DTexture && (l = t.TEXTURE_3D);
            const c = K(e, r),
                u = r.source;
            n.bindTexture(l, e.__webglTexture, t.TEXTURE0 + a);
            const d = i.get(u);
            if (u.version !== d.__version || !0 === c) {
                n.activeTexture(t.TEXTURE0 + a), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
                const e = function (t) {
                    return !o && (t.wrapS !== E || t.wrapT !== E || t.minFilter !== T && t.minFilter !== C)
                }(r) && !1 === x(r.image);
                let i = b(r.image, e, !1, h);
                i = st(r, i);
                const p = x(i) || o,
                    f = s.convert(r.format, r.colorSpace);
                let m, g = s.convert(r.type),
                    v = S(r.internalFormat, f, g, r.colorSpace);
                Y(l, r, p);
                const y = r.mipmaps,
                    M = o && !0 !== r.isVideoTexture,
                    A = void 0 === d.__version || !0 === c,
                    R = k(r, i, p);
                if (r.isDepthTexture) v = t.DEPTH_COMPONENT, o ? v = r.type === L ? t.DEPTH_COMPONENT32F : r.type === P ? t.DEPTH_COMPONENT24 : r.type === D ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT16 : r.type === L && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === N && v === t.DEPTH_COMPONENT && 1012 !== r.type && r.type !== P && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = P, g = s.convert(r.type)), r.format === U && v === t.DEPTH_COMPONENT && (v = t.DEPTH_STENCIL, r.type !== D && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = D, g = s.convert(r.type))), A && (M ? n.texStorage2D(t.TEXTURE_2D, 1, v, i.width, i.height) : n.texImage2D(t.TEXTURE_2D, 0, v, i.width, i.height, 0, f, g, null));
                else if (r.isDataTexture)
                    if (y.length > 0 && p) {
                        M && A && n.texStorage2D(t.TEXTURE_2D, R, v, y[0].width, y[0].height);
                        for (let e = 0, i = y.length; e < i; e++) m = y[e], M ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, m.width, m.height, f, g, m.data) : n.texImage2D(t.TEXTURE_2D, e, v, m.width, m.height, 0, f, g, m.data);
                        r.generateMipmaps = !1
                    } else M ? (A && n.texStorage2D(t.TEXTURE_2D, R, v, i.width, i.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, i.width, i.height, f, g, i.data)) : n.texImage2D(t.TEXTURE_2D, 0, v, i.width, i.height, 0, f, g, i.data);
                else if (r.isCompressedTexture)
                    if (r.isCompressedArrayTexture) {
                        M && A && n.texStorage3D(t.TEXTURE_2D_ARRAY, R, v, y[0].width, y[0].height, i.depth);
                        for (let e = 0, s = y.length; e < s; e++) m = y[e], r.format !== I ? null !== f ? M ? n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, m.width, m.height, i.depth, f, m.data, 0, 0) : n.compressedTexImage3D(t.TEXTURE_2D_ARRAY, e, v, m.width, m.height, i.depth, 0, m.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M ? n.texSubImage3D(t.TEXTURE_2D_ARRAY, e, 0, 0, 0, m.width, m.height, i.depth, f, g, m.data) : n.texImage3D(t.TEXTURE_2D_ARRAY, e, v, m.width, m.height, i.depth, 0, f, g, m.data)
                    } else {
                        M && A && n.texStorage2D(t.TEXTURE_2D, R, v, y[0].width, y[0].height);
                        for (let e = 0, i = y.length; e < i; e++) m = y[e], r.format !== I ? null !== f ? M ? n.compressedTexSubImage2D(t.TEXTURE_2D, e, 0, 0, m.width, m.height, f, m.data) : n.compressedTexImage2D(t.TEXTURE_2D, e, v, m.width, m.height, 0, m.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, m.width, m.height, f, g, m.data) : n.texImage2D(t.TEXTURE_2D, e, v, m.width, m.height, 0, f, g, m.data)
                    }
                else if (r.isDataArrayTexture) M ? (A && n.texStorage3D(t.TEXTURE_2D_ARRAY, R, v, i.width, i.height, i.depth), n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, i.width, i.height, i.depth, f, g, i.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, v, i.width, i.height, i.depth, 0, f, g, i.data);
                else if (r.isData3DTexture) M ? (A && n.texStorage3D(t.TEXTURE_3D, R, v, i.width, i.height, i.depth), n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, i.width, i.height, i.depth, f, g, i.data)) : n.texImage3D(t.TEXTURE_3D, 0, v, i.width, i.height, i.depth, 0, f, g, i.data);
                else if (r.isFramebufferTexture) {
                    if (A)
                        if (M) n.texStorage2D(t.TEXTURE_2D, R, v, i.width, i.height);
                        else {
                            let e = i.width,
                                r = i.height;
                            for (let i = 0; i < R; i++) n.texImage2D(t.TEXTURE_2D, i, v, e, r, 0, f, g, null), e >>= 1, r >>= 1
                        }
                } else if (y.length > 0 && p) {
                    M && A && n.texStorage2D(t.TEXTURE_2D, R, v, y[0].width, y[0].height);
                    for (let e = 0, i = y.length; e < i; e++) m = y[e], M ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, f, g, m) : n.texImage2D(t.TEXTURE_2D, e, v, f, g, m);
                    r.generateMipmaps = !1
                } else M ? (A && n.texStorage2D(t.TEXTURE_2D, R, v, i.width, i.height), n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, f, g, i)) : n.texImage2D(t.TEXTURE_2D, 0, v, f, g, i);
                _(r, p) && w(l), d.__version = u.version, r.onUpdate && r.onUpdate(r)
            }
            e.__version = r.version
        }

        function J(e, r, a, o, l, c) {
            const h = s.convert(a.format, a.colorSpace),
                u = s.convert(a.type),
                p = S(a.internalFormat, h, u, a.colorSpace);
            if (!i.get(r).__hasExternalTextures) {
                const e = Math.max(1, r.width >> c),
                    i = Math.max(1, r.height >> c);
                l === t.TEXTURE_3D || l === t.TEXTURE_2D_ARRAY ? n.texImage3D(l, c, p, e, i, r.depth, 0, h, u, null) : n.texImage2D(l, c, p, e, i, 0, h, u, null)
            }
            n.bindFramebuffer(t.FRAMEBUFFER, e), rt(r) ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, o, l, i.get(a).__webglTexture, 0, nt(r)) : (l === t.TEXTURE_2D || l >= t.TEXTURE_CUBE_MAP_POSITIVE_X && l <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, o, l, i.get(a).__webglTexture, c), n.bindFramebuffer(t.FRAMEBUFFER, null)
        }

        function Q(e, n, i) {
            if (t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer) {
                let r = t.DEPTH_COMPONENT16;
                if (i || rt(n)) {
                    const e = n.depthTexture;
                    e && e.isDepthTexture && (e.type === L ? r = t.DEPTH_COMPONENT32F : e.type === P && (r = t.DEPTH_COMPONENT24));
                    const i = nt(n);
                    rt(n) ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, i, r, n.width, n.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, i, r, n.width, n.height)
                } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
                t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)
            } else if (n.depthBuffer && n.stencilBuffer) {
                const r = nt(n);
                i && !1 === rt(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : rt(n) ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, r, t.DEPTH24_STENCIL8, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)
            } else {
                const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
                for (let r = 0; r < e.length; r++) {
                    const a = e[r],
                        o = s.convert(a.format, a.colorSpace),
                        l = s.convert(a.type),
                        c = S(a.internalFormat, o, l, a.colorSpace),
                        h = nt(n);
                    i && !1 === rt(n) ? t.renderbufferStorageMultisample(t.RENDERBUFFER, h, c, n.width, n.height) : rt(n) ? d.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, h, c, n.width, n.height) : t.renderbufferStorage(t.RENDERBUFFER, c, n.width, n.height)
                }
            }
            t.bindRenderbuffer(t.RENDERBUFFER, null)
        }

        function tt(e) {
            const r = i.get(e),
                s = !0 === e.isWebGLCubeRenderTarget;
            if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
                if (s) throw new Error("target.depthTexture not supported in Cube render targets");
                ! function (e, r) {
                    if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                    if (n.bindFramebuffer(t.FRAMEBUFFER, e), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), j(r.depthTexture, 0);
                    const s = i.get(r.depthTexture).__webglTexture,
                        a = nt(r);
                    if (r.depthTexture.format === N) rt(r) ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, s, 0);
                    else {
                        if (r.depthTexture.format !== U) throw new Error("Unknown depthTexture format");
                        rt(r) ? d.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, s, 0)
                    }
                }(r.__webglFramebuffer, e)
            } else if (s) {
                r.__webglDepthbuffer = [];
                for (let i = 0; i < 6; i++) n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = t.createRenderbuffer(), Q(r.__webglDepthbuffer[i], e, !1)
            } else n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), Q(r.__webglDepthbuffer, e, !1);
            n.bindFramebuffer(t.FRAMEBUFFER, null)
        }

        function nt(t) {
            return Math.min(u, t.samples)
        }

        function rt(t) {
            const n = i.get(t);
            return o && t.samples > 0 && !0 === e.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
        }

        function st(t, n) {
            const i = t.colorSpace,
                r = t.format,
                s = t.type;
            return !0 === t.isCompressedTexture || 1035 === t.format || i !== G && "" !== i && (i === V ? !1 === o ? !0 === e.has("EXT_sRGB") && r === I ? (t.format = 1035, t.minFilter = C, t.generateMipmaps = !1) : n = wt.sRGBToLinear(n) : r === I && s === R || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", i)), n
        }
        this.allocateTextureUnit = function () {
            const t = H;
            return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), H += 1, t
        }, this.resetTextureUnits = function () {
            H = 0
        }, this.setTexture2D = j, this.setTexture2DArray = function (e, r) {
            const s = i.get(e);
            e.version > 0 && s.__version !== e.version ? Z(s, e, r) : n.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture, t.TEXTURE0 + r)
        }, this.setTexture3D = function (e, r) {
            const s = i.get(e);
            e.version > 0 && s.__version !== e.version ? Z(s, e, r) : n.bindTexture(t.TEXTURE_3D, s.__webglTexture, t.TEXTURE0 + r)
        }, this.setTextureCube = function (e, r) {
            const a = i.get(e);
            e.version > 0 && a.__version !== e.version ? function (e, r, a) {
                if (6 !== r.image.length) return;
                const l = K(e, r),
                    h = r.source;
                n.bindTexture(t.TEXTURE_CUBE_MAP, e.__webglTexture, t.TEXTURE0 + a);
                const u = i.get(h);
                if (h.version !== u.__version || !0 === l) {
                    n.activeTexture(t.TEXTURE0 + a), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
                    const e = r.isCompressedTexture || r.image[0].isCompressedTexture,
                        i = r.image[0] && r.image[0].isDataTexture,
                        d = [];
                    for (let t = 0; t < 6; t++) d[t] = e || i ? i ? r.image[t].image : r.image[t] : b(r.image[t], !1, !0, c), d[t] = st(r, d[t]);
                    const p = d[0],
                        f = x(p) || o,
                        m = s.convert(r.format, r.colorSpace),
                        g = s.convert(r.type),
                        v = S(r.internalFormat, m, g, r.colorSpace),
                        y = o && !0 !== r.isVideoTexture,
                        M = void 0 === u.__version || !0 === l;
                    let E, T = k(r, p, f);
                    if (Y(t.TEXTURE_CUBE_MAP, r, f), e) {
                        y && M && n.texStorage2D(t.TEXTURE_CUBE_MAP, T, v, p.width, p.height);
                        for (let e = 0; e < 6; e++) {
                            E = d[e].mipmaps;
                            for (let i = 0; i < E.length; i++) {
                                const s = E[i];
                                r.format !== I ? null !== m ? y ? n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, 0, 0, s.width, s.height, m, s.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, v, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : y ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, 0, 0, s.width, s.height, m, g, s.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i, v, s.width, s.height, 0, m, g, s.data)
                            }
                        }
                    } else {
                        E = r.mipmaps, y && M && (E.length > 0 && T++, n.texStorage2D(t.TEXTURE_CUBE_MAP, T, v, d[0].width, d[0].height));
                        for (let e = 0; e < 6; e++)
                            if (i) {
                                y ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, d[e].width, d[e].height, m, g, d[e].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, v, d[e].width, d[e].height, 0, m, g, d[e].data);
                                for (let i = 0; i < E.length; i++) {
                                    const r = E[i].image[e].image;
                                    y ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, r.width, r.height, m, g, r.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, v, r.width, r.height, 0, m, g, r.data)
                                }
                            } else {
                                y ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, 0, 0, m, g, d[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, v, m, g, d[e]);
                                for (let i = 0; i < E.length; i++) {
                                    const r = E[i];
                                    y ? n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, 0, 0, m, g, r.image[e]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + e, i + 1, v, m, g, r.image[e])
                                }
                            }
                    }
                    _(r, f) && w(t.TEXTURE_CUBE_MAP), u.__version = h.version, r.onUpdate && r.onUpdate(r)
                }
                e.__version = r.version
            }(a, e, r) : n.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture, t.TEXTURE0 + r)
        }, this.rebindTextures = function (e, n, r) {
            const s = i.get(e);
            void 0 !== n && J(s.__webglFramebuffer, e, e.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0), void 0 !== r && tt(e)
        }, this.setupRenderTarget = function (e) {
            const l = e.texture,
                c = i.get(e),
                h = i.get(l);
            e.addEventListener("dispose", $), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === h.__webglTexture && (h.__webglTexture = t.createTexture()), h.__version = l.version, a.memory.textures++);
            const u = !0 === e.isWebGLCubeRenderTarget,
                d = !0 === e.isWebGLMultipleRenderTargets,
                p = x(e) || o;
            if (u) {
                c.__webglFramebuffer = [];
                for (let e = 0; e < 6; e++)
                    if (o && l.mipmaps && l.mipmaps.length > 0) {
                        c.__webglFramebuffer[e] = [];
                        for (let n = 0; n < l.mipmaps.length; n++) c.__webglFramebuffer[e][n] = t.createFramebuffer()
                    } else c.__webglFramebuffer[e] = t.createFramebuffer()
            } else {
                if (o && l.mipmaps && l.mipmaps.length > 0) {
                    c.__webglFramebuffer = [];
                    for (let e = 0; e < l.mipmaps.length; e++) c.__webglFramebuffer[e] = t.createFramebuffer()
                } else c.__webglFramebuffer = t.createFramebuffer();
                if (d)
                    if (r.drawBuffers) {
                        const n = e.texture;
                        for (let e = 0, r = n.length; e < r; e++) {
                            const r = i.get(n[e]);
                            void 0 === r.__webglTexture && (r.__webglTexture = t.createTexture(), a.memory.textures++)
                        }
                    } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                if (o && e.samples > 0 && !1 === rt(e)) {
                    const i = d ? l : [l];
                    c.__webglMultisampledFramebuffer = t.createFramebuffer(), c.__webglColorRenderbuffer = [], n.bindFramebuffer(t.FRAMEBUFFER, c.__webglMultisampledFramebuffer);
                    for (let n = 0; n < i.length; n++) {
                        const r = i[n];
                        c.__webglColorRenderbuffer[n] = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, c.__webglColorRenderbuffer[n]);
                        const a = s.convert(r.format, r.colorSpace),
                            o = s.convert(r.type),
                            l = S(r.internalFormat, a, o, r.colorSpace, !0 === e.isXRRenderTarget),
                            h = nt(e);
                        t.renderbufferStorageMultisample(t.RENDERBUFFER, h, l, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + n, t.RENDERBUFFER, c.__webglColorRenderbuffer[n])
                    }
                    t.bindRenderbuffer(t.RENDERBUFFER, null), e.depthBuffer && (c.__webglDepthRenderbuffer = t.createRenderbuffer(), Q(c.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(t.FRAMEBUFFER, null)
                }
            }
            if (u) {
                n.bindTexture(t.TEXTURE_CUBE_MAP, h.__webglTexture), Y(t.TEXTURE_CUBE_MAP, l, p);
                for (let n = 0; n < 6; n++)
                    if (o && l.mipmaps && l.mipmaps.length > 0)
                        for (let i = 0; i < l.mipmaps.length; i++) J(c.__webglFramebuffer[n][i], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n, i);
                    else J(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                _(l, p) && w(t.TEXTURE_CUBE_MAP), n.unbindTexture()
            } else if (d) {
                const r = e.texture;
                for (let s = 0, a = r.length; s < a; s++) {
                    const a = r[s],
                        o = i.get(a);
                    n.bindTexture(t.TEXTURE_2D, o.__webglTexture), Y(t.TEXTURE_2D, a, p), J(c.__webglFramebuffer, e, a, t.COLOR_ATTACHMENT0 + s, t.TEXTURE_2D, 0), _(a, p) && w(t.TEXTURE_2D)
                }
                n.unbindTexture()
            } else {
                let i = t.TEXTURE_2D;
                if ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) && (o ? i = e.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(i, h.__webglTexture), Y(i, l, p), o && l.mipmaps && l.mipmaps.length > 0)
                    for (let n = 0; n < l.mipmaps.length; n++) J(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, i, n);
                else J(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i, 0);
                _(l, p) && w(i), n.unbindTexture()
            }
            e.depthBuffer && tt(e)
        }, this.updateRenderTargetMipmap = function (e) {
            const r = x(e) || o,
                s = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
            for (let a = 0, o = s.length; a < o; a++) {
                const o = s[a];
                if (_(o, r)) {
                    const r = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
                        s = i.get(o).__webglTexture;
                    n.bindTexture(r, s), w(r), n.unbindTexture()
                }
            }
        }, this.updateMultisampleRenderTarget = function (e) {
            if (o && e.samples > 0 && !1 === rt(e)) {
                const r = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture],
                    s = e.width,
                    a = e.height;
                let o = t.COLOR_BUFFER_BIT;
                const l = [],
                    c = e.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
                    h = i.get(e),
                    u = !0 === e.isWebGLMultipleRenderTargets;
                if (u)
                    for (let e = 0; e < r.length; e++) n.bindFramebuffer(t.FRAMEBUFFER, h.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, null), n.bindFramebuffer(t.FRAMEBUFFER, h.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, null, 0);
                n.bindFramebuffer(t.READ_FRAMEBUFFER, h.__webglMultisampledFramebuffer), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, h.__webglFramebuffer);
                for (let n = 0; n < r.length; n++) {
                    l.push(t.COLOR_ATTACHMENT0 + n), e.depthBuffer && l.push(c);
                    const d = void 0 !== h.__ignoreDepthValues && h.__ignoreDepthValues;
                    if (!1 === d && (e.depthBuffer && (o |= t.DEPTH_BUFFER_BIT), e.stencilBuffer && (o |= t.STENCIL_BUFFER_BIT)), u && t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, h.__webglColorRenderbuffer[n]), !0 === d && (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [c]), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [c])), u) {
                        const e = i.get(r[n]).__webglTexture;
                        t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0)
                    }
                    t.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, t.NEAREST), p && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, l)
                }
                if (n.bindFramebuffer(t.READ_FRAMEBUFFER, null), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), u)
                    for (let e = 0; e < r.length; e++) {
                        n.bindFramebuffer(t.FRAMEBUFFER, h.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.RENDERBUFFER, h.__webglColorRenderbuffer[e]);
                        const s = i.get(r[e]).__webglTexture;
                        n.bindFramebuffer(t.FRAMEBUFFER, h.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e, t.TEXTURE_2D, s, 0)
                    }
                n.bindFramebuffer(t.DRAW_FRAMEBUFFER, h.__webglMultisampledFramebuffer)
            }
        }, this.setupDepthRenderbuffer = tt, this.setupFrameBufferTexture = J, this.useMultisampledRTT = rt
    }

    function Ms(t, e, n) {
        const i = n.isWebGL2;
        return {
            convert: function (n, r = "") {
                let s;
                if (n === R) return t.UNSIGNED_BYTE;
                if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
                if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
                if (1010 === n) return t.BYTE;
                if (1011 === n) return t.SHORT;
                if (1012 === n) return t.UNSIGNED_SHORT;
                if (1013 === n) return t.INT;
                if (n === P) return t.UNSIGNED_INT;
                if (n === L) return t.FLOAT;
                if (n === O) return i ? t.HALF_FLOAT : (s = e.get("OES_texture_half_float"), null !== s ? s.HALF_FLOAT_OES : null);
                if (1021 === n) return t.ALPHA;
                if (n === I) return t.RGBA;
                if (n === k) return t.LUMINANCE;
                if (1025 === n) return t.LUMINANCE_ALPHA;
                if (n === N) return t.DEPTH_COMPONENT;
                if (n === U) return t.DEPTH_STENCIL;
                if (1035 === n) return s = e.get("EXT_sRGB"), null !== s ? s.SRGB_ALPHA_EXT : null;
                if (n === z) return t.RED;
                if (1029 === n) return t.RED_INTEGER;
                if (n === F) return t.RG;
                if (1031 === n) return t.RG_INTEGER;
                if (1033 === n) return t.RGBA_INTEGER;
                if (33776 === n || 33777 === n || 33778 === n || 33779 === n)
                    if (r === V) {
                        if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === s) return null;
                        if (33776 === n) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                        if (33777 === n) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                        if (33778 === n) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                        if (33779 === n) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                    } else {
                        if (s = e.get("WEBGL_compressed_texture_s3tc"), null === s) return null;
                        if (33776 === n) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (33777 === n) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (33778 === n) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (33779 === n) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    } if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
                        if (s = e.get("WEBGL_compressed_texture_pvrtc"), null === s) return null;
                        if (35840 === n) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === n) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === n) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === n) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                if (36196 === n) return s = e.get("WEBGL_compressed_texture_etc1"), null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
                if (37492 === n || 37496 === n) {
                    if (s = e.get("WEBGL_compressed_texture_etc"), null === s) return null;
                    if (37492 === n) return r === V ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                    if (37496 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
                }
                if (37808 === n || 37809 === n || 37810 === n || 37811 === n || 37812 === n || 37813 === n || 37814 === n || 37815 === n || 37816 === n || 37817 === n || 37818 === n || 37819 === n || 37820 === n || 37821 === n) {
                    if (s = e.get("WEBGL_compressed_texture_astc"), null === s) return null;
                    if (37808 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    if (37809 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                    if (37810 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                    if (37811 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                    if (37812 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                    if (37813 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                    if (37814 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                    if (37815 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                    if (37816 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                    if (37817 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                    if (37818 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                    if (37819 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                    if (37820 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                    if (37821 === n) return r === V ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
                }
                if (36492 === n) {
                    if (s = e.get("EXT_texture_compression_bptc"), null === s) return null;
                    if (36492 === n) return r === V ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
                }
                if (36283 === n || 36284 === n || 36285 === n || 36286 === n) {
                    if (s = e.get("EXT_texture_compression_rgtc"), null === s) return null;
                    if (36492 === n) return s.COMPRESSED_RED_RGTC1_EXT;
                    if (36284 === n) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                    if (36285 === n) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                    if (36286 === n) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                }
                return n === D ? i ? t.UNSIGNED_INT_24_8 : (s = e.get("WEBGL_depth_texture"), null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== t[n] ? t[n] : null
            }
        }
    }
    class Es extends Vn {
        constructor(t = []) {
            super(), this.isArrayCamera = !0, this.cameras = t
        }
    }
    class Ts extends ke {
        constructor() {
            super(), this.isGroup = !0, this.type = "Group"
        }
    }
    const Cs = {
        type: "move"
    };
    class As {
        constructor() {
            this._targetRay = null, this._grip = null, this._hand = null
        }
        getHandSpace() {
            return null === this._hand && (this._hand = new Ts, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                pinching: !1
            }), this._hand
        }
        getTargetRaySpace() {
            return null === this._targetRay && (this._targetRay = new Ts, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new It, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new It), this._targetRay
        }
        getGripSpace() {
            return null === this._grip && (this._grip = new Ts, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new It, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new It), this._grip
        }
        dispatchEvent(t) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
        }
        connect(t) {
            if (t && t.hand) {
                const e = this._hand;
                if (e)
                    for (const n of t.hand.values()) this._getHandJoint(e, n)
            }
            return this.dispatchEvent({
                type: "connected",
                data: t
            }), this
        }
        disconnect(t) {
            return this.dispatchEvent({
                type: "disconnected",
                data: t
            }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
        }
        update(t, e, n) {
            let i = null,
                r = null,
                s = null;
            const a = this._targetRay,
                o = this._grip,
                l = this._hand;
            if (t && "visible-blurred" !== e.session.visibilityState) {
                if (l && t.hand) {
                    s = !0;
                    for (const i of t.hand.values()) {
                        const t = e.getJointPose(i, n),
                            r = this._getHandJoint(l, i);
                        null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.matrixWorldNeedsUpdate = !0, r.jointRadius = t.radius), r.visible = null !== t
                    }
                    const i = l.joints["index-finger-tip"],
                        r = l.joints["thumb-tip"],
                        a = i.position.distanceTo(r.position),
                        o = .02,
                        c = .005;
                    l.inputState.pinching && a > o + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                        type: "pinchend",
                        handedness: t.handedness,
                        target: this
                    })) : !l.inputState.pinching && a <= o - c && (l.inputState.pinching = !0, this.dispatchEvent({
                        type: "pinchstart",
                        handedness: t.handedness,
                        target: this
                    }))
                } else null !== o && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                null !== a && (i = e.getPose(t.targetRaySpace, n), null === i && null !== r && (i = r), null !== i && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(Cs)))
            }
            return null !== a && (a.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== s), this
        }
        _getHandJoint(t, e) {
            if (void 0 === t.joints[e.jointName]) {
                const n = new Ts;
                n.matrixAutoUpdate = !1, n.visible = !1, t.joints[e.jointName] = n, t.add(n)
            }
            return t.joints[e.jointName]
        }
    }
    class Rs extends Ct {
        constructor(t, e, n, i, r, s, a, o, l, c) {
            if ((c = void 0 !== c ? c : N) !== N && c !== U) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === n && c === N && (n = P), void 0 === n && c === U && (n = D), super(null, i, r, s, a, o, c, n, l), this.isDepthTexture = !0, this.image = {
                width: t,
                height: e
            }, this.magFilter = void 0 !== a ? a : T, this.minFilter = void 0 !== o ? o : T, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
        }
        copy(t) {
            return super.copy(t), this.compareFunction = t.compareFunction, this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return null !== this.compareFunction && (e.compareFunction = this.compareFunction), e
        }
    }
    class Ps extends W {
        constructor(t, e) {
            super();
            const n = this;
            let i = null,
                r = 1,
                s = null,
                a = "local-floor",
                o = 1,
                l = null,
                c = null,
                h = null,
                u = null,
                d = null,
                p = null;
            const f = e.getContextAttributes();
            let m = null,
                g = null;
            const v = [],
                y = [],
                b = new Vn;
            b.layers.enable(1), b.viewport = new At;
            const x = new Vn;
            x.layers.enable(2), x.viewport = new At;
            const _ = [b, x],
                w = new Es;
            w.layers.enable(1), w.layers.enable(2);
            let S = null,
                M = null;

            function E(t) {
                const e = y.indexOf(t.inputSource);
                if (-1 === e) return;
                const n = v[e];
                void 0 !== n && (n.update(t.inputSource, t.frame, l || s), n.dispatchEvent({
                    type: t.type,
                    data: t.inputSource
                }))
            }

            function T() {
                i.removeEventListener("select", E), i.removeEventListener("selectstart", E), i.removeEventListener("selectend", E), i.removeEventListener("squeeze", E), i.removeEventListener("squeezestart", E), i.removeEventListener("squeezeend", E), i.removeEventListener("end", T), i.removeEventListener("inputsourceschange", C);
                for (let t = 0; t < v.length; t++) {
                    const e = y[t];
                    null !== e && (y[t] = null, v[t].disconnect(e))
                }
                S = null, M = null, t.setRenderTarget(m), d = null, u = null, h = null, i = null, g = null, z.stop(), n.isPresenting = !1, n.dispatchEvent({
                    type: "sessionend"
                })
            }

            function C(t) {
                for (let e = 0; e < t.removed.length; e++) {
                    const n = t.removed[e],
                        i = y.indexOf(n);
                    i >= 0 && (y[i] = null, v[i].disconnect(n))
                }
                for (let e = 0; e < t.added.length; e++) {
                    const n = t.added[e];
                    let i = y.indexOf(n);
                    if (-1 === i) {
                        for (let t = 0; t < v.length; t++) {
                            if (t >= y.length) {
                                y.push(n), i = t;
                                break
                            }
                            if (null === y[t]) {
                                y[t] = n, i = t;
                                break
                            }
                        }
                        if (-1 === i) break
                    }
                    const r = v[i];
                    r && r.connect(n)
                }
            }
            this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (t) {
                let e = v[t];
                return void 0 === e && (e = new As, v[t] = e), e.getTargetRaySpace()
            }, this.getControllerGrip = function (t) {
                let e = v[t];
                return void 0 === e && (e = new As, v[t] = e), e.getGripSpace()
            }, this.getHand = function (t) {
                let e = v[t];
                return void 0 === e && (e = new As, v[t] = e), e.getHandSpace()
            }, this.setFramebufferScaleFactor = function (t) {
                r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
            }, this.setReferenceSpaceType = function (t) {
                a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
            }, this.getReferenceSpace = function () {
                return l || s
            }, this.setReferenceSpace = function (t) {
                l = t
            }, this.getBaseLayer = function () {
                return null !== u ? u : d
            }, this.getBinding = function () {
                return h
            }, this.getFrame = function () {
                return p
            }, this.getSession = function () {
                return i
            }, this.setSession = async function (c) {
                if (i = c, null !== i) {
                    if (m = t.getRenderTarget(), i.addEventListener("select", E), i.addEventListener("selectstart", E), i.addEventListener("selectend", E), i.addEventListener("squeeze", E), i.addEventListener("squeezestart", E), i.addEventListener("squeezeend", E), i.addEventListener("end", T), i.addEventListener("inputsourceschange", C), !0 !== f.xrCompatible && await e.makeXRCompatible(), void 0 === i.renderState.layers || !1 === t.capabilities.isWebGL2) {
                        const n = {
                            antialias: void 0 !== i.renderState.layers || f.antialias,
                            alpha: !0,
                            depth: f.depth,
                            stencil: f.stencil,
                            framebufferScaleFactor: r
                        };
                        d = new XRWebGLLayer(i, e, n), i.updateRenderState({
                            baseLayer: d
                        }), g = new Pt(d.framebufferWidth, d.framebufferHeight, {
                            format: I,
                            type: R,
                            colorSpace: t.outputColorSpace,
                            stencilBuffer: f.stencil
                        })
                    } else {
                        let n = null,
                            s = null,
                            a = null;
                        f.depth && (a = f.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, n = f.stencil ? U : N, s = f.stencil ? D : P);
                        const o = {
                            colorFormat: e.RGBA8,
                            depthFormat: a,
                            scaleFactor: r
                        };
                        h = new XRWebGLBinding(i, e), u = h.createProjectionLayer(o), i.updateRenderState({
                            layers: [u]
                        }), g = new Pt(u.textureWidth, u.textureHeight, {
                            format: I,
                            type: R,
                            depthTexture: new Rs(u.textureWidth, u.textureHeight, s, void 0, void 0, void 0, void 0, void 0, void 0, n),
                            stencilBuffer: f.stencil,
                            colorSpace: t.outputColorSpace,
                            samples: f.antialias ? 4 : 0
                        });
                        t.properties.get(g).__ignoreDepthValues = u.ignoreDepthValues
                    }
                    g.isXRRenderTarget = !0, this.setFoveation(o), l = null, s = await i.requestReferenceSpace(a), z.setContext(i), z.start(), n.isPresenting = !0, n.dispatchEvent({
                        type: "sessionstart"
                    })
                }
            }, this.getEnvironmentBlendMode = function () {
                if (null !== i) return i.environmentBlendMode
            };
            const A = new It,
                L = new It;

            function O(t, e) {
                null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
            }
            this.updateCamera = function (t) {
                if (null === i) return;
                w.near = x.near = b.near = t.near, w.far = x.far = b.far = t.far, S === w.near && M === w.far || (i.updateRenderState({
                    depthNear: w.near,
                    depthFar: w.far
                }), S = w.near, M = w.far);
                const e = t.parent,
                    n = w.cameras;
                O(w, e);
                for (let t = 0; t < n.length; t++) O(n[t], e);
                2 === n.length ? function (t, e, n) {
                    A.setFromMatrixPosition(e.matrixWorld), L.setFromMatrixPosition(n.matrixWorld);
                    const i = A.distanceTo(L),
                        r = e.projectionMatrix.elements,
                        s = n.projectionMatrix.elements,
                        a = r[14] / (r[10] - 1),
                        o = r[14] / (r[10] + 1),
                        l = (r[9] + 1) / r[5],
                        c = (r[9] - 1) / r[5],
                        h = (r[8] - 1) / r[0],
                        u = (s[8] + 1) / s[0],
                        d = a * h,
                        p = a * u,
                        f = i / (-h + u),
                        m = f * -h;
                    e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    const g = a + f,
                        v = o + f,
                        y = d - m,
                        b = p + (i - m),
                        x = l * o / v * g,
                        _ = c * o / v * g;
                    t.projectionMatrix.makePerspective(y, b, x, _, g, v), t.projectionMatrixInverse.copy(t.projectionMatrix).invert()
                }(w, b, x) : w.projectionMatrix.copy(b.projectionMatrix),
                    function (t, e, n) {
                        null === n ? t.matrix.copy(e.matrixWorld) : (t.matrix.copy(n.matrixWorld), t.matrix.invert(), t.matrix.multiply(e.matrixWorld));
                        t.matrix.decompose(t.position, t.quaternion, t.scale), t.updateMatrixWorld(!0);
                        const i = t.children;
                        for (let t = 0, e = i.length; t < e; t++) i[t].updateMatrixWorld(!0);
                        t.projectionMatrix.copy(e.projectionMatrix), t.projectionMatrixInverse.copy(e.projectionMatrixInverse), t.isPerspectiveCamera && (t.fov = 2 * K * Math.atan(1 / t.projectionMatrix.elements[5]), t.zoom = 1)
                    }(t, w, e)
            }, this.getCamera = function () {
                return w
            }, this.getFoveation = function () {
                if (null !== u || null !== d) return o
            }, this.setFoveation = function (t) {
                o = t, null !== u && (u.fixedFoveation = t), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t)
            };
            let k = null;
            const z = new ei;
            z.setAnimationLoop((function (e, i) {
                if (c = i.getViewerPose(l || s), p = i, null !== c) {
                    const e = c.views;
                    null !== d && (t.setRenderTargetFramebuffer(g, d.framebuffer), t.setRenderTarget(g));
                    let n = !1;
                    e.length !== w.cameras.length && (w.cameras.length = 0, n = !0);
                    for (let i = 0; i < e.length; i++) {
                        const r = e[i];
                        let s = null;
                        if (null !== d) s = d.getViewport(r);
                        else {
                            const e = h.getViewSubImage(u, r);
                            s = e.viewport, 0 === i && (t.setRenderTargetTextures(g, e.colorTexture, u.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(g))
                        }
                        let a = _[i];
                        void 0 === a && (a = new Vn, a.layers.enable(i), a.viewport = new At, _[i] = a), a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.quaternion, a.scale), a.projectionMatrix.fromArray(r.projectionMatrix), a.projectionMatrixInverse.copy(a.projectionMatrix).invert(), a.viewport.set(s.x, s.y, s.width, s.height), 0 === i && (w.matrix.copy(a.matrix), w.matrix.decompose(w.position, w.quaternion, w.scale)), !0 === n && w.cameras.push(a)
                    }
                }
                for (let t = 0; t < v.length; t++) {
                    const e = y[t],
                        n = v[t];
                    null !== e && void 0 !== n && n.update(e, i, l || s)
                }
                k && k(e, i), i.detectedPlanes && n.dispatchEvent({
                    type: "planesdetected",
                    data: i
                }), p = null
            })), this.setAnimationLoop = function (t) {
                k = t
            }, this.dispose = function () { }
        }
    }

    function Ls(t, e) {
        function n(t, e) {
            !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix)
        }

        function i(i, r) {
            i.opacity.value = r.opacity, r.color && i.diffuse.value.copy(r.color), r.emissive && i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (i.map.value = r.map, n(r.map, i.mapTransform)), r.alphaMap && (i.alphaMap.value = r.alphaMap, n(r.alphaMap, i.alphaMapTransform)), r.bumpMap && (i.bumpMap.value = r.bumpMap, n(r.bumpMap, i.bumpMapTransform), i.bumpScale.value = r.bumpScale, r.side === o && (i.bumpScale.value *= -1)), r.normalMap && (i.normalMap.value = r.normalMap, n(r.normalMap, i.normalMapTransform), i.normalScale.value.copy(r.normalScale), r.side === o && i.normalScale.value.negate()), r.displacementMap && (i.displacementMap.value = r.displacementMap, n(r.displacementMap, i.displacementMapTransform), i.displacementScale.value = r.displacementScale, i.displacementBias.value = r.displacementBias), r.emissiveMap && (i.emissiveMap.value = r.emissiveMap, n(r.emissiveMap, i.emissiveMapTransform)), r.specularMap && (i.specularMap.value = r.specularMap, n(r.specularMap, i.specularMapTransform)), r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
            const s = e.get(r).envMap;
            if (s && (i.envMap.value = s, i.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1, i.reflectivity.value = r.reflectivity, i.ior.value = r.ior, i.refractionRatio.value = r.refractionRatio), r.lightMap) {
                i.lightMap.value = r.lightMap;
                const e = !0 === t._useLegacyLights ? Math.PI : 1;
                i.lightMapIntensity.value = r.lightMapIntensity * e, n(r.lightMap, i.lightMapTransform)
            }
            r.aoMap && (i.aoMap.value = r.aoMap, i.aoMapIntensity.value = r.aoMapIntensity, n(r.aoMap, i.aoMapTransform))
        }
        return {
            refreshFogUniforms: function (e, n) {
                n.color.getRGB(e.fogColor.value, $n(t)), n.isFog ? (e.fogNear.value = n.near, e.fogFar.value = n.far) : n.isFogExp2 && (e.fogDensity.value = n.density)
            },
            refreshMaterialUniforms: function (t, r, s, a, l) {
                r.isMeshBasicMaterial || r.isMeshLambertMaterial ? i(t, r) : r.isMeshToonMaterial ? (i(t, r), function (t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap)
                }(t, r)) : r.isMeshPhongMaterial ? (i(t, r), function (t, e) {
                    t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4)
                }(t, r)) : r.isMeshStandardMaterial ? (i(t, r), function (t, i) {
                    t.metalness.value = i.metalness, i.metalnessMap && (t.metalnessMap.value = i.metalnessMap, n(i.metalnessMap, t.metalnessMapTransform));
                    t.roughness.value = i.roughness, i.roughnessMap && (t.roughnessMap.value = i.roughnessMap, n(i.roughnessMap, t.roughnessMapTransform));
                    e.get(i).envMap && (t.envMapIntensity.value = i.envMapIntensity)
                }(t, r), r.isMeshPhysicalMaterial && function (t, e, i) {
                    t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap, n(e.sheenColorMap, t.sheenColorMapTransform)), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap, n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform)));
                    e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap, n(e.clearcoatMap, t.clearcoatMapTransform)), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap, n(e.clearcoatRoughnessMap, t.clearcoatRoughnessMapTransform)), e.clearcoatNormalMap && (t.clearcoatNormalMap.value = e.clearcoatNormalMap, n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform), t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), e.side === o && t.clearcoatNormalScale.value.negate()));
                    e.iridescence > 0 && (t.iridescence.value = e.iridescence, t.iridescenceIOR.value = e.iridescenceIOR, t.iridescenceThicknessMinimum.value = e.iridescenceThicknessRange[0], t.iridescenceThicknessMaximum.value = e.iridescenceThicknessRange[1], e.iridescenceMap && (t.iridescenceMap.value = e.iridescenceMap, n(e.iridescenceMap, t.iridescenceMapTransform)), e.iridescenceThicknessMap && (t.iridescenceThicknessMap.value = e.iridescenceThicknessMap, n(e.iridescenceThicknessMap, t.iridescenceThicknessMapTransform)));
                    e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = i.texture, t.transmissionSamplerSize.value.set(i.width, i.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap, n(e.transmissionMap, t.transmissionMapTransform)), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap, n(e.thicknessMap, t.thicknessMapTransform)), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor));
                    e.anisotropy > 0 && (t.anisotropyVector.value.set(e.anisotropy * Math.cos(e.anisotropyRotation), e.anisotropy * Math.sin(e.anisotropyRotation)), e.anisotropyMap && (t.anisotropyMap.value = e.anisotropyMap, n(e.anisotropyMap, t.anisotropyMapTransform)));
                    t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularColorMap && (t.specularColorMap.value = e.specularColorMap, n(e.specularColorMap, t.specularColorMapTransform));
                    e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap, n(e.specularIntensityMap, t.specularIntensityMapTransform))
                }(t, r, l)) : r.isMeshMatcapMaterial ? (i(t, r), function (t, e) {
                    e.matcap && (t.matcap.value = e.matcap)
                }(t, r)) : r.isMeshDepthMaterial ? i(t, r) : r.isMeshDistanceMaterial ? (i(t, r), function (t, n) {
                    const i = e.get(n).light;
                    t.referencePosition.value.setFromMatrixPosition(i.matrixWorld), t.nearDistance.value = i.shadow.camera.near, t.farDistance.value = i.shadow.camera.far
                }(t, r)) : r.isMeshNormalMaterial ? i(t, r) : r.isLineBasicMaterial ? (function (t, e) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, e.map && (t.map.value = e.map, n(e.map, t.mapTransform))
                }(t, r), r.isLineDashedMaterial && function (t, e) {
                    t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                }(t, r)) : r.isPointsMaterial ? function (t, e, i, r) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * i, t.scale.value = .5 * r, e.map && (t.map.value = e.map, n(e.map, t.uvTransform));
                    e.alphaMap && (t.alphaMap.value = e.alphaMap, n(e.alphaMap, t.alphaMapTransform));
                    e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                }(t, r, s, a) : r.isSpriteMaterial ? function (t, e) {
                    t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map, n(e.map, t.mapTransform));
                    e.alphaMap && (t.alphaMap.value = e.alphaMap, n(e.alphaMap, t.alphaMapTransform));
                    e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest)
                }(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color), t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
            }
        }
    }

    function Os(t, e, n, i) {
        let r = {},
            s = {},
            a = [];
        const o = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;

        function l(t, e, n) {
            const i = t.value;
            if (void 0 === n[e]) {
                if ("number" == typeof i) n[e] = i;
                else {
                    const t = Array.isArray(i) ? i : [i],
                        r = [];
                    for (let e = 0; e < t.length; e++) r.push(t[e].clone());
                    n[e] = r
                }
                return !0
            }
            if ("number" == typeof i) {
                if (n[e] !== i) return n[e] = i, !0
            } else {
                const t = Array.isArray(n[e]) ? n[e] : [n[e]],
                    r = Array.isArray(i) ? i : [i];
                for (let e = 0; e < t.length; e++) {
                    const n = t[e];
                    if (!1 === n.equals(r[e])) return n.copy(r[e]), !0
                }
            }
            return !1
        }

        function c(t) {
            const e = {
                boundary: 0,
                storage: 0
            };
            return "number" == typeof t ? (e.boundary = 4, e.storage = 4) : t.isVector2 ? (e.boundary = 8, e.storage = 8) : t.isVector3 || t.isColor ? (e.boundary = 16, e.storage = 12) : t.isVector4 ? (e.boundary = 16, e.storage = 16) : t.isMatrix3 ? (e.boundary = 48, e.storage = 48) : t.isMatrix4 ? (e.boundary = 64, e.storage = 64) : t.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t), e
        }

        function h(e) {
            const n = e.target;
            n.removeEventListener("dispose", h);
            const i = a.indexOf(n.__bindingPointIndex);
            a.splice(i, 1), t.deleteBuffer(r[n.id]), delete r[n.id], delete s[n.id]
        }
        return {
            bind: function (t, e) {
                const n = e.program;
                i.uniformBlockBinding(t, n)
            },
            update: function (n, u) {
                let d = r[n.id];
                void 0 === d && (! function (t) {
                    const e = t.uniforms;
                    let n = 0;
                    let i = 0;
                    for (let t = 0, r = e.length; t < r; t++) {
                        const r = e[t],
                            s = {
                                boundary: 0,
                                storage: 0
                            },
                            a = Array.isArray(r.value) ? r.value : [r.value];
                        for (let t = 0, e = a.length; t < e; t++) {
                            const e = c(a[t]);
                            s.boundary += e.boundary, s.storage += e.storage
                        }
                        if (r.__data = new Float32Array(s.storage / Float32Array.BYTES_PER_ELEMENT), r.__offset = n, t > 0) {
                            i = n % 16;
                            const t = 16 - i;
                            0 !== i && t - s.boundary < 0 && (n += 16 - i, r.__offset = n)
                        }
                        n += s.storage
                    }
                    i = n % 16, i > 0 && (n += 16 - i);
                    t.__size = n, t.__cache = {}
                }(n), d = function (e) {
                    const n = function () {
                        for (let t = 0; t < o; t++)
                            if (-1 === a.indexOf(t)) return a.push(t), t;
                        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                    }();
                    e.__bindingPointIndex = n;
                    const i = t.createBuffer(),
                        r = e.__size,
                        s = e.usage;
                    return t.bindBuffer(t.UNIFORM_BUFFER, i), t.bufferData(t.UNIFORM_BUFFER, r, s), t.bindBuffer(t.UNIFORM_BUFFER, null), t.bindBufferBase(t.UNIFORM_BUFFER, n, i), i
                }(n), r[n.id] = d, n.addEventListener("dispose", h));
                const p = u.program;
                i.updateUBOMapping(n, p);
                const f = e.render.frame;
                s[n.id] !== f && (! function (e) {
                    const n = r[e.id],
                        i = e.uniforms,
                        s = e.__cache;
                    t.bindBuffer(t.UNIFORM_BUFFER, n);
                    for (let e = 0, n = i.length; e < n; e++) {
                        const n = i[e];
                        if (!0 === l(n, e, s)) {
                            const e = n.__offset,
                                i = Array.isArray(n.value) ? n.value : [n.value];
                            let r = 0;
                            for (let s = 0; s < i.length; s++) {
                                const a = i[s],
                                    o = c(a);
                                "number" == typeof a ? (n.__data[0] = a, t.bufferSubData(t.UNIFORM_BUFFER, e + r, n.__data)) : a.isMatrix3 ? (n.__data[0] = a.elements[0], n.__data[1] = a.elements[1], n.__data[2] = a.elements[2], n.__data[3] = a.elements[0], n.__data[4] = a.elements[3], n.__data[5] = a.elements[4], n.__data[6] = a.elements[5], n.__data[7] = a.elements[0], n.__data[8] = a.elements[6], n.__data[9] = a.elements[7], n.__data[10] = a.elements[8], n.__data[11] = a.elements[0]) : (a.toArray(n.__data, r), r += o.storage / Float32Array.BYTES_PER_ELEMENT)
                            }
                            t.bufferSubData(t.UNIFORM_BUFFER, e, n.__data)
                        }
                    }
                    t.bindBuffer(t.UNIFORM_BUFFER, null)
                }(n), s[n.id] = f)
            },
            dispose: function () {
                for (const e in r) t.deleteBuffer(r[e]);
                a = [], r = {}, s = {}
            }
        }
    }

    function Ds() {
        const t = ut("canvas");
        return t.style.display = "block", t
    }
    class Is {
        constructor(t = {}) {
            const {
                canvas: e = Ds(),
                context: n = null,
                depth: r = !0,
                stencil: s = !0,
                alpha: c = !1,
                antialias: h = !1,
                premultipliedAlpha: u = !0,
                preserveDrawingBuffer: d = !1,
                powerPreference: p = "default",
                failIfMajorPerformanceCaveat: f = !1
            } = t;
            let m;
            this.isWebGLRenderer = !0, m = null !== n ? n.getContextAttributes().alpha : c;
            const g = new Uint32Array(4),
                v = new Int32Array(4);
            let y = null,
                x = null;
            const _ = [],
                w = [];
            this.domElement = e, this.debug = {
                checkShaderErrors: !0,
                onShaderError: null
            }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputColorSpace = V, this._useLegacyLights = !1, this.toneMapping = b, this.toneMappingExposure = 1;
            const S = this;
            let M = !1,
                E = 0,
                T = 0,
                C = null,
                k = -1,
                N = null;
            const U = new At,
                z = new At;
            let F = null;
            const $ = new tn(0);
            let B = 0,
                H = e.width,
                j = e.height,
                W = 1,
                q = null,
                X = null;
            const Y = new At(0, 0, H, j),
                K = new At(0, 0, H, j);
            let Z = !1;
            const J = new ti;
            let Q = !1,
                tt = !1,
                et = null;
            const nt = new he,
                rt = new ot,
                st = new It,
                at = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };

            function lt() {
                return null === C ? W : 1
            }
            let ct, ht, ut, dt, pt, ft, mt, gt, vt, yt, bt, xt, _t, wt, St, Mt, Et, Tt, Ct, Rt, Lt, Ot, Dt, kt, Nt = n;

            function Ut(t, n) {
                for (let i = 0; i < t.length; i++) {
                    const r = t[i],
                        s = e.getContext(r, n);
                    if (null !== s) return s
                }
                return null
            }
            try {
                const t = {
                    alpha: !0,
                    depth: r,
                    stencil: s,
                    antialias: h,
                    premultipliedAlpha: u,
                    preserveDrawingBuffer: d,
                    powerPreference: p,
                    failIfMajorPerformanceCaveat: f
                };
                if ("setAttribute" in e && e.setAttribute("data-engine", "three.js r" + i), e.addEventListener("webglcontextlost", $t, !1), e.addEventListener("webglcontextrestored", Bt, !1), e.addEventListener("webglcontextcreationerror", Ht, !1), null === Nt) {
                    const e = ["webgl2", "webgl", "experimental-webgl"];
                    if (!0 === S.isWebGL1Renderer && e.shift(), Nt = Ut(e, t), null === Nt) throw Ut(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                }
                "undefined" != typeof WebGLRenderingContext && Nt instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), void 0 === Nt.getShaderPrecisionFormat && (Nt.getShaderPrecisionFormat = function () {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                })
            } catch (t) {
                throw console.error("THREE.WebGLRenderer: " + t.message), t
            }

            function zt() {
                ct = new Ri(Nt), ht = new ui(Nt, ct, t), ct.init(ht), Ot = new Ms(Nt, ct, ht), ut = new ws(Nt, ct, ht), dt = new Oi(Nt), pt = new ls, ft = new Ss(Nt, ct, ut, pt, ht, Ot, dt), mt = new pi(S), gt = new Ai(S), vt = new ni(Nt, ht), Dt = new ci(Nt, ct, vt, ht), yt = new Pi(Nt, vt, dt, Dt), bt = new Ni(Nt, yt, vt, dt), Ct = new ki(Nt, ht, ft), Mt = new di(pt), xt = new os(S, mt, gt, ct, ht, Dt, Mt), _t = new Ls(S, pt), wt = new ds, St = new ys(ct, ht), Tt = new li(S, mt, gt, ut, bt, m, u), Et = new _s(S, bt, ht), kt = new Os(Nt, dt, ht, ut), Rt = new hi(Nt, ct, dt, ht), Lt = new Li(Nt, ct, dt, ht), dt.programs = xt.programs, S.capabilities = ht, S.extensions = ct, S.properties = pt, S.renderLists = wt, S.shadowMap = Et, S.state = ut, S.info = dt
            }
            zt();
            const Ft = new Ps(S, Nt);

            function $t(t) {
                t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), M = !0
            }

            function Bt() {
                console.log("THREE.WebGLRenderer: Context Restored."), M = !1;
                const t = dt.autoReset,
                    e = Et.enabled,
                    n = Et.autoUpdate,
                    i = Et.needsUpdate,
                    r = Et.type;
                zt(), dt.autoReset = t, Et.enabled = e, Et.autoUpdate = n, Et.needsUpdate = i, Et.type = r
            }

            function Ht(t) {
                console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", t.statusMessage)
            }

            function jt(t) {
                const e = t.target;
                e.removeEventListener("dispose", jt),
                    function (t) {
                        (function (t) {
                            const e = pt.get(t).programs;
                            void 0 !== e && (e.forEach((function (t) {
                                xt.releaseProgram(t)
                            })), t.isShaderMaterial && xt.releaseShaderCache(t))
                        })(t), pt.remove(t)
                    }(e)
            }
            this.xr = Ft, this.getContext = function () {
                return Nt
            }, this.getContextAttributes = function () {
                return Nt.getContextAttributes()
            }, this.forceContextLoss = function () {
                const t = ct.get("WEBGL_lose_context");
                t && t.loseContext()
            }, this.forceContextRestore = function () {
                const t = ct.get("WEBGL_lose_context");
                t && t.restoreContext()
            }, this.getPixelRatio = function () {
                return W
            }, this.setPixelRatio = function (t) {
                void 0 !== t && (W = t, this.setSize(H, j, !1))
            }, this.getSize = function (t) {
                return t.set(H, j)
            }, this.setSize = function (t, n, i = !0) {
                Ft.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (H = t, j = n, e.width = Math.floor(t * W), e.height = Math.floor(n * W), !0 === i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
            }, this.getDrawingBufferSize = function (t) {
                return t.set(H * W, j * W).floor()
            }, this.setDrawingBufferSize = function (t, n, i) {
                H = t, j = n, W = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
            }, this.getCurrentViewport = function (t) {
                return t.copy(U)
            }, this.getViewport = function (t) {
                return t.copy(Y)
            }, this.setViewport = function (t, e, n, i) {
                t.isVector4 ? Y.set(t.x, t.y, t.z, t.w) : Y.set(t, e, n, i), ut.viewport(U.copy(Y).multiplyScalar(W).floor())
            }, this.getScissor = function (t) {
                return t.copy(K)
            }, this.setScissor = function (t, e, n, i) {
                t.isVector4 ? K.set(t.x, t.y, t.z, t.w) : K.set(t, e, n, i), ut.scissor(z.copy(K).multiplyScalar(W).floor())
            }, this.getScissorTest = function () {
                return Z
            }, this.setScissorTest = function (t) {
                ut.setScissorTest(Z = t)
            }, this.setOpaqueSort = function (t) {
                q = t
            }, this.setTransparentSort = function (t) {
                X = t
            }, this.getClearColor = function (t) {
                return t.copy(Tt.getClearColor())
            }, this.setClearColor = function () {
                Tt.setClearColor.apply(Tt, arguments)
            }, this.getClearAlpha = function () {
                return Tt.getClearAlpha()
            }, this.setClearAlpha = function () {
                Tt.setClearAlpha.apply(Tt, arguments)
            }, this.clear = function (t = !0, e = !0, n = !0) {
                let i = 0;
                if (t) {
                    let t = !1;
                    if (null !== C) {
                        const e = C.texture.format;
                        t = 1033 === e || 1031 === e || 1029 === e
                    }
                    if (t) {
                        const t = C.texture.type,
                            e = t === R || t === P || 1012 === t || t === D || 1017 === t || 1018 === t,
                            n = Tt.getClearColor(),
                            i = Tt.getClearAlpha(),
                            r = n.r,
                            s = n.g,
                            a = n.b;
                        e ? (g[0] = r, g[1] = s, g[2] = a, g[3] = i, Nt.clearBufferuiv(Nt.COLOR, 0, g)) : (v[0] = r, v[1] = s, v[2] = a, v[3] = i, Nt.clearBufferiv(Nt.COLOR, 0, v))
                    } else i |= Nt.COLOR_BUFFER_BIT
                }
                e && (i |= Nt.DEPTH_BUFFER_BIT), n && (i |= Nt.STENCIL_BUFFER_BIT), Nt.clear(i)
            }, this.clearColor = function () {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function () {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function () {
                this.clear(!1, !1, !0)
            }, this.dispose = function () {
                e.removeEventListener("webglcontextlost", $t, !1), e.removeEventListener("webglcontextrestored", Bt, !1), e.removeEventListener("webglcontextcreationerror", Ht, !1), wt.dispose(), St.dispose(), pt.dispose(), mt.dispose(), gt.dispose(), bt.dispose(), Dt.dispose(), kt.dispose(), xt.dispose(), Ft.dispose(), Ft.removeEventListener("sessionstart", Gt), Ft.removeEventListener("sessionend", Wt), et && (et.dispose(), et = null), qt.stop()
            }, this.renderBufferDirect = function (t, e, n, i, r, s) {
                null === e && (e = at);
                const a = r.isMesh && r.matrixWorld.determinant() < 0,
                    o = function (t, e, n, i, r) {
                        !0 !== e.isScene && (e = at);
                        ft.resetTextureUnits();
                        const s = e.fog,
                            a = i.isMeshStandardMaterial ? e.environment : null,
                            o = null === C ? S.outputColorSpace : !0 === C.isXRRenderTarget ? C.texture.colorSpace : G,
                            l = (i.isMeshStandardMaterial ? gt : mt).get(i.envMap || a),
                            c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                            h = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0),
                            u = !!n.morphAttributes.position,
                            d = !!n.morphAttributes.normal,
                            p = !!n.morphAttributes.color;
                        let f = b;
                        i.toneMapped && (null !== C && !0 !== C.isXRRenderTarget || (f = S.toneMapping));
                        const m = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                            g = void 0 !== m ? m.length : 0,
                            v = pt.get(i),
                            y = x.state.lights;
                        if (!0 === Q && (!0 === tt || t !== N)) {
                            const e = t === N && i.id === k;
                            Mt.setState(i, t, e)
                        }
                        let _ = !1;
                        i.version === v.__version ? v.needsLights && v.lightsStateVersion !== y.state.version || v.outputColorSpace !== o || r.isInstancedMesh && !1 === v.instancing ? _ = !0 : r.isInstancedMesh || !0 !== v.instancing ? r.isSkinnedMesh && !1 === v.skinning ? _ = !0 : r.isSkinnedMesh || !0 !== v.skinning ? r.isInstancedMesh && !0 === v.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === v.instancingColor && null !== r.instanceColor || v.envMap !== l || !0 === i.fog && v.fog !== s ? _ = !0 : void 0 === v.numClippingPlanes || v.numClippingPlanes === Mt.numPlanes && v.numIntersection === Mt.numIntersection ? (v.vertexAlphas !== c || v.vertexTangents !== h || v.morphTargets !== u || v.morphNormals !== d || v.morphColors !== p || v.toneMapping !== f || !0 === ht.isWebGL2 && v.morphTargetsCount !== g) && (_ = !0) : _ = !0 : _ = !0 : _ = !0 : (_ = !0, v.__version = i.version);
                        let w = v.currentProgram;
                        !0 === _ && (w = Zt(i, e, r));
                        let M = !1,
                            E = !1,
                            T = !1;
                        const A = w.getUniforms(),
                            R = v.uniforms;
                        ut.useProgram(w.program) && (M = !0, E = !0, T = !0);
                        i.id !== k && (k = i.id, E = !0);
                        if (M || N !== t) {
                            if (A.setValue(Nt, "projectionMatrix", t.projectionMatrix), ht.logarithmicDepthBuffer && A.setValue(Nt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), N !== t && (N = t, E = !0, T = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                                const e = A.map.cameraPosition;
                                void 0 !== e && e.setValue(Nt, st.setFromMatrixPosition(t.matrixWorld))
                            } (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && A.setValue(Nt, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && A.setValue(Nt, "viewMatrix", t.matrixWorldInverse)
                        }
                        if (r.isSkinnedMesh) {
                            A.setOptional(Nt, r, "bindMatrix"), A.setOptional(Nt, r, "bindMatrixInverse");
                            const t = r.skeleton;
                            t && (ht.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), A.setValue(Nt, "boneTexture", t.boneTexture, ft), A.setValue(Nt, "boneTextureSize", t.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                        }
                        const P = n.morphAttributes;
                        (void 0 !== P.position || void 0 !== P.normal || void 0 !== P.color && !0 === ht.isWebGL2) && Ct.update(r, n, w);
                        (E || v.receiveShadow !== r.receiveShadow) && (v.receiveShadow = r.receiveShadow, A.setValue(Nt, "receiveShadow", r.receiveShadow));
                        i.isMeshGouraudMaterial && null !== i.envMap && (R.envMap.value = l, R.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1);
                        E && (A.setValue(Nt, "toneMappingExposure", S.toneMappingExposure), v.needsLights && (O = T, (L = R).ambientLightColor.needsUpdate = O, L.lightProbe.needsUpdate = O, L.directionalLights.needsUpdate = O, L.directionalLightShadows.needsUpdate = O, L.pointLights.needsUpdate = O, L.pointLightShadows.needsUpdate = O, L.spotLights.needsUpdate = O, L.spotLightShadows.needsUpdate = O, L.rectAreaLights.needsUpdate = O, L.hemisphereLights.needsUpdate = O), s && !0 === i.fog && _t.refreshFogUniforms(R, s), _t.refreshMaterialUniforms(R, i, W, j, et), $r.upload(Nt, v.uniformsList, R, ft));
                        var L, O;
                        i.isShaderMaterial && !0 === i.uniformsNeedUpdate && ($r.upload(Nt, v.uniformsList, R, ft), i.uniformsNeedUpdate = !1);
                        i.isSpriteMaterial && A.setValue(Nt, "center", r.center);
                        if (A.setValue(Nt, "modelViewMatrix", r.modelViewMatrix), A.setValue(Nt, "normalMatrix", r.normalMatrix), A.setValue(Nt, "modelMatrix", r.matrixWorld), i.isShaderMaterial || i.isRawShaderMaterial) {
                            const t = i.uniformsGroups;
                            for (let e = 0, n = t.length; e < n; e++)
                                if (ht.isWebGL2) {
                                    const n = t[e];
                                    kt.update(n, w), kt.bind(n, w)
                                } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                        }
                        return w
                    }(t, e, n, i, r);
                ut.setMaterial(i, a);
                let l = n.index,
                    c = 1;
                if (!0 === i.wireframe) {
                    if (l = yt.getWireframeAttribute(n), void 0 === l) return;
                    c = 2
                }
                const h = n.drawRange,
                    u = n.attributes.position;
                let d = h.start * c,
                    p = (h.start + h.count) * c;
                null !== s && (d = Math.max(d, s.start * c), p = Math.min(p, (s.start + s.count) * c)), null !== l ? (d = Math.max(d, 0), p = Math.min(p, l.count)) : null != u && (d = Math.max(d, 0), p = Math.min(p, u.count));
                const f = p - d;
                if (f < 0 || f === 1 / 0) return;
                let m;
                Dt.setup(r, i, o, n, l);
                let g = Rt;
                if (null !== l && (m = vt.get(l), g = Lt, g.setIndex(m)), r.isMesh) !0 === i.wireframe ? (ut.setLineWidth(i.wireframeLinewidth * lt()), g.setMode(Nt.LINES)) : g.setMode(Nt.TRIANGLES);
                else if (r.isLine) {
                    let t = i.linewidth;
                    void 0 === t && (t = 1), ut.setLineWidth(t * lt()), r.isLineSegments ? g.setMode(Nt.LINES) : r.isLineLoop ? g.setMode(Nt.LINE_LOOP) : g.setMode(Nt.LINE_STRIP)
                } else r.isPoints ? g.setMode(Nt.POINTS) : r.isSprite && g.setMode(Nt.TRIANGLES);
                if (r.isInstancedMesh) g.renderInstances(d, f, r.count);
                else if (n.isInstancedBufferGeometry) {
                    const t = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                        e = Math.min(n.instanceCount, t);
                    g.renderInstances(d, f, e)
                } else g.render(d, f)
            }, this.compile = function (t, e) {
                function n(t, e, n) {
                    !0 === t.transparent && t.side === l && !1 === t.forceSinglePass ? (t.side = o, t.needsUpdate = !0, Zt(t, e, n), t.side = a, t.needsUpdate = !0, Zt(t, e, n), t.side = l) : Zt(t, e, n)
                }
                x = St.get(t), x.init(), w.push(x), t.traverseVisible((function (t) {
                    t.isLight && t.layers.test(e.layers) && (x.pushLight(t), t.castShadow && x.pushShadow(t))
                })), x.setupLights(S._useLegacyLights), t.traverse((function (e) {
                    const i = e.material;
                    if (i)
                        if (Array.isArray(i))
                            for (let r = 0; r < i.length; r++) {
                                n(i[r], t, e)
                            } else n(i, t, e)
                })), w.pop(), x = null
            };
            let Vt = null;

            function Gt() {
                qt.stop()
            }

            function Wt() {
                qt.start()
            }
            const qt = new ei;

            function Xt(t, e, n, i) {
                const r = t.opaque,
                    s = t.transmissive,
                    a = t.transparent;
                x.setupLightsView(n), !0 === Q && Mt.setGlobalState(S.clippingPlanes, n), s.length > 0 && function (t, e, n, i) {
                    const r = ht.isWebGL2;
                    null === et && (et = new Pt(1, 1, {
                        generateMipmaps: !0,
                        type: ct.has("EXT_color_buffer_half_float") ? O : R,
                        minFilter: A,
                        samples: r ? 4 : 0
                    }));
                    S.getDrawingBufferSize(rt), r ? et.setSize(rt.x, rt.y) : et.setSize(it(rt.x), it(rt.y));
                    const s = S.getRenderTarget();
                    S.setRenderTarget(et), S.getClearColor($), B = S.getClearAlpha(), B < 1 && S.setClearColor(16777215, .5);
                    S.clear();
                    const a = S.toneMapping;
                    S.toneMapping = b, Yt(t, n, i), ft.updateMultisampleRenderTarget(et), ft.updateRenderTargetMipmap(et);
                    let c = !1;
                    for (let t = 0, r = e.length; t < r; t++) {
                        const r = e[t],
                            s = r.object,
                            a = r.geometry,
                            h = r.material,
                            u = r.group;
                        if (h.side === l && s.layers.test(i.layers)) {
                            const t = h.side;
                            h.side = o, h.needsUpdate = !0, Kt(s, n, i, a, h, u), h.side = t, h.needsUpdate = !0, c = !0
                        }
                    } !0 === c && (ft.updateMultisampleRenderTarget(et), ft.updateRenderTargetMipmap(et));
                    S.setRenderTarget(s), S.setClearColor($, B), S.toneMapping = a
                }(r, s, e, n), i && ut.viewport(U.copy(i)), r.length > 0 && Yt(r, e, n), s.length > 0 && Yt(s, e, n), a.length > 0 && Yt(a, e, n), ut.buffers.depth.setTest(!0), ut.buffers.depth.setMask(!0), ut.buffers.color.setMask(!0), ut.setPolygonOffset(!1)
            }

            function Yt(t, e, n) {
                const i = !0 === e.isScene ? e.overrideMaterial : null;
                for (let r = 0, s = t.length; r < s; r++) {
                    const s = t[r],
                        a = s.object,
                        o = s.geometry,
                        l = null === i ? s.material : i,
                        c = s.group;
                    a.layers.test(n.layers) && Kt(a, e, n, o, l, c)
                }
            }

            function Kt(t, e, n, i, r, s) {
                t.onBeforeRender(S, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r.onBeforeRender(S, e, n, i, t, s), !0 === r.transparent && r.side === l && !1 === r.forceSinglePass ? (r.side = o, r.needsUpdate = !0, S.renderBufferDirect(n, e, i, r, t, s), r.side = a, r.needsUpdate = !0, S.renderBufferDirect(n, e, i, r, t, s), r.side = l) : S.renderBufferDirect(n, e, i, r, t, s), t.onAfterRender(S, e, n, i, r, s)
            }

            function Zt(t, e, n) {
                !0 !== e.isScene && (e = at);
                const i = pt.get(t),
                    r = x.state.lights,
                    s = x.state.shadowsArray,
                    a = r.state.version,
                    o = xt.getParameters(t, r.state, s, e, n),
                    l = xt.getProgramCacheKey(o);
                let c = i.programs;
                i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = (t.isMeshStandardMaterial ? gt : mt).get(t.envMap || i.environment), void 0 === c && (t.addEventListener("dispose", jt), c = new Map, i.programs = c);
                let h = c.get(l);
                if (void 0 !== h) {
                    if (i.currentProgram === h && i.lightsStateVersion === a) return Jt(t, o), h
                } else o.uniforms = xt.getUniforms(t), t.onBuild(n, o, S), t.onBeforeCompile(o, S), h = xt.acquireProgram(o, l), c.set(l, h), i.uniforms = o.uniforms;
                const u = i.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = Mt.uniform), Jt(t, o), i.needsLights = function (t) {
                    return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                }(t), i.lightsStateVersion = a, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotLightMatrix.value = r.state.spotLightMatrix, u.spotLightMap.value = r.state.spotLightMap, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix);
                const d = h.getUniforms(),
                    p = $r.seqWithValue(d.seq, u);
                return i.currentProgram = h, i.uniformsList = p, h
            }

            function Jt(t, e) {
                const n = pt.get(t);
                n.outputColorSpace = e.outputColorSpace, n.instancing = e.instancing, n.instancingColor = e.instancingColor, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphColors = e.morphColors, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping
            }
            qt.setAnimationLoop((function (t) {
                Vt && Vt(t)
            })), "undefined" != typeof self && qt.setContext(self), this.setAnimationLoop = function (t) {
                Vt = t, Ft.setAnimationLoop(t), null === t ? qt.stop() : qt.start()
            }, Ft.addEventListener("sessionstart", Gt), Ft.addEventListener("sessionend", Wt), this.render = function (t, e) {
                if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                if (!0 === M) return;
                !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), null === e.parent && !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), !0 === Ft.enabled && !0 === Ft.isPresenting && (!0 === Ft.cameraAutoUpdate && Ft.updateCamera(e), e = Ft.getCamera()), !0 === t.isScene && t.onBeforeRender(S, t, e, C), x = St.get(t, w.length), x.init(), w.push(x), nt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), J.setFromProjectionMatrix(nt), tt = this.localClippingEnabled, Q = Mt.init(this.clippingPlanes, tt), y = wt.get(t, _.length), y.init(), _.push(y),
                    function t(e, n, i, r) {
                        if (!1 === e.visible) return;
                        if (e.layers.test(n.layers))
                            if (e.isGroup) i = e.renderOrder;
                            else if (e.isLOD) !0 === e.autoUpdate && e.update(n);
                            else if (e.isLight) x.pushLight(e), e.castShadow && x.pushShadow(e);
                            else if (e.isSprite) {
                                if (!e.frustumCulled || J.intersectsSprite(e)) {
                                    r && st.setFromMatrixPosition(e.matrixWorld).applyMatrix4(nt);
                                    const t = bt.update(e),
                                        n = e.material;
                                    n.visible && y.push(e, t, n, i, st.z, null)
                                }
                            } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || J.intersectsObject(e))) {
                                const t = bt.update(e),
                                    n = e.material;
                                if (r && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(), st.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(), st.copy(t.boundingSphere.center)), st.applyMatrix4(e.matrixWorld).applyMatrix4(nt)), Array.isArray(n)) {
                                    const r = t.groups;
                                    for (let s = 0, a = r.length; s < a; s++) {
                                        const a = r[s],
                                            o = n[a.materialIndex];
                                        o && o.visible && y.push(e, t, o, i, st.z, a)
                                    }
                                } else n.visible && y.push(e, t, n, i, st.z, null)
                            }
                        const s = e.children;
                        for (let e = 0, a = s.length; e < a; e++) t(s[e], n, i, r)
                    }(t, e, 0, S.sortObjects), y.finish(), !0 === S.sortObjects && y.sort(q, X), this.info.render.frame++, !0 === Q && Mt.beginShadows();
                const n = x.state.shadowsArray;
                if (Et.render(n, t, e), !0 === Q && Mt.endShadows(), !0 === this.info.autoReset && this.info.reset(), Tt.render(y, t), x.setupLights(S._useLegacyLights), e.isArrayCamera) {
                    const n = e.cameras;
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        Xt(y, t, i, i.viewport)
                    }
                } else Xt(y, t, e);
                null !== C && (ft.updateMultisampleRenderTarget(C), ft.updateRenderTargetMipmap(C)), !0 === t.isScene && t.onAfterRender(S, t, e), Dt.resetDefaultState(), k = -1, N = null, w.pop(), x = w.length > 0 ? w[w.length - 1] : null, _.pop(), y = _.length > 0 ? _[_.length - 1] : null
            }, this.getActiveCubeFace = function () {
                return E
            }, this.getActiveMipmapLevel = function () {
                return T
            }, this.getRenderTarget = function () {
                return C
            }, this.setRenderTargetTextures = function (t, e, n) {
                pt.get(t.texture).__webglTexture = e, pt.get(t.depthTexture).__webglTexture = n;
                const i = pt.get(t);
                i.__hasExternalTextures = !0, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || !0 === ct.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), i.__useRenderToTexture = !1))
            }, this.setRenderTargetFramebuffer = function (t, e) {
                const n = pt.get(t);
                n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e
            }, this.setRenderTarget = function (t, e = 0, n = 0) {
                C = t, E = e, T = n;
                let i = !0,
                    r = null,
                    s = !1,
                    a = !1;
                if (t) {
                    const o = pt.get(t);
                    void 0 !== o.__useDefaultFramebuffer ? (ut.bindFramebuffer(Nt.FRAMEBUFFER, null), i = !1) : void 0 === o.__webglFramebuffer ? ft.setupRenderTarget(t) : o.__hasExternalTextures && ft.rebindTextures(t, pt.get(t.texture).__webglTexture, pt.get(t.depthTexture).__webglTexture);
                    const l = t.texture;
                    (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (a = !0);
                    const c = pt.get(t).__webglFramebuffer;
                    t.isWebGLCubeRenderTarget ? (r = Array.isArray(c[e]) ? c[e][n] : c[e], s = !0) : r = ht.isWebGL2 && t.samples > 0 && !1 === ft.useMultisampledRTT(t) ? pt.get(t).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c, U.copy(t.viewport), z.copy(t.scissor), F = t.scissorTest
                } else U.copy(Y).multiplyScalar(W).floor(), z.copy(K).multiplyScalar(W).floor(), F = Z;
                if (ut.bindFramebuffer(Nt.FRAMEBUFFER, r) && ht.drawBuffers && i && ut.drawBuffers(t, r), ut.viewport(U), ut.scissor(z), ut.setScissorTest(F), s) {
                    const i = pt.get(t.texture);
                    Nt.framebufferTexture2D(Nt.FRAMEBUFFER, Nt.COLOR_ATTACHMENT0, Nt.TEXTURE_CUBE_MAP_POSITIVE_X + e, i.__webglTexture, n)
                } else if (a) {
                    const i = pt.get(t.texture),
                        r = e || 0;
                    Nt.framebufferTextureLayer(Nt.FRAMEBUFFER, Nt.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
                }
                k = -1
            }, this.readRenderTargetPixels = function (t, e, n, i, r, s, a) {
                if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                let o = pt.get(t).__webglFramebuffer;
                if (t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o) {
                    ut.bindFramebuffer(Nt.FRAMEBUFFER, o);
                    try {
                        const a = t.texture,
                            o = a.format,
                            l = a.type;
                        if (o !== I && Ot.convert(o) !== Nt.getParameter(Nt.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        const c = l === O && (ct.has("EXT_color_buffer_half_float") || ht.isWebGL2 && ct.has("EXT_color_buffer_float"));
                        if (!(l === R || Ot.convert(l) === Nt.getParameter(Nt.IMPLEMENTATION_COLOR_READ_TYPE) || l === L && (ht.isWebGL2 || ct.has("OES_texture_float") || ct.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && Nt.readPixels(e, n, i, r, Ot.convert(o), Ot.convert(l), s)
                    } finally {
                        const t = null !== C ? pt.get(C).__webglFramebuffer : null;
                        ut.bindFramebuffer(Nt.FRAMEBUFFER, t)
                    }
                }
            }, this.copyFramebufferToTexture = function (t, e, n = 0) {
                const i = Math.pow(2, -n),
                    r = Math.floor(e.image.width * i),
                    s = Math.floor(e.image.height * i);
                ft.setTexture2D(e, 0), Nt.copyTexSubImage2D(Nt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s), ut.unbindTexture()
            }, this.copyTextureToTexture = function (t, e, n, i = 0) {
                const r = e.image.width,
                    s = e.image.height,
                    a = Ot.convert(n.format),
                    o = Ot.convert(n.type);
                ft.setTexture2D(n, 0), Nt.pixelStorei(Nt.UNPACK_FLIP_Y_WEBGL, n.flipY), Nt.pixelStorei(Nt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), Nt.pixelStorei(Nt.UNPACK_ALIGNMENT, n.unpackAlignment), e.isDataTexture ? Nt.texSubImage2D(Nt.TEXTURE_2D, i, t.x, t.y, r, s, a, o, e.image.data) : e.isCompressedTexture ? Nt.compressedTexSubImage2D(Nt.TEXTURE_2D, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : Nt.texSubImage2D(Nt.TEXTURE_2D, i, t.x, t.y, a, o, e.image), 0 === i && n.generateMipmaps && Nt.generateMipmap(Nt.TEXTURE_2D), ut.unbindTexture()
            }, this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
                if (S.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                const s = t.max.x - t.min.x + 1,
                    a = t.max.y - t.min.y + 1,
                    o = t.max.z - t.min.z + 1,
                    l = Ot.convert(i.format),
                    c = Ot.convert(i.type);
                let h;
                if (i.isData3DTexture) ft.setTexture3D(i, 0), h = Nt.TEXTURE_3D;
                else {
                    if (!i.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                    ft.setTexture2DArray(i, 0), h = Nt.TEXTURE_2D_ARRAY
                }
                Nt.pixelStorei(Nt.UNPACK_FLIP_Y_WEBGL, i.flipY), Nt.pixelStorei(Nt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), Nt.pixelStorei(Nt.UNPACK_ALIGNMENT, i.unpackAlignment);
                const u = Nt.getParameter(Nt.UNPACK_ROW_LENGTH),
                    d = Nt.getParameter(Nt.UNPACK_IMAGE_HEIGHT),
                    p = Nt.getParameter(Nt.UNPACK_SKIP_PIXELS),
                    f = Nt.getParameter(Nt.UNPACK_SKIP_ROWS),
                    m = Nt.getParameter(Nt.UNPACK_SKIP_IMAGES),
                    g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                Nt.pixelStorei(Nt.UNPACK_ROW_LENGTH, g.width), Nt.pixelStorei(Nt.UNPACK_IMAGE_HEIGHT, g.height), Nt.pixelStorei(Nt.UNPACK_SKIP_PIXELS, t.min.x), Nt.pixelStorei(Nt.UNPACK_SKIP_ROWS, t.min.y), Nt.pixelStorei(Nt.UNPACK_SKIP_IMAGES, t.min.z), n.isDataTexture || n.isData3DTexture ? Nt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g.data) : n.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Nt.compressedTexSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, g.data)) : Nt.texSubImage3D(h, r, e.x, e.y, e.z, s, a, o, l, c, g), Nt.pixelStorei(Nt.UNPACK_ROW_LENGTH, u), Nt.pixelStorei(Nt.UNPACK_IMAGE_HEIGHT, d), Nt.pixelStorei(Nt.UNPACK_SKIP_PIXELS, p), Nt.pixelStorei(Nt.UNPACK_SKIP_ROWS, f), Nt.pixelStorei(Nt.UNPACK_SKIP_IMAGES, m), 0 === r && i.generateMipmaps && Nt.generateMipmap(h), ut.unbindTexture()
            }, this.initTexture = function (t) {
                t.isCubeTexture ? ft.setTextureCube(t, 0) : t.isData3DTexture ? ft.setTexture3D(t, 0) : t.isDataArrayTexture || t.isCompressedArrayTexture ? ft.setTexture2DArray(t, 0) : ft.setTexture2D(t, 0), ut.unbindTexture()
            }, this.resetState = function () {
                E = 0, T = 0, C = null, ut.reset(), Dt.reset()
            }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }
        get coordinateSystem() {
            return 2e3
        }
        get physicallyCorrectLights() {
            return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights
        }
        set physicallyCorrectLights(t) {
            console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !t
        }
        get outputEncoding() {
            return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === V ? B : $
        }
        set outputEncoding(t) {
            console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = t === B ? V : G
        }
        get useLegacyLights() {
            return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights
        }
        set useLegacyLights(t) {
            console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = t
        }
    } (class extends Is { }).prototype.isWebGL1Renderer = !0;
    class ks {
        constructor(t, e = 1, n = 1e3) {
            this.isFog = !0, this.name = "", this.color = new tn(t), this.near = e, this.far = n
        }
        clone() {
            return new ks(this.color, this.near, this.far)
        }
        toJSON() {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }
    }
    class Ns extends ke {
        constructor() {
            super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                detail: this
            }))
        }
        copy(t, e) {
            return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return null !== this.fog && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (e.object.backgroundIntensity = this.backgroundIntensity), e
        }
    }
    class Us {
        constructor(t, e) {
            this.isInterleavedBuffer = !0, this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = 35044, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0, this.uuid = Z()
        }
        onUploadCallback() { }
        set needsUpdate(t) {
            !0 === t && this.version++
        }
        setUsage(t) {
            return this.usage = t, this
        }
        copy(t) {
            return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
        }
        copyAt(t, e, n) {
            t *= this.stride, n *= e.stride;
            for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
            return this
        }
        set(t, e = 0) {
            return this.array.set(t, e), this
        }
        clone(t) {
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Z()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                n = new this.constructor(e, this.stride);
            return n.setUsage(this.usage), n
        }
        onUpload(t) {
            return this.onUploadCallback = t, this
        }
        toJSON(t) {
            return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Z()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            }
        }
    }
    const zs = new It;
    class Fs {
        constructor(t, e, n, i = !1) {
            this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = i
        }
        get count() {
            return this.data.count
        }
        get array() {
            return this.data.array
        }
        set needsUpdate(t) {
            this.data.needsUpdate = t
        }
        applyMatrix4(t) {
            for (let e = 0, n = this.data.count; e < n; e++) zs.fromBufferAttribute(this, e), zs.applyMatrix4(t), this.setXYZ(e, zs.x, zs.y, zs.z);
            return this
        }
        applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++) zs.fromBufferAttribute(this, e), zs.applyNormalMatrix(t), this.setXYZ(e, zs.x, zs.y, zs.z);
            return this
        }
        transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++) zs.fromBufferAttribute(this, e), zs.transformDirection(t), this.setXYZ(e, zs.x, zs.y, zs.z);
            return this
        }
        setX(t, e) {
            return this.normalized && (e = st(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this
        }
        setY(t, e) {
            return this.normalized && (e = st(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this
        }
        setZ(t, e) {
            return this.normalized && (e = st(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this
        }
        setW(t, e) {
            return this.normalized && (e = st(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this
        }
        getX(t) {
            let e = this.data.array[t * this.data.stride + this.offset];
            return this.normalized && (e = rt(e, this.array)), e
        }
        getY(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 1];
            return this.normalized && (e = rt(e, this.array)), e
        }
        getZ(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 2];
            return this.normalized && (e = rt(e, this.array)), e
        }
        getW(t) {
            let e = this.data.array[t * this.data.stride + this.offset + 3];
            return this.normalized && (e = rt(e, this.array)), e
        }
        setXY(t, e, n) {
            return t = t * this.data.stride + this.offset, this.normalized && (e = st(e, this.array), n = st(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
        }
        setXYZ(t, e, n, i) {
            return t = t * this.data.stride + this.offset, this.normalized && (e = st(e, this.array), n = st(n, this.array), i = st(i, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
        }
        setXYZW(t, e, n, i, r) {
            return t = t * this.data.stride + this.offset, this.normalized && (e = st(e, this.array), n = st(n, this.array), i = st(i, this.array), r = st(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
        }
        clone(t) {
            if (void 0 === t) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                const t = [];
                for (let e = 0; e < this.count; e++) {
                    const n = e * this.data.stride + this.offset;
                    for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                }
                return new an(new this.array.constructor(t), this.itemSize, this.normalized)
            }
            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Fs(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
        }
        toJSON(t) {
            if (void 0 === t) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                const t = [];
                for (let e = 0; e < this.count; e++) {
                    const n = e * this.data.stride + this.offset;
                    for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: t,
                    normalized: this.normalized
                }
            }
            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
        }
    }
    class $s extends Ct {
        constructor(t = null, e = 1, n = 1, i, r, s, a, o, l = T, c = T, h, u) {
            super(null, s, a, o, l, c, i, r, h, u), this.isDataTexture = !0, this.image = {
                data: t,
                width: e,
                height: n
            }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
        }
    }
    class Bs extends Ye {
        constructor(t) {
            super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new tn(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t)
        }
        copy(t) {
            return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this
        }
    }
    const Hs = new It,
        js = new It,
        Vs = new he,
        Gs = new ce,
        Ws = new ee;
    class qs extends ke {
        constructor(t = new vn, e = new Bs) {
            super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
        }
        copy(t, e) {
            return super.copy(t, e), this.material = t.material, this.geometry = t.geometry, this
        }
        computeLineDistances() {
            const t = this.geometry;
            if (null === t.index) {
                const e = t.attributes.position,
                    n = [0];
                for (let t = 1, i = e.count; t < i; t++) Hs.fromBufferAttribute(e, t - 1), js.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Hs.distanceTo(js);
                t.setAttribute("lineDistance", new cn(n, 1))
            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this
        }
        raycast(t, e) {
            const n = this.geometry,
                i = this.matrixWorld,
                r = t.params.Line.threshold,
                s = n.drawRange;
            if (null === n.boundingSphere && n.computeBoundingSphere(), Ws.copy(n.boundingSphere), Ws.applyMatrix4(i), Ws.radius += r, !1 === t.ray.intersectsSphere(Ws)) return;
            Vs.copy(i).invert(), Gs.copy(t.ray).applyMatrix4(Vs);
            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                o = a * a,
                l = new It,
                c = new It,
                h = new It,
                u = new It,
                d = this.isLineSegments ? 2 : 1,
                p = n.index,
                f = n.attributes.position;
            if (null !== p) {
                for (let n = Math.max(0, s.start), i = Math.min(p.count, s.start + s.count) - 1; n < i; n += d) {
                    const i = p.getX(n),
                        r = p.getX(n + 1);
                    l.fromBufferAttribute(f, i), c.fromBufferAttribute(f, r);
                    if (Gs.distanceSqToSegment(l, c, u, h) > o) continue;
                    u.applyMatrix4(this.matrixWorld);
                    const s = t.ray.origin.distanceTo(u);
                    s < t.near || s > t.far || e.push({
                        distance: s,
                        point: h.clone().applyMatrix4(this.matrixWorld),
                        index: n,
                        face: null,
                        faceIndex: null,
                        object: this
                    })
                }
            } else {
                for (let n = Math.max(0, s.start), i = Math.min(f.count, s.start + s.count) - 1; n < i; n += d) {
                    l.fromBufferAttribute(f, n), c.fromBufferAttribute(f, n + 1);
                    if (Gs.distanceSqToSegment(l, c, u, h) > o) continue;
                    u.applyMatrix4(this.matrixWorld);
                    const i = t.ray.origin.distanceTo(u);
                    i < t.near || i > t.far || e.push({
                        distance: i,
                        point: h.clone().applyMatrix4(this.matrixWorld),
                        index: n,
                        face: null,
                        faceIndex: null,
                        object: this
                    })
                }
            }
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes,
                e = Object.keys(t);
            if (e.length > 0) {
                const n = t[e[0]];
                if (void 0 !== n) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let t = 0, e = n.length; t < e; t++) {
                        const e = n[t].name || String(t);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                    }
                }
            }
        }
    }
    const Xs = new It,
        Ys = new It;
    class Ks extends qs {
        constructor(t, e) {
            super(t, e), this.isLineSegments = !0, this.type = "LineSegments"
        }
        computeLineDistances() {
            const t = this.geometry;
            if (null === t.index) {
                const e = t.attributes.position,
                    n = [];
                for (let t = 0, i = e.count; t < i; t += 2) Xs.fromBufferAttribute(e, t), Ys.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Xs.distanceTo(Ys);
                t.setAttribute("lineDistance", new cn(n, 1))
            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            return this
        }
    }
    class Zs extends Ye {
        constructor(t) {
            super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new tn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(t)
        }
        copy(t) {
            return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.fog = t.fog, this
        }
    }
    const Js = new he,
        Qs = new ce,
        ta = new ee,
        ea = new It;
    class na extends ke {
        constructor(t = new vn, e = new Zs) {
            super(), this.isPoints = !0, this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
        }
        copy(t, e) {
            return super.copy(t, e), this.material = t.material, this.geometry = t.geometry, this
        }
        raycast(t, e) {
            const n = this.geometry,
                i = this.matrixWorld,
                r = t.params.Points.threshold,
                s = n.drawRange;
            if (null === n.boundingSphere && n.computeBoundingSphere(), ta.copy(n.boundingSphere), ta.applyMatrix4(i), ta.radius += r, !1 === t.ray.intersectsSphere(ta)) return;
            Js.copy(i).invert(), Qs.copy(t.ray).applyMatrix4(Js);
            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                o = a * a,
                l = n.index,
                c = n.attributes.position;
            if (null !== l) {
                for (let n = Math.max(0, s.start), r = Math.min(l.count, s.start + s.count); n < r; n++) {
                    const r = l.getX(n);
                    ea.fromBufferAttribute(c, r), ia(ea, r, o, i, t, e, this)
                }
            } else {
                for (let n = Math.max(0, s.start), r = Math.min(c.count, s.start + s.count); n < r; n++) ea.fromBufferAttribute(c, n), ia(ea, n, o, i, t, e, this)
            }
        }
        updateMorphTargets() {
            const t = this.geometry.morphAttributes,
                e = Object.keys(t);
            if (e.length > 0) {
                const n = t[e[0]];
                if (void 0 !== n) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (let t = 0, e = n.length; t < e; t++) {
                        const e = n[t].name || String(t);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[e] = t
                    }
                }
            }
        }
    }

    function ia(t, e, n, i, r, s, a) {
        const o = Qs.distanceSqToPoint(t);
        if (o < n) {
            const n = new It;
            Qs.closestPointToPoint(t, n), n.applyMatrix4(i);
            const l = r.ray.origin.distanceTo(n);
            if (l < r.near || l > r.far) return;
            s.push({
                distance: l,
                distanceToRay: Math.sqrt(o),
                point: n,
                index: e,
                face: null,
                object: a
            })
        }
    }
    class ra extends Ct {
        constructor(t, e, n, i, r, s, a, o, l) {
            super(t, e, n, i, r, s, a, o, l), this.isCanvasTexture = !0, this.needsUpdate = !0
        }
    }
    class sa {
        constructor() {
            this.type = "Curve", this.arcLengthDivisions = 200
        }
        getPoint() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        }
        getPointAt(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getPoint(n, e)
        }
        getPoints(t = 5) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return e
        }
        getSpacedPoints(t = 5) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
            return e
        }
        getLength() {
            const t = this.getLengths();
            return t[t.length - 1]
        }
        getLengths(t = this.arcLengthDivisions) {
            if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            const e = [];
            let n, i = this.getPoint(0),
                r = 0;
            e.push(0);
            for (let s = 1; s <= t; s++) n = this.getPoint(s / t), r += n.distanceTo(i), e.push(r), i = n;
            return this.cacheArcLengths = e, e
        }
        updateArcLengths() {
            this.needsUpdate = !0, this.getLengths()
        }
        getUtoTmapping(t, e) {
            const n = this.getLengths();
            let i = 0;
            const r = n.length;
            let s;
            s = e || t * n[r - 1];
            let a, o = 0,
                l = r - 1;
            for (; o <= l;)
                if (i = Math.floor(o + (l - o) / 2), a = n[i] - s, a < 0) o = i + 1;
                else {
                    if (!(a > 0)) {
                        l = i;
                        break
                    }
                    l = i - 1
                } if (i = l, n[i] === s) return i / (r - 1);
            const c = n[i];
            return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
        }
        getTangent(t, e) {
            let n = t - 1e-4,
                i = t + 1e-4;
            n < 0 && (n = 0), i > 1 && (i = 1);
            const r = this.getPoint(n),
                s = this.getPoint(i),
                a = e || (r.isVector2 ? new ot : new It);
            return a.copy(s).sub(r).normalize(), a
        }
        getTangentAt(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getTangent(n, e)
        }
        computeFrenetFrames(t, e) {
            const n = new It,
                i = [],
                r = [],
                s = [],
                a = new It,
                o = new he;
            for (let e = 0; e <= t; e++) {
                const n = e / t;
                i[e] = this.getTangentAt(n, new It)
            }
            r[0] = new It, s[0] = new It;
            let l = Number.MAX_VALUE;
            const c = Math.abs(i[0].x),
                h = Math.abs(i[0].y),
                u = Math.abs(i[0].z);
            c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], a), s[0].crossVectors(i[0], r[0]);
            for (let e = 1; e <= t; e++) {
                if (r[e] = r[e - 1].clone(), s[e] = s[e - 1].clone(), a.crossVectors(i[e - 1], i[e]), a.length() > Number.EPSILON) {
                    a.normalize();
                    const t = Math.acos(J(i[e - 1].dot(i[e]), -1, 1));
                    r[e].applyMatrix4(o.makeRotationAxis(a, t))
                }
                s[e].crossVectors(i[e], r[e])
            }
            if (!0 === e) {
                let e = Math.acos(J(r[0].dot(r[t]), -1, 1));
                e /= t, i[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
                for (let n = 1; n <= t; n++) r[n].applyMatrix4(o.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n])
            }
            return {
                tangents: i,
                normals: r,
                binormals: s
            }
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions, this
        }
        toJSON() {
            const t = {
                metadata: {
                    version: 4.6,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
        }
        fromJSON(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions, this
        }
    }
    class aa extends vn {
        constructor(t = 1, e = 1, n = 1, i = 32, r = 1, s = !1, a = 0, o = 2 * Math.PI) {
            super(), this.type = "CylinderGeometry", this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: n,
                radialSegments: i,
                heightSegments: r,
                openEnded: s,
                thetaStart: a,
                thetaLength: o
            };
            const l = this;
            i = Math.floor(i), r = Math.floor(r);
            const c = [],
                h = [],
                u = [],
                d = [];
            let p = 0;
            const f = [],
                m = n / 2;
            let g = 0;

            function v(n) {
                const r = p,
                    s = new ot,
                    f = new It;
                let v = 0;
                const y = !0 === n ? t : e,
                    b = !0 === n ? 1 : -1;
                for (let t = 1; t <= i; t++) h.push(0, m * b, 0), u.push(0, b, 0), d.push(.5, .5), p++;
                const x = p;
                for (let t = 0; t <= i; t++) {
                    const e = t / i * o + a,
                        n = Math.cos(e),
                        r = Math.sin(e);
                    f.x = y * r, f.y = m * b, f.z = y * n, h.push(f.x, f.y, f.z), u.push(0, b, 0), s.x = .5 * n + .5, s.y = .5 * r * b + .5, d.push(s.x, s.y), p++
                }
                for (let t = 0; t < i; t++) {
                    const e = r + t,
                        i = x + t;
                    !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), v += 3
                }
                l.addGroup(g, v, !0 === n ? 1 : 2), g += v
            } ! function () {
                const s = new It,
                    v = new It;
                let y = 0;
                const b = (e - t) / n;
                for (let l = 0; l <= r; l++) {
                    const c = [],
                        g = l / r,
                        y = g * (e - t) + t;
                    for (let t = 0; t <= i; t++) {
                        const e = t / i,
                            r = e * o + a,
                            l = Math.sin(r),
                            f = Math.cos(r);
                        v.x = y * l, v.y = -g * n + m, v.z = y * f, h.push(v.x, v.y, v.z), s.set(l, b, f).normalize(), u.push(s.x, s.y, s.z), d.push(e, 1 - g), c.push(p++)
                    }
                    f.push(c)
                }
                for (let t = 0; t < i; t++)
                    for (let e = 0; e < r; e++) {
                        const n = f[e][t],
                            i = f[e + 1][t],
                            r = f[e + 1][t + 1],
                            s = f[e][t + 1];
                        c.push(n, i, s), c.push(i, r, s), y += 6
                    }
                l.addGroup(g, y, 0), g += y
            }(), !1 === s && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new cn(h, 3)), this.setAttribute("normal", new cn(u, 3)), this.setAttribute("uv", new cn(d, 2))
        }
        copy(t) {
            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
        }
        static fromJSON(t) {
            return new aa(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength)
        }
    }
    class oa extends vn {
        constructor(t = 1, e = 32, n = 16, i = 0, r = 2 * Math.PI, s = 0, a = Math.PI) {
            super(), this.type = "SphereGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: n,
                phiStart: i,
                phiLength: r,
                thetaStart: s,
                thetaLength: a
            }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
            const o = Math.min(s + a, Math.PI);
            let l = 0;
            const c = [],
                h = new It,
                u = new It,
                d = [],
                p = [],
                f = [],
                m = [];
            for (let d = 0; d <= n; d++) {
                const g = [],
                    v = d / n;
                let y = 0;
                0 === d && 0 === s ? y = .5 / e : d === n && o === Math.PI && (y = -.5 / e);
                for (let n = 0; n <= e; n++) {
                    const o = n / e;
                    h.x = -t * Math.cos(i + o * r) * Math.sin(s + v * a), h.y = t * Math.cos(s + v * a), h.z = t * Math.sin(i + o * r) * Math.sin(s + v * a), p.push(h.x, h.y, h.z), u.copy(h).normalize(), f.push(u.x, u.y, u.z), m.push(o + y, 1 - v), g.push(l++)
                }
                c.push(g)
            }
            for (let t = 0; t < n; t++)
                for (let i = 0; i < e; i++) {
                    const e = c[t][i + 1],
                        r = c[t][i],
                        a = c[t + 1][i],
                        l = c[t + 1][i + 1];
                    (0 !== t || s > 0) && d.push(e, r, l), (t !== n - 1 || o < Math.PI) && d.push(r, a, l)
                }
            this.setIndex(d), this.setAttribute("position", new cn(p, 3)), this.setAttribute("normal", new cn(f, 3)), this.setAttribute("uv", new cn(m, 2))
        }
        copy(t) {
            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
        }
        static fromJSON(t) {
            return new oa(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength)
        }
    }
    class la extends vn {
        constructor(t = null) {
            if (super(), this.type = "WireframeGeometry", this.parameters = {
                geometry: t
            }, null !== t) {
                const e = [],
                    n = new Set,
                    i = new It,
                    r = new It;
                if (null !== t.index) {
                    const s = t.attributes.position,
                        a = t.index;
                    let o = t.groups;
                    0 === o.length && (o = [{
                        start: 0,
                        count: a.count,
                        materialIndex: 0
                    }]);
                    for (let t = 0, l = o.length; t < l; ++t) {
                        const l = o[t],
                            c = l.start;
                        for (let t = c, o = c + l.count; t < o; t += 3)
                            for (let o = 0; o < 3; o++) {
                                const l = a.getX(t + o),
                                    c = a.getX(t + (o + 1) % 3);
                                i.fromBufferAttribute(s, l), r.fromBufferAttribute(s, c), !0 === ca(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z))
                            }
                    }
                } else {
                    const s = t.attributes.position;
                    for (let t = 0, a = s.count / 3; t < a; t++)
                        for (let a = 0; a < 3; a++) {
                            const o = 3 * t + a,
                                l = 3 * t + (a + 1) % 3;
                            i.fromBufferAttribute(s, o), r.fromBufferAttribute(s, l), !0 === ca(i, r, n) && (e.push(i.x, i.y, i.z), e.push(r.x, r.y, r.z))
                        }
                }
                this.setAttribute("position", new cn(e, 3))
            }
        }
        copy(t) {
            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
        }
    }

    function ca(t, e, n) {
        const i = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
            r = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
        return !0 !== n.has(i) && !0 !== n.has(r) && (n.add(i), n.add(r), !0)
    }
    class ha extends Hn {
        constructor(t) {
            super(t), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
        }
    }
    class ua extends Ye {
        constructor(t) {
            super(), this.isMeshStandardMaterial = !0, this.defines = {
                STANDARD: ""
            }, this.type = "MeshStandardMaterial", this.color = new tn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new tn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ot(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
        }
        copy(t) {
            return super.copy(t), this.defines = {
                STANDARD: ""
            }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
        }
    }
    class da extends Ye {
        constructor(t) {
            super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new tn(16777215), this.specular = new tn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new tn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ot(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t)
        }
        copy(t) {
            return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this
        }
    }
    class pa extends Ye {
        constructor(t) {
            super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ot(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(t)
        }
        copy(t) {
            return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this
        }
    }

    function fa(t, e, n) {
        return ga(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
    }

    function ma(t, e, n) {
        return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
    }

    function ga(t) {
        return ArrayBuffer.isView(t) && !(t instanceof DataView)
    }
    class va {
        constructor(t, e, n, i) {
            this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
        }
        evaluate(t) {
            const e = this.parameterPositions;
            let n = this._cachedIndex,
                i = e[n],
                r = e[n - 1];
            t: {
                e: {
                    let s; n: {
                        i: if (!(t < i)) {
                            for (let s = n + 2; ;) {
                                if (void 0 === i) {
                                    if (t < r) break i;
                                    return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                }
                                if (n === s) break;
                                if (r = i, i = e[++n], t < i) break e
                            }
                            s = e.length;
                            break n
                        } if (t >= r) break t;
                        {
                            const a = e[1];
                            t < a && (n = 2, r = a);
                            for (let s = n - 2; ;) {
                                if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                                if (n === s) break;
                                if (i = r, r = e[--n - 1], t >= r) break e
                            }
                            s = n, n = 0
                        }
                    }
                    for (; n < s;) {
                        const i = n + s >>> 1;
                        t < e[i] ? s = i : n = i + 1
                    }
                    if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0,
                        this.copySampleValue_(0);
                    if (void 0 === i) return n = e.length,
                        this._cachedIndex = n,
                        this.copySampleValue_(n - 1)
                }
                this._cachedIndex = n,
                    this.intervalChanged_(n, r, i)
            }
            return this.interpolate_(n, r, t, i)
        }
        getSettings_() {
            return this.settings || this.DefaultSettings_
        }
        copySampleValue_(t) {
            const e = this.resultBuffer,
                n = this.sampleValues,
                i = this.valueSize,
                r = t * i;
            for (let t = 0; t !== i; ++t) e[t] = n[r + t];
            return e
        }
        interpolate_() {
            throw new Error("call to abstract method")
        }
        intervalChanged_() { }
    }
    class ya extends va {
        constructor(t, e, n, i) {
            super(t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                endingStart: 2400,
                endingEnd: 2400
            }
        }
        intervalChanged_(t, e, n) {
            const i = this.parameterPositions;
            let r = t - 2,
                s = t + 1,
                a = i[r],
                o = i[s];
            if (void 0 === a) switch (this.getSettings_().endingStart) {
                case 2401:
                    r = t, a = 2 * e - n;
                    break;
                case 2402:
                    r = i.length - 2, a = e + i[r] - i[r + 1];
                    break;
                default:
                    r = t, a = n
            }
            if (void 0 === o) switch (this.getSettings_().endingEnd) {
                case 2401:
                    s = t, o = 2 * n - e;
                    break;
                case 2402:
                    s = 1, o = n + i[1] - i[0];
                    break;
                default:
                    s = t - 1, o = e
            }
            const l = .5 * (n - e),
                c = this.valueSize;
            this._weightPrev = l / (e - a), this._weightNext = l / (o - n), this._offsetPrev = r * c, this._offsetNext = s * c
        }
        interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
                s = this.sampleValues,
                a = this.valueSize,
                o = t * a,
                l = o - a,
                c = this._offsetPrev,
                h = this._offsetNext,
                u = this._weightPrev,
                d = this._weightNext,
                p = (n - e) / (i - e),
                f = p * p,
                m = f * p,
                g = -u * m + 2 * u * f - u * p,
                v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1,
                y = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                b = d * m - d * f;
            for (let t = 0; t !== a; ++t) r[t] = g * s[c + t] + v * s[l + t] + y * s[o + t] + b * s[h + t];
            return r
        }
    }
    class ba extends va {
        constructor(t, e, n, i) {
            super(t, e, n, i)
        }
        interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
                s = this.sampleValues,
                a = this.valueSize,
                o = t * a,
                l = o - a,
                c = (n - e) / (i - e),
                h = 1 - c;
            for (let t = 0; t !== a; ++t) r[t] = s[l + t] * h + s[o + t] * c;
            return r
        }
    }
    class xa extends va {
        constructor(t, e, n, i) {
            super(t, e, n, i)
        }
        interpolate_(t) {
            return this.copySampleValue_(t - 1)
        }
    }
    class _a {
        constructor(t, e, n, i) {
            if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
            this.name = t, this.times = ma(e, this.TimeBufferType), this.values = ma(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
        }
        static toJSON(t) {
            const e = t.constructor;
            let n;
            if (e.toJSON !== this.toJSON) n = e.toJSON(t);
            else {
                n = {
                    name: t.name,
                    times: ma(t.times, Array),
                    values: ma(t.values, Array)
                };
                const e = t.getInterpolation();
                e !== t.DefaultInterpolation && (n.interpolation = e)
            }
            return n.type = t.ValueTypeName, n
        }
        InterpolantFactoryMethodDiscrete(t) {
            return new xa(this.times, this.values, this.getValueSize(), t)
        }
        InterpolantFactoryMethodLinear(t) {
            return new ba(this.times, this.values, this.getValueSize(), t)
        }
        InterpolantFactoryMethodSmooth(t) {
            return new ya(this.times, this.values, this.getValueSize(), t)
        }
        setInterpolation(t) {
            let e;
            switch (t) {
                case 2300:
                    e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case 2301:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === e) {
                const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (t === this.DefaultInterpolation) throw new Error(e);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", e), this
            }
            return this.createInterpolant = e, this
        }
        getInterpolation() {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return 2300;
                case this.InterpolantFactoryMethodLinear:
                    return 2301;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
            }
        }
        getValueSize() {
            return this.values.length / this.times.length
        }
        shift(t) {
            if (0 !== t) {
                const e = this.times;
                for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
            }
            return this
        }
        scale(t) {
            if (1 !== t) {
                const e = this.times;
                for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
            }
            return this
        }
        trim(t, e) {
            const n = this.times,
                i = n.length;
            let r = 0,
                s = i - 1;
            for (; r !== i && n[r] < t;) ++r;
            for (; - 1 !== s && n[s] > e;) --s;
            if (++s, 0 !== r || s !== i) {
                r >= s && (s = Math.max(s, 1), r = s - 1);
                const t = this.getValueSize();
                this.times = fa(n, r, s), this.values = fa(this.values, r * t, s * t)
            }
            return this
        }
        validate() {
            let t = !0;
            const e = this.getValueSize();
            e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
            const n = this.times,
                i = this.values,
                r = n.length;
            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
            let s = null;
            for (let e = 0; e !== r; e++) {
                const i = n[e];
                if ("number" == typeof i && isNaN(i)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), t = !1;
                    break
                }
                if (null !== s && s > i) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s), t = !1;
                    break
                }
                s = i
            }
            if (void 0 !== i && ga(i))
                for (let e = 0, n = i.length; e !== n; ++e) {
                    const n = i[e];
                    if (isNaN(n)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                        break
                    }
                }
            return t
        }
        optimize() {
            const t = fa(this.times),
                e = fa(this.values),
                n = this.getValueSize(),
                i = 2302 === this.getInterpolation(),
                r = t.length - 1;
            let s = 1;
            for (let a = 1; a < r; ++a) {
                let r = !1;
                const o = t[a];
                if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                    if (i) r = !0;
                    else {
                        const t = a * n,
                            i = t - n,
                            s = t + n;
                        for (let a = 0; a !== n; ++a) {
                            const n = e[t + a];
                            if (n !== e[i + a] || n !== e[s + a]) {
                                r = !0;
                                break
                            }
                        }
                    } if (r) {
                        if (a !== s) {
                            t[s] = t[a];
                            const i = a * n,
                                r = s * n;
                            for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
                        } ++s
                    }
            }
            if (r > 0) {
                t[s] = t[r];
                for (let t = r * n, i = s * n, a = 0; a !== n; ++a) e[i + a] = e[t + a];
                ++s
            }
            return s !== t.length ? (this.times = fa(t, 0, s), this.values = fa(e, 0, s * n)) : (this.times = t, this.values = e), this
        }
        clone() {
            const t = fa(this.times, 0),
                e = fa(this.values, 0),
                n = new (0, this.constructor)(this.name, t, e);
            return n.createInterpolant = this.createInterpolant, n
        }
    }
    _a.prototype.TimeBufferType = Float32Array, _a.prototype.ValueBufferType = Float32Array, _a.prototype.DefaultInterpolation = 2301;
    class wa extends _a { }
    wa.prototype.ValueTypeName = "bool", wa.prototype.ValueBufferType = Array, wa.prototype.DefaultInterpolation = 2300, wa.prototype.InterpolantFactoryMethodLinear = void 0, wa.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Sa extends _a { }
    Sa.prototype.ValueTypeName = "color";
    class Ma extends _a { }
    Ma.prototype.ValueTypeName = "number";
    class Ea extends va {
        constructor(t, e, n, i) {
            super(t, e, n, i)
        }
        interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
                s = this.sampleValues,
                a = this.valueSize,
                o = (n - e) / (i - e);
            let l = t * a;
            for (let t = l + a; l !== t; l += 4) Dt.slerpFlat(r, 0, s, l - a, s, l, o);
            return r
        }
    }
    class Ta extends _a {
        InterpolantFactoryMethodLinear(t) {
            return new Ea(this.times, this.values, this.getValueSize(), t)
        }
    }
    Ta.prototype.ValueTypeName = "quaternion", Ta.prototype.DefaultInterpolation = 2301, Ta.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Ca extends _a { }
    Ca.prototype.ValueTypeName = "string", Ca.prototype.ValueBufferType = Array, Ca.prototype.DefaultInterpolation = 2300, Ca.prototype.InterpolantFactoryMethodLinear = void 0, Ca.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Aa extends _a { }
    Aa.prototype.ValueTypeName = "vector";
    const Ra = {
        enabled: !1,
        files: {},
        add: function (t, e) {
            !1 !== this.enabled && (this.files[t] = e)
        },
        get: function (t) {
            if (!1 !== this.enabled) return this.files[t]
        },
        remove: function (t) {
            delete this.files[t]
        },
        clear: function () {
            this.files = {}
        }
    };
    class Pa {
        constructor(t, e, n) {
            const i = this;
            let r = !1,
                s = 0,
                a = 0,
                o = void 0;
            const l = [];
            this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) {
                a++, !1 === r && void 0 !== i.onStart && i.onStart(t, s, a), r = !0
            }, this.itemEnd = function (t) {
                s++, void 0 !== i.onProgress && i.onProgress(t, s, a), s === a && (r = !1, void 0 !== i.onLoad && i.onLoad())
            }, this.itemError = function (t) {
                void 0 !== i.onError && i.onError(t)
            }, this.resolveURL = function (t) {
                return o ? o(t) : t
            }, this.setURLModifier = function (t) {
                return o = t, this
            }, this.addHandler = function (t, e) {
                return l.push(t, e), this
            }, this.removeHandler = function (t) {
                const e = l.indexOf(t);
                return -1 !== e && l.splice(e, 2), this
            }, this.getHandler = function (t) {
                for (let e = 0, n = l.length; e < n; e += 2) {
                    const n = l[e],
                        i = l[e + 1];
                    if (n.global && (n.lastIndex = 0), n.test(t)) return i
                }
                return null
            }
        }
    }
    const La = new Pa;
    class Oa {
        constructor(t) {
            this.manager = void 0 !== t ? t : La, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
        }
        load() { }
        loadAsync(t, e) {
            const n = this;
            return new Promise((function (i, r) {
                n.load(t, i, e, r)
            }))
        }
        parse() { }
        setCrossOrigin(t) {
            return this.crossOrigin = t, this
        }
        setWithCredentials(t) {
            return this.withCredentials = t, this
        }
        setPath(t) {
            return this.path = t, this
        }
        setResourcePath(t) {
            return this.resourcePath = t, this
        }
        setRequestHeader(t) {
            return this.requestHeader = t, this
        }
    }
    Oa.DEFAULT_MATERIAL_NAME = "__DEFAULT";
    const Da = {};
    class Ia extends Error {
        constructor(t, e) {
            super(t), this.response = e
        }
    }
    class ka extends Oa {
        constructor(t) {
            super(t)
        }
        load(t, e, n, i) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            const r = Ra.get(t);
            if (void 0 !== r) return this.manager.itemStart(t), setTimeout(() => {
                e && e(r), this.manager.itemEnd(t)
            }, 0), r;
            if (void 0 !== Da[t]) return void Da[t].push({
                onLoad: e,
                onProgress: n,
                onError: i
            });
            Da[t] = [], Da[t].push({
                onLoad: e,
                onProgress: n,
                onError: i
            });
            const s = new Request(t, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            }),
                a = this.mimeType,
                o = this.responseType;
            fetch(s).then(e => {
                if (200 === e.status || 0 === e.status) {
                    if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body || void 0 === e.body.getReader) return e;
                    const n = Da[t],
                        i = e.body.getReader(),
                        r = e.headers.get("Content-Length") || e.headers.get("X-File-Size"),
                        s = r ? parseInt(r) : 0,
                        a = 0 !== s;
                    let o = 0;
                    const l = new ReadableStream({
                        start(t) {
                            ! function e() {
                                i.read().then(({
                                    done: i,
                                    value: r
                                }) => {
                                    if (i) t.close();
                                    else {
                                        o += r.byteLength;
                                        const i = new ProgressEvent("progress", {
                                            lengthComputable: a,
                                            loaded: o,
                                            total: s
                                        });
                                        for (let t = 0, e = n.length; t < e; t++) {
                                            const e = n[t];
                                            e.onProgress && e.onProgress(i)
                                        }
                                        t.enqueue(r), e()
                                    }
                                })
                            }()
                        }
                    });
                    return new Response(l)
                }
                throw new Ia(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`, e)
            }).then(t => {
                switch (o) {
                    case "arraybuffer":
                        return t.arrayBuffer();
                    case "blob":
                        return t.blob();
                    case "document":
                        return t.text().then(t => (new DOMParser).parseFromString(t, a));
                    case "json":
                        return t.json();
                    default:
                        if (void 0 === a) return t.text();
                        {
                            const e = /charset="?([^;"\s]*)"?/i.exec(a),
                                n = e && e[1] ? e[1].toLowerCase() : void 0,
                                i = new TextDecoder(n);
                            return t.arrayBuffer().then(t => i.decode(t))
                        }
                }
            }).then(e => {
                Ra.add(t, e);
                const n = Da[t];
                delete Da[t];
                for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t];
                    i.onLoad && i.onLoad(e)
                }
            }).catch(e => {
                const n = Da[t];
                if (void 0 === n) throw this.manager.itemError(t), e;
                delete Da[t];
                for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t];
                    i.onError && i.onError(e)
                }
                this.manager.itemError(t)
            }).finally(() => {
                this.manager.itemEnd(t)
            }), this.manager.itemStart(t)
        }
        setResponseType(t) {
            return this.responseType = t, this
        }
        setMimeType(t) {
            return this.mimeType = t, this
        }
    }
    class Na extends Oa {
        constructor(t) {
            super(t)
        }
        load(t, e, n, i) {
            void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            const r = this,
                s = Ra.get(t);
            if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function () {
                e && e(s), r.manager.itemEnd(t)
            }), 0), s;
            const a = ut("img");

            function o() {
                c(), Ra.add(t, this), e && e(this), r.manager.itemEnd(t)
            }

            function l(e) {
                c(), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
            }

            function c() {
                a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1)
            }
            return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
        }
    }
    class Ua extends Oa {
        constructor(t) {
            super(t)
        }
        load(t, e, n, i) {
            const r = new Wn;
            r.colorSpace = V;
            const s = new Na(this.manager);
            s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
            let a = 0;

            function o(n) {
                s.load(t[n], (function (t) {
                    r.images[n] = t, a++, 6 === a && (r.needsUpdate = !0, e && e(r))
                }), void 0, i)
            }
            for (let e = 0; e < t.length; ++e) o(e);
            return r
        }
    }
    class za extends Oa {
        constructor(t) {
            super(t)
        }
        load(t, e, n, i) {
            const r = new Ct,
                s = new Na(this.manager);
            return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function (t) {
                r.image = t, r.needsUpdate = !0, void 0 !== e && e(r)
            }), n, i), r
        }
    }
    class Fa extends ke {
        constructor(t, e = 1) {
            super(), this.isLight = !0, this.type = "Light", this.color = new tn(t), this.intensity = e
        }
        dispose() { }
        copy(t, e) {
            return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
        }
    }
    const $a = new he,
        Ba = new It,
        Ha = new It;
    class ja {
        constructor(t) {
            this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ot(512, 512), this.map = null, this.mapPass = null, this.matrix = new he, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new ti, this._frameExtents = new ot(1, 1), this._viewportCount = 1, this._viewports = [new At(0, 0, 1, 1)]
        }
        getViewportCount() {
            return this._viewportCount
        }
        getFrustum() {
            return this._frustum
        }
        updateMatrices(t) {
            const e = this.camera,
                n = this.matrix;
            Ba.setFromMatrixPosition(t.matrixWorld), e.position.copy(Ba), Ha.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Ha), e.updateMatrixWorld(), $a.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix($a), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply($a)
        }
        getViewport(t) {
            return this._viewports[t]
        }
        getFrameExtents() {
            return this._frameExtents
        }
        dispose() {
            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
        }
        copy(t) {
            return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        toJSON() {
            const t = {};
            return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
        }
    }
    const Va = new he,
        Ga = new It,
        Wa = new It;
    class qa extends ja {
        constructor() {
            super(new Vn(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new ot(4, 2), this._viewportCount = 6, this._viewports = [new At(2, 1, 1, 1), new At(0, 1, 1, 1), new At(3, 1, 1, 1), new At(1, 1, 1, 1), new At(3, 0, 1, 1), new At(1, 0, 1, 1)], this._cubeDirections = [new It(1, 0, 0), new It(-1, 0, 0), new It(0, 0, 1), new It(0, 0, -1), new It(0, 1, 0), new It(0, -1, 0)], this._cubeUps = [new It(0, 1, 0), new It(0, 1, 0), new It(0, 1, 0), new It(0, 1, 0), new It(0, 0, 1), new It(0, 0, -1)]
        }
        updateMatrices(t, e = 0) {
            const n = this.camera,
                i = this.matrix,
                r = t.distance || n.far;
            r !== n.far && (n.far = r, n.updateProjectionMatrix()), Ga.setFromMatrixPosition(t.matrixWorld), n.position.copy(Ga), Wa.copy(n.position), Wa.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Wa), n.updateMatrixWorld(), i.makeTranslation(-Ga.x, -Ga.y, -Ga.z), Va.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Va)
        }
    }
    class Xa extends Fa {
        constructor(t, e, n = 0, i = 2) {
            super(t, e), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new qa
        }
        get power() {
            return 4 * this.intensity * Math.PI
        }
        set power(t) {
            this.intensity = t / (4 * Math.PI)
        }
        dispose() {
            this.shadow.dispose()
        }
        copy(t, e) {
            return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
        }
    }
    class Ya extends Fa {
        constructor(t, e) {
            super(t, e), this.isAmbientLight = !0, this.type = "AmbientLight"
        }
    }
    class Ka extends vn {
        constructor() {
            super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
        }
        copy(t) {
            return super.copy(t), this.instanceCount = t.instanceCount, this
        }
        toJSON() {
            const t = super.toJSON();
            return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
        }
    }
    class Za {
        constructor(t = !0) {
            this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
        }
        start() {
            this.startTime = Ja(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
        }
        stop() {
            this.getElapsedTime(), this.running = !1, this.autoStart = !1
        }
        getElapsedTime() {
            return this.getDelta(), this.elapsedTime
        }
        getDelta() {
            let t = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                const e = Ja();
                t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
            }
            return t
        }
    }

    function Ja() {
        return ("undefined" == typeof performance ? Date : performance).now()
    }
    const Qa = new RegExp("[\\[\\]\\.:\\/]", "g"),
        to = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        eo = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]") + /(WCOD+)?/.source.replace("WCOD", to) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]") + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]") + "$"),
        no = ["material", "materials", "bones", "map"];
    class io {
        constructor(t, e, n) {
            this.path = e, this.parsedPath = n || io.parseTrackName(e), this.node = io.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
        static create(t, e, n) {
            return t && t.isAnimationObjectGroup ? new io.Composite(t, e, n) : new io(t, e, n)
        }
        static sanitizeNodeName(t) {
            return t.replace(/\s/g, "_").replace(Qa, "")
        }
        static parseTrackName(t) {
            const e = eo.exec(t);
            if (null === e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            const n = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6]
            },
                i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
                const t = n.nodeName.substring(i + 1); - 1 !== no.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
            }
            if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
            return n
        }
        static findNode(t, e) {
            if (void 0 === e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
            if (t.skeleton) {
                const n = t.skeleton.getBoneByName(e);
                if (void 0 !== n) return n
            }
            if (t.children) {
                const n = function (t) {
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i];
                        if (r.name === e || r.uuid === e) return r;
                        const s = n(r.children);
                        if (s) return s
                    }
                    return null
                },
                    i = n(t.children);
                if (i) return i
            }
            return null
        }
        _getValue_unavailable() { }
        _setValue_unavailable() { }
        _getValue_direct(t, e) {
            t[e] = this.targetObject[this.propertyName]
        }
        _getValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
        }
        _getValue_arrayElement(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex]
        }
        _getValue_toArray(t, e) {
            this.resolvedProperty.toArray(t, e)
        }
        _setValue_direct(t, e) {
            this.targetObject[this.propertyName] = t[e]
        }
        _setValue_direct_setNeedsUpdate(t, e) {
            this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
            this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
        }
        _setValue_array_setNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
            this.targetObject.needsUpdate = !0
        }
        _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_arrayElement(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e]
        }
        _setValue_arrayElement_setNeedsUpdate(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _setValue_fromArray(t, e) {
            this.resolvedProperty.fromArray(t, e)
        }
        _setValue_fromArray_setNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
        }
        _getValue_unbound(t, e) {
            this.bind(), this.getValue(t, e)
        }
        _setValue_unbound(t, e) {
            this.bind(), this.setValue(t, e)
        }
        bind() {
            let t = this.node;
            const e = this.parsedPath,
                n = e.objectName,
                i = e.propertyName;
            let r = e.propertyIndex;
            if (t || (t = io.findNode(this.rootNode, e.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            if (n) {
                let i = e.objectIndex;
                switch (n) {
                    case "materials":
                        if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        t = t.skeleton.bones;
                        for (let e = 0; e < t.length; e++)
                            if (t[e].name === i) {
                                i = e;
                                break
                            } break;
                    case "map":
                        if ("map" in t) {
                            t = t.map;
                            break
                        }
                        if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        t = t.material.map;
                        break;
                    default:
                        if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        t = t[n]
                }
                if (void 0 !== i) {
                    if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                    t = t[i]
                }
            }
            const s = t[i];
            if (void 0 === s) {
                const n = e.nodeName;
                return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
            }
            let a = this.Versioning.None;
            this.targetObject = t, void 0 !== t.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
            let o = this.BindingType.Direct;
            if (void 0 !== r) {
                if ("morphTargetInfluences" === i) {
                    if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                }
                o = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
            } else void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
            this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
        }
        unbind() {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }
    io.Composite = class {
        constructor(t, e, n) {
            const i = n || io.parseTrackName(e);
            this._targetGroup = t, this._bindings = t.subscribe_(e, i)
        }
        getValue(t, e) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_,
                i = this._bindings[n];
            void 0 !== i && i.getValue(t, e)
        }
        setValue(t, e) {
            const n = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
        }
        bind() {
            const t = this._bindings;
            for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
        }
        unbind() {
            const t = this._bindings;
            for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
        }
    }, io.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    }, io.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    }, io.prototype.GetterByBindingType = [io.prototype._getValue_direct, io.prototype._getValue_array, io.prototype._getValue_arrayElement, io.prototype._getValue_toArray], io.prototype.SetterByBindingTypeAndVersioning = [
        [io.prototype._setValue_direct, io.prototype._setValue_direct_setNeedsUpdate, io.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
        [io.prototype._setValue_array, io.prototype._setValue_array_setNeedsUpdate, io.prototype._setValue_array_setMatrixWorldNeedsUpdate],
        [io.prototype._setValue_arrayElement, io.prototype._setValue_arrayElement_setNeedsUpdate, io.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
        [io.prototype._setValue_fromArray, io.prototype._setValue_fromArray_setNeedsUpdate, io.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
    ];
    new Float32Array(1);
    class ro {
        constructor(t) {
            this.value = t
        }
        clone() {
            return new ro(void 0 === this.value.clone ? this.value : this.value.clone())
        }
    }
    class so extends Us {
        constructor(t, e, n = 1) {
            super(t, e), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n
        }
        copy(t) {
            return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
        }
        clone(t) {
            const e = super.clone(t);
            return e.meshPerAttribute = this.meshPerAttribute, e
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
        }
    }
    class ao {
        constructor(t, e, n = 0, i = 1 / 0) {
            this.ray = new ce(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new _e, this.params = {
                Mesh: {},
                Line: {
                    threshold: 1
                },
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }
        }
        set(t, e) {
            this.ray.set(t, e)
        }
        setFromCamera(t, e) {
            e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
        }
        intersectObject(t, e = !0, n = []) {
            return lo(t, this, n, e), n.sort(oo), n
        }
        intersectObjects(t, e = !0, n = []) {
            for (let i = 0, r = t.length; i < r; i++) lo(t[i], this, n, e);
            return n.sort(oo), n
        }
    }

    function oo(t, e) {
        return t.distance - e.distance
    }

    function lo(t, e, n, i) {
        if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) {
            const i = t.children;
            for (let t = 0, r = i.length; t < r; t++) lo(i[t], e, n, !0)
        }
    }
    class co {
        constructor(t = 1, e = 0, n = 0) {
            return this.radius = t, this.phi = e, this.theta = n, this
        }
        set(t, e, n) {
            return this.radius = t, this.phi = e, this.theta = n, this
        }
        copy(t) {
            return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
        }
        makeSafe() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
        }
        setFromVector3(t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z)
        }
        setFromCartesianCoords(t, e, n) {
            return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(J(e / this.radius, -1, 1))), this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    const ho = new It,
        uo = new It;
    class po {
        constructor(t = new It, e = new It) {
            this.start = t, this.end = e
        }
        set(t, e) {
            return this.start.copy(t), this.end.copy(e), this
        }
        copy(t) {
            return this.start.copy(t.start), this.end.copy(t.end), this
        }
        getCenter(t) {
            return t.addVectors(this.start, this.end).multiplyScalar(.5)
        }
        delta(t) {
            return t.subVectors(this.end, this.start)
        }
        distanceSq() {
            return this.start.distanceToSquared(this.end)
        }
        distance() {
            return this.start.distanceTo(this.end)
        }
        at(t, e) {
            return this.delta(e).multiplyScalar(t).add(this.start)
        }
        closestPointToPointParameter(t, e) {
            ho.subVectors(t, this.start), uo.subVectors(this.end, this.start);
            const n = uo.dot(uo);
            let i = uo.dot(ho) / n;
            return e && (i = J(i, 0, 1)), i
        }
        closestPointToPoint(t, e, n) {
            const i = this.closestPointToPointParameter(t, e);
            return this.delta(n).multiplyScalar(i).add(this.start)
        }
        applyMatrix4(t) {
            return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
        }
        equals(t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    class fo extends kn {
        constructor(t, e, n) {
            super(new oa(e, 4, 2), new nn({
                wireframe: !0,
                fog: !1,
                toneMapped: !1
            })), this.light = t, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
        }
        dispose() {
            this.geometry.dispose(), this.material.dispose()
        }
        update() {
            this.light.updateWorldMatrix(!0, !1), void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
        }
    }
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
            revision: i
        }
    })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = i)
}, function (t, e, n) {
    "use strict";
    var i = n(2),
        r = n.n(i);
    window.$ = window.jQuery = r.a, e.a = r.a
}, function (t, e, n) {
    var i;
    /*!
     * jQuery JavaScript Library v3.6.1
     * https://jquery.com/
     *
     * Includes Sizzle.js
     * https://sizzlejs.com/
     *
     * Copyright OpenJS Foundation and other contributors
     * Released under the MIT license
     * https://jquery.org/license
     *
     * Date: 2022-08-26T17:52Z
     */
    ! function (e, n) {
        "use strict";
        "object" == typeof t.exports ? t.exports = e.document ? n(e, !0) : function (t) {
            if (!t.document) throw new Error("jQuery requires a window with a document");
            return n(t)
        } : n(e)
    }("undefined" != typeof window ? window : this, (function (n, r) {
        "use strict";
        var s = [],
            a = Object.getPrototypeOf,
            o = s.slice,
            l = s.flat ? function (t) {
                return s.flat.call(t)
            } : function (t) {
                return s.concat.apply([], t)
            },
            c = s.push,
            h = s.indexOf,
            u = {},
            d = u.toString,
            p = u.hasOwnProperty,
            f = p.toString,
            m = f.call(Object),
            g = {},
            v = function (t) {
                return "function" == typeof t && "number" != typeof t.nodeType && "function" != typeof t.item
            },
            y = function (t) {
                return null != t && t === t.window
            },
            b = n.document,
            x = {
                type: !0,
                src: !0,
                nonce: !0,
                noModule: !0
            };

        function _(t, e, n) {
            var i, r, s = (n = n || b).createElement("script");
            if (s.text = t, e)
                for (i in x) (r = e[i] || e.getAttribute && e.getAttribute(i)) && s.setAttribute(i, r);
            n.head.appendChild(s).parentNode.removeChild(s)
        }

        function w(t) {
            return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? u[d.call(t)] || "object" : typeof t
        }
        var S = function (t, e) {
            return new S.fn.init(t, e)
        };

        function M(t) {
            var e = !!t && "length" in t && t.length,
                n = w(t);
            return !v(t) && !y(t) && ("array" === n || 0 === e || "number" == typeof e && e > 0 && e - 1 in t)
        }
        S.fn = S.prototype = {
            jquery: "3.6.1",
            constructor: S,
            length: 0,
            toArray: function () {
                return o.call(this)
            },
            get: function (t) {
                return null == t ? o.call(this) : t < 0 ? this[t + this.length] : this[t]
            },
            pushStack: function (t) {
                var e = S.merge(this.constructor(), t);
                return e.prevObject = this, e
            },
            each: function (t) {
                return S.each(this, t)
            },
            map: function (t) {
                return this.pushStack(S.map(this, (function (e, n) {
                    return t.call(e, n, e)
                })))
            },
            slice: function () {
                return this.pushStack(o.apply(this, arguments))
            },
            first: function () {
                return this.eq(0)
            },
            last: function () {
                return this.eq(-1)
            },
            even: function () {
                return this.pushStack(S.grep(this, (function (t, e) {
                    return (e + 1) % 2
                })))
            },
            odd: function () {
                return this.pushStack(S.grep(this, (function (t, e) {
                    return e % 2
                })))
            },
            eq: function (t) {
                var e = this.length,
                    n = +t + (t < 0 ? e : 0);
                return this.pushStack(n >= 0 && n < e ? [this[n]] : [])
            },
            end: function () {
                return this.prevObject || this.constructor()
            },
            push: c,
            sort: s.sort,
            splice: s.splice
        }, S.extend = S.fn.extend = function () {
            var t, e, n, i, r, s, a = arguments[0] || {},
                o = 1,
                l = arguments.length,
                c = !1;
            for ("boolean" == typeof a && (c = a, a = arguments[o] || {}, o++), "object" == typeof a || v(a) || (a = {}), o === l && (a = this, o--); o < l; o++)
                if (null != (t = arguments[o]))
                    for (e in t) i = t[e], "__proto__" !== e && a !== i && (c && i && (S.isPlainObject(i) || (r = Array.isArray(i))) ? (n = a[e], s = r && !Array.isArray(n) ? [] : r || S.isPlainObject(n) ? n : {}, r = !1, a[e] = S.extend(c, s, i)) : void 0 !== i && (a[e] = i));
            return a
        }, S.extend({
            expando: "jQuery" + ("3.6.1" + Math.random()).replace(/\D/g, ""),
            isReady: !0,
            error: function (t) {
                throw new Error(t)
            },
            noop: function () { },
            isPlainObject: function (t) {
                var e, n;
                return !(!t || "[object Object]" !== d.call(t)) && (!(e = a(t)) || "function" == typeof (n = p.call(e, "constructor") && e.constructor) && f.call(n) === m)
            },
            isEmptyObject: function (t) {
                var e;
                for (e in t) return !1;
                return !0
            },
            globalEval: function (t, e, n) {
                _(t, {
                    nonce: e && e.nonce
                }, n)
            },
            each: function (t, e) {
                var n, i = 0;
                if (M(t))
                    for (n = t.length; i < n && !1 !== e.call(t[i], i, t[i]); i++);
                else
                    for (i in t)
                        if (!1 === e.call(t[i], i, t[i])) break;
                return t
            },
            makeArray: function (t, e) {
                var n = e || [];
                return null != t && (M(Object(t)) ? S.merge(n, "string" == typeof t ? [t] : t) : c.call(n, t)), n
            },
            inArray: function (t, e, n) {
                return null == e ? -1 : h.call(e, t, n)
            },
            merge: function (t, e) {
                for (var n = +e.length, i = 0, r = t.length; i < n; i++) t[r++] = e[i];
                return t.length = r, t
            },
            grep: function (t, e, n) {
                for (var i = [], r = 0, s = t.length, a = !n; r < s; r++) !e(t[r], r) !== a && i.push(t[r]);
                return i
            },
            map: function (t, e, n) {
                var i, r, s = 0,
                    a = [];
                if (M(t))
                    for (i = t.length; s < i; s++) null != (r = e(t[s], s, n)) && a.push(r);
                else
                    for (s in t) null != (r = e(t[s], s, n)) && a.push(r);
                return l(a)
            },
            guid: 1,
            support: g
        }), "function" == typeof Symbol && (S.fn[Symbol.iterator] = s[Symbol.iterator]), S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function (t, e) {
            u["[object " + e + "]"] = e.toLowerCase()
        }));
        var E =
            /*!
             * Sizzle CSS Selector Engine v2.3.6
             * https://sizzlejs.com/
             *
             * Copyright JS Foundation and other contributors
             * Released under the MIT license
             * https://js.foundation/
             *
             * Date: 2021-02-16
             */
            function (t) {
                var e, n, i, r, s, a, o, l, c, h, u, d, p, f, m, g, v, y, b, x = "sizzle" + 1 * new Date,
                    _ = t.document,
                    w = 0,
                    S = 0,
                    M = lt(),
                    E = lt(),
                    T = lt(),
                    C = lt(),
                    A = function (t, e) {
                        return t === e && (u = !0), 0
                    },
                    R = {}.hasOwnProperty,
                    P = [],
                    L = P.pop,
                    O = P.push,
                    D = P.push,
                    I = P.slice,
                    k = function (t, e) {
                        for (var n = 0, i = t.length; n < i; n++)
                            if (t[n] === e) return n;
                        return -1
                    },
                    N = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                    U = "[\\x20\\t\\r\\n\\f]",
                    z = "(?:\\\\[\\da-fA-F]{1,6}" + U + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
                    F = "\\[" + U + "*(" + z + ")(?:" + U + "*([*^$|!~]?=)" + U + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + z + "))|)" + U + "*\\]",
                    $ = ":(" + z + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + F + ")*)|.*)\\)|)",
                    B = new RegExp(U + "+", "g"),
                    H = new RegExp("^" + U + "+|((?:^|[^\\\\])(?:\\\\.)*)" + U + "+$", "g"),
                    j = new RegExp("^" + U + "*," + U + "*"),
                    V = new RegExp("^" + U + "*([>+~]|" + U + ")" + U + "*"),
                    G = new RegExp(U + "|>"),
                    W = new RegExp($),
                    q = new RegExp("^" + z + "$"),
                    X = {
                        ID: new RegExp("^#(" + z + ")"),
                        CLASS: new RegExp("^\\.(" + z + ")"),
                        TAG: new RegExp("^(" + z + "|[*])"),
                        ATTR: new RegExp("^" + F),
                        PSEUDO: new RegExp("^" + $),
                        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + U + "*(even|odd|(([+-]|)(\\d*)n|)" + U + "*(?:([+-]|)" + U + "*(\\d+)|))" + U + "*\\)|)", "i"),
                        bool: new RegExp("^(?:" + N + ")$", "i"),
                        needsContext: new RegExp("^" + U + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + U + "*((?:-\\d)?\\d*)" + U + "*\\)|)(?=[^-]|$)", "i")
                    },
                    Y = /HTML$/i,
                    K = /^(?:input|select|textarea|button)$/i,
                    Z = /^h\d$/i,
                    J = /^[^{]+\{\s*\[native \w/,
                    Q = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                    tt = /[+~]/,
                    et = new RegExp("\\\\[\\da-fA-F]{1,6}" + U + "?|\\\\([^\\r\\n\\f])", "g"),
                    nt = function (t, e) {
                        var n = "0x" + t.slice(1) - 65536;
                        return e || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
                    },
                    it = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                    rt = function (t, e) {
                        return e ? "\0" === t ? "�" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t
                    },
                    st = function () {
                        d()
                    },
                    at = xt((function (t) {
                        return !0 === t.disabled && "fieldset" === t.nodeName.toLowerCase()
                    }), {
                        dir: "parentNode",
                        next: "legend"
                    });
                try {
                    D.apply(P = I.call(_.childNodes), _.childNodes), P[_.childNodes.length].nodeType
                } catch (t) {
                    D = {
                        apply: P.length ? function (t, e) {
                            O.apply(t, I.call(e))
                        } : function (t, e) {
                            for (var n = t.length, i = 0; t[n++] = e[i++];);
                            t.length = n - 1
                        }
                    }
                }

                function ot(t, e, i, r) {
                    var s, o, c, h, u, f, v, y = e && e.ownerDocument,
                        _ = e ? e.nodeType : 9;
                    if (i = i || [], "string" != typeof t || !t || 1 !== _ && 9 !== _ && 11 !== _) return i;
                    if (!r && (d(e), e = e || p, m)) {
                        if (11 !== _ && (u = Q.exec(t)))
                            if (s = u[1]) {
                                if (9 === _) {
                                    if (!(c = e.getElementById(s))) return i;
                                    if (c.id === s) return i.push(c), i
                                } else if (y && (c = y.getElementById(s)) && b(e, c) && c.id === s) return i.push(c), i
                            } else {
                                if (u[2]) return D.apply(i, e.getElementsByTagName(t)), i;
                                if ((s = u[3]) && n.getElementsByClassName && e.getElementsByClassName) return D.apply(i, e.getElementsByClassName(s)), i
                            } if (n.qsa && !C[t + " "] && (!g || !g.test(t)) && (1 !== _ || "object" !== e.nodeName.toLowerCase())) {
                                if (v = t, y = e, 1 === _ && (G.test(t) || V.test(t))) {
                                    for ((y = tt.test(t) && vt(e.parentNode) || e) === e && n.scope || ((h = e.getAttribute("id")) ? h = h.replace(it, rt) : e.setAttribute("id", h = x)), o = (f = a(t)).length; o--;) f[o] = (h ? "#" + h : ":scope") + " " + bt(f[o]);
                                    v = f.join(",")
                                }
                                try {
                                    return D.apply(i, y.querySelectorAll(v)), i
                                } catch (e) {
                                    C(t, !0)
                                } finally {
                                    h === x && e.removeAttribute("id")
                                }
                            }
                    }
                    return l(t.replace(H, "$1"), e, i, r)
                }

                function lt() {
                    var t = [];
                    return function e(n, r) {
                        return t.push(n + " ") > i.cacheLength && delete e[t.shift()], e[n + " "] = r
                    }
                }

                function ct(t) {
                    return t[x] = !0, t
                }

                function ht(t) {
                    var e = p.createElement("fieldset");
                    try {
                        return !!t(e)
                    } catch (t) {
                        return !1
                    } finally {
                        e.parentNode && e.parentNode.removeChild(e), e = null
                    }
                }

                function ut(t, e) {
                    for (var n = t.split("|"), r = n.length; r--;) i.attrHandle[n[r]] = e
                }

                function dt(t, e) {
                    var n = e && t,
                        i = n && 1 === t.nodeType && 1 === e.nodeType && t.sourceIndex - e.sourceIndex;
                    if (i) return i;
                    if (n)
                        for (; n = n.nextSibling;)
                            if (n === e) return -1;
                    return t ? 1 : -1
                }

                function pt(t) {
                    return function (e) {
                        return "input" === e.nodeName.toLowerCase() && e.type === t
                    }
                }

                function ft(t) {
                    return function (e) {
                        var n = e.nodeName.toLowerCase();
                        return ("input" === n || "button" === n) && e.type === t
                    }
                }

                function mt(t) {
                    return function (e) {
                        return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && at(e) === t : e.disabled === t : "label" in e && e.disabled === t
                    }
                }

                function gt(t) {
                    return ct((function (e) {
                        return e = +e, ct((function (n, i) {
                            for (var r, s = t([], n.length, e), a = s.length; a--;) n[r = s[a]] && (n[r] = !(i[r] = n[r]))
                        }))
                    }))
                }

                function vt(t) {
                    return t && void 0 !== t.getElementsByTagName && t
                }
                for (e in n = ot.support = {}, s = ot.isXML = function (t) {
                    var e = t && t.namespaceURI,
                        n = t && (t.ownerDocument || t).documentElement;
                    return !Y.test(e || n && n.nodeName || "HTML")
                }, d = ot.setDocument = function (t) {
                    var e, r, a = t ? t.ownerDocument || t : _;
                    return a != p && 9 === a.nodeType && a.documentElement ? (f = (p = a).documentElement, m = !s(p), _ != p && (r = p.defaultView) && r.top !== r && (r.addEventListener ? r.addEventListener("unload", st, !1) : r.attachEvent && r.attachEvent("onunload", st)), n.scope = ht((function (t) {
                        return f.appendChild(t).appendChild(p.createElement("div")), void 0 !== t.querySelectorAll && !t.querySelectorAll(":scope fieldset div").length
                    })), n.attributes = ht((function (t) {
                        return t.className = "i", !t.getAttribute("className")
                    })), n.getElementsByTagName = ht((function (t) {
                        return t.appendChild(p.createComment("")), !t.getElementsByTagName("*").length
                    })), n.getElementsByClassName = J.test(p.getElementsByClassName), n.getById = ht((function (t) {
                        return f.appendChild(t).id = x, !p.getElementsByName || !p.getElementsByName(x).length
                    })), n.getById ? (i.filter.ID = function (t) {
                        var e = t.replace(et, nt);
                        return function (t) {
                            return t.getAttribute("id") === e
                        }
                    }, i.find.ID = function (t, e) {
                        if (void 0 !== e.getElementById && m) {
                            var n = e.getElementById(t);
                            return n ? [n] : []
                        }
                    }) : (i.filter.ID = function (t) {
                        var e = t.replace(et, nt);
                        return function (t) {
                            var n = void 0 !== t.getAttributeNode && t.getAttributeNode("id");
                            return n && n.value === e
                        }
                    }, i.find.ID = function (t, e) {
                        if (void 0 !== e.getElementById && m) {
                            var n, i, r, s = e.getElementById(t);
                            if (s) {
                                if ((n = s.getAttributeNode("id")) && n.value === t) return [s];
                                for (r = e.getElementsByName(t), i = 0; s = r[i++];)
                                    if ((n = s.getAttributeNode("id")) && n.value === t) return [s]
                            }
                            return []
                        }
                    }), i.find.TAG = n.getElementsByTagName ? function (t, e) {
                        return void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t) : n.qsa ? e.querySelectorAll(t) : void 0
                    } : function (t, e) {
                        var n, i = [],
                            r = 0,
                            s = e.getElementsByTagName(t);
                        if ("*" === t) {
                            for (; n = s[r++];) 1 === n.nodeType && i.push(n);
                            return i
                        }
                        return s
                    }, i.find.CLASS = n.getElementsByClassName && function (t, e) {
                        if (void 0 !== e.getElementsByClassName && m) return e.getElementsByClassName(t)
                    }, v = [], g = [], (n.qsa = J.test(p.querySelectorAll)) && (ht((function (t) {
                        var e;
                        f.appendChild(t).innerHTML = "<a id='" + x + "'></a><select id='" + x + "-\r\\' msallowcapture=''><option selected=''></option></select>", t.querySelectorAll("[msallowcapture^='']").length && g.push("[*^$]=" + U + "*(?:''|\"\")"), t.querySelectorAll("[selected]").length || g.push("\\[" + U + "*(?:value|" + N + ")"), t.querySelectorAll("[id~=" + x + "-]").length || g.push("~="), (e = p.createElement("input")).setAttribute("name", ""), t.appendChild(e), t.querySelectorAll("[name='']").length || g.push("\\[" + U + "*name" + U + "*=" + U + "*(?:''|\"\")"), t.querySelectorAll(":checked").length || g.push(":checked"), t.querySelectorAll("a#" + x + "+*").length || g.push(".#.+[+~]"), t.querySelectorAll("\\\f"), g.push("[\\r\\n\\f]")
                    })), ht((function (t) {
                        t.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                        var e = p.createElement("input");
                        e.setAttribute("type", "hidden"), t.appendChild(e).setAttribute("name", "D"), t.querySelectorAll("[name=d]").length && g.push("name" + U + "*[*^$|!~]?="), 2 !== t.querySelectorAll(":enabled").length && g.push(":enabled", ":disabled"), f.appendChild(t).disabled = !0, 2 !== t.querySelectorAll(":disabled").length && g.push(":enabled", ":disabled"), t.querySelectorAll("*,:x"), g.push(",.*:")
                    }))), (n.matchesSelector = J.test(y = f.matches || f.webkitMatchesSelector || f.mozMatchesSelector || f.oMatchesSelector || f.msMatchesSelector)) && ht((function (t) {
                        n.disconnectedMatch = y.call(t, "*"), y.call(t, "[s!='']:x"), v.push("!=", $)
                    })), g = g.length && new RegExp(g.join("|")), v = v.length && new RegExp(v.join("|")), e = J.test(f.compareDocumentPosition), b = e || J.test(f.contains) ? function (t, e) {
                        var n = 9 === t.nodeType ? t.documentElement : t,
                            i = e && e.parentNode;
                        return t === i || !(!i || 1 !== i.nodeType || !(n.contains ? n.contains(i) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(i)))
                    } : function (t, e) {
                        if (e)
                            for (; e = e.parentNode;)
                                if (e === t) return !0;
                        return !1
                    }, A = e ? function (t, e) {
                        if (t === e) return u = !0, 0;
                        var i = !t.compareDocumentPosition - !e.compareDocumentPosition;
                        return i || (1 & (i = (t.ownerDocument || t) == (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1) || !n.sortDetached && e.compareDocumentPosition(t) === i ? t == p || t.ownerDocument == _ && b(_, t) ? -1 : e == p || e.ownerDocument == _ && b(_, e) ? 1 : h ? k(h, t) - k(h, e) : 0 : 4 & i ? -1 : 1)
                    } : function (t, e) {
                        if (t === e) return u = !0, 0;
                        var n, i = 0,
                            r = t.parentNode,
                            s = e.parentNode,
                            a = [t],
                            o = [e];
                        if (!r || !s) return t == p ? -1 : e == p ? 1 : r ? -1 : s ? 1 : h ? k(h, t) - k(h, e) : 0;
                        if (r === s) return dt(t, e);
                        for (n = t; n = n.parentNode;) a.unshift(n);
                        for (n = e; n = n.parentNode;) o.unshift(n);
                        for (; a[i] === o[i];) i++;
                        return i ? dt(a[i], o[i]) : a[i] == _ ? -1 : o[i] == _ ? 1 : 0
                    }, p) : p
                }, ot.matches = function (t, e) {
                    return ot(t, null, null, e)
                }, ot.matchesSelector = function (t, e) {
                    if (d(t), n.matchesSelector && m && !C[e + " "] && (!v || !v.test(e)) && (!g || !g.test(e))) try {
                        var i = y.call(t, e);
                        if (i || n.disconnectedMatch || t.document && 11 !== t.document.nodeType) return i
                    } catch (t) {
                        C(e, !0)
                    }
                    return ot(e, p, null, [t]).length > 0
                }, ot.contains = function (t, e) {
                    return (t.ownerDocument || t) != p && d(t), b(t, e)
                }, ot.attr = function (t, e) {
                    (t.ownerDocument || t) != p && d(t);
                    var r = i.attrHandle[e.toLowerCase()],
                        s = r && R.call(i.attrHandle, e.toLowerCase()) ? r(t, e, !m) : void 0;
                    return void 0 !== s ? s : n.attributes || !m ? t.getAttribute(e) : (s = t.getAttributeNode(e)) && s.specified ? s.value : null
                }, ot.escape = function (t) {
                    return (t + "").replace(it, rt)
                }, ot.error = function (t) {
                    throw new Error("Syntax error, unrecognized expression: " + t)
                }, ot.uniqueSort = function (t) {
                    var e, i = [],
                        r = 0,
                        s = 0;
                    if (u = !n.detectDuplicates, h = !n.sortStable && t.slice(0), t.sort(A), u) {
                        for (; e = t[s++];) e === t[s] && (r = i.push(s));
                        for (; r--;) t.splice(i[r], 1)
                    }
                    return h = null, t
                }, r = ot.getText = function (t) {
                    var e, n = "",
                        i = 0,
                        s = t.nodeType;
                    if (s) {
                        if (1 === s || 9 === s || 11 === s) {
                            if ("string" == typeof t.textContent) return t.textContent;
                            for (t = t.firstChild; t; t = t.nextSibling) n += r(t)
                        } else if (3 === s || 4 === s) return t.nodeValue
                    } else
                        for (; e = t[i++];) n += r(e);
                    return n
                }, (i = ot.selectors = {
                    cacheLength: 50,
                    createPseudo: ct,
                    match: X,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: !0
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: !0
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: function (t) {
                            return t[1] = t[1].replace(et, nt), t[3] = (t[3] || t[4] || t[5] || "").replace(et, nt), "~=" === t[2] && (t[3] = " " + t[3] + " "), t.slice(0, 4)
                        },
                        CHILD: function (t) {
                            return t[1] = t[1].toLowerCase(), "nth" === t[1].slice(0, 3) ? (t[3] || ot.error(t[0]), t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])), t[5] = +(t[7] + t[8] || "odd" === t[3])) : t[3] && ot.error(t[0]), t
                        },
                        PSEUDO: function (t) {
                            var e, n = !t[6] && t[2];
                            return X.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || "" : n && W.test(n) && (e = a(n, !0)) && (e = n.indexOf(")", n.length - e) - n.length) && (t[0] = t[0].slice(0, e), t[2] = n.slice(0, e)), t.slice(0, 3))
                        }
                    },
                    filter: {
                        TAG: function (t) {
                            var e = t.replace(et, nt).toLowerCase();
                            return "*" === t ? function () {
                                return !0
                            } : function (t) {
                                return t.nodeName && t.nodeName.toLowerCase() === e
                            }
                        },
                        CLASS: function (t) {
                            var e = M[t + " "];
                            return e || (e = new RegExp("(^|" + U + ")" + t + "(" + U + "|$)")) && M(t, (function (t) {
                                return e.test("string" == typeof t.className && t.className || void 0 !== t.getAttribute && t.getAttribute("class") || "")
                            }))
                        },
                        ATTR: function (t, e, n) {
                            return function (i) {
                                var r = ot.attr(i, t);
                                return null == r ? "!=" === e : !e || (r += "", "=" === e ? r === n : "!=" === e ? r !== n : "^=" === e ? n && 0 === r.indexOf(n) : "*=" === e ? n && r.indexOf(n) > -1 : "$=" === e ? n && r.slice(-n.length) === n : "~=" === e ? (" " + r.replace(B, " ") + " ").indexOf(n) > -1 : "|=" === e && (r === n || r.slice(0, n.length + 1) === n + "-"))
                            }
                        },
                        CHILD: function (t, e, n, i, r) {
                            var s = "nth" !== t.slice(0, 3),
                                a = "last" !== t.slice(-4),
                                o = "of-type" === e;
                            return 1 === i && 0 === r ? function (t) {
                                return !!t.parentNode
                            } : function (e, n, l) {
                                var c, h, u, d, p, f, m = s !== a ? "nextSibling" : "previousSibling",
                                    g = e.parentNode,
                                    v = o && e.nodeName.toLowerCase(),
                                    y = !l && !o,
                                    b = !1;
                                if (g) {
                                    if (s) {
                                        for (; m;) {
                                            for (d = e; d = d[m];)
                                                if (o ? d.nodeName.toLowerCase() === v : 1 === d.nodeType) return !1;
                                            f = m = "only" === t && !f && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (f = [a ? g.firstChild : g.lastChild], a && y) {
                                        for (b = (p = (c = (h = (u = (d = g)[x] || (d[x] = {}))[d.uniqueID] || (u[d.uniqueID] = {}))[t] || [])[0] === w && c[1]) && c[2], d = p && g.childNodes[p]; d = ++p && d && d[m] || (b = p = 0) || f.pop();)
                                            if (1 === d.nodeType && ++b && d === e) {
                                                h[t] = [w, p, b];
                                                break
                                            }
                                    } else if (y && (b = p = (c = (h = (u = (d = e)[x] || (d[x] = {}))[d.uniqueID] || (u[d.uniqueID] = {}))[t] || [])[0] === w && c[1]), !1 === b)
                                        for (;
                                            (d = ++p && d && d[m] || (b = p = 0) || f.pop()) && ((o ? d.nodeName.toLowerCase() !== v : 1 !== d.nodeType) || !++b || (y && ((h = (u = d[x] || (d[x] = {}))[d.uniqueID] || (u[d.uniqueID] = {}))[t] = [w, b]), d !== e)););
                                    return (b -= r) === i || b % i == 0 && b / i >= 0
                                }
                            }
                        },
                        PSEUDO: function (t, e) {
                            var n, r = i.pseudos[t] || i.setFilters[t.toLowerCase()] || ot.error("unsupported pseudo: " + t);
                            return r[x] ? r(e) : r.length > 1 ? (n = [t, t, "", e], i.setFilters.hasOwnProperty(t.toLowerCase()) ? ct((function (t, n) {
                                for (var i, s = r(t, e), a = s.length; a--;) t[i = k(t, s[a])] = !(n[i] = s[a])
                            })) : function (t) {
                                return r(t, 0, n)
                            }) : r
                        }
                    },
                    pseudos: {
                        not: ct((function (t) {
                            var e = [],
                                n = [],
                                i = o(t.replace(H, "$1"));
                            return i[x] ? ct((function (t, e, n, r) {
                                for (var s, a = i(t, null, r, []), o = t.length; o--;)(s = a[o]) && (t[o] = !(e[o] = s))
                            })) : function (t, r, s) {
                                return e[0] = t, i(e, null, s, n), e[0] = null, !n.pop()
                            }
                        })),
                        has: ct((function (t) {
                            return function (e) {
                                return ot(t, e).length > 0
                            }
                        })),
                        contains: ct((function (t) {
                            return t = t.replace(et, nt),
                                function (e) {
                                    return (e.textContent || r(e)).indexOf(t) > -1
                                }
                        })),
                        lang: ct((function (t) {
                            return q.test(t || "") || ot.error("unsupported lang: " + t), t = t.replace(et, nt).toLowerCase(),
                                function (e) {
                                    var n;
                                    do {
                                        if (n = m ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (n = n.toLowerCase()) === t || 0 === n.indexOf(t + "-")
                                    } while ((e = e.parentNode) && 1 === e.nodeType);
                                    return !1
                                }
                        })),
                        target: function (e) {
                            var n = t.location && t.location.hash;
                            return n && n.slice(1) === e.id
                        },
                        root: function (t) {
                            return t === f
                        },
                        focus: function (t) {
                            return t === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(t.type || t.href || ~t.tabIndex)
                        },
                        enabled: mt(!1),
                        disabled: mt(!0),
                        checked: function (t) {
                            var e = t.nodeName.toLowerCase();
                            return "input" === e && !!t.checked || "option" === e && !!t.selected
                        },
                        selected: function (t) {
                            return t.parentNode && t.parentNode.selectedIndex, !0 === t.selected
                        },
                        empty: function (t) {
                            for (t = t.firstChild; t; t = t.nextSibling)
                                if (t.nodeType < 6) return !1;
                            return !0
                        },
                        parent: function (t) {
                            return !i.pseudos.empty(t)
                        },
                        header: function (t) {
                            return Z.test(t.nodeName)
                        },
                        input: function (t) {
                            return K.test(t.nodeName)
                        },
                        button: function (t) {
                            var e = t.nodeName.toLowerCase();
                            return "input" === e && "button" === t.type || "button" === e
                        },
                        text: function (t) {
                            var e;
                            return "input" === t.nodeName.toLowerCase() && "text" === t.type && (null == (e = t.getAttribute("type")) || "text" === e.toLowerCase())
                        },
                        first: gt((function () {
                            return [0]
                        })),
                        last: gt((function (t, e) {
                            return [e - 1]
                        })),
                        eq: gt((function (t, e, n) {
                            return [n < 0 ? n + e : n]
                        })),
                        even: gt((function (t, e) {
                            for (var n = 0; n < e; n += 2) t.push(n);
                            return t
                        })),
                        odd: gt((function (t, e) {
                            for (var n = 1; n < e; n += 2) t.push(n);
                            return t
                        })),
                        lt: gt((function (t, e, n) {
                            for (var i = n < 0 ? n + e : n > e ? e : n; --i >= 0;) t.push(i);
                            return t
                        })),
                        gt: gt((function (t, e, n) {
                            for (var i = n < 0 ? n + e : n; ++i < e;) t.push(i);
                            return t
                        }))
                    }
                }).pseudos.nth = i.pseudos.eq, {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                }) i.pseudos[e] = pt(e);
                for (e in {
                    submit: !0,
                    reset: !0
                }) i.pseudos[e] = ft(e);

                function yt() { }

                function bt(t) {
                    for (var e = 0, n = t.length, i = ""; e < n; e++) i += t[e].value;
                    return i
                }

                function xt(t, e, n) {
                    var i = e.dir,
                        r = e.next,
                        s = r || i,
                        a = n && "parentNode" === s,
                        o = S++;
                    return e.first ? function (e, n, r) {
                        for (; e = e[i];)
                            if (1 === e.nodeType || a) return t(e, n, r);
                        return !1
                    } : function (e, n, l) {
                        var c, h, u, d = [w, o];
                        if (l) {
                            for (; e = e[i];)
                                if ((1 === e.nodeType || a) && t(e, n, l)) return !0
                        } else
                            for (; e = e[i];)
                                if (1 === e.nodeType || a)
                                    if (h = (u = e[x] || (e[x] = {}))[e.uniqueID] || (u[e.uniqueID] = {}), r && r === e.nodeName.toLowerCase()) e = e[i] || e;
                                    else {
                                        if ((c = h[s]) && c[0] === w && c[1] === o) return d[2] = c[2];
                                        if (h[s] = d, d[2] = t(e, n, l)) return !0
                                    } return !1
                    }
                }

                function _t(t) {
                    return t.length > 1 ? function (e, n, i) {
                        for (var r = t.length; r--;)
                            if (!t[r](e, n, i)) return !1;
                        return !0
                    } : t[0]
                }

                function wt(t, e, n, i, r) {
                    for (var s, a = [], o = 0, l = t.length, c = null != e; o < l; o++)(s = t[o]) && (n && !n(s, i, r) || (a.push(s), c && e.push(o)));
                    return a
                }

                function St(t, e, n, i, r, s) {
                    return i && !i[x] && (i = St(i)), r && !r[x] && (r = St(r, s)), ct((function (s, a, o, l) {
                        var c, h, u, d = [],
                            p = [],
                            f = a.length,
                            m = s || function (t, e, n) {
                                for (var i = 0, r = e.length; i < r; i++) ot(t, e[i], n);
                                return n
                            }(e || "*", o.nodeType ? [o] : o, []),
                            g = !t || !s && e ? m : wt(m, d, t, o, l),
                            v = n ? r || (s ? t : f || i) ? [] : a : g;
                        if (n && n(g, v, o, l), i)
                            for (c = wt(v, p), i(c, [], o, l), h = c.length; h--;)(u = c[h]) && (v[p[h]] = !(g[p[h]] = u));
                        if (s) {
                            if (r || t) {
                                if (r) {
                                    for (c = [], h = v.length; h--;)(u = v[h]) && c.push(g[h] = u);
                                    r(null, v = [], c, l)
                                }
                                for (h = v.length; h--;)(u = v[h]) && (c = r ? k(s, u) : d[h]) > -1 && (s[c] = !(a[c] = u))
                            }
                        } else v = wt(v === a ? v.splice(f, v.length) : v), r ? r(null, a, v, l) : D.apply(a, v)
                    }))
                }

                function Mt(t) {
                    for (var e, n, r, s = t.length, a = i.relative[t[0].type], o = a || i.relative[" "], l = a ? 1 : 0, h = xt((function (t) {
                        return t === e
                    }), o, !0), u = xt((function (t) {
                        return k(e, t) > -1
                    }), o, !0), d = [function (t, n, i) {
                        var r = !a && (i || n !== c) || ((e = n).nodeType ? h(t, n, i) : u(t, n, i));
                        return e = null, r
                    }]; l < s; l++)
                        if (n = i.relative[t[l].type]) d = [xt(_t(d), n)];
                        else {
                            if ((n = i.filter[t[l].type].apply(null, t[l].matches))[x]) {
                                for (r = ++l; r < s && !i.relative[t[r].type]; r++);
                                return St(l > 1 && _t(d), l > 1 && bt(t.slice(0, l - 1).concat({
                                    value: " " === t[l - 2].type ? "*" : ""
                                })).replace(H, "$1"), n, l < r && Mt(t.slice(l, r)), r < s && Mt(t = t.slice(r)), r < s && bt(t))
                            }
                            d.push(n)
                        } return _t(d)
                }
                return yt.prototype = i.filters = i.pseudos, i.setFilters = new yt, a = ot.tokenize = function (t, e) {
                    var n, r, s, a, o, l, c, h = E[t + " "];
                    if (h) return e ? 0 : h.slice(0);
                    for (o = t, l = [], c = i.preFilter; o;) {
                        for (a in n && !(r = j.exec(o)) || (r && (o = o.slice(r[0].length) || o), l.push(s = [])), n = !1, (r = V.exec(o)) && (n = r.shift(), s.push({
                            value: n,
                            type: r[0].replace(H, " ")
                        }), o = o.slice(n.length)), i.filter) !(r = X[a].exec(o)) || c[a] && !(r = c[a](r)) || (n = r.shift(), s.push({
                            value: n,
                            type: a,
                            matches: r
                        }), o = o.slice(n.length));
                        if (!n) break
                    }
                    return e ? o.length : o ? ot.error(t) : E(t, l).slice(0)
                }, o = ot.compile = function (t, e) {
                    var n, r = [],
                        s = [],
                        o = T[t + " "];
                    if (!o) {
                        for (e || (e = a(t)), n = e.length; n--;)(o = Mt(e[n]))[x] ? r.push(o) : s.push(o);
                        (o = T(t, function (t, e) {
                            var n = e.length > 0,
                                r = t.length > 0,
                                s = function (s, a, o, l, h) {
                                    var u, f, g, v = 0,
                                        y = "0",
                                        b = s && [],
                                        x = [],
                                        _ = c,
                                        S = s || r && i.find.TAG("*", h),
                                        M = w += null == _ ? 1 : Math.random() || .1,
                                        E = S.length;
                                    for (h && (c = a == p || a || h); y !== E && null != (u = S[y]); y++) {
                                        if (r && u) {
                                            for (f = 0, a || u.ownerDocument == p || (d(u), o = !m); g = t[f++];)
                                                if (g(u, a || p, o)) {
                                                    l.push(u);
                                                    break
                                                } h && (w = M)
                                        }
                                        n && ((u = !g && u) && v--, s && b.push(u))
                                    }
                                    if (v += y, n && y !== v) {
                                        for (f = 0; g = e[f++];) g(b, x, a, o);
                                        if (s) {
                                            if (v > 0)
                                                for (; y--;) b[y] || x[y] || (x[y] = L.call(l));
                                            x = wt(x)
                                        }
                                        D.apply(l, x), h && !s && x.length > 0 && v + e.length > 1 && ot.uniqueSort(l)
                                    }
                                    return h && (w = M, c = _), b
                                };
                            return n ? ct(s) : s
                        }(s, r))).selector = t
                    }
                    return o
                }, l = ot.select = function (t, e, n, r) {
                    var s, l, c, h, u, d = "function" == typeof t && t,
                        p = !r && a(t = d.selector || t);
                    if (n = n || [], 1 === p.length) {
                        if ((l = p[0] = p[0].slice(0)).length > 2 && "ID" === (c = l[0]).type && 9 === e.nodeType && m && i.relative[l[1].type]) {
                            if (!(e = (i.find.ID(c.matches[0].replace(et, nt), e) || [])[0])) return n;
                            d && (e = e.parentNode), t = t.slice(l.shift().value.length)
                        }
                        for (s = X.needsContext.test(t) ? 0 : l.length; s-- && (c = l[s], !i.relative[h = c.type]);)
                            if ((u = i.find[h]) && (r = u(c.matches[0].replace(et, nt), tt.test(l[0].type) && vt(e.parentNode) || e))) {
                                if (l.splice(s, 1), !(t = r.length && bt(l))) return D.apply(n, r), n;
                                break
                            }
                    }
                    return (d || o(t, p))(r, e, !m, n, !e || tt.test(t) && vt(e.parentNode) || e), n
                }, n.sortStable = x.split("").sort(A).join("") === x, n.detectDuplicates = !!u, d(), n.sortDetached = ht((function (t) {
                    return 1 & t.compareDocumentPosition(p.createElement("fieldset"))
                })), ht((function (t) {
                    return t.innerHTML = "<a href='#'></a>", "#" === t.firstChild.getAttribute("href")
                })) || ut("type|href|height|width", (function (t, e, n) {
                    if (!n) return t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2)
                })), n.attributes && ht((function (t) {
                    return t.innerHTML = "<input/>", t.firstChild.setAttribute("value", ""), "" === t.firstChild.getAttribute("value")
                })) || ut("value", (function (t, e, n) {
                    if (!n && "input" === t.nodeName.toLowerCase()) return t.defaultValue
                })), ht((function (t) {
                    return null == t.getAttribute("disabled")
                })) || ut(N, (function (t, e, n) {
                    var i;
                    if (!n) return !0 === t[e] ? e.toLowerCase() : (i = t.getAttributeNode(e)) && i.specified ? i.value : null
                })), ot
            }(n);
        S.find = E, S.expr = E.selectors, S.expr[":"] = S.expr.pseudos, S.uniqueSort = S.unique = E.uniqueSort, S.text = E.getText, S.isXMLDoc = E.isXML, S.contains = E.contains, S.escapeSelector = E.escape;
        var T = function (t, e, n) {
            for (var i = [], r = void 0 !== n;
                (t = t[e]) && 9 !== t.nodeType;)
                if (1 === t.nodeType) {
                    if (r && S(t).is(n)) break;
                    i.push(t)
                } return i
        },
            C = function (t, e) {
                for (var n = []; t; t = t.nextSibling) 1 === t.nodeType && t !== e && n.push(t);
                return n
            },
            A = S.expr.match.needsContext;

        function R(t, e) {
            return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase()
        }
        var P = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

        function L(t, e, n) {
            return v(e) ? S.grep(t, (function (t, i) {
                return !!e.call(t, i, t) !== n
            })) : e.nodeType ? S.grep(t, (function (t) {
                return t === e !== n
            })) : "string" != typeof e ? S.grep(t, (function (t) {
                return h.call(e, t) > -1 !== n
            })) : S.filter(e, t, n)
        }
        S.filter = function (t, e, n) {
            var i = e[0];
            return n && (t = ":not(" + t + ")"), 1 === e.length && 1 === i.nodeType ? S.find.matchesSelector(i, t) ? [i] : [] : S.find.matches(t, S.grep(e, (function (t) {
                return 1 === t.nodeType
            })))
        }, S.fn.extend({
            find: function (t) {
                var e, n, i = this.length,
                    r = this;
                if ("string" != typeof t) return this.pushStack(S(t).filter((function () {
                    for (e = 0; e < i; e++)
                        if (S.contains(r[e], this)) return !0
                })));
                for (n = this.pushStack([]), e = 0; e < i; e++) S.find(t, r[e], n);
                return i > 1 ? S.uniqueSort(n) : n
            },
            filter: function (t) {
                return this.pushStack(L(this, t || [], !1))
            },
            not: function (t) {
                return this.pushStack(L(this, t || [], !0))
            },
            is: function (t) {
                return !!L(this, "string" == typeof t && A.test(t) ? S(t) : t || [], !1).length
            }
        });
        var O, D = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
        (S.fn.init = function (t, e, n) {
            var i, r;
            if (!t) return this;
            if (n = n || O, "string" == typeof t) {
                if (!(i = "<" === t[0] && ">" === t[t.length - 1] && t.length >= 3 ? [null, t, null] : D.exec(t)) || !i[1] && e) return !e || e.jquery ? (e || n).find(t) : this.constructor(e).find(t);
                if (i[1]) {
                    if (e = e instanceof S ? e[0] : e, S.merge(this, S.parseHTML(i[1], e && e.nodeType ? e.ownerDocument || e : b, !0)), P.test(i[1]) && S.isPlainObject(e))
                        for (i in e) v(this[i]) ? this[i](e[i]) : this.attr(i, e[i]);
                    return this
                }
                return (r = b.getElementById(i[2])) && (this[0] = r, this.length = 1), this
            }
            return t.nodeType ? (this[0] = t, this.length = 1, this) : v(t) ? void 0 !== n.ready ? n.ready(t) : t(S) : S.makeArray(t, this)
        }).prototype = S.fn, O = S(b);
        var I = /^(?:parents|prev(?:Until|All))/,
            k = {
                children: !0,
                contents: !0,
                next: !0,
                prev: !0
            };

        function N(t, e) {
            for (;
                (t = t[e]) && 1 !== t.nodeType;);
            return t
        }
        S.fn.extend({
            has: function (t) {
                var e = S(t, this),
                    n = e.length;
                return this.filter((function () {
                    for (var t = 0; t < n; t++)
                        if (S.contains(this, e[t])) return !0
                }))
            },
            closest: function (t, e) {
                var n, i = 0,
                    r = this.length,
                    s = [],
                    a = "string" != typeof t && S(t);
                if (!A.test(t))
                    for (; i < r; i++)
                        for (n = this[i]; n && n !== e; n = n.parentNode)
                            if (n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && S.find.matchesSelector(n, t))) {
                                s.push(n);
                                break
                            } return this.pushStack(s.length > 1 ? S.uniqueSort(s) : s)
            },
            index: function (t) {
                return t ? "string" == typeof t ? h.call(S(t), this[0]) : h.call(this, t.jquery ? t[0] : t) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            },
            add: function (t, e) {
                return this.pushStack(S.uniqueSort(S.merge(this.get(), S(t, e))))
            },
            addBack: function (t) {
                return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
            }
        }), S.each({
            parent: function (t) {
                var e = t.parentNode;
                return e && 11 !== e.nodeType ? e : null
            },
            parents: function (t) {
                return T(t, "parentNode")
            },
            parentsUntil: function (t, e, n) {
                return T(t, "parentNode", n)
            },
            next: function (t) {
                return N(t, "nextSibling")
            },
            prev: function (t) {
                return N(t, "previousSibling")
            },
            nextAll: function (t) {
                return T(t, "nextSibling")
            },
            prevAll: function (t) {
                return T(t, "previousSibling")
            },
            nextUntil: function (t, e, n) {
                return T(t, "nextSibling", n)
            },
            prevUntil: function (t, e, n) {
                return T(t, "previousSibling", n)
            },
            siblings: function (t) {
                return C((t.parentNode || {}).firstChild, t)
            },
            children: function (t) {
                return C(t.firstChild)
            },
            contents: function (t) {
                return null != t.contentDocument && a(t.contentDocument) ? t.contentDocument : (R(t, "template") && (t = t.content || t), S.merge([], t.childNodes))
            }
        }, (function (t, e) {
            S.fn[t] = function (n, i) {
                var r = S.map(this, e, n);
                return "Until" !== t.slice(-5) && (i = n), i && "string" == typeof i && (r = S.filter(i, r)), this.length > 1 && (k[t] || S.uniqueSort(r), I.test(t) && r.reverse()), this.pushStack(r)
            }
        }));
        var U = /[^\x20\t\r\n\f]+/g;

        function z(t) {
            return t
        }

        function F(t) {
            throw t
        }

        function $(t, e, n, i) {
            var r;
            try {
                t && v(r = t.promise) ? r.call(t).done(e).fail(n) : t && v(r = t.then) ? r.call(t, e, n) : e.apply(void 0, [t].slice(i))
            } catch (t) {
                n.apply(void 0, [t])
            }
        }
        S.Callbacks = function (t) {
            t = "string" == typeof t ? function (t) {
                var e = {};
                return S.each(t.match(U) || [], (function (t, n) {
                    e[n] = !0
                })), e
            }(t) : S.extend({}, t);
            var e, n, i, r, s = [],
                a = [],
                o = -1,
                l = function () {
                    for (r = r || t.once, i = e = !0; a.length; o = -1)
                        for (n = a.shift(); ++o < s.length;) !1 === s[o].apply(n[0], n[1]) && t.stopOnFalse && (o = s.length, n = !1);
                    t.memory || (n = !1), e = !1, r && (s = n ? [] : "")
                },
                c = {
                    add: function () {
                        return s && (n && !e && (o = s.length - 1, a.push(n)), function e(n) {
                            S.each(n, (function (n, i) {
                                v(i) ? t.unique && c.has(i) || s.push(i) : i && i.length && "string" !== w(i) && e(i)
                            }))
                        }(arguments), n && !e && l()), this
                    },
                    remove: function () {
                        return S.each(arguments, (function (t, e) {
                            for (var n;
                                (n = S.inArray(e, s, n)) > -1;) s.splice(n, 1), n <= o && o--
                        })), this
                    },
                    has: function (t) {
                        return t ? S.inArray(t, s) > -1 : s.length > 0
                    },
                    empty: function () {
                        return s && (s = []), this
                    },
                    disable: function () {
                        return r = a = [], s = n = "", this
                    },
                    disabled: function () {
                        return !s
                    },
                    lock: function () {
                        return r = a = [], n || e || (s = n = ""), this
                    },
                    locked: function () {
                        return !!r
                    },
                    fireWith: function (t, n) {
                        return r || (n = [t, (n = n || []).slice ? n.slice() : n], a.push(n), e || l()), this
                    },
                    fire: function () {
                        return c.fireWith(this, arguments), this
                    },
                    fired: function () {
                        return !!i
                    }
                };
            return c
        }, S.extend({
            Deferred: function (t) {
                var e = [
                    ["notify", "progress", S.Callbacks("memory"), S.Callbacks("memory"), 2],
                    ["resolve", "done", S.Callbacks("once memory"), S.Callbacks("once memory"), 0, "resolved"],
                    ["reject", "fail", S.Callbacks("once memory"), S.Callbacks("once memory"), 1, "rejected"]
                ],
                    i = "pending",
                    r = {
                        state: function () {
                            return i
                        },
                        always: function () {
                            return s.done(arguments).fail(arguments), this
                        },
                        catch: function (t) {
                            return r.then(null, t)
                        },
                        pipe: function () {
                            var t = arguments;
                            return S.Deferred((function (n) {
                                S.each(e, (function (e, i) {
                                    var r = v(t[i[4]]) && t[i[4]];
                                    s[i[1]]((function () {
                                        var t = r && r.apply(this, arguments);
                                        t && v(t.promise) ? t.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[i[0] + "With"](this, r ? [t] : arguments)
                                    }))
                                })), t = null
                            })).promise()
                        },
                        then: function (t, i, r) {
                            var s = 0;

                            function a(t, e, i, r) {
                                return function () {
                                    var o = this,
                                        l = arguments,
                                        c = function () {
                                            var n, c;
                                            if (!(t < s)) {
                                                if ((n = i.apply(o, l)) === e.promise()) throw new TypeError("Thenable self-resolution");
                                                c = n && ("object" == typeof n || "function" == typeof n) && n.then, v(c) ? r ? c.call(n, a(s, e, z, r), a(s, e, F, r)) : (s++, c.call(n, a(s, e, z, r), a(s, e, F, r), a(s, e, z, e.notifyWith))) : (i !== z && (o = void 0, l = [n]), (r || e.resolveWith)(o, l))
                                            }
                                        },
                                        h = r ? c : function () {
                                            try {
                                                c()
                                            } catch (n) {
                                                S.Deferred.exceptionHook && S.Deferred.exceptionHook(n, h.stackTrace), t + 1 >= s && (i !== F && (o = void 0, l = [n]), e.rejectWith(o, l))
                                            }
                                        };
                                    t ? h() : (S.Deferred.getStackHook && (h.stackTrace = S.Deferred.getStackHook()), n.setTimeout(h))
                                }
                            }
                            return S.Deferred((function (n) {
                                e[0][3].add(a(0, n, v(r) ? r : z, n.notifyWith)), e[1][3].add(a(0, n, v(t) ? t : z)), e[2][3].add(a(0, n, v(i) ? i : F))
                            })).promise()
                        },
                        promise: function (t) {
                            return null != t ? S.extend(t, r) : r
                        }
                    },
                    s = {};
                return S.each(e, (function (t, n) {
                    var a = n[2],
                        o = n[5];
                    r[n[1]] = a.add, o && a.add((function () {
                        i = o
                    }), e[3 - t][2].disable, e[3 - t][3].disable, e[0][2].lock, e[0][3].lock), a.add(n[3].fire), s[n[0]] = function () {
                        return s[n[0] + "With"](this === s ? void 0 : this, arguments), this
                    }, s[n[0] + "With"] = a.fireWith
                })), r.promise(s), t && t.call(s, s), s
            },
            when: function (t) {
                var e = arguments.length,
                    n = e,
                    i = Array(n),
                    r = o.call(arguments),
                    s = S.Deferred(),
                    a = function (t) {
                        return function (n) {
                            i[t] = this, r[t] = arguments.length > 1 ? o.call(arguments) : n, --e || s.resolveWith(i, r)
                        }
                    };
                if (e <= 1 && ($(t, s.done(a(n)).resolve, s.reject, !e), "pending" === s.state() || v(r[n] && r[n].then))) return s.then();
                for (; n--;) $(r[n], a(n), s.reject);
                return s.promise()
            }
        });
        var B = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        S.Deferred.exceptionHook = function (t, e) {
            n.console && n.console.warn && t && B.test(t.name) && n.console.warn("jQuery.Deferred exception: " + t.message, t.stack, e)
        }, S.readyException = function (t) {
            n.setTimeout((function () {
                throw t
            }))
        };
        var H = S.Deferred();

        function j() {
            b.removeEventListener("DOMContentLoaded", j), n.removeEventListener("load", j), S.ready()
        }
        S.fn.ready = function (t) {
            return H.then(t).catch((function (t) {
                S.readyException(t)
            })), this
        }, S.extend({
            isReady: !1,
            readyWait: 1,
            ready: function (t) {
                (!0 === t ? --S.readyWait : S.isReady) || (S.isReady = !0, !0 !== t && --S.readyWait > 0 || H.resolveWith(b, [S]))
            }
        }), S.ready.then = H.then, "complete" === b.readyState || "loading" !== b.readyState && !b.documentElement.doScroll ? n.setTimeout(S.ready) : (b.addEventListener("DOMContentLoaded", j), n.addEventListener("load", j));
        var V = function (t, e, n, i, r, s, a) {
            var o = 0,
                l = t.length,
                c = null == n;
            if ("object" === w(n))
                for (o in r = !0, n) V(t, e, o, n[o], !0, s, a);
            else if (void 0 !== i && (r = !0, v(i) || (a = !0), c && (a ? (e.call(t, i), e = null) : (c = e, e = function (t, e, n) {
                return c.call(S(t), n)
            })), e))
                for (; o < l; o++) e(t[o], n, a ? i : i.call(t[o], o, e(t[o], n)));
            return r ? t : c ? e.call(t) : l ? e(t[0], n) : s
        },
            G = /^-ms-/,
            W = /-([a-z])/g;

        function q(t, e) {
            return e.toUpperCase()
        }

        function X(t) {
            return t.replace(G, "ms-").replace(W, q)
        }
        var Y = function (t) {
            return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType
        };

        function K() {
            this.expando = S.expando + K.uid++
        }
        K.uid = 1, K.prototype = {
            cache: function (t) {
                var e = t[this.expando];
                return e || (e = {}, Y(t) && (t.nodeType ? t[this.expando] = e : Object.defineProperty(t, this.expando, {
                    value: e,
                    configurable: !0
                }))), e
            },
            set: function (t, e, n) {
                var i, r = this.cache(t);
                if ("string" == typeof e) r[X(e)] = n;
                else
                    for (i in e) r[X(i)] = e[i];
                return r
            },
            get: function (t, e) {
                return void 0 === e ? this.cache(t) : t[this.expando] && t[this.expando][X(e)]
            },
            access: function (t, e, n) {
                return void 0 === e || e && "string" == typeof e && void 0 === n ? this.get(t, e) : (this.set(t, e, n), void 0 !== n ? n : e)
            },
            remove: function (t, e) {
                var n, i = t[this.expando];
                if (void 0 !== i) {
                    if (void 0 !== e) {
                        n = (e = Array.isArray(e) ? e.map(X) : (e = X(e)) in i ? [e] : e.match(U) || []).length;
                        for (; n--;) delete i[e[n]]
                    } (void 0 === e || S.isEmptyObject(i)) && (t.nodeType ? t[this.expando] = void 0 : delete t[this.expando])
                }
            },
            hasData: function (t) {
                var e = t[this.expando];
                return void 0 !== e && !S.isEmptyObject(e)
            }
        };
        var Z = new K,
            J = new K,
            Q = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            tt = /[A-Z]/g;

        function et(t, e, n) {
            var i;
            if (void 0 === n && 1 === t.nodeType)
                if (i = "data-" + e.replace(tt, "-$&").toLowerCase(), "string" == typeof (n = t.getAttribute(i))) {
                    try {
                        n = function (t) {
                            return "true" === t || "false" !== t && ("null" === t ? null : t === +t + "" ? +t : Q.test(t) ? JSON.parse(t) : t)
                        }(n)
                    } catch (t) { }
                    J.set(t, e, n)
                } else n = void 0;
            return n
        }
        S.extend({
            hasData: function (t) {
                return J.hasData(t) || Z.hasData(t)
            },
            data: function (t, e, n) {
                return J.access(t, e, n)
            },
            removeData: function (t, e) {
                J.remove(t, e)
            },
            _data: function (t, e, n) {
                return Z.access(t, e, n)
            },
            _removeData: function (t, e) {
                Z.remove(t, e)
            }
        }), S.fn.extend({
            data: function (t, e) {
                var n, i, r, s = this[0],
                    a = s && s.attributes;
                if (void 0 === t) {
                    if (this.length && (r = J.get(s), 1 === s.nodeType && !Z.get(s, "hasDataAttrs"))) {
                        for (n = a.length; n--;) a[n] && 0 === (i = a[n].name).indexOf("data-") && (i = X(i.slice(5)), et(s, i, r[i]));
                        Z.set(s, "hasDataAttrs", !0)
                    }
                    return r
                }
                return "object" == typeof t ? this.each((function () {
                    J.set(this, t)
                })) : V(this, (function (e) {
                    var n;
                    if (s && void 0 === e) return void 0 !== (n = J.get(s, t)) || void 0 !== (n = et(s, t)) ? n : void 0;
                    this.each((function () {
                        J.set(this, t, e)
                    }))
                }), null, e, arguments.length > 1, null, !0)
            },
            removeData: function (t) {
                return this.each((function () {
                    J.remove(this, t)
                }))
            }
        }), S.extend({
            queue: function (t, e, n) {
                var i;
                if (t) return e = (e || "fx") + "queue", i = Z.get(t, e), n && (!i || Array.isArray(n) ? i = Z.access(t, e, S.makeArray(n)) : i.push(n)), i || []
            },
            dequeue: function (t, e) {
                e = e || "fx";
                var n = S.queue(t, e),
                    i = n.length,
                    r = n.shift(),
                    s = S._queueHooks(t, e);
                "inprogress" === r && (r = n.shift(), i--), r && ("fx" === e && n.unshift("inprogress"), delete s.stop, r.call(t, (function () {
                    S.dequeue(t, e)
                }), s)), !i && s && s.empty.fire()
            },
            _queueHooks: function (t, e) {
                var n = e + "queueHooks";
                return Z.get(t, n) || Z.access(t, n, {
                    empty: S.Callbacks("once memory").add((function () {
                        Z.remove(t, [e + "queue", n])
                    }))
                })
            }
        }), S.fn.extend({
            queue: function (t, e) {
                var n = 2;
                return "string" != typeof t && (e = t, t = "fx", n--), arguments.length < n ? S.queue(this[0], t) : void 0 === e ? this : this.each((function () {
                    var n = S.queue(this, t, e);
                    S._queueHooks(this, t), "fx" === t && "inprogress" !== n[0] && S.dequeue(this, t)
                }))
            },
            dequeue: function (t) {
                return this.each((function () {
                    S.dequeue(this, t)
                }))
            },
            clearQueue: function (t) {
                return this.queue(t || "fx", [])
            },
            promise: function (t, e) {
                var n, i = 1,
                    r = S.Deferred(),
                    s = this,
                    a = this.length,
                    o = function () {
                        --i || r.resolveWith(s, [s])
                    };
                for ("string" != typeof t && (e = t, t = void 0), t = t || "fx"; a--;)(n = Z.get(s[a], t + "queueHooks")) && n.empty && (i++, n.empty.add(o));
                return o(), r.promise(e)
            }
        });
        var nt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
            it = new RegExp("^(?:([+-])=|)(" + nt + ")([a-z%]*)$", "i"),
            rt = ["Top", "Right", "Bottom", "Left"],
            st = b.documentElement,
            at = function (t) {
                return S.contains(t.ownerDocument, t)
            },
            ot = {
                composed: !0
            };
        st.getRootNode && (at = function (t) {
            return S.contains(t.ownerDocument, t) || t.getRootNode(ot) === t.ownerDocument
        });
        var lt = function (t, e) {
            return "none" === (t = e || t).style.display || "" === t.style.display && at(t) && "none" === S.css(t, "display")
        };

        function ct(t, e, n, i) {
            var r, s, a = 20,
                o = i ? function () {
                    return i.cur()
                } : function () {
                    return S.css(t, e, "")
                },
                l = o(),
                c = n && n[3] || (S.cssNumber[e] ? "" : "px"),
                h = t.nodeType && (S.cssNumber[e] || "px" !== c && +l) && it.exec(S.css(t, e));
            if (h && h[3] !== c) {
                for (l /= 2, c = c || h[3], h = +l || 1; a--;) S.style(t, e, h + c), (1 - s) * (1 - (s = o() / l || .5)) <= 0 && (a = 0), h /= s;
                h *= 2, S.style(t, e, h + c), n = n || []
            }
            return n && (h = +h || +l || 0, r = n[1] ? h + (n[1] + 1) * n[2] : +n[2], i && (i.unit = c, i.start = h, i.end = r)), r
        }
        var ht = {};

        function ut(t) {
            var e, n = t.ownerDocument,
                i = t.nodeName,
                r = ht[i];
            return r || (e = n.body.appendChild(n.createElement(i)), r = S.css(e, "display"), e.parentNode.removeChild(e), "none" === r && (r = "block"), ht[i] = r, r)
        }

        function dt(t, e) {
            for (var n, i, r = [], s = 0, a = t.length; s < a; s++)(i = t[s]).style && (n = i.style.display, e ? ("none" === n && (r[s] = Z.get(i, "display") || null, r[s] || (i.style.display = "")), "" === i.style.display && lt(i) && (r[s] = ut(i))) : "none" !== n && (r[s] = "none", Z.set(i, "display", n)));
            for (s = 0; s < a; s++) null != r[s] && (t[s].style.display = r[s]);
            return t
        }
        S.fn.extend({
            show: function () {
                return dt(this, !0)
            },
            hide: function () {
                return dt(this)
            },
            toggle: function (t) {
                return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each((function () {
                    lt(this) ? S(this).show() : S(this).hide()
                }))
            }
        });
        var pt, ft, mt = /^(?:checkbox|radio)$/i,
            gt = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
            vt = /^$|^module$|\/(?:java|ecma)script/i;
        pt = b.createDocumentFragment().appendChild(b.createElement("div")), (ft = b.createElement("input")).setAttribute("type", "radio"), ft.setAttribute("checked", "checked"), ft.setAttribute("name", "t"), pt.appendChild(ft), g.checkClone = pt.cloneNode(!0).cloneNode(!0).lastChild.checked, pt.innerHTML = "<textarea>x</textarea>", g.noCloneChecked = !!pt.cloneNode(!0).lastChild.defaultValue, pt.innerHTML = "<option></option>", g.option = !!pt.lastChild;
        var yt = {
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        };

        function bt(t, e) {
            var n;
            return n = void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e || "*") : void 0 !== t.querySelectorAll ? t.querySelectorAll(e || "*") : [], void 0 === e || e && R(t, e) ? S.merge([t], n) : n
        }

        function xt(t, e) {
            for (var n = 0, i = t.length; n < i; n++) Z.set(t[n], "globalEval", !e || Z.get(e[n], "globalEval"))
        }
        yt.tbody = yt.tfoot = yt.colgroup = yt.caption = yt.thead, yt.th = yt.td, g.option || (yt.optgroup = yt.option = [1, "<select multiple='multiple'>", "</select>"]);
        var _t = /<|&#?\w+;/;

        function wt(t, e, n, i, r) {
            for (var s, a, o, l, c, h, u = e.createDocumentFragment(), d = [], p = 0, f = t.length; p < f; p++)
                if ((s = t[p]) || 0 === s)
                    if ("object" === w(s)) S.merge(d, s.nodeType ? [s] : s);
                    else if (_t.test(s)) {
                        for (a = a || u.appendChild(e.createElement("div")), o = (gt.exec(s) || ["", ""])[1].toLowerCase(), l = yt[o] || yt._default, a.innerHTML = l[1] + S.htmlPrefilter(s) + l[2], h = l[0]; h--;) a = a.lastChild;
                        S.merge(d, a.childNodes), (a = u.firstChild).textContent = ""
                    } else d.push(e.createTextNode(s));
            for (u.textContent = "", p = 0; s = d[p++];)
                if (i && S.inArray(s, i) > -1) r && r.push(s);
                else if (c = at(s), a = bt(u.appendChild(s), "script"), c && xt(a), n)
                    for (h = 0; s = a[h++];) vt.test(s.type || "") && n.push(s);
            return u
        }
        var St = /^([^.]*)(?:\.(.+)|)/;

        function Mt() {
            return !0
        }

        function Et() {
            return !1
        }

        function Tt(t, e) {
            return t === function () {
                try {
                    return b.activeElement
                } catch (t) { }
            }() == ("focus" === e)
        }

        function Ct(t, e, n, i, r, s) {
            var a, o;
            if ("object" == typeof e) {
                for (o in "string" != typeof n && (i = i || n, n = void 0), e) Ct(t, o, n, i, e[o], s);
                return t
            }
            if (null == i && null == r ? (r = n, i = n = void 0) : null == r && ("string" == typeof n ? (r = i, i = void 0) : (r = i, i = n, n = void 0)), !1 === r) r = Et;
            else if (!r) return t;
            return 1 === s && (a = r, (r = function (t) {
                return S().off(t), a.apply(this, arguments)
            }).guid = a.guid || (a.guid = S.guid++)), t.each((function () {
                S.event.add(this, e, r, i, n)
            }))
        }

        function At(t, e, n) {
            n ? (Z.set(t, e, !1), S.event.add(t, e, {
                namespace: !1,
                handler: function (t) {
                    var i, r, s = Z.get(this, e);
                    if (1 & t.isTrigger && this[e]) {
                        if (s.length) (S.event.special[e] || {}).delegateType && t.stopPropagation();
                        else if (s = o.call(arguments), Z.set(this, e, s), i = n(this, e), this[e](), s !== (r = Z.get(this, e)) || i ? Z.set(this, e, !1) : r = {}, s !== r) return t.stopImmediatePropagation(), t.preventDefault(), r && r.value
                    } else s.length && (Z.set(this, e, {
                        value: S.event.trigger(S.extend(s[0], S.Event.prototype), s.slice(1), this)
                    }), t.stopImmediatePropagation())
                }
            })) : void 0 === Z.get(t, e) && S.event.add(t, e, Mt)
        }
        S.event = {
            global: {},
            add: function (t, e, n, i, r) {
                var s, a, o, l, c, h, u, d, p, f, m, g = Z.get(t);
                if (Y(t))
                    for (n.handler && (n = (s = n).handler, r = s.selector), r && S.find.matchesSelector(st, r), n.guid || (n.guid = S.guid++), (l = g.events) || (l = g.events = Object.create(null)), (a = g.handle) || (a = g.handle = function (e) {
                        return void 0 !== S && S.event.triggered !== e.type ? S.event.dispatch.apply(t, arguments) : void 0
                    }), c = (e = (e || "").match(U) || [""]).length; c--;) p = m = (o = St.exec(e[c]) || [])[1], f = (o[2] || "").split(".").sort(), p && (u = S.event.special[p] || {}, p = (r ? u.delegateType : u.bindType) || p, u = S.event.special[p] || {}, h = S.extend({
                        type: p,
                        origType: m,
                        data: i,
                        handler: n,
                        guid: n.guid,
                        selector: r,
                        needsContext: r && S.expr.match.needsContext.test(r),
                        namespace: f.join(".")
                    }, s), (d = l[p]) || ((d = l[p] = []).delegateCount = 0, u.setup && !1 !== u.setup.call(t, i, f, a) || t.addEventListener && t.addEventListener(p, a)), u.add && (u.add.call(t, h), h.handler.guid || (h.handler.guid = n.guid)), r ? d.splice(d.delegateCount++, 0, h) : d.push(h), S.event.global[p] = !0)
            },
            remove: function (t, e, n, i, r) {
                var s, a, o, l, c, h, u, d, p, f, m, g = Z.hasData(t) && Z.get(t);
                if (g && (l = g.events)) {
                    for (c = (e = (e || "").match(U) || [""]).length; c--;)
                        if (p = m = (o = St.exec(e[c]) || [])[1], f = (o[2] || "").split(".").sort(), p) {
                            for (u = S.event.special[p] || {}, d = l[p = (i ? u.delegateType : u.bindType) || p] || [], o = o[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = s = d.length; s--;) h = d[s], !r && m !== h.origType || n && n.guid !== h.guid || o && !o.test(h.namespace) || i && i !== h.selector && ("**" !== i || !h.selector) || (d.splice(s, 1), h.selector && d.delegateCount--, u.remove && u.remove.call(t, h));
                            a && !d.length && (u.teardown && !1 !== u.teardown.call(t, f, g.handle) || S.removeEvent(t, p, g.handle), delete l[p])
                        } else
                            for (p in l) S.event.remove(t, p + e[c], n, i, !0);
                    S.isEmptyObject(l) && Z.remove(t, "handle events")
                }
            },
            dispatch: function (t) {
                var e, n, i, r, s, a, o = new Array(arguments.length),
                    l = S.event.fix(t),
                    c = (Z.get(this, "events") || Object.create(null))[l.type] || [],
                    h = S.event.special[l.type] || {};
                for (o[0] = l, e = 1; e < arguments.length; e++) o[e] = arguments[e];
                if (l.delegateTarget = this, !h.preDispatch || !1 !== h.preDispatch.call(this, l)) {
                    for (a = S.event.handlers.call(this, l, c), e = 0;
                        (r = a[e++]) && !l.isPropagationStopped();)
                        for (l.currentTarget = r.elem, n = 0;
                            (s = r.handlers[n++]) && !l.isImmediatePropagationStopped();) l.rnamespace && !1 !== s.namespace && !l.rnamespace.test(s.namespace) || (l.handleObj = s, l.data = s.data, void 0 !== (i = ((S.event.special[s.origType] || {}).handle || s.handler).apply(r.elem, o)) && !1 === (l.result = i) && (l.preventDefault(), l.stopPropagation()));
                    return h.postDispatch && h.postDispatch.call(this, l), l.result
                }
            },
            handlers: function (t, e) {
                var n, i, r, s, a, o = [],
                    l = e.delegateCount,
                    c = t.target;
                if (l && c.nodeType && !("click" === t.type && t.button >= 1))
                    for (; c !== this; c = c.parentNode || this)
                        if (1 === c.nodeType && ("click" !== t.type || !0 !== c.disabled)) {
                            for (s = [], a = {}, n = 0; n < l; n++) void 0 === a[r = (i = e[n]).selector + " "] && (a[r] = i.needsContext ? S(r, this).index(c) > -1 : S.find(r, this, null, [c]).length), a[r] && s.push(i);
                            s.length && o.push({
                                elem: c,
                                handlers: s
                            })
                        } return c = this, l < e.length && o.push({
                            elem: c,
                            handlers: e.slice(l)
                        }), o
            },
            addProp: function (t, e) {
                Object.defineProperty(S.Event.prototype, t, {
                    enumerable: !0,
                    configurable: !0,
                    get: v(e) ? function () {
                        if (this.originalEvent) return e(this.originalEvent)
                    } : function () {
                        if (this.originalEvent) return this.originalEvent[t]
                    },
                    set: function (e) {
                        Object.defineProperty(this, t, {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: e
                        })
                    }
                })
            },
            fix: function (t) {
                return t[S.expando] ? t : new S.Event(t)
            },
            special: {
                load: {
                    noBubble: !0
                },
                click: {
                    setup: function (t) {
                        var e = this || t;
                        return mt.test(e.type) && e.click && R(e, "input") && At(e, "click", Mt), !1
                    },
                    trigger: function (t) {
                        var e = this || t;
                        return mt.test(e.type) && e.click && R(e, "input") && At(e, "click"), !0
                    },
                    _default: function (t) {
                        var e = t.target;
                        return mt.test(e.type) && e.click && R(e, "input") && Z.get(e, "click") || R(e, "a")
                    }
                },
                beforeunload: {
                    postDispatch: function (t) {
                        void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result)
                    }
                }
            }
        }, S.removeEvent = function (t, e, n) {
            t.removeEventListener && t.removeEventListener(e, n)
        }, S.Event = function (t, e) {
            if (!(this instanceof S.Event)) return new S.Event(t, e);
            t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && !1 === t.returnValue ? Mt : Et, this.target = t.target && 3 === t.target.nodeType ? t.target.parentNode : t.target, this.currentTarget = t.currentTarget, this.relatedTarget = t.relatedTarget) : this.type = t, e && S.extend(this, e), this.timeStamp = t && t.timeStamp || Date.now(), this[S.expando] = !0
        }, S.Event.prototype = {
            constructor: S.Event,
            isDefaultPrevented: Et,
            isPropagationStopped: Et,
            isImmediatePropagationStopped: Et,
            isSimulated: !1,
            preventDefault: function () {
                var t = this.originalEvent;
                this.isDefaultPrevented = Mt, t && !this.isSimulated && t.preventDefault()
            },
            stopPropagation: function () {
                var t = this.originalEvent;
                this.isPropagationStopped = Mt, t && !this.isSimulated && t.stopPropagation()
            },
            stopImmediatePropagation: function () {
                var t = this.originalEvent;
                this.isImmediatePropagationStopped = Mt, t && !this.isSimulated && t.stopImmediatePropagation(), this.stopPropagation()
            }
        }, S.each({
            altKey: !0,
            bubbles: !0,
            cancelable: !0,
            changedTouches: !0,
            ctrlKey: !0,
            detail: !0,
            eventPhase: !0,
            metaKey: !0,
            pageX: !0,
            pageY: !0,
            shiftKey: !0,
            view: !0,
            char: !0,
            code: !0,
            charCode: !0,
            key: !0,
            keyCode: !0,
            button: !0,
            buttons: !0,
            clientX: !0,
            clientY: !0,
            offsetX: !0,
            offsetY: !0,
            pointerId: !0,
            pointerType: !0,
            screenX: !0,
            screenY: !0,
            targetTouches: !0,
            toElement: !0,
            touches: !0,
            which: !0
        }, S.event.addProp), S.each({
            focus: "focusin",
            blur: "focusout"
        }, (function (t, e) {
            S.event.special[t] = {
                setup: function () {
                    return At(this, t, Tt), !1
                },
                trigger: function () {
                    return At(this, t), !0
                },
                _default: function (e) {
                    return Z.get(e.target, t)
                },
                delegateType: e
            }
        })), S.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        }, (function (t, e) {
            S.event.special[t] = {
                delegateType: e,
                bindType: e,
                handle: function (t) {
                    var n, i = this,
                        r = t.relatedTarget,
                        s = t.handleObj;
                    return r && (r === i || S.contains(i, r)) || (t.type = s.origType, n = s.handler.apply(this, arguments), t.type = e), n
                }
            }
        })), S.fn.extend({
            on: function (t, e, n, i) {
                return Ct(this, t, e, n, i)
            },
            one: function (t, e, n, i) {
                return Ct(this, t, e, n, i, 1)
            },
            off: function (t, e, n) {
                var i, r;
                if (t && t.preventDefault && t.handleObj) return i = t.handleObj, S(t.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this;
                if ("object" == typeof t) {
                    for (r in t) this.off(r, e, t[r]);
                    return this
                }
                return !1 !== e && "function" != typeof e || (n = e, e = void 0), !1 === n && (n = Et), this.each((function () {
                    S.event.remove(this, t, n, e)
                }))
            }
        });
        var Rt = /<script|<style|<link/i,
            Pt = /checked\s*(?:[^=]|=\s*.checked.)/i,
            Lt = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

        function Ot(t, e) {
            return R(t, "table") && R(11 !== e.nodeType ? e : e.firstChild, "tr") && S(t).children("tbody")[0] || t
        }

        function Dt(t) {
            return t.type = (null !== t.getAttribute("type")) + "/" + t.type, t
        }

        function It(t) {
            return "true/" === (t.type || "").slice(0, 5) ? t.type = t.type.slice(5) : t.removeAttribute("type"), t
        }

        function kt(t, e) {
            var n, i, r, s, a, o;
            if (1 === e.nodeType) {
                if (Z.hasData(t) && (o = Z.get(t).events))
                    for (r in Z.remove(e, "handle events"), o)
                        for (n = 0, i = o[r].length; n < i; n++) S.event.add(e, r, o[r][n]);
                J.hasData(t) && (s = J.access(t), a = S.extend({}, s), J.set(e, a))
            }
        }

        function Nt(t, e) {
            var n = e.nodeName.toLowerCase();
            "input" === n && mt.test(t.type) ? e.checked = t.checked : "input" !== n && "textarea" !== n || (e.defaultValue = t.defaultValue)
        }

        function Ut(t, e, n, i) {
            e = l(e);
            var r, s, a, o, c, h, u = 0,
                d = t.length,
                p = d - 1,
                f = e[0],
                m = v(f);
            if (m || d > 1 && "string" == typeof f && !g.checkClone && Pt.test(f)) return t.each((function (r) {
                var s = t.eq(r);
                m && (e[0] = f.call(this, r, s.html())), Ut(s, e, n, i)
            }));
            if (d && (s = (r = wt(e, t[0].ownerDocument, !1, t, i)).firstChild, 1 === r.childNodes.length && (r = s), s || i)) {
                for (o = (a = S.map(bt(r, "script"), Dt)).length; u < d; u++) c = r, u !== p && (c = S.clone(c, !0, !0), o && S.merge(a, bt(c, "script"))), n.call(t[u], c, u);
                if (o)
                    for (h = a[a.length - 1].ownerDocument, S.map(a, It), u = 0; u < o; u++) c = a[u], vt.test(c.type || "") && !Z.access(c, "globalEval") && S.contains(h, c) && (c.src && "module" !== (c.type || "").toLowerCase() ? S._evalUrl && !c.noModule && S._evalUrl(c.src, {
                        nonce: c.nonce || c.getAttribute("nonce")
                    }, h) : _(c.textContent.replace(Lt, ""), c, h))
            }
            return t
        }

        function zt(t, e, n) {
            for (var i, r = e ? S.filter(e, t) : t, s = 0; null != (i = r[s]); s++) n || 1 !== i.nodeType || S.cleanData(bt(i)), i.parentNode && (n && at(i) && xt(bt(i, "script")), i.parentNode.removeChild(i));
            return t
        }
        S.extend({
            htmlPrefilter: function (t) {
                return t
            },
            clone: function (t, e, n) {
                var i, r, s, a, o = t.cloneNode(!0),
                    l = at(t);
                if (!(g.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || S.isXMLDoc(t)))
                    for (a = bt(o), i = 0, r = (s = bt(t)).length; i < r; i++) Nt(s[i], a[i]);
                if (e)
                    if (n)
                        for (s = s || bt(t), a = a || bt(o), i = 0, r = s.length; i < r; i++) kt(s[i], a[i]);
                    else kt(t, o);
                return (a = bt(o, "script")).length > 0 && xt(a, !l && bt(t, "script")), o
            },
            cleanData: function (t) {
                for (var e, n, i, r = S.event.special, s = 0; void 0 !== (n = t[s]); s++)
                    if (Y(n)) {
                        if (e = n[Z.expando]) {
                            if (e.events)
                                for (i in e.events) r[i] ? S.event.remove(n, i) : S.removeEvent(n, i, e.handle);
                            n[Z.expando] = void 0
                        }
                        n[J.expando] && (n[J.expando] = void 0)
                    }
            }
        }), S.fn.extend({
            detach: function (t) {
                return zt(this, t, !0)
            },
            remove: function (t) {
                return zt(this, t)
            },
            text: function (t) {
                return V(this, (function (t) {
                    return void 0 === t ? S.text(this) : this.empty().each((function () {
                        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = t)
                    }))
                }), null, t, arguments.length)
            },
            append: function () {
                return Ut(this, arguments, (function (t) {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Ot(this, t).appendChild(t)
                }))
            },
            prepend: function () {
                return Ut(this, arguments, (function (t) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var e = Ot(this, t);
                        e.insertBefore(t, e.firstChild)
                    }
                }))
            },
            before: function () {
                return Ut(this, arguments, (function (t) {
                    this.parentNode && this.parentNode.insertBefore(t, this)
                }))
            },
            after: function () {
                return Ut(this, arguments, (function (t) {
                    this.parentNode && this.parentNode.insertBefore(t, this.nextSibling)
                }))
            },
            empty: function () {
                for (var t, e = 0; null != (t = this[e]); e++) 1 === t.nodeType && (S.cleanData(bt(t, !1)), t.textContent = "");
                return this
            },
            clone: function (t, e) {
                return t = null != t && t, e = null == e ? t : e, this.map((function () {
                    return S.clone(this, t, e)
                }))
            },
            html: function (t) {
                return V(this, (function (t) {
                    var e = this[0] || {},
                        n = 0,
                        i = this.length;
                    if (void 0 === t && 1 === e.nodeType) return e.innerHTML;
                    if ("string" == typeof t && !Rt.test(t) && !yt[(gt.exec(t) || ["", ""])[1].toLowerCase()]) {
                        t = S.htmlPrefilter(t);
                        try {
                            for (; n < i; n++) 1 === (e = this[n] || {}).nodeType && (S.cleanData(bt(e, !1)), e.innerHTML = t);
                            e = 0
                        } catch (t) { }
                    }
                    e && this.empty().append(t)
                }), null, t, arguments.length)
            },
            replaceWith: function () {
                var t = [];
                return Ut(this, arguments, (function (e) {
                    var n = this.parentNode;
                    S.inArray(this, t) < 0 && (S.cleanData(bt(this)), n && n.replaceChild(e, this))
                }), t)
            }
        }), S.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, (function (t, e) {
            S.fn[t] = function (t) {
                for (var n, i = [], r = S(t), s = r.length - 1, a = 0; a <= s; a++) n = a === s ? this : this.clone(!0), S(r[a])[e](n), c.apply(i, n.get());
                return this.pushStack(i)
            }
        }));
        var Ft = new RegExp("^(" + nt + ")(?!px)[a-z%]+$", "i"),
            $t = /^--/,
            Bt = function (t) {
                var e = t.ownerDocument.defaultView;
                return e && e.opener || (e = n), e.getComputedStyle(t)
            },
            Ht = function (t, e, n) {
                var i, r, s = {};
                for (r in e) s[r] = t.style[r], t.style[r] = e[r];
                for (r in i = n.call(t), e) t.style[r] = s[r];
                return i
            },
            jt = new RegExp(rt.join("|"), "i"),
            Vt = new RegExp("^[\\x20\\t\\r\\n\\f]+|((?:^|[^\\\\])(?:\\\\.)*)[\\x20\\t\\r\\n\\f]+$", "g");

        function Gt(t, e, n) {
            var i, r, s, a, o = $t.test(e),
                l = t.style;
            return (n = n || Bt(t)) && (a = n.getPropertyValue(e) || n[e], o && (a = a.replace(Vt, "$1")), "" !== a || at(t) || (a = S.style(t, e)), !g.pixelBoxStyles() && Ft.test(a) && jt.test(e) && (i = l.width, r = l.minWidth, s = l.maxWidth, l.minWidth = l.maxWidth = l.width = a, a = n.width, l.width = i, l.minWidth = r, l.maxWidth = s)), void 0 !== a ? a + "" : a
        }

        function Wt(t, e) {
            return {
                get: function () {
                    if (!t()) return (this.get = e).apply(this, arguments);
                    delete this.get
                }
            }
        } ! function () {
            function t() {
                if (h) {
                    c.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", h.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", st.appendChild(c).appendChild(h);
                    var t = n.getComputedStyle(h);
                    i = "1%" !== t.top, l = 12 === e(t.marginLeft), h.style.right = "60%", a = 36 === e(t.right), r = 36 === e(t.width), h.style.position = "absolute", s = 12 === e(h.offsetWidth / 3), st.removeChild(c), h = null
                }
            }

            function e(t) {
                return Math.round(parseFloat(t))
            }
            var i, r, s, a, o, l, c = b.createElement("div"),
                h = b.createElement("div");
            h.style && (h.style.backgroundClip = "content-box", h.cloneNode(!0).style.backgroundClip = "", g.clearCloneStyle = "content-box" === h.style.backgroundClip, S.extend(g, {
                boxSizingReliable: function () {
                    return t(), r
                },
                pixelBoxStyles: function () {
                    return t(), a
                },
                pixelPosition: function () {
                    return t(), i
                },
                reliableMarginLeft: function () {
                    return t(), l
                },
                scrollboxSize: function () {
                    return t(), s
                },
                reliableTrDimensions: function () {
                    var t, e, i, r;
                    return null == o && (t = b.createElement("table"), e = b.createElement("tr"), i = b.createElement("div"), t.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", e.style.cssText = "border:1px solid", e.style.height = "1px", i.style.height = "9px", i.style.display = "block", st.appendChild(t).appendChild(e).appendChild(i), r = n.getComputedStyle(e), o = parseInt(r.height, 10) + parseInt(r.borderTopWidth, 10) + parseInt(r.borderBottomWidth, 10) === e.offsetHeight, st.removeChild(t)), o
                }
            }))
        }();
        var qt = ["Webkit", "Moz", "ms"],
            Xt = b.createElement("div").style,
            Yt = {};

        function Kt(t) {
            var e = S.cssProps[t] || Yt[t];
            return e || (t in Xt ? t : Yt[t] = function (t) {
                for (var e = t[0].toUpperCase() + t.slice(1), n = qt.length; n--;)
                    if ((t = qt[n] + e) in Xt) return t
            }(t) || t)
        }
        var Zt = /^(none|table(?!-c[ea]).+)/,
            Jt = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            },
            Qt = {
                letterSpacing: "0",
                fontWeight: "400"
            };

        function te(t, e, n) {
            var i = it.exec(e);
            return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || "px") : e
        }

        function ee(t, e, n, i, r, s) {
            var a = "width" === e ? 1 : 0,
                o = 0,
                l = 0;
            if (n === (i ? "border" : "content")) return 0;
            for (; a < 4; a += 2) "margin" === n && (l += S.css(t, n + rt[a], !0, r)), i ? ("content" === n && (l -= S.css(t, "padding" + rt[a], !0, r)), "margin" !== n && (l -= S.css(t, "border" + rt[a] + "Width", !0, r))) : (l += S.css(t, "padding" + rt[a], !0, r), "padding" !== n ? l += S.css(t, "border" + rt[a] + "Width", !0, r) : o += S.css(t, "border" + rt[a] + "Width", !0, r));
            return !i && s >= 0 && (l += Math.max(0, Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - s - l - o - .5)) || 0), l
        }

        function ne(t, e, n) {
            var i = Bt(t),
                r = (!g.boxSizingReliable() || n) && "border-box" === S.css(t, "boxSizing", !1, i),
                s = r,
                a = Gt(t, e, i),
                o = "offset" + e[0].toUpperCase() + e.slice(1);
            if (Ft.test(a)) {
                if (!n) return a;
                a = "auto"
            }
            return (!g.boxSizingReliable() && r || !g.reliableTrDimensions() && R(t, "tr") || "auto" === a || !parseFloat(a) && "inline" === S.css(t, "display", !1, i)) && t.getClientRects().length && (r = "border-box" === S.css(t, "boxSizing", !1, i), (s = o in t) && (a = t[o])), (a = parseFloat(a) || 0) + ee(t, e, n || (r ? "border" : "content"), s, i, a) + "px"
        }

        function ie(t, e, n, i, r) {
            return new ie.prototype.init(t, e, n, i, r)
        }
        S.extend({
            cssHooks: {
                opacity: {
                    get: function (t, e) {
                        if (e) {
                            var n = Gt(t, "opacity");
                            return "" === n ? "1" : n
                        }
                    }
                }
            },
            cssNumber: {
                animationIterationCount: !0,
                columnCount: !0,
                fillOpacity: !0,
                flexGrow: !0,
                flexShrink: !0,
                fontWeight: !0,
                gridArea: !0,
                gridColumn: !0,
                gridColumnEnd: !0,
                gridColumnStart: !0,
                gridRow: !0,
                gridRowEnd: !0,
                gridRowStart: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0
            },
            cssProps: {},
            style: function (t, e, n, i) {
                if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
                    var r, s, a, o = X(e),
                        l = $t.test(e),
                        c = t.style;
                    if (l || (e = Kt(o)), a = S.cssHooks[e] || S.cssHooks[o], void 0 === n) return a && "get" in a && void 0 !== (r = a.get(t, !1, i)) ? r : c[e];
                    "string" === (s = typeof n) && (r = it.exec(n)) && r[1] && (n = ct(t, e, r), s = "number"), null != n && n == n && ("number" !== s || l || (n += r && r[3] || (S.cssNumber[o] ? "" : "px")), g.clearCloneStyle || "" !== n || 0 !== e.indexOf("background") || (c[e] = "inherit"), a && "set" in a && void 0 === (n = a.set(t, n, i)) || (l ? c.setProperty(e, n) : c[e] = n))
                }
            },
            css: function (t, e, n, i) {
                var r, s, a, o = X(e);
                return $t.test(e) || (e = Kt(o)), (a = S.cssHooks[e] || S.cssHooks[o]) && "get" in a && (r = a.get(t, !0, n)), void 0 === r && (r = Gt(t, e, i)), "normal" === r && e in Qt && (r = Qt[e]), "" === n || n ? (s = parseFloat(r), !0 === n || isFinite(s) ? s || 0 : r) : r
            }
        }), S.each(["height", "width"], (function (t, e) {
            S.cssHooks[e] = {
                get: function (t, n, i) {
                    if (n) return !Zt.test(S.css(t, "display")) || t.getClientRects().length && t.getBoundingClientRect().width ? ne(t, e, i) : Ht(t, Jt, (function () {
                        return ne(t, e, i)
                    }))
                },
                set: function (t, n, i) {
                    var r, s = Bt(t),
                        a = !g.scrollboxSize() && "absolute" === s.position,
                        o = (a || i) && "border-box" === S.css(t, "boxSizing", !1, s),
                        l = i ? ee(t, e, i, o, s) : 0;
                    return o && a && (l -= Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - parseFloat(s[e]) - ee(t, e, "border", !1, s) - .5)), l && (r = it.exec(n)) && "px" !== (r[3] || "px") && (t.style[e] = n, n = S.css(t, e)), te(0, n, l)
                }
            }
        })), S.cssHooks.marginLeft = Wt(g.reliableMarginLeft, (function (t, e) {
            if (e) return (parseFloat(Gt(t, "marginLeft")) || t.getBoundingClientRect().left - Ht(t, {
                marginLeft: 0
            }, (function () {
                return t.getBoundingClientRect().left
            }))) + "px"
        })), S.each({
            margin: "",
            padding: "",
            border: "Width"
        }, (function (t, e) {
            S.cssHooks[t + e] = {
                expand: function (n) {
                    for (var i = 0, r = {}, s = "string" == typeof n ? n.split(" ") : [n]; i < 4; i++) r[t + rt[i] + e] = s[i] || s[i - 2] || s[0];
                    return r
                }
            }, "margin" !== t && (S.cssHooks[t + e].set = te)
        })), S.fn.extend({
            css: function (t, e) {
                return V(this, (function (t, e, n) {
                    var i, r, s = {},
                        a = 0;
                    if (Array.isArray(e)) {
                        for (i = Bt(t), r = e.length; a < r; a++) s[e[a]] = S.css(t, e[a], !1, i);
                        return s
                    }
                    return void 0 !== n ? S.style(t, e, n) : S.css(t, e)
                }), t, e, arguments.length > 1)
            }
        }), S.Tween = ie, ie.prototype = {
            constructor: ie,
            init: function (t, e, n, i, r, s) {
                this.elem = t, this.prop = n, this.easing = r || S.easing._default, this.options = e, this.start = this.now = this.cur(), this.end = i, this.unit = s || (S.cssNumber[n] ? "" : "px")
            },
            cur: function () {
                var t = ie.propHooks[this.prop];
                return t && t.get ? t.get(this) : ie.propHooks._default.get(this)
            },
            run: function (t) {
                var e, n = ie.propHooks[this.prop];
                return this.options.duration ? this.pos = e = S.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : this.pos = e = t, this.now = (this.end - this.start) * e + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : ie.propHooks._default.set(this), this
            }
        }, ie.prototype.init.prototype = ie.prototype, ie.propHooks = {
            _default: {
                get: function (t) {
                    var e;
                    return 1 !== t.elem.nodeType || null != t.elem[t.prop] && null == t.elem.style[t.prop] ? t.elem[t.prop] : (e = S.css(t.elem, t.prop, "")) && "auto" !== e ? e : 0
                },
                set: function (t) {
                    S.fx.step[t.prop] ? S.fx.step[t.prop](t) : 1 !== t.elem.nodeType || !S.cssHooks[t.prop] && null == t.elem.style[Kt(t.prop)] ? t.elem[t.prop] = t.now : S.style(t.elem, t.prop, t.now + t.unit)
                }
            }
        }, ie.propHooks.scrollTop = ie.propHooks.scrollLeft = {
            set: function (t) {
                t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now)
            }
        }, S.easing = {
            linear: function (t) {
                return t
            },
            swing: function (t) {
                return .5 - Math.cos(t * Math.PI) / 2
            },
            _default: "swing"
        }, S.fx = ie.prototype.init, S.fx.step = {};
        var re, se, ae = /^(?:toggle|show|hide)$/,
            oe = /queueHooks$/;

        function le() {
            se && (!1 === b.hidden && n.requestAnimationFrame ? n.requestAnimationFrame(le) : n.setTimeout(le, S.fx.interval), S.fx.tick())
        }

        function ce() {
            return n.setTimeout((function () {
                re = void 0
            })), re = Date.now()
        }

        function he(t, e) {
            var n, i = 0,
                r = {
                    height: t
                };
            for (e = e ? 1 : 0; i < 4; i += 2 - e) r["margin" + (n = rt[i])] = r["padding" + n] = t;
            return e && (r.opacity = r.width = t), r
        }

        function ue(t, e, n) {
            for (var i, r = (de.tweeners[e] || []).concat(de.tweeners["*"]), s = 0, a = r.length; s < a; s++)
                if (i = r[s].call(n, e, t)) return i
        }

        function de(t, e, n) {
            var i, r, s = 0,
                a = de.prefilters.length,
                o = S.Deferred().always((function () {
                    delete l.elem
                })),
                l = function () {
                    if (r) return !1;
                    for (var e = re || ce(), n = Math.max(0, c.startTime + c.duration - e), i = 1 - (n / c.duration || 0), s = 0, a = c.tweens.length; s < a; s++) c.tweens[s].run(i);
                    return o.notifyWith(t, [c, i, n]), i < 1 && a ? n : (a || o.notifyWith(t, [c, 1, 0]), o.resolveWith(t, [c]), !1)
                },
                c = o.promise({
                    elem: t,
                    props: S.extend({}, e),
                    opts: S.extend(!0, {
                        specialEasing: {},
                        easing: S.easing._default
                    }, n),
                    originalProperties: e,
                    originalOptions: n,
                    startTime: re || ce(),
                    duration: n.duration,
                    tweens: [],
                    createTween: function (e, n) {
                        var i = S.Tween(t, c.opts, e, n, c.opts.specialEasing[e] || c.opts.easing);
                        return c.tweens.push(i), i
                    },
                    stop: function (e) {
                        var n = 0,
                            i = e ? c.tweens.length : 0;
                        if (r) return this;
                        for (r = !0; n < i; n++) c.tweens[n].run(1);
                        return e ? (o.notifyWith(t, [c, 1, 0]), o.resolveWith(t, [c, e])) : o.rejectWith(t, [c, e]), this
                    }
                }),
                h = c.props;
            for (! function (t, e) {
                var n, i, r, s, a;
                for (n in t)
                    if (r = e[i = X(n)], s = t[n], Array.isArray(s) && (r = s[1], s = t[n] = s[0]), n !== i && (t[i] = s, delete t[n]), (a = S.cssHooks[i]) && "expand" in a)
                        for (n in s = a.expand(s), delete t[i], s) n in t || (t[n] = s[n], e[n] = r);
                    else e[i] = r
            }(h, c.opts.specialEasing); s < a; s++)
                if (i = de.prefilters[s].call(c, t, h, c.opts)) return v(i.stop) && (S._queueHooks(c.elem, c.opts.queue).stop = i.stop.bind(i)), i;
            return S.map(h, ue, c), v(c.opts.start) && c.opts.start.call(t, c), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), S.fx.timer(S.extend(l, {
                elem: t,
                anim: c,
                queue: c.opts.queue
            })), c
        }
        S.Animation = S.extend(de, {
            tweeners: {
                "*": [function (t, e) {
                    var n = this.createTween(t, e);
                    return ct(n.elem, t, it.exec(e), n), n
                }]
            },
            tweener: function (t, e) {
                v(t) ? (e = t, t = ["*"]) : t = t.match(U);
                for (var n, i = 0, r = t.length; i < r; i++) n = t[i], de.tweeners[n] = de.tweeners[n] || [], de.tweeners[n].unshift(e)
            },
            prefilters: [function (t, e, n) {
                var i, r, s, a, o, l, c, h, u = "width" in e || "height" in e,
                    d = this,
                    p = {},
                    f = t.style,
                    m = t.nodeType && lt(t),
                    g = Z.get(t, "fxshow");
                for (i in n.queue || (null == (a = S._queueHooks(t, "fx")).unqueued && (a.unqueued = 0, o = a.empty.fire, a.empty.fire = function () {
                    a.unqueued || o()
                }), a.unqueued++, d.always((function () {
                    d.always((function () {
                        a.unqueued--, S.queue(t, "fx").length || a.empty.fire()
                    }))
                }))), e)
                    if (r = e[i], ae.test(r)) {
                        if (delete e[i], s = s || "toggle" === r, r === (m ? "hide" : "show")) {
                            if ("show" !== r || !g || void 0 === g[i]) continue;
                            m = !0
                        }
                        p[i] = g && g[i] || S.style(t, i)
                    } if ((l = !S.isEmptyObject(e)) || !S.isEmptyObject(p))
                    for (i in u && 1 === t.nodeType && (n.overflow = [f.overflow, f.overflowX, f.overflowY], null == (c = g && g.display) && (c = Z.get(t, "display")), "none" === (h = S.css(t, "display")) && (c ? h = c : (dt([t], !0), c = t.style.display || c, h = S.css(t, "display"), dt([t]))), ("inline" === h || "inline-block" === h && null != c) && "none" === S.css(t, "float") && (l || (d.done((function () {
                        f.display = c
                    })), null == c && (h = f.display, c = "none" === h ? "" : h)), f.display = "inline-block")), n.overflow && (f.overflow = "hidden", d.always((function () {
                        f.overflow = n.overflow[0], f.overflowX = n.overflow[1], f.overflowY = n.overflow[2]
                    }))), l = !1, p) l || (g ? "hidden" in g && (m = g.hidden) : g = Z.access(t, "fxshow", {
                        display: c
                    }), s && (g.hidden = !m), m && dt([t], !0), d.done((function () {
                        for (i in m || dt([t]), Z.remove(t, "fxshow"), p) S.style(t, i, p[i])
                    }))), l = ue(m ? g[i] : 0, i, d), i in g || (g[i] = l.start, m && (l.end = l.start, l.start = 0))
            }],
            prefilter: function (t, e) {
                e ? de.prefilters.unshift(t) : de.prefilters.push(t)
            }
        }), S.speed = function (t, e, n) {
            var i = t && "object" == typeof t ? S.extend({}, t) : {
                complete: n || !n && e || v(t) && t,
                duration: t,
                easing: n && e || e && !v(e) && e
            };
            return S.fx.off ? i.duration = 0 : "number" != typeof i.duration && (i.duration in S.fx.speeds ? i.duration = S.fx.speeds[i.duration] : i.duration = S.fx.speeds._default), null != i.queue && !0 !== i.queue || (i.queue = "fx"), i.old = i.complete, i.complete = function () {
                v(i.old) && i.old.call(this), i.queue && S.dequeue(this, i.queue)
            }, i
        }, S.fn.extend({
            fadeTo: function (t, e, n, i) {
                return this.filter(lt).css("opacity", 0).show().end().animate({
                    opacity: e
                }, t, n, i)
            },
            animate: function (t, e, n, i) {
                var r = S.isEmptyObject(t),
                    s = S.speed(e, n, i),
                    a = function () {
                        var e = de(this, S.extend({}, t), s);
                        (r || Z.get(this, "finish")) && e.stop(!0)
                    };
                return a.finish = a, r || !1 === s.queue ? this.each(a) : this.queue(s.queue, a)
            },
            stop: function (t, e, n) {
                var i = function (t) {
                    var e = t.stop;
                    delete t.stop, e(n)
                };
                return "string" != typeof t && (n = e, e = t, t = void 0), e && this.queue(t || "fx", []), this.each((function () {
                    var e = !0,
                        r = null != t && t + "queueHooks",
                        s = S.timers,
                        a = Z.get(this);
                    if (r) a[r] && a[r].stop && i(a[r]);
                    else
                        for (r in a) a[r] && a[r].stop && oe.test(r) && i(a[r]);
                    for (r = s.length; r--;) s[r].elem !== this || null != t && s[r].queue !== t || (s[r].anim.stop(n), e = !1, s.splice(r, 1));
                    !e && n || S.dequeue(this, t)
                }))
            },
            finish: function (t) {
                return !1 !== t && (t = t || "fx"), this.each((function () {
                    var e, n = Z.get(this),
                        i = n[t + "queue"],
                        r = n[t + "queueHooks"],
                        s = S.timers,
                        a = i ? i.length : 0;
                    for (n.finish = !0, S.queue(this, t, []), r && r.stop && r.stop.call(this, !0), e = s.length; e--;) s[e].elem === this && s[e].queue === t && (s[e].anim.stop(!0), s.splice(e, 1));
                    for (e = 0; e < a; e++) i[e] && i[e].finish && i[e].finish.call(this);
                    delete n.finish
                }))
            }
        }), S.each(["toggle", "show", "hide"], (function (t, e) {
            var n = S.fn[e];
            S.fn[e] = function (t, i, r) {
                return null == t || "boolean" == typeof t ? n.apply(this, arguments) : this.animate(he(e, !0), t, i, r)
            }
        })), S.each({
            slideDown: he("show"),
            slideUp: he("hide"),
            slideToggle: he("toggle"),
            fadeIn: {
                opacity: "show"
            },
            fadeOut: {
                opacity: "hide"
            },
            fadeToggle: {
                opacity: "toggle"
            }
        }, (function (t, e) {
            S.fn[t] = function (t, n, i) {
                return this.animate(e, t, n, i)
            }
        })), S.timers = [], S.fx.tick = function () {
            var t, e = 0,
                n = S.timers;
            for (re = Date.now(); e < n.length; e++)(t = n[e])() || n[e] !== t || n.splice(e--, 1);
            n.length || S.fx.stop(), re = void 0
        }, S.fx.timer = function (t) {
            S.timers.push(t), S.fx.start()
        }, S.fx.interval = 13, S.fx.start = function () {
            se || (se = !0, le())
        }, S.fx.stop = function () {
            se = null
        }, S.fx.speeds = {
            slow: 600,
            fast: 200,
            _default: 400
        }, S.fn.delay = function (t, e) {
            return t = S.fx && S.fx.speeds[t] || t, e = e || "fx", this.queue(e, (function (e, i) {
                var r = n.setTimeout(e, t);
                i.stop = function () {
                    n.clearTimeout(r)
                }
            }))
        },
            function () {
                var t = b.createElement("input"),
                    e = b.createElement("select").appendChild(b.createElement("option"));
                t.type = "checkbox", g.checkOn = "" !== t.value, g.optSelected = e.selected, (t = b.createElement("input")).value = "t", t.type = "radio", g.radioValue = "t" === t.value
            }();
        var pe, fe = S.expr.attrHandle;
        S.fn.extend({
            attr: function (t, e) {
                return V(this, S.attr, t, e, arguments.length > 1)
            },
            removeAttr: function (t) {
                return this.each((function () {
                    S.removeAttr(this, t)
                }))
            }
        }), S.extend({
            attr: function (t, e, n) {
                var i, r, s = t.nodeType;
                if (3 !== s && 8 !== s && 2 !== s) return void 0 === t.getAttribute ? S.prop(t, e, n) : (1 === s && S.isXMLDoc(t) || (r = S.attrHooks[e.toLowerCase()] || (S.expr.match.bool.test(e) ? pe : void 0)), void 0 !== n ? null === n ? void S.removeAttr(t, e) : r && "set" in r && void 0 !== (i = r.set(t, n, e)) ? i : (t.setAttribute(e, n + ""), n) : r && "get" in r && null !== (i = r.get(t, e)) ? i : null == (i = S.find.attr(t, e)) ? void 0 : i)
            },
            attrHooks: {
                type: {
                    set: function (t, e) {
                        if (!g.radioValue && "radio" === e && R(t, "input")) {
                            var n = t.value;
                            return t.setAttribute("type", e), n && (t.value = n), e
                        }
                    }
                }
            },
            removeAttr: function (t, e) {
                var n, i = 0,
                    r = e && e.match(U);
                if (r && 1 === t.nodeType)
                    for (; n = r[i++];) t.removeAttribute(n)
            }
        }), pe = {
            set: function (t, e, n) {
                return !1 === e ? S.removeAttr(t, n) : t.setAttribute(n, n), n
            }
        }, S.each(S.expr.match.bool.source.match(/\w+/g), (function (t, e) {
            var n = fe[e] || S.find.attr;
            fe[e] = function (t, e, i) {
                var r, s, a = e.toLowerCase();
                return i || (s = fe[a], fe[a] = r, r = null != n(t, e, i) ? a : null, fe[a] = s), r
            }
        }));
        var me = /^(?:input|select|textarea|button)$/i,
            ge = /^(?:a|area)$/i;

        function ve(t) {
            return (t.match(U) || []).join(" ")
        }

        function ye(t) {
            return t.getAttribute && t.getAttribute("class") || ""
        }

        function be(t) {
            return Array.isArray(t) ? t : "string" == typeof t && t.match(U) || []
        }
        S.fn.extend({
            prop: function (t, e) {
                return V(this, S.prop, t, e, arguments.length > 1)
            },
            removeProp: function (t) {
                return this.each((function () {
                    delete this[S.propFix[t] || t]
                }))
            }
        }), S.extend({
            prop: function (t, e, n) {
                var i, r, s = t.nodeType;
                if (3 !== s && 8 !== s && 2 !== s) return 1 === s && S.isXMLDoc(t) || (e = S.propFix[e] || e, r = S.propHooks[e]), void 0 !== n ? r && "set" in r && void 0 !== (i = r.set(t, n, e)) ? i : t[e] = n : r && "get" in r && null !== (i = r.get(t, e)) ? i : t[e]
            },
            propHooks: {
                tabIndex: {
                    get: function (t) {
                        var e = S.find.attr(t, "tabindex");
                        return e ? parseInt(e, 10) : me.test(t.nodeName) || ge.test(t.nodeName) && t.href ? 0 : -1
                    }
                }
            },
            propFix: {
                for: "htmlFor",
                class: "className"
            }
        }), g.optSelected || (S.propHooks.selected = {
            get: function (t) {
                var e = t.parentNode;
                return e && e.parentNode && e.parentNode.selectedIndex, null
            },
            set: function (t) {
                var e = t.parentNode;
                e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex)
            }
        }), S.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function () {
            S.propFix[this.toLowerCase()] = this
        })), S.fn.extend({
            addClass: function (t) {
                var e, n, i, r, s, a;
                return v(t) ? this.each((function (e) {
                    S(this).addClass(t.call(this, e, ye(this)))
                })) : (e = be(t)).length ? this.each((function () {
                    if (i = ye(this), n = 1 === this.nodeType && " " + ve(i) + " ") {
                        for (s = 0; s < e.length; s++) r = e[s], n.indexOf(" " + r + " ") < 0 && (n += r + " ");
                        a = ve(n), i !== a && this.setAttribute("class", a)
                    }
                })) : this
            },
            removeClass: function (t) {
                var e, n, i, r, s, a;
                return v(t) ? this.each((function (e) {
                    S(this).removeClass(t.call(this, e, ye(this)))
                })) : arguments.length ? (e = be(t)).length ? this.each((function () {
                    if (i = ye(this), n = 1 === this.nodeType && " " + ve(i) + " ") {
                        for (s = 0; s < e.length; s++)
                            for (r = e[s]; n.indexOf(" " + r + " ") > -1;) n = n.replace(" " + r + " ", " ");
                        a = ve(n), i !== a && this.setAttribute("class", a)
                    }
                })) : this : this.attr("class", "")
            },
            toggleClass: function (t, e) {
                var n, i, r, s, a = typeof t,
                    o = "string" === a || Array.isArray(t);
                return v(t) ? this.each((function (n) {
                    S(this).toggleClass(t.call(this, n, ye(this), e), e)
                })) : "boolean" == typeof e && o ? e ? this.addClass(t) : this.removeClass(t) : (n = be(t), this.each((function () {
                    if (o)
                        for (s = S(this), r = 0; r < n.length; r++) i = n[r], s.hasClass(i) ? s.removeClass(i) : s.addClass(i);
                    else void 0 !== t && "boolean" !== a || ((i = ye(this)) && Z.set(this, "__className__", i), this.setAttribute && this.setAttribute("class", i || !1 === t ? "" : Z.get(this, "__className__") || ""))
                })))
            },
            hasClass: function (t) {
                var e, n, i = 0;
                for (e = " " + t + " "; n = this[i++];)
                    if (1 === n.nodeType && (" " + ve(ye(n)) + " ").indexOf(e) > -1) return !0;
                return !1
            }
        });
        var xe = /\r/g;
        S.fn.extend({
            val: function (t) {
                var e, n, i, r = this[0];
                return arguments.length ? (i = v(t), this.each((function (n) {
                    var r;
                    1 === this.nodeType && (null == (r = i ? t.call(this, n, S(this).val()) : t) ? r = "" : "number" == typeof r ? r += "" : Array.isArray(r) && (r = S.map(r, (function (t) {
                        return null == t ? "" : t + ""
                    }))), (e = S.valHooks[this.type] || S.valHooks[this.nodeName.toLowerCase()]) && "set" in e && void 0 !== e.set(this, r, "value") || (this.value = r))
                }))) : r ? (e = S.valHooks[r.type] || S.valHooks[r.nodeName.toLowerCase()]) && "get" in e && void 0 !== (n = e.get(r, "value")) ? n : "string" == typeof (n = r.value) ? n.replace(xe, "") : null == n ? "" : n : void 0
            }
        }), S.extend({
            valHooks: {
                option: {
                    get: function (t) {
                        var e = S.find.attr(t, "value");
                        return null != e ? e : ve(S.text(t))
                    }
                },
                select: {
                    get: function (t) {
                        var e, n, i, r = t.options,
                            s = t.selectedIndex,
                            a = "select-one" === t.type,
                            o = a ? null : [],
                            l = a ? s + 1 : r.length;
                        for (i = s < 0 ? l : a ? s : 0; i < l; i++)
                            if (((n = r[i]).selected || i === s) && !n.disabled && (!n.parentNode.disabled || !R(n.parentNode, "optgroup"))) {
                                if (e = S(n).val(), a) return e;
                                o.push(e)
                            } return o
                    },
                    set: function (t, e) {
                        for (var n, i, r = t.options, s = S.makeArray(e), a = r.length; a--;)((i = r[a]).selected = S.inArray(S.valHooks.option.get(i), s) > -1) && (n = !0);
                        return n || (t.selectedIndex = -1), s
                    }
                }
            }
        }), S.each(["radio", "checkbox"], (function () {
            S.valHooks[this] = {
                set: function (t, e) {
                    if (Array.isArray(e)) return t.checked = S.inArray(S(t).val(), e) > -1
                }
            }, g.checkOn || (S.valHooks[this].get = function (t) {
                return null === t.getAttribute("value") ? "on" : t.value
            })
        })), g.focusin = "onfocusin" in n;
        var _e = /^(?:focusinfocus|focusoutblur)$/,
            we = function (t) {
                t.stopPropagation()
            };
        S.extend(S.event, {
            trigger: function (t, e, i, r) {
                var s, a, o, l, c, h, u, d, f = [i || b],
                    m = p.call(t, "type") ? t.type : t,
                    g = p.call(t, "namespace") ? t.namespace.split(".") : [];
                if (a = d = o = i = i || b, 3 !== i.nodeType && 8 !== i.nodeType && !_e.test(m + S.event.triggered) && (m.indexOf(".") > -1 && (g = m.split("."), m = g.shift(), g.sort()), c = m.indexOf(":") < 0 && "on" + m, (t = t[S.expando] ? t : new S.Event(m, "object" == typeof t && t)).isTrigger = r ? 2 : 3, t.namespace = g.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + g.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = i), e = null == e ? [t] : S.makeArray(e, [t]), u = S.event.special[m] || {}, r || !u.trigger || !1 !== u.trigger.apply(i, e))) {
                    if (!r && !u.noBubble && !y(i)) {
                        for (l = u.delegateType || m, _e.test(l + m) || (a = a.parentNode); a; a = a.parentNode) f.push(a), o = a;
                        o === (i.ownerDocument || b) && f.push(o.defaultView || o.parentWindow || n)
                    }
                    for (s = 0;
                        (a = f[s++]) && !t.isPropagationStopped();) d = a, t.type = s > 1 ? l : u.bindType || m, (h = (Z.get(a, "events") || Object.create(null))[t.type] && Z.get(a, "handle")) && h.apply(a, e), (h = c && a[c]) && h.apply && Y(a) && (t.result = h.apply(a, e), !1 === t.result && t.preventDefault());
                    return t.type = m, r || t.isDefaultPrevented() || u._default && !1 !== u._default.apply(f.pop(), e) || !Y(i) || c && v(i[m]) && !y(i) && ((o = i[c]) && (i[c] = null), S.event.triggered = m, t.isPropagationStopped() && d.addEventListener(m, we), i[m](), t.isPropagationStopped() && d.removeEventListener(m, we), S.event.triggered = void 0, o && (i[c] = o)), t.result
                }
            },
            simulate: function (t, e, n) {
                var i = S.extend(new S.Event, n, {
                    type: t,
                    isSimulated: !0
                });
                S.event.trigger(i, null, e)
            }
        }), S.fn.extend({
            trigger: function (t, e) {
                return this.each((function () {
                    S.event.trigger(t, e, this)
                }))
            },
            triggerHandler: function (t, e) {
                var n = this[0];
                if (n) return S.event.trigger(t, e, n, !0)
            }
        }), g.focusin || S.each({
            focus: "focusin",
            blur: "focusout"
        }, (function (t, e) {
            var n = function (t) {
                S.event.simulate(e, t.target, S.event.fix(t))
            };
            S.event.special[e] = {
                setup: function () {
                    var i = this.ownerDocument || this.document || this,
                        r = Z.access(i, e);
                    r || i.addEventListener(t, n, !0), Z.access(i, e, (r || 0) + 1)
                },
                teardown: function () {
                    var i = this.ownerDocument || this.document || this,
                        r = Z.access(i, e) - 1;
                    r ? Z.access(i, e, r) : (i.removeEventListener(t, n, !0), Z.remove(i, e))
                }
            }
        }));
        var Se = n.location,
            Me = {
                guid: Date.now()
            },
            Ee = /\?/;
        S.parseXML = function (t) {
            var e, i;
            if (!t || "string" != typeof t) return null;
            try {
                e = (new n.DOMParser).parseFromString(t, "text/xml")
            } catch (t) { }
            return i = e && e.getElementsByTagName("parsererror")[0], e && !i || S.error("Invalid XML: " + (i ? S.map(i.childNodes, (function (t) {
                return t.textContent
            })).join("\n") : t)), e
        };
        var Te = /\[\]$/,
            Ce = /\r?\n/g,
            Ae = /^(?:submit|button|image|reset|file)$/i,
            Re = /^(?:input|select|textarea|keygen)/i;

        function Pe(t, e, n, i) {
            var r;
            if (Array.isArray(e)) S.each(e, (function (e, r) {
                n || Te.test(t) ? i(t, r) : Pe(t + "[" + ("object" == typeof r && null != r ? e : "") + "]", r, n, i)
            }));
            else if (n || "object" !== w(e)) i(t, e);
            else
                for (r in e) Pe(t + "[" + r + "]", e[r], n, i)
        }
        S.param = function (t, e) {
            var n, i = [],
                r = function (t, e) {
                    var n = v(e) ? e() : e;
                    i[i.length] = encodeURIComponent(t) + "=" + encodeURIComponent(null == n ? "" : n)
                };
            if (null == t) return "";
            if (Array.isArray(t) || t.jquery && !S.isPlainObject(t)) S.each(t, (function () {
                r(this.name, this.value)
            }));
            else
                for (n in t) Pe(n, t[n], e, r);
            return i.join("&")
        }, S.fn.extend({
            serialize: function () {
                return S.param(this.serializeArray())
            },
            serializeArray: function () {
                return this.map((function () {
                    var t = S.prop(this, "elements");
                    return t ? S.makeArray(t) : this
                })).filter((function () {
                    var t = this.type;
                    return this.name && !S(this).is(":disabled") && Re.test(this.nodeName) && !Ae.test(t) && (this.checked || !mt.test(t))
                })).map((function (t, e) {
                    var n = S(this).val();
                    return null == n ? null : Array.isArray(n) ? S.map(n, (function (t) {
                        return {
                            name: e.name,
                            value: t.replace(Ce, "\r\n")
                        }
                    })) : {
                        name: e.name,
                        value: n.replace(Ce, "\r\n")
                    }
                })).get()
            }
        });
        var Le = /%20/g,
            Oe = /#.*$/,
            De = /([?&])_=[^&]*/,
            Ie = /^(.*?):[ \t]*([^\r\n]*)$/gm,
            ke = /^(?:GET|HEAD)$/,
            Ne = /^\/\//,
            Ue = {},
            ze = {},
            Fe = "*/".concat("*"),
            $e = b.createElement("a");

        function Be(t) {
            return function (e, n) {
                "string" != typeof e && (n = e, e = "*");
                var i, r = 0,
                    s = e.toLowerCase().match(U) || [];
                if (v(n))
                    for (; i = s[r++];) "+" === i[0] ? (i = i.slice(1) || "*", (t[i] = t[i] || []).unshift(n)) : (t[i] = t[i] || []).push(n)
            }
        }

        function He(t, e, n, i) {
            var r = {},
                s = t === ze;

            function a(o) {
                var l;
                return r[o] = !0, S.each(t[o] || [], (function (t, o) {
                    var c = o(e, n, i);
                    return "string" != typeof c || s || r[c] ? s ? !(l = c) : void 0 : (e.dataTypes.unshift(c), a(c), !1)
                })), l
            }
            return a(e.dataTypes[0]) || !r["*"] && a("*")
        }

        function je(t, e) {
            var n, i, r = S.ajaxSettings.flatOptions || {};
            for (n in e) void 0 !== e[n] && ((r[n] ? t : i || (i = {}))[n] = e[n]);
            return i && S.extend(!0, t, i), t
        }
        $e.href = Se.href, S.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: Se.href,
                type: "GET",
                isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Se.protocol),
                global: !0,
                processData: !0,
                async: !0,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                    "*": Fe,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },
                contents: {
                    xml: /\bxml\b/,
                    html: /\bhtml/,
                    json: /\bjson\b/
                },
                responseFields: {
                    xml: "responseXML",
                    text: "responseText",
                    json: "responseJSON"
                },
                converters: {
                    "* text": String,
                    "text html": !0,
                    "text json": JSON.parse,
                    "text xml": S.parseXML
                },
                flatOptions: {
                    url: !0,
                    context: !0
                }
            },
            ajaxSetup: function (t, e) {
                return e ? je(je(t, S.ajaxSettings), e) : je(S.ajaxSettings, t)
            },
            ajaxPrefilter: Be(Ue),
            ajaxTransport: Be(ze),
            ajax: function (t, e) {
                "object" == typeof t && (e = t, t = void 0), e = e || {};
                var i, r, s, a, o, l, c, h, u, d, p = S.ajaxSetup({}, e),
                    f = p.context || p,
                    m = p.context && (f.nodeType || f.jquery) ? S(f) : S.event,
                    g = S.Deferred(),
                    v = S.Callbacks("once memory"),
                    y = p.statusCode || {},
                    x = {},
                    _ = {},
                    w = "canceled",
                    M = {
                        readyState: 0,
                        getResponseHeader: function (t) {
                            var e;
                            if (c) {
                                if (!a)
                                    for (a = {}; e = Ie.exec(s);) a[e[1].toLowerCase() + " "] = (a[e[1].toLowerCase() + " "] || []).concat(e[2]);
                                e = a[t.toLowerCase() + " "]
                            }
                            return null == e ? null : e.join(", ")
                        },
                        getAllResponseHeaders: function () {
                            return c ? s : null
                        },
                        setRequestHeader: function (t, e) {
                            return null == c && (t = _[t.toLowerCase()] = _[t.toLowerCase()] || t, x[t] = e), this
                        },
                        overrideMimeType: function (t) {
                            return null == c && (p.mimeType = t), this
                        },
                        statusCode: function (t) {
                            var e;
                            if (t)
                                if (c) M.always(t[M.status]);
                                else
                                    for (e in t) y[e] = [y[e], t[e]];
                            return this
                        },
                        abort: function (t) {
                            var e = t || w;
                            return i && i.abort(e), E(0, e), this
                        }
                    };
                if (g.promise(M), p.url = ((t || p.url || Se.href) + "").replace(Ne, Se.protocol + "//"), p.type = e.method || e.type || p.method || p.type, p.dataTypes = (p.dataType || "*").toLowerCase().match(U) || [""], null == p.crossDomain) {
                    l = b.createElement("a");
                    try {
                        l.href = p.url, l.href = l.href, p.crossDomain = $e.protocol + "//" + $e.host != l.protocol + "//" + l.host
                    } catch (t) {
                        p.crossDomain = !0
                    }
                }
                if (p.data && p.processData && "string" != typeof p.data && (p.data = S.param(p.data, p.traditional)), He(Ue, p, e, M), c) return M;
                for (u in (h = S.event && p.global) && 0 == S.active++ && S.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !ke.test(p.type), r = p.url.replace(Oe, ""), p.hasContent ? p.data && p.processData && 0 === (p.contentType || "").indexOf("application/x-www-form-urlencoded") && (p.data = p.data.replace(Le, "+")) : (d = p.url.slice(r.length), p.data && (p.processData || "string" == typeof p.data) && (r += (Ee.test(r) ? "&" : "?") + p.data, delete p.data), !1 === p.cache && (r = r.replace(De, "$1"), d = (Ee.test(r) ? "&" : "?") + "_=" + Me.guid++ + d), p.url = r + d), p.ifModified && (S.lastModified[r] && M.setRequestHeader("If-Modified-Since", S.lastModified[r]), S.etag[r] && M.setRequestHeader("If-None-Match", S.etag[r])), (p.data && p.hasContent && !1 !== p.contentType || e.contentType) && M.setRequestHeader("Content-Type", p.contentType), M.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Fe + "; q=0.01" : "") : p.accepts["*"]), p.headers) M.setRequestHeader(u, p.headers[u]);
                if (p.beforeSend && (!1 === p.beforeSend.call(f, M, p) || c)) return M.abort();
                if (w = "abort", v.add(p.complete), M.done(p.success), M.fail(p.error), i = He(ze, p, e, M)) {
                    if (M.readyState = 1, h && m.trigger("ajaxSend", [M, p]), c) return M;
                    p.async && p.timeout > 0 && (o = n.setTimeout((function () {
                        M.abort("timeout")
                    }), p.timeout));
                    try {
                        c = !1, i.send(x, E)
                    } catch (t) {
                        if (c) throw t;
                        E(-1, t)
                    }
                } else E(-1, "No Transport");

                function E(t, e, a, l) {
                    var u, d, b, x, _, w = e;
                    c || (c = !0, o && n.clearTimeout(o), i = void 0, s = l || "", M.readyState = t > 0 ? 4 : 0, u = t >= 200 && t < 300 || 304 === t, a && (x = function (t, e, n) {
                        for (var i, r, s, a, o = t.contents, l = t.dataTypes;
                            "*" === l[0];) l.shift(), void 0 === i && (i = t.mimeType || e.getResponseHeader("Content-Type"));
                        if (i)
                            for (r in o)
                                if (o[r] && o[r].test(i)) {
                                    l.unshift(r);
                                    break
                                } if (l[0] in n) s = l[0];
                        else {
                            for (r in n) {
                                if (!l[0] || t.converters[r + " " + l[0]]) {
                                    s = r;
                                    break
                                }
                                a || (a = r)
                            }
                            s = s || a
                        }
                        if (s) return s !== l[0] && l.unshift(s), n[s]
                    }(p, M, a)), !u && S.inArray("script", p.dataTypes) > -1 && S.inArray("json", p.dataTypes) < 0 && (p.converters["text script"] = function () { }), x = function (t, e, n, i) {
                        var r, s, a, o, l, c = {},
                            h = t.dataTypes.slice();
                        if (h[1])
                            for (a in t.converters) c[a.toLowerCase()] = t.converters[a];
                        for (s = h.shift(); s;)
                            if (t.responseFields[s] && (n[t.responseFields[s]] = e), !l && i && t.dataFilter && (e = t.dataFilter(e, t.dataType)), l = s, s = h.shift())
                                if ("*" === s) s = l;
                                else if ("*" !== l && l !== s) {
                                    if (!(a = c[l + " " + s] || c["* " + s]))
                                        for (r in c)
                                            if ((o = r.split(" "))[1] === s && (a = c[l + " " + o[0]] || c["* " + o[0]])) {
                                                !0 === a ? a = c[r] : !0 !== c[r] && (s = o[0], h.unshift(o[1]));
                                                break
                                            } if (!0 !== a)
                                        if (a && t.throws) e = a(e);
                                        else try {
                                            e = a(e)
                                        } catch (t) {
                                            return {
                                                state: "parsererror",
                                                error: a ? t : "No conversion from " + l + " to " + s
                                            }
                                        }
                                }
                        return {
                            state: "success",
                            data: e
                        }
                    }(p, x, M, u), u ? (p.ifModified && ((_ = M.getResponseHeader("Last-Modified")) && (S.lastModified[r] = _), (_ = M.getResponseHeader("etag")) && (S.etag[r] = _)), 204 === t || "HEAD" === p.type ? w = "nocontent" : 304 === t ? w = "notmodified" : (w = x.state, d = x.data, u = !(b = x.error))) : (b = w, !t && w || (w = "error", t < 0 && (t = 0))), M.status = t, M.statusText = (e || w) + "", u ? g.resolveWith(f, [d, w, M]) : g.rejectWith(f, [M, w, b]), M.statusCode(y), y = void 0, h && m.trigger(u ? "ajaxSuccess" : "ajaxError", [M, p, u ? d : b]), v.fireWith(f, [M, w]), h && (m.trigger("ajaxComplete", [M, p]), --S.active || S.event.trigger("ajaxStop")))
                }
                return M
            },
            getJSON: function (t, e, n) {
                return S.get(t, e, n, "json")
            },
            getScript: function (t, e) {
                return S.get(t, void 0, e, "script")
            }
        }), S.each(["get", "post"], (function (t, e) {
            S[e] = function (t, n, i, r) {
                return v(n) && (r = r || i, i = n, n = void 0), S.ajax(S.extend({
                    url: t,
                    type: e,
                    dataType: r,
                    data: n,
                    success: i
                }, S.isPlainObject(t) && t))
            }
        })), S.ajaxPrefilter((function (t) {
            var e;
            for (e in t.headers) "content-type" === e.toLowerCase() && (t.contentType = t.headers[e] || "")
        })), S._evalUrl = function (t, e, n) {
            return S.ajax({
                url: t,
                type: "GET",
                dataType: "script",
                cache: !0,
                async: !1,
                global: !1,
                converters: {
                    "text script": function () { }
                },
                dataFilter: function (t) {
                    S.globalEval(t, e, n)
                }
            })
        }, S.fn.extend({
            wrapAll: function (t) {
                var e;
                return this[0] && (v(t) && (t = t.call(this[0])), e = S(t, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && e.insertBefore(this[0]), e.map((function () {
                    for (var t = this; t.firstElementChild;) t = t.firstElementChild;
                    return t
                })).append(this)), this
            },
            wrapInner: function (t) {
                return v(t) ? this.each((function (e) {
                    S(this).wrapInner(t.call(this, e))
                })) : this.each((function () {
                    var e = S(this),
                        n = e.contents();
                    n.length ? n.wrapAll(t) : e.append(t)
                }))
            },
            wrap: function (t) {
                var e = v(t);
                return this.each((function (n) {
                    S(this).wrapAll(e ? t.call(this, n) : t)
                }))
            },
            unwrap: function (t) {
                return this.parent(t).not("body").each((function () {
                    S(this).replaceWith(this.childNodes)
                })), this
            }
        }), S.expr.pseudos.hidden = function (t) {
            return !S.expr.pseudos.visible(t)
        }, S.expr.pseudos.visible = function (t) {
            return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length)
        }, S.ajaxSettings.xhr = function () {
            try {
                return new n.XMLHttpRequest
            } catch (t) { }
        };
        var Ve = {
            0: 200,
            1223: 204
        },
            Ge = S.ajaxSettings.xhr();
        g.cors = !!Ge && "withCredentials" in Ge, g.ajax = Ge = !!Ge, S.ajaxTransport((function (t) {
            var e, i;
            if (g.cors || Ge && !t.crossDomain) return {
                send: function (r, s) {
                    var a, o = t.xhr();
                    if (o.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields)
                        for (a in t.xhrFields) o[a] = t.xhrFields[a];
                    for (a in t.mimeType && o.overrideMimeType && o.overrideMimeType(t.mimeType), t.crossDomain || r["X-Requested-With"] || (r["X-Requested-With"] = "XMLHttpRequest"), r) o.setRequestHeader(a, r[a]);
                    e = function (t) {
                        return function () {
                            e && (e = i = o.onload = o.onerror = o.onabort = o.ontimeout = o.onreadystatechange = null, "abort" === t ? o.abort() : "error" === t ? "number" != typeof o.status ? s(0, "error") : s(o.status, o.statusText) : s(Ve[o.status] || o.status, o.statusText, "text" !== (o.responseType || "text") || "string" != typeof o.responseText ? {
                                binary: o.response
                            } : {
                                text: o.responseText
                            }, o.getAllResponseHeaders()))
                        }
                    }, o.onload = e(), i = o.onerror = o.ontimeout = e("error"), void 0 !== o.onabort ? o.onabort = i : o.onreadystatechange = function () {
                        4 === o.readyState && n.setTimeout((function () {
                            e && i()
                        }))
                    }, e = e("abort");
                    try {
                        o.send(t.hasContent && t.data || null)
                    } catch (t) {
                        if (e) throw t
                    }
                },
                abort: function () {
                    e && e()
                }
            }
        })), S.ajaxPrefilter((function (t) {
            t.crossDomain && (t.contents.script = !1)
        })), S.ajaxSetup({
            accepts: {
                script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            },
            contents: {
                script: /\b(?:java|ecma)script\b/
            },
            converters: {
                "text script": function (t) {
                    return S.globalEval(t), t
                }
            }
        }), S.ajaxPrefilter("script", (function (t) {
            void 0 === t.cache && (t.cache = !1), t.crossDomain && (t.type = "GET")
        })), S.ajaxTransport("script", (function (t) {
            var e, n;
            if (t.crossDomain || t.scriptAttrs) return {
                send: function (i, r) {
                    e = S("<script>").attr(t.scriptAttrs || {}).prop({
                        charset: t.scriptCharset,
                        src: t.url
                    }).on("load error", n = function (t) {
                        e.remove(), n = null, t && r("error" === t.type ? 404 : 200, t.type)
                    }), b.head.appendChild(e[0])
                },
                abort: function () {
                    n && n()
                }
            }
        }));
        var We, qe = [],
            Xe = /(=)\?(?=&|$)|\?\?/;
        S.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function () {
                var t = qe.pop() || S.expando + "_" + Me.guid++;
                return this[t] = !0, t
            }
        }), S.ajaxPrefilter("json jsonp", (function (t, e, i) {
            var r, s, a, o = !1 !== t.jsonp && (Xe.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && Xe.test(t.data) && "data");
            if (o || "jsonp" === t.dataTypes[0]) return r = t.jsonpCallback = v(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, o ? t[o] = t[o].replace(Xe, "$1" + r) : !1 !== t.jsonp && (t.url += (Ee.test(t.url) ? "&" : "?") + t.jsonp + "=" + r), t.converters["script json"] = function () {
                return a || S.error(r + " was not called"), a[0]
            }, t.dataTypes[0] = "json", s = n[r], n[r] = function () {
                a = arguments
            }, i.always((function () {
                void 0 === s ? S(n).removeProp(r) : n[r] = s, t[r] && (t.jsonpCallback = e.jsonpCallback, qe.push(r)), a && v(s) && s(a[0]), a = s = void 0
            })), "script"
        })), g.createHTMLDocument = ((We = b.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === We.childNodes.length), S.parseHTML = function (t, e, n) {
            return "string" != typeof t ? [] : ("boolean" == typeof e && (n = e, e = !1), e || (g.createHTMLDocument ? ((i = (e = b.implementation.createHTMLDocument("")).createElement("base")).href = b.location.href, e.head.appendChild(i)) : e = b), s = !n && [], (r = P.exec(t)) ? [e.createElement(r[1])] : (r = wt([t], e, s), s && s.length && S(s).remove(), S.merge([], r.childNodes)));
            var i, r, s
        }, S.fn.load = function (t, e, n) {
            var i, r, s, a = this,
                o = t.indexOf(" ");
            return o > -1 && (i = ve(t.slice(o)), t = t.slice(0, o)), v(e) ? (n = e, e = void 0) : e && "object" == typeof e && (r = "POST"), a.length > 0 && S.ajax({
                url: t,
                type: r || "GET",
                dataType: "html",
                data: e
            }).done((function (t) {
                s = arguments, a.html(i ? S("<div>").append(S.parseHTML(t)).find(i) : t)
            })).always(n && function (t, e) {
                a.each((function () {
                    n.apply(this, s || [t.responseText, e, t])
                }))
            }), this
        }, S.expr.pseudos.animated = function (t) {
            return S.grep(S.timers, (function (e) {
                return t === e.elem
            })).length
        }, S.offset = {
            setOffset: function (t, e, n) {
                var i, r, s, a, o, l, c = S.css(t, "position"),
                    h = S(t),
                    u = {};
                "static" === c && (t.style.position = "relative"), o = h.offset(), s = S.css(t, "top"), l = S.css(t, "left"), ("absolute" === c || "fixed" === c) && (s + l).indexOf("auto") > -1 ? (a = (i = h.position()).top, r = i.left) : (a = parseFloat(s) || 0, r = parseFloat(l) || 0), v(e) && (e = e.call(t, n, S.extend({}, o))), null != e.top && (u.top = e.top - o.top + a), null != e.left && (u.left = e.left - o.left + r), "using" in e ? e.using.call(t, u) : h.css(u)
            }
        }, S.fn.extend({
            offset: function (t) {
                if (arguments.length) return void 0 === t ? this : this.each((function (e) {
                    S.offset.setOffset(this, t, e)
                }));
                var e, n, i = this[0];
                return i ? i.getClientRects().length ? (e = i.getBoundingClientRect(), n = i.ownerDocument.defaultView, {
                    top: e.top + n.pageYOffset,
                    left: e.left + n.pageXOffset
                }) : {
                    top: 0,
                    left: 0
                } : void 0
            },
            position: function () {
                if (this[0]) {
                    var t, e, n, i = this[0],
                        r = {
                            top: 0,
                            left: 0
                        };
                    if ("fixed" === S.css(i, "position")) e = i.getBoundingClientRect();
                    else {
                        for (e = this.offset(), n = i.ownerDocument, t = i.offsetParent || n.documentElement; t && (t === n.body || t === n.documentElement) && "static" === S.css(t, "position");) t = t.parentNode;
                        t && t !== i && 1 === t.nodeType && ((r = S(t).offset()).top += S.css(t, "borderTopWidth", !0), r.left += S.css(t, "borderLeftWidth", !0))
                    }
                    return {
                        top: e.top - r.top - S.css(i, "marginTop", !0),
                        left: e.left - r.left - S.css(i, "marginLeft", !0)
                    }
                }
            },
            offsetParent: function () {
                return this.map((function () {
                    for (var t = this.offsetParent; t && "static" === S.css(t, "position");) t = t.offsetParent;
                    return t || st
                }))
            }
        }), S.each({
            scrollLeft: "pageXOffset",
            scrollTop: "pageYOffset"
        }, (function (t, e) {
            var n = "pageYOffset" === e;
            S.fn[t] = function (i) {
                return V(this, (function (t, i, r) {
                    var s;
                    if (y(t) ? s = t : 9 === t.nodeType && (s = t.defaultView), void 0 === r) return s ? s[e] : t[i];
                    s ? s.scrollTo(n ? s.pageXOffset : r, n ? r : s.pageYOffset) : t[i] = r
                }), t, i, arguments.length)
            }
        })), S.each(["top", "left"], (function (t, e) {
            S.cssHooks[e] = Wt(g.pixelPosition, (function (t, n) {
                if (n) return n = Gt(t, e), Ft.test(n) ? S(t).position()[e] + "px" : n
            }))
        })), S.each({
            Height: "height",
            Width: "width"
        }, (function (t, e) {
            S.each({
                padding: "inner" + t,
                content: e,
                "": "outer" + t
            }, (function (n, i) {
                S.fn[i] = function (r, s) {
                    var a = arguments.length && (n || "boolean" != typeof r),
                        o = n || (!0 === r || !0 === s ? "margin" : "border");
                    return V(this, (function (e, n, r) {
                        var s;
                        return y(e) ? 0 === i.indexOf("outer") ? e["inner" + t] : e.document.documentElement["client" + t] : 9 === e.nodeType ? (s = e.documentElement, Math.max(e.body["scroll" + t], s["scroll" + t], e.body["offset" + t], s["offset" + t], s["client" + t])) : void 0 === r ? S.css(e, n, o) : S.style(e, n, r, o)
                    }), e, a ? r : void 0, a)
                }
            }))
        })), S.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], (function (t, e) {
            S.fn[e] = function (t) {
                return this.on(e, t)
            }
        })), S.fn.extend({
            bind: function (t, e, n) {
                return this.on(t, null, e, n)
            },
            unbind: function (t, e) {
                return this.off(t, null, e)
            },
            delegate: function (t, e, n, i) {
                return this.on(e, t, n, i)
            },
            undelegate: function (t, e, n) {
                return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", n)
            },
            hover: function (t, e) {
                return this.mouseenter(t).mouseleave(e || t)
            }
        }), S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function (t, e) {
            S.fn[e] = function (t, n) {
                return arguments.length > 0 ? this.on(e, null, t, n) : this.trigger(e)
            }
        }));
        var Ye = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
        S.proxy = function (t, e) {
            var n, i, r;
            if ("string" == typeof e && (n = t[e], e = t, t = n), v(t)) return i = o.call(arguments, 2), (r = function () {
                return t.apply(e || this, i.concat(o.call(arguments)))
            }).guid = t.guid = t.guid || S.guid++, r
        }, S.holdReady = function (t) {
            t ? S.readyWait++ : S.ready(!0)
        }, S.isArray = Array.isArray, S.parseJSON = JSON.parse, S.nodeName = R, S.isFunction = v, S.isWindow = y, S.camelCase = X, S.type = w, S.now = Date.now, S.isNumeric = function (t) {
            var e = S.type(t);
            return ("number" === e || "string" === e) && !isNaN(t - parseFloat(t))
        }, S.trim = function (t) {
            return null == t ? "" : (t + "").replace(Ye, "$1")
        }, void 0 === (i = function () {
            return S
        }.apply(e, [])) || (t.exports = i);
        var Ke = n.jQuery,
            Ze = n.$;
        return S.noConflict = function (t) {
            return n.$ === S && (n.$ = Ze), t && n.jQuery === S && (n.jQuery = Ke), S
        }, void 0 === r && (n.jQuery = n.$ = S), S
    }))
}, function (t, e) {
    /*!
     * jquery-plugin-generator <https://github.com/kasparsz/jquery-plugin-generator>
     *
     * Copyright (c) 2020, Kaspars Zuks.
     * Licensed under the MIT License.
     */
    var n = 0;

    function i(t, e, n, i) {
        var r = function (t, e) {
            if ("string" == typeof t[0]) {
                var n = t[0],
                    i = e.api;
                if (!i || -1 !== i.indexOf(n)) return {
                    apiName: n,
                    apiParams: t.slice(1),
                    params: []
                }
            }
            return {
                apiName: null,
                apiParams: null,
                params: t
            }
        }(n, i),
            s = r.apiName,
            a = r.apiParams,
            o = r.params;
        if ("instance" === s) return t.data(i.namespace) || null;
        var l = function (t, e, n, i) {
            var r = t.data(i.namespace);
            if (r) i.optionsSetter && "function" == typeof r[i.optionsSetter] && r[i.optionsSetter].apply(r, n);
            else {
                var s = e.bind.apply(e, [e, t].concat(n));
                if (!(r = e.prototype ? new s : s()) || "object" != typeof r) return;
                t.data(i.namespace, r)
            }
            return r
        }(t, e, o, i);
        return l && s ? l[s].apply(l, a) : void 0
    }

    function r(t, e, n, r) {
        for (var s = t, a = 0, o = t.length; a < o; a++) {
            var l = i(t.eq(a), e, n, r);
            void 0 !== l && (s = l)
        }
        return s
    }
    t.exports = function (t, e) {
        void 0 === e && (e = {});
        var i = Object.assign({
            api: null,
            namespace: "ns" + n++,
            optionsSetter: "setOptions"
        }, e);
        if ("function" == typeof t) return function () {
            for (var e = [], n = arguments.length; n--;) e[n] = arguments[n];
            return r(this, t, e, i)
        };
        throw "fn is required field for jquery-plugin-generator"
    }
}, , function (t, e, n) {
    t.exports = n(339)
}, function (t, e, n) {
    "use strict";
    var i = n(82);
    const r = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i,
        s = /android|ipad|playbook|silk/i;
    let a;

    function o() {
        const t = window.innerWidth - document.documentElement.clientWidth;
        return t || (a || (a = document.createElement("div"), a.style.cssText = "width:100px;height:100px;overflow:scroll !important;position:absolute;top:-9999px", document.documentElement.appendChild(a)), a.offsetWidth - a.clientWidth)
    }

    function l() {
        let t = navigator.userAgent;
        return t.indexOf("MSIE ") > 0 || t.indexOf("Trident/") > 0 || t.indexOf("Edge/") > 0
    }

    function c() {
        let t = navigator.userAgent;
        return t.indexOf("MSIE ") > 0 || t.indexOf("Trident/") > 0
    }

    function h() {
        return u() || d()
    }

    function u() {
        const t = navigator.userAgent || navigator.vendor || window.opera;
        return r.test(t)
    }

    function d() {
        const t = navigator.userAgent || navigator.vendor || window.opera;
        return s.test(t)
    }
    e.a = {
        hasHoverSupport: function () {
            let t;
            return t = !(!c() && !l() || !o()) || !h() && (!(!matchMedia("(any-hover: hover)").matches && !matchMedia("(hover: hover)").matches) || !matchMedia("(hover: none)").matches && void 0 === document.documentElement.ontouchstart),
                function () {
                    return t
                }
        }(),
        getScrollbarWidth: o,
        isEdge: l,
        isIE: c,
        isSafari: function () {
            let t = navigator.userAgent;
            return /^((?!chrome|android).)*safari/i.test(t)
        },
        isMac: function () {
            return navigator.platform.toUpperCase().indexOf("MAC") >= 0
        },
        isIOS: function () {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1
        },
        isAndroid: function () {
            return navigator.userAgent.toLowerCase().indexOf("android") > -1
        },
        isMobile: h,
        isPhone: u,
        isTablet: d,
        isFirefox: function () {
            return navigator.userAgent.toLowerCase().indexOf("firefox") > -1
        },
        isBitrix: function () {
            return "undefined" != typeof BX
        },
        isReducedMotion: function () {
            return matchMedia("(prefers-reduced-motion: reduce)").matches || matchMedia("(update: slow)").matches || Object(i.a)()
        },
        isBrowserMessageTestMode: function () {
            let t = null;
            return function () {
                if (null === t) {
                    const e = $(".browser-message").get(0);
                    t = e && getComputedStyle(e).getPropertyValue("--test-mode")
                }
                return !!t
            }
        }(),
        isBot: i.a
    }
}, function (t, e, n) {
    "use strict";
    var i = n(80),
        r = n.n(i);

    function s(t) {
        return function (t) {
            let e = null;
            return r()(document.styleSheets, n => {
                let i = null;
                try {
                    i = n.rules || n.cssRules
                } catch (t) { }
                return r()(i || {}, n => {
                    if (n.type !== CSSRule.MEDIA_RULE && (n = n.parentRule), n) {
                        const i = n.cssText.indexOf(t);
                        if (-1 !== i) {
                            if (n.cssText[i + t.length] in {
                                " ": 1,
                                "{": 1,
                                ",": 1,
                                "\n": 1
                            }) {
                                if (n.media && n.media.length && n.media[0]) {
                                    e = n.media[0];
                                    for (let t = 1; t < n.media.length; t++) n.media[t] && (e += ", " + n.media[t])
                                } else n.media && n.media.mediaText && (e = n.media.mediaText);
                                return !0
                            }
                        }
                    }
                })
            }), e
        }(".is-hidden--" + t)
    }
    var a = {};

    function o(t) {
        let e = a[t];
        return null === e ? null : (e || (e = a[t] = s(t), null !== e ? e = a[t] = matchMedia(e) : function (t) {
            const e = matchMedia(t);
            return !(!e || "not all" === e.media)
        }(t) && (e = a[t] = matchMedia(t))), e)
    }

    function l(t, e) {
        const n = o(t);
        return n && n.addListener(e),
            function () {
                n && n.removeListener(e)
            }
    }
    e.a = {
        on: l,
        enter: function (t, e) {
            const n = l(t, (function (t) {
                t.matches && e.call(this, t)
            })),
                i = o(t);
            return i && i.matches && e.call(i, i), n
        },
        leave: function (t, e) {
            const n = l(t, (function (t) {
                t.matches || e.call(this, t)
            })),
                i = o(t);
            return i && !i.matches && e.call(i, i), n
        },
        matches: function (t) {
            if ("xs-up" === t) return !0;
            const e = o(t);
            return !!e && e.matches
        },
        getCSSQuery: s
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return a
    }));
    var i = n(1),
        r = n(9),
        s = n(139);
    n(30);
    class a {
        static get Defaults() {
            return {
                enableMq: null,
                enableHover: !0,
                enableTouch: !0,
                enableOnlyInView: !1,
                enableSmoothScroll: !0,
                enableNotSmoothScroll: !0
            }
        }
        constructor(t, e) {
            const n = this.options = i.a.extend({}, this.constructor.Defaults, e);
            this.$container = t, this.enabled = !1, this.ns = Object(r.a)(), this.init(), Object(s.a)(t, n, {
                enable: this.enable.bind(this),
                disable: this.disable.bind(this)
            }), t.on("destroyed", this.destroy.bind(this))
        }
        init() { }
        destroy() { }
        enable() {
            if (!this.enabled) return this.enabled = !0, !0
        }
        disable() {
            if (this.enabled) return this.enabled = !1, !0
        }
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return r
    }));
    let i = 0;

    function r() {
        return "ns" + i++
    }
}, function (t, e, n) {
    "use strict";
    var i = n(11),
        r = n.n(i),
        s = n(6);
    const a = s.a.isPhone() ? 160 : 16;
    const o = new class {
        constructor() {
            this.queue = [], this.queue[0] = [], this.queue[1] = [], this.queue[2] = [], this.running = !1, this.scheduled = !1, this.run = r()(this.run.bind(this), a), $(window).on("resize.queue appear.queue", this.run)
        }
        add(t, e) {
            this.queue[t].push(e)
        }
        remove(t, e) {
            const n = this.queue[t];
            for (let t = n.length - 1; t >= 0; t--)
                if (n[t] === e) return void n.splice(t, 1)
        }
        run() {
            if (this.running) return;
            this.running = !0;
            const t = this.queue;
            for (let e = 0; e < t[0].length; e++) t[0][e]();
            for (let e = 0; e < t[1].length; e++) t[1][e]();
            for (let e = 0; e < t[2].length; e++) t[2][e]();
            this.running = !1
        }
        schedule() {
            this.scheduled || (this.scheduled = !0, requestAnimationFrame(() => {
                this.scheduled = !1, this.run()
            }))
        }
    };
    o.QUEUE_RESET = 0, o.QUEUE_MEASURE = 1, o.QUEUE_APPLY = 2, e.a = o
}, function (t, e, n) {
    var i = n(27),
        r = n(342),
        s = n(215),
        a = Math.max,
        o = Math.min;
    t.exports = function (t, e, n) {
        var l, c, h, u, d, p, f = 0,
            m = !1,
            g = !1,
            v = !0;
        if ("function" != typeof t) throw new TypeError("Expected a function");

        function y(e) {
            var n = l,
                i = c;
            return l = c = void 0, f = e, u = t.apply(i, n)
        }

        function b(t) {
            return f = t, d = setTimeout(_, e), m ? y(t) : u
        }

        function x(t) {
            var n = t - p;
            return void 0 === p || n >= e || n < 0 || g && t - f >= h
        }

        function _() {
            var t = r();
            if (x(t)) return w(t);
            d = setTimeout(_, function (t) {
                var n = e - (t - p);
                return g ? o(n, h - (t - f)) : n
            }(t))
        }

        function w(t) {
            return d = void 0, v && l ? y(t) : (l = c = void 0, u)
        }

        function S() {
            var t = r(),
                n = x(t);
            if (l = arguments, c = this, p = t, n) {
                if (void 0 === d) return b(p);
                if (g) return clearTimeout(d), d = setTimeout(_, e), y(p)
            }
            return void 0 === d && (d = setTimeout(_, e)), u
        }
        return e = s(e) || 0, i(n) && (m = !!n.leading, h = (g = "maxWait" in n) ? a(s(n.maxWait) || 0, e) : h, v = "trailing" in n ? !!n.trailing : v), S.cancel = function () {
            void 0 !== d && clearTimeout(d), f = 0, l = p = c = d = void 0
        }, S.flush = function () {
            return void 0 === d ? u : w(r())
        }, S
    }
}, function (t, e, n) {
    var i = n(74),
        r = n(56),
        s = n(334),
        a = n(26);
    t.exports = function (t, e) {
        return (a(t) ? i : s)(t, r(e, 3))
    }
}, function (t, e, n) {
    "use strict";
    n.r(e);
    n(262);
    var i = {
        log: "log",
        debug: "debug",
        info: "info",
        warn: "warn",
        error: "error"
    },
        r = console,
        s = {};
    Object.keys(i).forEach((function (t) {
        s[t] = r[t]
    }));
    var a = "Datadog Browser SDK:",
        o = {
            debug: s.debug.bind(r, a),
            log: s.log.bind(r, a),
            info: s.info.bind(r, a),
            warn: s.warn.bind(r, a),
            error: s.error.bind(r, a)
        },
        l = "https://docs.datadoghq.com",
        c = "".concat(l, "/real_user_monitoring/browser/troubleshooting");

    function h(t, e) {
        return function () {
            for (var n = [], i = 0; i < arguments.length; i++) n[i] = arguments[i];
            try {
                return t.apply(void 0, n)
            } catch (t) {
                o.error(e, t)
            }
        }
    }
    var u, d = function (t, e, n) {
        if (n || 2 === arguments.length)
            for (var i, r = 0, s = e.length; r < s; r++) !i && r in e || (i || (i = Array.prototype.slice.call(e, 0, r)), i[r] = e[r]);
        return t.concat(i || Array.prototype.slice.call(e))
    },
        p = !1;

    function f(t) {
        p = t
    }

    function m(t) {
        return function () {
            return g(t, this, arguments)
        }
    }

    function g(t, e, n) {
        try {
            return t.apply(e, n)
        } catch (t) {
            if (v(t), u) try {
                u(t)
            } catch (t) {
                v(t)
            }
        }
    }

    function v() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        p && o.error.apply(o, d(["[MONITOR]"], t, !1))
    }

    function y(t, e) {
        return -1 !== t.indexOf(e)
    }

    function b(t) {
        if (Array.from) return Array.from(t);
        var e = [];
        if (t instanceof Set) t.forEach((function (t) {
            return e.push(t)
        }));
        else
            for (var n = 0; n < t.length; n++) e.push(t[n]);
        return e
    }

    function x(t, e) {
        for (var n = 0; n < t.length; n += 1) {
            var i = t[n];
            if (e(i, n)) return i
        }
    }

    function _(t, e) {
        Array.prototype.forEach.call(t, e)
    }

    function w(t) {
        return Object.keys(t).map((function (e) {
            return t[e]
        }))
    }

    function S(t) {
        return Object.keys(t).map((function (e) {
            return [e, t[e]]
        }))
    }

    function M(t, e) {
        return t.slice(0, e.length) === e
    }

    function E(t) {
        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
        return e.forEach((function (e) {
            for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
        })), t
    }

    function T() {
        if ("object" == typeof globalThis) return globalThis;
        Object.defineProperty(Object.prototype, "_dd_temp_", {
            get: function () {
                return this
            },
            configurable: !0
        });
        var t = _dd_temp_;
        return delete Object.prototype._dd_temp_, "object" != typeof t && (t = "object" == typeof self ? self : "object" == typeof window ? window : {}), t
    }
    var C = /[^\u0000-\u007F]/;

    function A(t) {
        return C.test(t) ? void 0 !== window.TextEncoder ? (new TextEncoder).encode(t).length : new Blob([t]).size : t.length
    }

    function R(t, e) {
        var n, i = T();
        return i.Zone && "function" == typeof i.Zone.__symbol__ && (n = t[i.Zone.__symbol__(e)]), n || (n = t[e]), n
    }

    function P(t, e) {
        return R(T(), "setTimeout")(m(t), e)
    }

    function L(t) {
        R(T(), "clearTimeout")(t)
    }

    function O(t, e) {
        return R(T(), "setInterval")(m(t), e)
    }

    function D(t) {
        R(T(), "clearInterval")(t)
    }

    function I(t, e, n) {
        var i, r, s = !n || void 0 === n.leading || n.leading,
            a = !n || void 0 === n.trailing || n.trailing,
            o = !1;
        return {
            throttled: function () {
                for (var n = [], l = 0; l < arguments.length; l++) n[l] = arguments[l];
                o ? i = n : (s ? t.apply(void 0, n) : i = n, o = !0, r = P((function () {
                    a && i && t.apply(void 0, i), o = !1, i = void 0
                }), e))
            },
            cancel: function () {
                L(r), o = !1, i = void 0
            }
        }
    }

    function k() { }

    function N(t, e, n) {
        if ("object" != typeof t || null === t) return JSON.stringify(t);
        var i = U(Object.prototype),
            r = U(Array.prototype),
            s = U(Object.getPrototypeOf(t)),
            a = U(t);
        try {
            return JSON.stringify(t, e, n)
        } catch (t) {
            return "<error: unable to serialize object>"
        } finally {
            i(), r(), s(), a()
        }
    }

    function U(t) {
        var e = t,
            n = e.toJSON;
        return n ? (delete e.toJSON, function () {
            e.toJSON = n
        }) : k
    }

    function z(t) {
        return E({}, t)
    }

    function F(t, e) {
        return Object.keys(t).some((function (n) {
            return t[n] === e
        }))
    }

    function B(t) {
        return 0 === Object.keys(t).length
    }

    function H(t) {
        void 0 === t && (t = 2);
        var e = new Map,
            n = !1;

        function i(i) {
            if (void 0 === i && (i = 0), !n && 0 !== t) {
                var r = 2 === t ? 3072 : 16384,
                    s = i;
                e.forEach((function (t) {
                    s += t.getBytesCount()
                })), s > r && (! function (t) {
                    o.warn("Customer data exceeds the recommended ".concat(t / 1024, "KiB threshold. ").concat("More details:", " ").concat(c, "/#customer-data-exceeds-the-recommended-threshold-warning"))
                }(r), n = !0)
            }
        }
        return {
            createDetachedTracker: function () {
                var t = j((function () {
                    return i(t.getBytesCount())
                }));
                return t
            },
            getOrCreateTracker: function (t) {
                return e.has(t) || e.set(t, j(i)), e.get(t)
            },
            setCompressionStatus: function (e) {
                0 === t && (t = e, i())
            },
            getCompressionStatus: function () {
                return t
            },
            stop: function () {
                e.forEach((function (t) {
                    return t.stop()
                })), e.clear()
            }
        }
    }

    function j(t) {
        var e = 0,
            n = I((function (n) {
                e = A(N(n)), t()
            }), 200),
            i = n.throttled,
            r = n.cancel,
            s = function () {
                r(), e = 0
            };
        return {
            updateCustomerData: function (t) {
                B(t) ? s() : i(t)
            },
            resetCustomerData: s,
            getBytesCount: function () {
                return e
            },
            stop: function () {
                r()
            }
        }
    }

    function V(t) {
        return null === t ? "null" : Array.isArray(t) ? "array" : typeof t
    }

    function G(t, e, n) {
        if (void 0 === n && (n = function () {
            if ("undefined" != typeof WeakSet) {
                var t = new WeakSet;
                return {
                    hasAlreadyBeenSeen: function (e) {
                        var n = t.has(e);
                        return n || t.add(e), n
                    }
                }
            }
            var e = [];
            return {
                hasAlreadyBeenSeen: function (t) {
                    var n = e.indexOf(t) >= 0;
                    return n || e.push(t), n
                }
            }
        }()), void 0 === e) return t;
        if ("object" != typeof e || null === e) return e;
        if (e instanceof Date) return new Date(e.getTime());
        if (e instanceof RegExp) {
            var i = e.flags || [e.global ? "g" : "", e.ignoreCase ? "i" : "", e.multiline ? "m" : "", e.sticky ? "y" : "", e.unicode ? "u" : ""].join("");
            return new RegExp(e.source, i)
        }
        if (!n.hasAlreadyBeenSeen(e)) {
            if (Array.isArray(e)) {
                for (var r = Array.isArray(t) ? t : [], s = 0; s < e.length; ++s) r[s] = G(r[s], e[s], n);
                return r
            }
            var a = "object" === V(t) ? t : {};
            for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && (a[o] = G(a[o], e[o], n));
            return a
        }
    }

    function W(t) {
        return G(void 0, t)
    }

    function q() {
        for (var t, e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
        for (var i = 0, r = e; i < r.length; i++) {
            var s = r[i];
            null != s && (t = G(t, s))
        }
        return t
    }

    function X(t, e) {
        void 0 === e && (e = 225280);
        var n = U(Object.prototype),
            i = U(Array.prototype),
            r = [],
            s = new WeakMap,
            a = Y(t, "$", void 0, r, s),
            o = JSON.stringify(a),
            l = o ? o.length : 0;
        if (!(l > e)) {
            for (; r.length > 0 && l < e;) {
                var c = r.shift(),
                    h = 0;
                if (Array.isArray(c.source))
                    for (var u = 0; u < c.source.length; u++) {
                        if (l += void 0 !== (d = Y(c.source[u], c.path, u, r, s)) ? JSON.stringify(d).length : 4, l += h, h = 1, l > e) {
                            K(e, "truncated", t);
                            break
                        }
                        c.target[u] = d
                    } else
                    for (var u in c.source)
                        if (Object.prototype.hasOwnProperty.call(c.source, u)) {
                            var d;
                            if (void 0 !== (d = Y(c.source[u], c.path, u, r, s)) && (l += JSON.stringify(d).length + h + u.length + 3, h = 1), l > e) {
                                K(e, "truncated", t);
                                break
                            }
                            c.target[u] = d
                        }
            }
            return n(), i(), a
        }
        K(e, "discarded", t)
    }

    function Y(t, e, n, i, r) {
        var s = function (t) {
            var e = t;
            if (e && "function" == typeof e.toJSON) try {
                return e.toJSON()
            } catch (t) { }
            return t
        }(t);
        if (!s || "object" != typeof s) return function (t) {
            if ("bigint" == typeof t) return "[BigInt] ".concat(t.toString());
            if ("function" == typeof t) return "[Function] ".concat(t.name || "unknown");
            if ("symbol" == typeof t) return "[Symbol] ".concat(t.description || t.toString());
            return t
        }(s);
        var a = function (t) {
            try {
                if (t instanceof Event) return {
                    isTrusted: t.isTrusted
                };
                var e = Object.prototype.toString.call(t).match(/\[object (.*)\]/);
                if (e && e[1]) return "[".concat(e[1], "]")
            } catch (t) { }
            return "[Unserializable]"
        }(s);
        if ("[Object]" !== a && "[Array]" !== a && "[Error]" !== a) return a;
        var o = t;
        if (r.has(o)) return "[Reference seen at ".concat(r.get(o), "]");
        var l = void 0 !== n ? "".concat(e, ".").concat(n) : e,
            c = Array.isArray(s) ? [] : {};
        return r.set(o, l), i.push({
            source: s,
            target: c,
            path: l
        }), c
    }

    function K(t, e, n) {
        o.warn("The data provided has been ".concat(e, " as it is over the limit of ").concat(t, " characters:"), n)
    }
    var Z = function () {
        function t(t) {
            this.onFirstSubscribe = t, this.observers = []
        }
        return t.prototype.subscribe = function (t) {
            var e = this;
            return this.observers.push(t), 1 === this.observers.length && this.onFirstSubscribe && (this.onLastUnsubscribe = this.onFirstSubscribe(this) || void 0), {
                unsubscribe: function () {
                    e.observers = e.observers.filter((function (e) {
                        return t !== e
                    })), !e.observers.length && e.onLastUnsubscribe && e.onLastUnsubscribe()
                }
            }
        }, t.prototype.notify = function (t) {
            this.observers.forEach((function (e) {
                return e(t)
            }))
        }, t
    }();

    function J() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        return new Z((function (e) {
            var n = t.map((function (t) {
                return t.subscribe((function (t) {
                    return e.notify(t)
                }))
            }));
            return function () {
                return n.forEach((function (t) {
                    return t.unsubscribe()
                }))
            }
        }))
    }

    function Q(t) {
        var e = {},
            n = new Z,
            i = {
                getContext: function () {
                    return W(e)
                },
                setContext: function (r) {
                    "object" === V(r) ? (e = X(r), t.updateCustomerData(e)) : i.clearContext(), n.notify()
                },
                setContextProperty: function (i, r) {
                    e[i] = X(r), t.updateCustomerData(e), n.notify()
                },
                removeContextProperty: function (i) {
                    delete e[i], t.updateCustomerData(e), n.notify()
                },
                clearContext: function () {
                    e = {}, t.resetCustomerData(), n.notify()
                },
                changeObservable: n
            };
        return i
    }
    var tt, et = {
        GRANTED: "granted",
        NOT_GRANTED: "not-granted"
    };
    ! function (t) {
        t.WRITABLE_RESOURCE_GRAPHQL = "writable_resource_graphql", t.CUSTOM_VITALS = "custom_vitals", t.TOLERANT_RESOURCE_TIMINGS = "tolerant_resource_timings", t.REMOTE_CONFIGURATION = "remote_configuration", t.UPDATE_VIEW_NAME = "update_view_name"
    }(tt || (tt = {}));
    var nt = new Set;

    function it(t) {
        Array.isArray(t) && t.filter((function (t) {
            return F(tt, t)
        })).forEach((function (t) {
            nt.add(t)
        }))
    }

    function rt(t) {
        return nt.has(t)
    }

    function st(t) {
        var e = [],
            n = pt(t, "stack"),
            i = String(t);
        return n && M(n, i) && (n = n.slice(i.length)), n && n.split("\n").forEach((function (t) {
            var n = function (t) {
                var e = ot.exec(t);
                if (!e) return;
                var n = e[2] && 0 === e[2].indexOf("native"),
                    i = e[2] && 0 === e[2].indexOf("eval"),
                    r = lt.exec(e[2]);
                i && r && (e[2] = r[1], e[3] = r[2], e[4] = r[3]);
                return {
                    args: n ? [e[2]] : [],
                    column: e[4] ? +e[4] : void 0,
                    func: e[1] || "?",
                    line: e[3] ? +e[3] : void 0,
                    url: n ? void 0 : e[2]
                }
            }(t) || function (t) {
                var e = ct.exec(t);
                if (!e) return;
                return {
                    args: [],
                    column: e[3] ? +e[3] : void 0,
                    func: "?",
                    line: e[2] ? +e[2] : void 0,
                    url: e[1]
                }
            }(t) || function (t) {
                var e = ht.exec(t);
                if (!e) return;
                return {
                    args: [],
                    column: e[4] ? +e[4] : void 0,
                    func: e[1] || "?",
                    line: +e[3],
                    url: e[2]
                }
            }(t) || function (t) {
                var e = ut.exec(t);
                if (!e) return;
                var n = e[3] && e[3].indexOf(" > eval") > -1,
                    i = dt.exec(e[3]);
                n && i && (e[3] = i[1], e[4] = i[2], e[5] = void 0);
                return {
                    args: e[2] ? e[2].split(",") : [],
                    column: e[5] ? +e[5] : void 0,
                    func: e[1] || "?",
                    line: e[4] ? +e[4] : void 0,
                    url: e[3]
                }
            }(t);
            n && (!n.func && n.line && (n.func = "?"), e.push(n))
        })), {
            message: pt(t, "message"),
            name: pt(t, "name"),
            stack: e
        }
    }
    var at = "((?:file|https?|blob|chrome-extension|native|eval|webpack|snippet|<anonymous>|\\w+\\.|\\/).*?)",
        ot = new RegExp("^\\s*at (.*?) ?\\(".concat(at).concat("(?::(\\d+))", "?").concat("(?::(\\d+))", "?\\)?\\s*$"), "i"),
        lt = new RegExp("\\((\\S*)".concat("(?::(\\d+))").concat("(?::(\\d+))", "\\)"));
    var ct = new RegExp("^\\s*at ?".concat(at).concat("(?::(\\d+))", "?").concat("(?::(\\d+))", "??\\s*$"), "i");
    var ht = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    var ut = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,
        dt = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

    function pt(t, e) {
        if ("object" == typeof t && t && e in t) {
            var n = t[e];
            return "string" == typeof n ? n : void 0
        }
    }

    function ft(t, e, n, i) {
        var r = [{
            url: e,
            column: i,
            line: n
        }],
            s = function (t) {
                var e, n, i;
                "[object String]" === {}.toString.call(t) && (e = mt.exec(t), n = e[1], i = e[2]);
                return {
                    name: n,
                    message: i
                }
            }(t);
        return {
            name: s.name,
            message: s.message,
            stack: r
        }
    }
    var mt = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?([\s\S]*)$/;

    function gt() {
        var t, e = new Error;
        if (!e.stack) try {
            throw e
        } catch (t) { }
        return g((function () {
            var n = st(e);
            n.stack = n.stack.slice(2), t = vt(n)
        })), t
    }

    function vt(t) {
        var e = yt(t);
        return t.stack.forEach((function (t) {
            var n = "?" === t.func ? "<anonymous>" : t.func,
                i = t.args && t.args.length > 0 ? "(".concat(t.args.join(", "), ")") : "",
                r = t.line ? ":".concat(t.line) : "",
                s = t.line && t.column ? ":".concat(t.column) : "";
            e += "\n  at ".concat(n).concat(i, " @ ").concat(t.url).concat(r).concat(s)
        })), e
    }

    function yt(t) {
        return "".concat(t.name || "Error", ": ").concat(t.message)
    }

    function bt(t) {
        var e = t.stackTrace,
            n = t.originalError,
            i = t.handlingStack,
            r = t.startClocks,
            s = t.nonErrorPrefix,
            a = t.source,
            o = t.handling,
            l = n instanceof Error,
            c = function (t, e, n, i) {
                return (null == t ? void 0 : t.message) && (null == t ? void 0 : t.name) ? t.message : e ? "Empty message" : "".concat(n, " ").concat(N(X(i)))
            }(e, l, s, n),
            h = function (t, e) {
                if (void 0 === e) return !1;
                if (t) return !0;
                return e.stack.length > 0 && (e.stack.length > 1 || void 0 !== e.stack[0].url)
            }(l, e) ? vt(e) : "No stack, consider using an instance of Error",
            u = l ? _t(n, a) : void 0;
        return {
            startClocks: r,
            source: a,
            handling: o,
            handlingStack: i,
            originalError: n,
            type: e ? e.name : void 0,
            message: c,
            stack: h,
            causes: u,
            fingerprint: xt(n)
        }
    }

    function xt(t) {
        return t instanceof Error && "dd_fingerprint" in t ? String(t.dd_fingerprint) : void 0
    }

    function _t(t, e) {
        for (var n = t, i = [];
            (null == n ? void 0 : n.cause) instanceof Error && i.length < 10;) {
            var r = st(n.cause);
            i.push({
                message: n.cause.message,
                source: e,
                type: null == r ? void 0 : r.name,
                stack: r && vt(r)
            }), n = n.cause
        }
        return i.length ? i : void 0
    }

    function wt(t) {
        return 0 !== t && 100 * Math.random() <= t
    }

    function St(t, e) {
        return +t.toFixed(e)
    }

    function Mt(t) {
        return "number" == typeof t
    }
    var Et;

    function Tt(t) {
        return {
            relative: t,
            timeStamp: Ct(t)
        }
    }

    function Ct(t) {
        var e = Rt() - performance.now();
        return e > Ut() ? Math.round(kt(e, t)) : function (t) {
            return Math.round(kt(Ut(), t))
        }(t)
    }

    function At(t) {
        return Mt(t) ? St(1e6 * t, 0) : t
    }

    function Rt() {
        return (new Date).getTime()
    }

    function Pt() {
        return Rt()
    }

    function Lt() {
        return performance.now()
    }

    function Ot() {
        return {
            relative: Lt(),
            timeStamp: Pt()
        }
    }

    function Dt() {
        return {
            relative: 0,
            timeStamp: Ut()
        }
    }

    function It(t, e) {
        return e - t
    }

    function kt(t, e) {
        return t + e
    }

    function Nt(t) {
        return t - Ut()
    }

    function Ut() {
        return void 0 === Et && (Et = performance.timing.navigationStart), Et
    }

    function zt(t, e) {
        var n = window.__ddBrowserSdkExtensionCallback;
        n && n({
            type: t,
            payload: e
        })
    }

    function Ft() {
        var t, e = window.navigator;
        return {
            status: e.onLine ? "connected" : "not_connected",
            interfaces: e.connection && e.connection.type ? [e.connection.type] : void 0,
            effective_type: null === (t = e.connection) || void 0 === t ? void 0 : t.effectiveType
        }
    }

    function $t(t, e) {
        var n = t.indexOf(e);
        n >= 0 && t.splice(n, 1)
    }

    function Bt() {
        var t = [];
        return {
            add: function (e) {
                t.push(e) > 500 && t.splice(0, 1)
            },
            remove: function (e) {
                $t(t, e)
            },
            drain: function (e) {
                t.forEach((function (t) {
                    return t(e)
                })), t.length = 0
            }
        }
    }
    var Ht = "log",
        jt = "configuration",
        Vt = "usage",
        Gt = ["https://www.datadoghq-browser-agent.com", "https://www.datad0g-browser-agent.com", "https://d3uc069fcn7uxw.cloudfront.net", "https://d20xtzwzcl0ceb.cloudfront.net", "http://localhost", "<anonymous>"],
        Wt = ["ddog-gov.com"],
        qt = Bt(),
        Xt = function (t) {
            qt.add((function () {
                return Xt(t)
            }))
        };

    function Yt(t, e) {
        var n, i, r = new Z,
            s = new Set,
            a = !y(Wt, e.site) && wt(e.telemetrySampleRate),
            o = ((n = {})[Ht] = a, n[jt] = a && wt(e.telemetryConfigurationSampleRate), n[Vt] = a && wt(e.telemetryUsageSampleRate), n),
            l = {
                is_local_file: "file:" === window.location.protocol,
                is_worker: "WorkerGlobalScope" in self
            };
        return Xt = function (n) {
            var a = N(n);
            if (o[n.type] && s.size < e.maxTelemetryEventsPerPage && !s.has(a)) {
                var c = function (t, e, n) {
                    return q({
                        type: "telemetry",
                        date: Pt(),
                        service: t,
                        version: "5.23.3",
                        source: "browser",
                        _dd: {
                            format_version: 2
                        },
                        telemetry: q(e, {
                            runtime_env: n,
                            connectivity: Ft()
                        }),
                        experimental_features: b(nt)
                    }, void 0 !== i ? i() : {})
                }(t, n, l);
                r.notify(c), zt("telemetry", c), s.add(a)
            }
        }, u = Zt, {
            setContextProvider: function (t) {
                i = t
            },
            observable: r,
            enabled: a
        }
    }

    function Kt(t, e) {
        v(i.debug, t, e), Xt(E({
            type: Ht,
            message: t,
            status: "debug"
        }, e))
    }

    function Zt(t, e) {
        Xt(E({
            type: Ht,
            status: "error"
        }, function (t) {
            if (t instanceof Error) {
                var e = st(t);
                return {
                    error: {
                        kind: e.name,
                        stack: vt(Qt(e))
                    },
                    message: e.message
                }
            }
            return {
                error: {
                    stack: "No stack, consider using an instance of Error"
                },
                message: "".concat("Uncaught", " ").concat(N(t))
            }
        }(t), e))
    }

    function Jt(t) {
        Xt({
            type: Vt,
            usage: t
        })
    }

    function Qt(t) {
        return t.stack = t.stack.filter((function (t) {
            return !t.url || Gt.some((function (e) {
                return M(t.url, e)
            }))
        })), t
    }

    function te(t, e, n, i, r) {
        return ee(t, e, [n], i, r)
    }

    function ee(t, e, n, i, r) {
        var s = void 0 === r ? {} : r,
            a = s.once,
            o = s.capture,
            l = s.passive,
            c = m((function (e) {
                (e.isTrusted || e.__ddIsTrusted || t.allowUntrustedEvents) && (a && d(), i(e))
            })),
            h = l ? {
                capture: o,
                passive: l
            } : o,
            u = R(e, "addEventListener");

        function d() {
            var t = R(e, "removeEventListener");
            n.forEach((function (n) {
                return t.call(e, n, c, h)
            }))
        }
        return n.forEach((function (t) {
            return u.call(e, t, c, h)
        })), {
            stop: d
        }
    }
    var ne = [];

    function ie(t, e, n, i) {
        var r = function (t, e) {
            return "".concat("_dd_c", "_").concat(t, "_").concat(e)
        }(n, i);

        function s() {
            var t = localStorage.getItem(r);
            return null !== t ? JSON.parse(t) : {}
        }
        ne.push(te(t, window, "storage", (function (t) {
            var n = t.key;
            r === n && e.setContext(s())
        }))), e.changeObservable.subscribe((function () {
            localStorage.setItem(r, JSON.stringify(e.getContext()))
        })), e.setContext(q(s(), e.getContext()))
    }

    function re() {
        var t = "",
            e = 0;
        return {
            isAsync: !1,
            get isEmpty() {
                return !t
            },
            write: function (n, i) {
                var r = A(n);
                e += r, t += n, i && i(r)
            },
            finish: function (t) {
                t(this.finishSync())
            },
            finishSync: function () {
                var n = {
                    output: t,
                    outputBytesCount: e,
                    rawBytesCount: e,
                    pendingData: ""
                };
                return t = "", e = 0, n
            },
            estimateEncodedBytesCount: function (t) {
                return t.length
            }
        }
    }

    function se(t) {
        var e = E({}, t);
        return ["id", "name", "email"].forEach((function (t) {
            t in e && (e[t] = String(e[t]))
        })), e
    }

    function ae(t, e) {
        e.silentMultipleInit || o.error("".concat(t, " is already initialized."))
    }

    function oe() {
        var t = T().DatadogEventBridge;
        if (t) return {
            getCapabilities: function () {
                var e;
                return JSON.parse((null === (e = t.getCapabilities) || void 0 === e ? void 0 : e.call(t)) || "[]")
            },
            getPrivacyLevel: function () {
                var e;
                return null === (e = t.getPrivacyLevel) || void 0 === e ? void 0 : e.call(t)
            },
            getAllowedWebViewHosts: function () {
                return JSON.parse(t.getAllowedWebViewHosts())
            },
            send: function (e, n, i) {
                var r = i ? {
                    id: i
                } : void 0;
                t.send(JSON.stringify({
                    eventType: e,
                    event: n,
                    view: r
                }))
            }
        }
    }

    function le(t) {
        var e = oe();
        return !!e && y(e.getCapabilities(), t)
    }

    function ce(t) {
        var e;
        void 0 === t && (t = null === (e = T().location) || void 0 === e ? void 0 : e.hostname);
        var n = oe();
        return !!n && n.getAllowedWebViewHosts().some((function (e) {
            return t === e || (n = t, i = ".".concat(e), n.slice(-i.length) === i);
            var n, i
        }))
    }

    function he(t, e, n, i) {
        var r = (void 0 === i ? {} : i).computeHandlingStack,
            s = t[e];
        if ("function" != typeof s) {
            if (!M(e, "on")) return {
                stop: k
            };
            s = k
        }
        var a = !1,
            o = function () {
                if (a) return s.apply(this, arguments);
                var t, e = b(arguments);
                g(n, null, [{
                    target: this,
                    parameters: e,
                    onPostCall: function (e) {
                        t = e
                    },
                    handlingStack: r ? gt() : void 0
                }]);
                var i = s.apply(this, e);
                return t && g(t, null, [i]), i
            };
        return t[e] = o, {
            stop: function () {
                a = !0, t[e] === o && (t[e] = s)
            }
        }
    }

    function ue(t, e, n) {
        var i = Object.getOwnPropertyDescriptor(t, e);
        if (!i || !i.set || !i.configurable) return {
            stop: k
        };
        var r = k,
            s = function (t, e) {
                P((function () {
                    s !== r && n(t, e)
                }), 0)
            },
            a = function (t) {
                i.set.call(this, t), s(this, t)
            };
        return Object.defineProperty(t, e, {
            set: a
        }), {
            stop: function () {
                var n;
                (null === (n = Object.getOwnPropertyDescriptor(t, e)) || void 0 === n ? void 0 : n.set) === a && Object.defineProperty(t, e, i), s = r
            }
        }
    }

    function de(t) {
        return pe(t, location.href).href
    }

    function pe(t, e) {
        var n = function () {
            if (void 0 === fe) try {
                var t = new ge("http://test/path");
                fe = "http://test/path" === t.href
            } catch (t) {
                fe = !1
            }
            return fe ? ge : void 0
        }();
        if (n) try {
            return void 0 !== e ? new n(t, e) : new n(t)
        } catch (n) {
            throw new Error("Failed to construct URL: ".concat(String(n), " ").concat(N({
                url: t,
                base: e
            })))
        }
        if (void 0 === e && !/:/.test(t)) throw new Error("Invalid URL: '".concat(t, "'"));
        var i = document,
            r = i.createElement("a");
        if (void 0 !== e) {
            var s = (i = document.implementation.createHTMLDocument("")).createElement("base");
            s.href = e, i.head.appendChild(s), i.body.appendChild(r)
        }
        return r.href = t, r
    }
    var fe, me, ge = URL;

    function ve() {
        return me || (me = new Z((function (t) {
            if (window.fetch) return he(window, "fetch", (function (e) {
                return function (t, e) {
                    var n = t.parameters,
                        i = t.onPostCall,
                        r = t.handlingStack,
                        s = n[0],
                        a = n[1],
                        o = a && a.method;
                    void 0 === o && s instanceof Request && (o = s.method);
                    var l = void 0 !== o ? String(o).toUpperCase() : "GET",
                        c = s instanceof Request ? s.url : de(String(s)),
                        h = Ot(),
                        u = {
                            state: "start",
                            init: a,
                            input: s,
                            method: l,
                            startClocks: h,
                            url: c,
                            handlingStack: r
                        };
                    e.notify(u), n[0] = u.input, n[1] = u.init, i((function (t) {
                        return function (t, e, n) {
                            var i = n;

                            function r(e) {
                                i.state = "resolve", E(i, e), t.notify(i)
                            }
                            e.then(m((function (t) {
                                r({
                                    response: t,
                                    responseType: t.type,
                                    status: t.status,
                                    isAborted: !1
                                })
                            })), m((function (t) {
                                var e, n;
                                r({
                                    status: 0,
                                    isAborted: (null === (n = null === (e = i.init) || void 0 === e ? void 0 : e.signal) || void 0 === n ? void 0 : n.aborted) || t instanceof DOMException && t.code === DOMException.ABORT_ERR,
                                    error: t
                                })
                            })))
                        }(e, t, u)
                    }))
                }(e, t)
            }), {
                computeHandlingStack: !0
            }).stop
        }))), me
    }

    function ye(t) {
        return t ? (parseInt(t, 10) ^ 16 * Math.random() >> parseInt(t, 10) / 4).toString(16) : "".concat(1e7, "-").concat(1e3, "-").concat(4e3, "-").concat(8e3, "-").concat(1e11).replace(/[018]/g, ye)
    }
    var be, xe, _e = /([\w-]+)\s*=\s*([^;]+)/g;

    function we(t, e) {
        for (_e.lastIndex = 0; ;) {
            var n = _e.exec(t);
            if (!n) break;
            if (n[1] === e) return n[2]
        }
    }

    function Se(t, e, n) {
        void 0 === n && (n = "");
        var i = t.charCodeAt(e - 1),
            r = i >= 55296 && i <= 56319 ? e + 1 : e;
        return t.length <= r ? t : "".concat(t.slice(0, r)).concat(n)
    }

    function Me(t, e, n, i) {
        var r = new Date;
        r.setTime(r.getTime() + n);
        var s = "expires=".concat(r.toUTCString()),
            a = i && i.crossSite ? "none" : "strict",
            o = i && i.domain ? ";domain=".concat(i.domain) : "",
            l = i && i.secure ? ";secure" : "",
            c = i && i.partitioned ? ";partitioned" : "";
        document.cookie = "".concat(t, "=").concat(e, ";").concat(s, ";path=/;samesite=").concat(a).concat(o).concat(l).concat(c)
    }

    function Ee(t) {
        return we(document.cookie, t)
    }

    function Te(t) {
        return be || (be = function (t) {
            var e = new Map;
            for (_e.lastIndex = 0; ;) {
                var n = _e.exec(t);
                if (!n) break;
                e.set(n[1], n[2])
            }
            return e
        }(document.cookie)), be.get(t)
    }

    function Ce(t, e) {
        Me(t, "", 0, e)
    }
    var Ae;

    function Re() {
        return Boolean(window._DATADOG_SYNTHETICS_INJECTS_RUM || Te("datadog-synthetics-injects-rum"))
    }

    function Pe() {
        return null != Ae ? Ae : Ae = function (t) {
            var e;
            void 0 === t && (t = window);
            var n = t.navigator.userAgent;
            if (t.chrome || /HeadlessChrome/.test(n)) return 1;
            if (0 === (null === (e = t.navigator.vendor) || void 0 === e ? void 0 : e.indexOf("Apple")) || /safari/i.test(n) && !/chrome|android/i.test(n)) return 2;
            if (t.document.documentMode) return 0;
            return 3
        }()
    }
    var Le = /^([a-zA-Z]+)=([a-z0-9-]+)$/;

    function Oe(t) {
        return B(t)
    }

    function De(t) {
        return !Oe(t)
    }

    function Ie(t) {
        return void 0 !== t.isExpired || !((void 0 === (e = t).created || Rt() - Number(e.created) < 144e5) && (void 0 === e.expire || Rt() < Number(e.expire)));
        var e
    }

    function ke(t) {
        t.expire = String(Rt() + 9e5)
    }

    function Ne(t) {
        return S(t).map((function (t) {
            var e = t[0],
                n = t[1];
            return "".concat(e, "=").concat(n)
        })).join("&")
    }

    function Ue(t) {
        var e = {};
        return function (t) {
            return !!t && (-1 !== t.indexOf("&") || Le.test(t))
        }(t) && t.split("&").forEach((function (t) {
            var n = Le.exec(t);
            if (null !== n) {
                var i = n[1],
                    r = n[2];
                e[i] = r
            }
        })), e
    }

    function ze(t) {
        var e = function (t) {
            var e = {};
            e.secure = !!t.useSecureSessionCookie || !!t.usePartitionedCrossSiteSessionCookie || !!t.useCrossSiteSessionCookie, e.crossSite = !!t.usePartitionedCrossSiteSessionCookie || !!t.useCrossSiteSessionCookie, e.partitioned = !!t.usePartitionedCrossSiteSessionCookie, t.trackSessionAcrossSubdomains && (e.domain = function () {
                if (void 0 === xe) {
                    for (var t = "dd_site_test_".concat(ye()), e = window.location.hostname.split("."), n = e.pop(); e.length && !Ee(t);) Me(t, "test", 1e3, {
                        domain: n = "".concat(e.pop(), ".").concat(n)
                    });
                    Ce(t, {
                        domain: n
                    }), xe = n
                }
                return xe
            }());
            return e
        }(t);
        return function (t) {
            if (void 0 === document.cookie || null === document.cookie) return !1;
            try {
                var e = "dd_cookie_test_".concat(ye());
                Me(e, "test", 6e4, t);
                var n = "test" === Ee(e);
                return Ce(e, t), n
            } catch (t) {
                return o.error(t), !1
            }
        }(e) ? {
            type: "Cookie",
            cookieOptions: e
        } : void 0
    }

    function Fe(t) {
        var e, n = {
            isLockEnabled: 1 === Pe(),
            persistSession: (e = t, function (t) {
                Me("_dd_s", Ne(t), 9e5, e)
            }),
            retrieveSession: $e,
            expireSession: function () {
                return function (t) {
                    Me("_dd_s", Ne({
                        isExpired: "1"
                    }), 144e5, t)
                }(t)
            }
        };
        return function (t) {
            if (!Te("_dd_s")) {
                var e = Te("_dd"),
                    n = Te("_dd_r"),
                    i = Te("_dd_l"),
                    r = {};
                e && (r.id = e), i && /^[01]$/.test(i) && (r.logs = i), n && /^[012]$/.test(n) && (r.rum = n), De(r) && (ke(r), t.persistSession(r))
            }
        }(n), n
    }

    function $e() {
        return Ue(Ee("_dd_s"))
    }

    function Be(t) {
        localStorage.setItem("_dd_s", Ne(t))
    }

    function He() {
        return Ue(localStorage.getItem("_dd_s"))
    }

    function je() {
        Be({
            isExpired: "1"
        })
    }
    var Ve, Ge = [];

    function We(t, e, n) {
        var i;
        void 0 === n && (n = 0);
        var r = e.isLockEnabled,
            s = e.persistSession,
            a = e.expireSession,
            o = function (t) {
                return s(E({}, t, {
                    lock: c
                }))
            },
            l = function () {
                var t = e.retrieveSession(),
                    n = t.lock;
                return t.lock && delete t.lock, {
                    session: t,
                    lock: n
                }
            };
        if (Ve || (Ve = t), t === Ve)
            if (r && n >= 100) Xe(e);
            else {
                var c, h = l();
                if (r) {
                    if (h.lock) return void qe(t, e, n);
                    if (c = ye(), o(h.session), (h = l()).lock !== c) return void qe(t, e, n)
                }
                var u = t.process(h.session);
                if (r && (h = l()).lock !== c) qe(t, e, n);
                else {
                    if (u && (Ie(u) ? a() : (ke(u), r ? o(u) : s(u))), r && (!u || !Ie(u))) {
                        if ((h = l()).lock !== c) return void qe(t, e, n);
                        s(h.session), u = h.session
                    }
                    null === (i = t.after) || void 0 === i || i.call(t, u || h.session), Xe(e)
                }
            }
        else Ge.push(t)
    }

    function qe(t, e, n) {
        P((function () {
            We(t, e, n + 1)
        }), 10)
    }

    function Xe(t) {
        Ve = void 0;
        var e = Ge.shift();
        e && We(e, t)
    }

    function Ye(t) {
        var e = ze(t);
        return !e && t.allowFallbackToLocalStorage && (e = function () {
            try {
                var t = ye(),
                    e = "".concat("_dd_test_").concat(t);
                localStorage.setItem(e, t);
                var n = localStorage.getItem(e);
                return localStorage.removeItem(e), t === n ? {
                    type: "LocalStorage"
                } : void 0
            } catch (t) {
                return
            }
        }()), e
    }

    function Ke(t, e, n) {
        var i, r = new Z,
            s = new Z,
            a = new Z,
            o = "Cookie" === t.type ? Fe(t.cookieOptions) : {
                isLockEnabled: !1,
                persistSession: Be,
                retrieveSession: He,
                expireSession: je
            },
            l = o.expireSession,
            c = O((function () {
                We({
                    process: function (t) {
                        return Ie(t) ? {
                            isExpired: "1"
                        } : void 0
                    },
                    after: p
                }, o)
            }), 1e3);
        f();
        var h = I((function () {
            We({
                process: function (t) {
                    if (!Oe(t)) {
                        var i = p(t);
                        return function (t) {
                            if (Oe(t)) return !1;
                            var i = n(t[e]),
                                r = i.trackingType,
                                s = i.isTracked;
                            t[e] = r, delete t.isExpired, s && !t.id && (t.id = ye(), t.created = String(Rt()))
                        }(i), i
                    }
                },
                after: function (t) {
                    De(t) && !m() && function (t) {
                        i = t, r.notify()
                    }(t), i = t
                }
            }, o)
        }), 1e3),
            u = h.throttled,
            d = h.cancel;

        function p(t) {
            return Ie(t) && (t = {
                isExpired: "1"
            }), m() && (! function (t) {
                return i.id !== t.id || i[e] !== t[e]
            }(t) ? (a.notify({
                previousState: i,
                newState: t
            }), i = t) : (i = {
                isExpired: "1"
            }, s.notify())), t
        }

        function f() {
            We({
                process: function (t) {
                    if (Oe(t)) return {
                        isExpired: "1"
                    }
                },
                after: function (t) {
                    i = t
                }
            }, o)
        }

        function m() {
            return void 0 !== i[e]
        }
        return {
            expandOrRenewSession: u,
            expandSession: function () {
                We({
                    process: function (t) {
                        return m() ? p(t) : void 0
                    }
                }, o)
            },
            getSession: function () {
                return i
            },
            renewObservable: r,
            expireObservable: s,
            sessionStateUpdateObservable: a,
            restartSession: f,
            expire: function () {
                d(), l(), p({
                    isExpired: "1"
                })
            },
            stop: function () {
                D(c)
            },
            updateSessionState: function (t) {
                We({
                    process: function (e) {
                        return E({}, e, t)
                    },
                    after: p
                }, o)
            }
        }
    }

    function Ze(t, e, n) {
        var i = function (t, e) {
            var n = "/api/v2/".concat(e),
                i = t.proxy;
            if ("string" == typeof i) {
                var r = de(i);
                return function (t) {
                    return "".concat(r, "?ddforward=").concat(encodeURIComponent("".concat(n, "?").concat(t)))
                }
            }
            if ("function" == typeof i) return function (t) {
                return i({
                    path: n,
                    parameters: t
                })
            };
            var s = function (t, e) {
                var n = e.site,
                    i = void 0 === n ? "datadoghq.com" : n,
                    r = e.internalAnalyticsSubdomain;
                if ("logs" === t && e.usePciIntake && "datadoghq.com" === i) return "pci.browser-intake-datadoghq.com";
                if (r && "datadoghq.com" === i) return "".concat(r, ".").concat("datadoghq.com");
                if ("dd0g-gov.com" === i) return "http-intake.logs.".concat(i);
                var s = i.split("."),
                    a = s.pop();
                return "browser-intake-".concat(s.join("-"), ".").concat(a)
            }(e, t);
            return function (t) {
                return "https://".concat(s).concat(n, "?").concat(t)
            }
        }(t, e);
        return {
            build: function (r, s) {
                var a = function (t, e, n, i, r) {
                    var s = t.clientToken,
                        a = t.internalAnalyticsSubdomain,
                        o = r.retry,
                        l = r.encoding,
                        c = ["sdk_version:".concat("5.23.3"), "api:".concat(i)].concat(n);
                    o && c.push("retry_count:".concat(o.count), "retry_after:".concat(o.lastFailureStatus));
                    var h = ["ddsource=browser", "ddtags=".concat(encodeURIComponent(c.join(","))), "dd-api-key=".concat(s), "dd-evp-origin-version=".concat(encodeURIComponent("5.23.3")), "dd-evp-origin=browser", "dd-request-id=".concat(ye())];
                    l && h.push("dd-evp-encoding=".concat(l));
                    "rum" === e && h.push("batch_time=".concat(Pt()));
                    a && h.reverse();
                    return h.join("&")
                }(t, e, n, r, s);
                return i(a)
            },
            urlPrefix: i(""),
            trackType: e
        }
    }
    var Je = /[^a-z0-9_:./-]/;

    function Qe(t, e) {
        var n = 200 - t.length - 1;
        (e.length > n || Je.test(e)) && o.warn("".concat(t, " value doesn't meet tag requirements and will be sanitized. ").concat("More details:", " ").concat(l, "/getting_started/tagging/#defining-tags"));
        var i = e.replace(/,/g, "_");
        return "".concat(t, ":").concat(i)
    }

    function tn(t) {
        var e = t.site || "datadoghq.com",
            n = function (t) {
                var e = t.env,
                    n = t.service,
                    i = t.version,
                    r = t.datacenter,
                    s = [];
                return e && s.push(Qe("env", e)), n && s.push(Qe("service", n)), i && s.push(Qe("version", i)), r && s.push(Qe("datacenter", r)), s
            }(t),
            i = function (t, e) {
                return {
                    logsEndpointBuilder: Ze(t, "logs", e),
                    rumEndpointBuilder: Ze(t, "rum", e),
                    sessionReplayEndpointBuilder: Ze(t, "replay", e)
                }
            }(t, n),
            r = function (t, e) {
                var n = w(t).map((function (t) {
                    return t.urlPrefix
                }));
                "datadoghq.com" === e && n.push("https://".concat("pci.browser-intake-datadoghq.com", "/"));
                return n
            }(i, e),
            s = function (t, e, n) {
                if (!t.replica) return;
                var i = E({}, t, {
                    site: "datadoghq.com",
                    clientToken: t.replica.clientToken
                }),
                    r = {
                        logsEndpointBuilder: Ze(i, "logs", n),
                        rumEndpointBuilder: Ze(i, "rum", n)
                    };
                return e.push.apply(e, w(r).map((function (t) {
                    return t.urlPrefix
                }))), E({
                    applicationId: t.replica.applicationId
                }, r)
            }(t, r, n);
        return E({
            isIntakeUrl: function (t) {
                return r.some((function (e) {
                    return 0 === t.indexOf(e)
                }))
            },
            replica: s,
            site: e
        }, i)
    }
    var en = {
        ALLOW: "allow",
        MASK: "mask",
        MASK_USER_INPUT: "mask-user-input"
    },
        nn = {
            ALL: "all",
            SAMPLED: "sampled"
        };

    function rn(t, e) {
        return null == t || "string" == typeof t || (o.error("".concat(e, " must be defined as a string")), !1)
    }

    function sn(t, e) {
        return !!(void 0 === t || (n = t, Mt(n) && n >= 0 && n <= 100)) || (o.error("".concat(e, " Sample Rate should be a number between 0 and 100")), !1);
        var n
    }

    function an(t) {
        var e, n, i, r, s;
        if (t && t.clientToken) {
            if ((!(a = t.site) || "string" != typeof a || /(datadog|ddog|datad0g|dd0g)/.test(a) || (o.error("Site should be a valid Datadog site. ".concat("More details:", " ").concat(l, "/getting_started/site/.")), 0)) && sn(t.sessionSampleRate, "Session") && sn(t.telemetrySampleRate, "Telemetry") && sn(t.telemetryConfigurationSampleRate, "Telemetry Configuration") && sn(t.telemetryUsageSampleRate, "Telemetry Usage") && rn(t.version, "Version") && rn(t.env, "Env") && rn(t.service, "Service")) {
                var a;
                if (void 0 === t.trackingConsent || F(et, t.trackingConsent)) return E({
                    beforeSend: t.beforeSend && h(t.beforeSend, "beforeSend threw an error:"),
                    sessionStoreStrategyType: Ye(t),
                    sessionSampleRate: null !== (e = t.sessionSampleRate) && void 0 !== e ? e : 100,
                    telemetrySampleRate: null !== (n = t.telemetrySampleRate) && void 0 !== n ? n : 20,
                    telemetryConfigurationSampleRate: null !== (i = t.telemetryConfigurationSampleRate) && void 0 !== i ? i : 5,
                    telemetryUsageSampleRate: null !== (r = t.telemetryUsageSampleRate) && void 0 !== r ? r : 5,
                    service: t.service || void 0,
                    silentMultipleInit: !!t.silentMultipleInit,
                    allowUntrustedEvents: !!t.allowUntrustedEvents,
                    trackingConsent: null !== (s = t.trackingConsent) && void 0 !== s ? s : et.GRANTED,
                    storeContextsAcrossPages: !!t.storeContextsAcrossPages,
                    batchBytesLimit: 16384,
                    eventRateLimiterThreshold: 3e3,
                    maxTelemetryEventsPerPage: 15,
                    flushTimeout: 3e4,
                    batchMessagesLimit: 50,
                    messageBytesLimit: 262144
                }, tn(t));
                o.error('Tracking Consent should be either "granted" or "not-granted"')
            }
        } else o.error("Client Token is not configured, we will not send any data.")
    }

    function on(t) {
        var e = V(t);
        return "string" === e || "function" === e || t instanceof RegExp
    }

    function ln(t, e, n) {
        return void 0 === n && (n = !1), t.some((function (t) {
            try {
                if ("function" == typeof t) return t(e);
                if (t instanceof RegExp) return t.test(e);
                if ("string" == typeof t) return n ? M(e, t) : t === e
            } catch (t) {
                o.error(t)
            }
            return !1
        }))
    }

    function cn(t) {
        0 !== t.status || t.isAborted || (t.traceId = void 0, t.spanId = void 0, t.traceSampled = void 0)
    }

    function hn(t, e, n, i) {
        if (void 0 !== un() && n.findTrackedSession()) {
            var r, s, a, o, l, c = x(t.allowedTracingUrls, (function (t) {
                return ln([t.match], e.url, !0)
            }));
            if (c)
                if (e.traceSampled = !Mt(t.traceSampleRate) || wt(t.traceSampleRate), e.traceSampled || t.traceContextInjection === nn.ALL) e.traceId = dn(), e.spanId = dn(), i((r = e.traceId, s = e.spanId, a = e.traceSampled, o = c.propagatorTypes, l = {}, o.forEach((function (t) {
                    switch (t) {
                        case "datadog":
                            E(l, {
                                "x-datadog-origin": "rum",
                                "x-datadog-parent-id": s.toDecimalString(),
                                "x-datadog-sampling-priority": a ? "1" : "0",
                                "x-datadog-trace-id": r.toDecimalString()
                            });
                            break;
                        case "tracecontext":
                            E(l, {
                                traceparent: "00-0000000000000000".concat(r.toPaddedHexadecimalString(), "-").concat(s.toPaddedHexadecimalString(), "-0").concat(a ? "1" : "0")
                            });
                            break;
                        case "b3":
                            E(l, {
                                b3: "".concat(r.toPaddedHexadecimalString(), "-").concat(s.toPaddedHexadecimalString(), "-").concat(a ? "1" : "0")
                            });
                            break;
                        case "b3multi":
                            E(l, {
                                "X-B3-TraceId": r.toPaddedHexadecimalString(),
                                "X-B3-SpanId": s.toPaddedHexadecimalString(),
                                "X-B3-Sampled": a ? "1" : "0"
                            })
                    }
                })), l))
        }
    }

    function un() {
        return window.crypto || window.msCrypto
    }

    function dn() {
        var t = new Uint8Array(8);

        function e(e) {
            return 16777216 * t[e] + (t[e + 1] << 16) + (t[e + 2] << 8) + t[e + 3]
        }

        function n(t) {
            var n = e(0),
                i = e(4),
                r = "";
            do {
                var s = n % t * 4294967296 + i;
                n = Math.floor(n / t), i = Math.floor(s / t), r = (s % t).toString(t) + r
            } while (n || i);
            return r
        }
        return un().getRandomValues(t), t[0] = 127 & t[0], {
            toDecimalString: function () {
                return n(10)
            },
            toPaddedHexadecimalString: function () {
                var t = n(16);
                return Array(17 - t.length).join("0") + t
            }
        }
    }
    var pn = ["tracecontext", "datadog"];

    function fn(t) {
        var e, n;
        if (t.applicationId) {
            if (sn(t.sessionReplaySampleRate, "Session Replay") && sn(t.traceSampleRate, "Trace"))
                if (void 0 === t.excludedActivityUrls || Array.isArray(t.excludedActivityUrls)) {
                    var i = function (t) {
                        if (void 0 === t.allowedTracingUrls) return [];
                        if (!Array.isArray(t.allowedTracingUrls)) return void o.error("Allowed Tracing URLs should be an array");
                        if (0 !== t.allowedTracingUrls.length && void 0 === t.service) return void o.error("Service needs to be configured when tracing is enabled");
                        var e = [];
                        return t.allowedTracingUrls.forEach((function (t) {
                            var n;
                            on(t) ? e.push({
                                match: t,
                                propagatorTypes: pn
                            }) : "object" === V(n = t) && on(n.match) && Array.isArray(n.propagatorTypes) ? e.push(t) : o.warn("Allowed Tracing Urls parameters should be a string, RegExp, function, or an object. Ignoring parameter", t)
                        })), e
                    }(t);
                    if (i) {
                        var r = an(t);
                        if (r) return E({
                            applicationId: t.applicationId,
                            version: t.version || void 0,
                            actionNameAttribute: t.actionNameAttribute,
                            sessionReplaySampleRate: null !== (e = t.sessionReplaySampleRate) && void 0 !== e ? e : 0,
                            startSessionReplayRecordingManually: !!t.startSessionReplayRecordingManually,
                            traceSampleRate: t.traceSampleRate,
                            allowedTracingUrls: i,
                            excludedActivityUrls: null !== (n = t.excludedActivityUrls) && void 0 !== n ? n : [],
                            workerUrl: t.workerUrl,
                            compressIntakeRequests: !!t.compressIntakeRequests,
                            trackUserInteractions: !!t.trackUserInteractions,
                            trackViewsManually: !!t.trackViewsManually,
                            trackResources: !!t.trackResources,
                            trackLongTasks: !!t.trackLongTasks,
                            subdomain: t.subdomain,
                            defaultPrivacyLevel: F(en, t.defaultPrivacyLevel) ? t.defaultPrivacyLevel : en.MASK,
                            enablePrivacyForActionName: !!t.enablePrivacyForActionName,
                            customerDataTelemetrySampleRate: 1,
                            traceContextInjection: F(nn, t.traceContextInjection) ? t.traceContextInjection : nn.ALL,
                            plugins: t.betaPlugins || []
                        }, r)
                    }
                } else o.error("Excluded Activity Urls should be an array")
        } else o.error("Application ID is not configured, no RUM data will be collected.")
    }

    function mn(t) {
        var e = new Set;
        return Array.isArray(t.allowedTracingUrls) && t.allowedTracingUrls.length > 0 && t.allowedTracingUrls.forEach((function (t) {
            on(t) ? pn.forEach((function (t) {
                return e.add(t)
            })) : "object" === V(t) && Array.isArray(t.propagatorTypes) && t.propagatorTypes.forEach((function (t) {
                return e.add(t)
            }))
        })), b(e)
    }

    function gn(t, e) {
        ! function (t, e) {
            var n = new XMLHttpRequest;
            te(t, n, "load", (function () {
                200 === n.status ? e(JSON.parse(n.responseText)) : vn()
            })), te(t, n, "error", (function () {
                vn()
            })), n.open("GET", "".concat("https://d3uc069fcn7uxw.cloudfront.net/configuration", "/").concat(encodeURIComponent(t.remoteConfigurationId), ".json")), n.send()
        }(t, (function (n) {
            e(function (t, e) {
                return E({}, t, e)
            }(t, n))
        }))
    }

    function vn() {
        o.error("Error fetching the remote configuration.")
    }

    function yn(t, e) {
        function n(n) {
            (function (t) {
                return !e.wasInPageStateDuringPeriod("frozen", t.startClocks.relative, t.duration)
            })(n) && t.notify(12, function (t, e) {
                var n = {
                    date: t.startClocks.timeStamp,
                    vital: {
                        id: ye(),
                        type: t.type,
                        name: t.name,
                        duration: At(t.duration),
                        details: t.details
                    },
                    type: "vital"
                };
                e && (n._dd = {
                    vital: {
                        computed_value: !0
                    }
                });
                return {
                    rawRumEvent: n,
                    startTime: t.startClocks.relative,
                    customerContext: t.context,
                    domainContext: {}
                }
            }(n, !0))
        }
        return {
            addDurationVital: n,
            startDurationVital: function (t) {
                return bn((function (t) {
                    n(t)
                }), t)
            }
        }
    }

    function bn(t, e) {
        var n, i = Ot();
        return {
            stop: function (r) {
                n || (n = Ot(), t(function (t, e, n, i) {
                    var r;
                    void 0 === n && (n = {});
                    return {
                        name: t.name,
                        type: "duration",
                        startClocks: e,
                        duration: It(e.timeStamp, i.timeStamp),
                        context: q(t.context, n.context),
                        details: null !== (r = n.details) && void 0 !== r ? r : t.details
                    }
                }(e, i, r, n)))
            }
        }
    }

    function xn(t, e, n, i) {
        var r, s, a, l, c = t.ignoreInitIfSyntheticsWillInjectRum,
            h = t.startDeflateWorker,
            u = Bt(),
            d = n.observable.subscribe(p);

        function p() {
            if (a && l && n.isGranted()) {
                var t;
                if (d.unsubscribe(), l.trackViewsManually) {
                    if (!r) return;
                    u.remove(r.callback), t = r.options
                }
                var e = i(l, s, t);
                u.drain(e)
            }
        }

        function f(t) {
            var e = ce();
            if (e && (t = function (t) {
                var e, n;
                return E({}, t, {
                    applicationId: "00000000-aaaa-0000-aaaa-000000000000",
                    clientToken: "empty",
                    sessionSampleRate: 100,
                    defaultPrivacyLevel: null !== (e = t.defaultPrivacyLevel) && void 0 !== e ? e : null === (n = oe()) || void 0 === n ? void 0 : n.getPrivacyLevel()
                })
            }(t)), a = t, function (t) {
                Xt({
                    type: jt,
                    configuration: t
                })
            }(function (t) {
                var e, n, i = {
                    session_sample_rate: (n = t).sessionSampleRate,
                    telemetry_sample_rate: n.telemetrySampleRate,
                    telemetry_configuration_sample_rate: n.telemetryConfigurationSampleRate,
                    telemetry_usage_sample_rate: n.telemetryUsageSampleRate,
                    use_before_send: !!n.beforeSend,
                    use_cross_site_session_cookie: n.useCrossSiteSessionCookie,
                    use_partitioned_cross_site_session_cookie: n.usePartitionedCrossSiteSessionCookie,
                    use_secure_session_cookie: n.useSecureSessionCookie,
                    use_proxy: !!n.proxy,
                    silent_multiple_init: n.silentMultipleInit,
                    track_session_across_subdomains: n.trackSessionAcrossSubdomains,
                    allow_fallback_to_local_storage: !!n.allowFallbackToLocalStorage,
                    store_contexts_across_pages: !!n.storeContextsAcrossPages,
                    allow_untrusted_events: !!n.allowUntrustedEvents,
                    tracking_consent: n.trackingConsent
                };
                return E({
                    session_replay_sample_rate: t.sessionReplaySampleRate,
                    start_session_replay_recording_manually: t.startSessionReplayRecordingManually,
                    trace_sample_rate: t.traceSampleRate,
                    trace_context_injection: t.traceContextInjection,
                    action_name_attribute: t.actionNameAttribute,
                    use_allowed_tracing_urls: Array.isArray(t.allowedTracingUrls) && t.allowedTracingUrls.length > 0,
                    selected_tracing_propagators: mn(t),
                    default_privacy_level: t.defaultPrivacyLevel,
                    enable_privacy_for_action_name: t.enablePrivacyForActionName,
                    use_excluded_activity_urls: Array.isArray(t.excludedActivityUrls) && t.excludedActivityUrls.length > 0,
                    use_worker_url: !!t.workerUrl,
                    compress_intake_requests: t.compressIntakeRequests,
                    track_views_manually: t.trackViewsManually,
                    track_user_interactions: t.trackUserInteractions,
                    track_resources: t.trackResources,
                    track_long_task: t.trackLongTasks,
                    plugins: null === (e = t.betaPlugins) || void 0 === e ? void 0 : e.map((function (t) {
                        var e;
                        return E({
                            name: t.name
                        }, null === (e = t.getConfigurationTelemetry) || void 0 === e ? void 0 : e.call(t))
                    }))
                }, i)
            }(t)), l) ae("DD_RUM", t);
            else {
                var i = fn(t);
                i && (e || i.sessionStoreStrategyType ? i.compressIntakeRequests && !e && h && !(s = h(i, "Datadog RUM", k)) || (l = i, ve().subscribe(k), n.tryToInit(i.trackingConsent), p()) : o.warn("No storage available for session. We will not send any data."))
            }
        }
        var m = function (t) {
            u.add((function (e) {
                return e.addDurationVital(t)
            }))
        };
        return {
            init: function (t, e) {
                t ? (it(t.enableExperimentalFeatures), a = t, c && Re() || (! function (t, e, n) {
                    if (t)
                        for (var i = 0, r = t; i < r.length; i++) {
                            var s = r[i][e];
                            s && s(n)
                        }
                }(t.betaPlugins, "onInit", {
                    initConfiguration: t,
                    publicApi: e
                }), t.remoteConfigurationId && rt(tt.REMOTE_CONFIGURATION) ? gn(t, f) : f(t))) : o.error("Missing configuration")
            },
            get initConfiguration() {
                return a
            },
            getInternalContext: k,
            stopSession: k,
            addTiming: function (t, e) {
                void 0 === e && (e = Pt()), u.add((function (n) {
                    return n.addTiming(t, e)
                }))
            },
            startView: function (t, e) {
                void 0 === e && (e = Ot());
                var n = function (n) {
                    n.startView(t, e)
                };
                u.add(n), r || (r = {
                    options: t,
                    callback: n
                }, p())
            },
            updateViewName: function (t) {
                u.add((function (e) {
                    return e.updateViewName(t)
                }))
            },
            addAction: function (t, n) {
                void 0 === n && (n = e()), u.add((function (e) {
                    return e.addAction(t, n)
                }))
            },
            addError: function (t, n) {
                void 0 === n && (n = e()), u.add((function (e) {
                    return e.addError(t, n)
                }))
            },
            addFeatureFlagEvaluation: function (t, e) {
                u.add((function (n) {
                    return n.addFeatureFlagEvaluation(t, e)
                }))
            },
            startDurationVital: function (t) {
                return bn((function (t) {
                    return m(t)
                }), t)
            },
            addDurationVital: m
        }
    }
    var _n = {
        HIDDEN: "visibility_hidden",
        UNLOADING: "before_unload",
        PAGEHIDE: "page_hide",
        FROZEN: "page_frozen"
    };

    function wn(t) {
        return y(w(_n), t)
    }

    function Sn() {
        var t, e = window;
        if (e.Zone && (t = R(e, "MutationObserver"), e.MutationObserver && t === e.MutationObserver)) {
            var n = R(new e.MutationObserver(k), "originalInstance");
            t = n && n.constructor
        }
        return t || (t = e.MutationObserver), t
    }
    var Mn = [
        ["document", function (t) {
            return "initial_document" === t
        }],
        ["xhr", function (t) {
            return "xmlhttprequest" === t
        }],
        ["fetch", function (t) {
            return "fetch" === t
        }],
        ["beacon", function (t) {
            return "beacon" === t
        }],
        ["css", function (t, e) {
            return /\.css$/i.test(e)
        }],
        ["js", function (t, e) {
            return /\.js$/i.test(e)
        }],
        ["image", function (t, e) {
            return y(["image", "img", "icon"], t) || null !== /\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(e)
        }],
        ["font", function (t, e) {
            return null !== /\.(woff|eot|woff2|ttf)$/i.exec(e)
        }],
        ["media", function (t, e) {
            return y(["audio", "video"], t) || null !== /\.(mp3|mp4)$/i.exec(e)
        }]
    ];

    function En(t) {
        var e = t.name;
        if (! function (t) {
            try {
                return !!pe(t)
            } catch (t) {
                return !1
            }
        }(e)) return Kt('Failed to construct URL for "'.concat(t.name, '"')), "other";
        for (var n = function (t) {
            var e = pe(t).pathname;
            return "/" === e[0] ? e : "/".concat(e)
        }(e), i = 0, r = Mn; i < r.length; i++) {
            var s = r[i],
                a = s[0];
            if ((0, s[1])(t.initiatorType, n)) return a
        }
        return "other"
    }

    function Tn() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        for (var n = 1; n < t.length; n += 1)
            if (t[n - 1] > t[n]) return !1;
        return !0
    }

    function Cn(t) {
        if (An(t)) {
            var e = t.startTime,
                n = t.fetchStart,
                i = t.redirectStart,
                r = t.redirectEnd,
                s = t.domainLookupStart,
                a = t.domainLookupEnd,
                o = t.connectStart,
                l = t.secureConnectionStart,
                c = t.connectEnd,
                h = t.requestStart,
                u = t.responseStart,
                d = {
                    download: Rn(e, u, t.responseEnd),
                    first_byte: Rn(e, h, u)
                };
            return n < c && (d.connect = Rn(e, o, c), o <= l && l <= c && (d.ssl = Rn(e, l, c))), n < a && (d.dns = Rn(e, s, a)), e < r && (d.redirect = Rn(e, i, r)), d
        }
    }

    function An(t) {
        if (rt(tt.TOLERANT_RESOURCE_TIMINGS)) return !0;
        var e = Tn(t.startTime, t.fetchStart, t.domainLookupStart, t.domainLookupEnd, t.connectStart, t.connectEnd, t.requestStart, t.responseStart, t.responseEnd),
            n = ! function (t) {
                return t.redirectEnd > t.startTime
            }(t) || Tn(t.startTime, t.redirectStart, t.redirectEnd, t.fetchStart);
        return e && n
    }

    function Rn(t, e, n) {
        if (t <= e && e <= n) return {
            duration: At(It(e, n)),
            start: At(It(t, e))
        }
    }

    function Pn(t) {
        if (t.startTime < t.responseStart) {
            var e = t.encodedBodySize,
                n = t.decodedBodySize;
            return {
                size: n,
                encoded_body_size: e,
                decoded_body_size: n,
                transfer_size: t.transferSize
            }
        }
        return {
            size: void 0,
            encoded_body_size: void 0,
            decoded_body_size: void 0,
            transfer_size: void 0
        }
    }

    function Ln(t, e) {
        return e && !t.isIntakeUrl(e)
    }
    var On, Dn, In = /data:(.+)?(;base64)?,/g;

    function kn(t) {
        return !(t.length <= 24e3) && ("data:" === t.substring(0, 5) && (t = t.substring(0, 24e3), !0))
    }

    function Nn(t) {
        return "".concat(t.match(In)[0], "[...]")
    }

    function Un(t, e) {
        return new Z((function (n) {
            if (window.PerformanceObserver) {
                var i, r = function (e) {
                    var i = function (t, e) {
                        return e.filter((function (e) {
                            return ! function (t, e) {
                                return e.entryType === On.RESOURCE && !Ln(t, e.name)
                            }(t, e)
                        }))
                    }(t, e);
                    i.length > 0 && n.notify(i)
                },
                    s = !0,
                    a = new PerformanceObserver(m((function (t) {
                        s ? i = P((function () {
                            return r(t.getEntries())
                        })) : r(t.getEntries())
                    })));
                try {
                    a.observe(e)
                } catch (t) {
                    if (y([On.RESOURCE, On.NAVIGATION, On.LONG_TASK, On.PAINT], e.type)) {
                        e.buffered && (i = P((function () {
                            return r(performance.getEntriesByType(e.type))
                        })));
                        try {
                            a.observe({
                                entryTypes: [e.type]
                            })
                        } catch (t) {
                            return
                        }
                    }
                }
                return s = !1,
                    function (t) {
                        !Dn && void 0 !== window.performance && "getEntries" in performance && "addEventListener" in performance && (Dn = te(t, performance, "resourcetimingbufferfull", (function () {
                            performance.clearResourceTimings()
                        })))
                    }(t),
                    function () {
                        a.disconnect(), L(i)
                    }
            }
        }))
    }

    function zn(t) {
        return window.PerformanceObserver && void 0 !== PerformanceObserver.supportedEntryTypes && PerformanceObserver.supportedEntryTypes.includes(t)
    }

    function Fn() {
        return void 0 !== window.performance && "getEntries" in performance
    }

    function $n(t, e) {
        var n = [];
        if (Fn()) {
            var i = performance.getEntries();
            P((function () {
                return Bn(t, i)
            }))
        }
        if (window.PerformanceObserver) {
            var r = m((function (e) {
                return Bn(t, e.getEntries())
            })),
                s = [On.LONG_TASK, On.PAINT],
                a = [On.LARGEST_CONTENTFUL_PAINT, On.FIRST_INPUT, On.LAYOUT_SHIFT, On.EVENT];
            try {
                a.forEach((function (t) {
                    var e = new window.PerformanceObserver(r);
                    e.observe({
                        type: t,
                        buffered: !0,
                        durationThreshold: 40
                    }), n.push((function () {
                        return e.disconnect()
                    }))
                }))
            } catch (t) {
                s.push.apply(s, a)
            }
            var o = new PerformanceObserver(r);
            try {
                o.observe({
                    entryTypes: s
                }), n.push((function () {
                    return o.disconnect()
                }))
            } catch (t) { }
            if (Fn() && "addEventListener" in performance) {
                var l = te(e, performance, "resourcetimingbufferfull", (function () {
                    performance.clearResourceTimings()
                })).stop;
                n.push(l)
            }
        }
        if (!zn(On.FIRST_INPUT)) {
            var c = function (t, e) {
                var n = Rt(),
                    i = !1,
                    r = ee(t, window, ["click", "mousedown", "keydown", "touchstart", "pointerdown"], (function (e) {
                        if (e.cancelable) {
                            var n = {
                                entryType: On.FIRST_INPUT,
                                processingStart: Lt(),
                                processingEnd: Lt(),
                                startTime: e.timeStamp,
                                duration: 0,
                                name: ""
                            };
                            "pointerdown" === e.type ? function (t, e) {
                                ee(t, window, ["pointerup", "pointercancel"], (function (t) {
                                    "pointerup" === t.type && s(e)
                                }), {
                                    once: !0
                                })
                            }(t, n) : s(n)
                        }
                    }), {
                        passive: !0,
                        capture: !0
                    }).stop;
                return {
                    stop: r
                };

                function s(t) {
                    if (!i) {
                        i = !0, r();
                        var s = t.processingStart - t.startTime;
                        s >= 0 && s < Rt() - n && e(t)
                    }
                }
            }(e, (function (e) {
                Bn(t, [e])
            })).stop;
            n.push(c)
        }
        return {
            stop: function () {
                n.forEach((function (t) {
                    return t()
                }))
            }
        }
    }

    function Bn(t, e) {
        var n = e.filter((function (t) {
            return F(On, t.entryType)
        }));
        n.length && t.notify(0, n)
    } ! function (t) {
        t.EVENT = "event", t.FIRST_INPUT = "first-input", t.LARGEST_CONTENTFUL_PAINT = "largest-contentful-paint", t.LAYOUT_SHIFT = "layout-shift", t.LONG_TASK = "longtask", t.NAVIGATION = "navigation", t.PAINT = "paint", t.RESOURCE = "resource"
    }(On || (On = {}));
    var Hn = "agent",
        jn = "console",
        Vn = "custom",
        Gn = "source",
        Wn = "report";

    function qn(t, e, n) {
        var i = 0,
            r = !1;
        return {
            isLimitReached: function () {
                if (0 === i && P((function () {
                    i = 0
                }), 6e4), (i += 1) <= e || r) return r = !1, !1;
                if (i === e + 1) {
                    r = !0;
                    try {
                        n({
                            message: "Reached max number of ".concat(t, "s by minute: ").concat(e),
                            source: Hn,
                            startClocks: Ot()
                        })
                    } finally {
                        r = !1
                    }
                }
                return !0
            }
        }
    }

    function Xn() {
        var t, e = "string" == typeof (t = window._DATADOG_SYNTHETICS_PUBLIC_ID || Te("datadog-synthetics-public-id")) ? t : void 0,
            n = function () {
                var t = window._DATADOG_SYNTHETICS_RESULT_ID || Te("datadog-synthetics-result-id");
                return "string" == typeof t ? t : void 0
            }();
        if (e && n) return {
            test_id: e,
            result_id: n,
            injected: Re()
        }
    }

    function Yn(t, e, n) {
        var i = W(t),
            r = n(i);
        return S(e).forEach((function (e) {
            var n = e[0],
                r = e[1],
                s = function (t, e) {
                    for (var n = t, i = 0, r = e.split("."); i < r.length; i++) {
                        var s = r[i];
                        if (!Jn(n, s)) return;
                        n = n[s]
                    }
                    return n
                }(i, n),
                a = V(s);
            a === r ? Kn(t, n, X(s)) : "object" !== r || "undefined" !== a && "null" !== a || Kn(t, n, {})
        })), r
    }

    function Kn(t, e, n) {
        for (var i = t, r = e.split("."), s = 0; s < r.length; s += 1) {
            var a = r[s];
            if (!Zn(i)) return;
            s !== r.length - 1 ? i = i[a] : i[a] = n
        }
    }

    function Zn(t) {
        return "object" === V(t)
    }

    function Jn(t, e) {
        return Zn(t) && Object.prototype.hasOwnProperty.call(t, e)
    }
    var Qn, ti = {
        "view.name": "string",
        "view.url": "string",
        "view.referrer": "string"
    },
        ei = {
            context: "object"
        },
        ni = {
            service: "string",
            version: "string"
        };

    function ii(t, e, n, i, r, s, a, l, c, h) {
        var u, d;
        (u = {}).view = ti, u.error = E({
            "error.message": "string",
            "error.stack": "string",
            "error.resource.url": "string",
            "error.fingerprint": "string"
        }, ei, ti, ni), u.resource = E({
            "resource.url": "string"
        }, rt(tt.WRITABLE_RESOURCE_GRAPHQL) ? {
            "resource.graphql": "object"
        } : {}, ei, ti, ni), u.action = E({
            "action.target.name": "string"
        }, ei, ti, ni), u.long_task = E({}, ei, ti), u.vital = E({}, ei, ti), Qn = u;
        var p = ((d = {}).error = qn("error", t.eventRateLimiterThreshold, h), d.action = qn("action", t.eventRateLimiterThreshold, h), d.vital = qn("vital", t.eventRateLimiterThreshold, h), d),
            f = Xn();
        e.subscribe(12, (function (h) {
            var u = h.startTime,
                d = h.rawRumEvent,
                m = h.domainContext,
                g = h.savedCommonContext,
                v = h.customerContext,
                y = i.findView(u),
                b = r.findUrl(u),
                x = n.findTrackedSession(u);
            if (x && y && b) {
                var _ = g || c(),
                    w = s.findActionId(u),
                    S = q({
                        _dd: {
                            format_version: 2,
                            drift: Math.round(Rt() - kt(Ut(), performance.now())),
                            configuration: {
                                session_sample_rate: St(t.sessionSampleRate, 3),
                                session_replay_sample_rate: St(t.sessionReplaySampleRate, 3)
                            },
                            browser_sdk_version: ce() ? "5.23.3" : void 0
                        },
                        application: {
                            id: t.applicationId
                        },
                        date: Pt(),
                        service: y.service || t.service,
                        version: y.version || t.version,
                        source: "browser",
                        session: {
                            id: x.id,
                            type: f ? "synthetics" : l.get() ? "ci_test" : "user"
                        },
                        view: {
                            id: y.id,
                            name: y.name,
                            url: b.url,
                            referrer: b.referrer
                        },
                        action: ri(d) && w ? {
                            id: w
                        } : void 0,
                        synthetics: f,
                        ci_test: l.get(),
                        display: a.get(),
                        connectivity: Ft()
                    }, d);
                S.context = q(_.context, v), "has_replay" in S.session || (S.session.has_replay = _.hasReplay), "view" === S.type && (S.session.sampled_for_replay = 1 === x.sessionReplay), B(_.user) || (S.usr = _.user),
                    function (t, e, n, i) {
                        var r;
                        if (e) {
                            var s = Yn(t, Qn[t.type], (function (t) {
                                return e(t, n)
                            }));
                            if (!1 === s && "view" !== t.type) return !1;
                            !1 === s && o.warn("Can't dismiss view events using beforeSend!")
                        }
                        return !(null === (r = i[t.type]) || void 0 === r ? void 0 : r.isLimitReached())
                    }(S, t.beforeSend, m, p) && (B(S.context) && delete S.context, e.notify(13, S))
            }
        }))
    }

    function ri(t) {
        return -1 !== ["error", "resource", "long_task"].indexOf(t.type)
    }
    var si = function () {
        function t() {
            this.callbacks = {}
        }
        return t.prototype.notify = function (t, e) {
            var n = this.callbacks[t];
            n && n.forEach((function (t) {
                return t(e)
            }))
        }, t.prototype.subscribe = function (t, e) {
            var n = this;
            return this.callbacks[t] || (this.callbacks[t] = []), this.callbacks[t].push(e), {
                unsubscribe: function () {
                    n.callbacks[t] = n.callbacks[t].filter((function (t) {
                        return e !== t
                    }))
                }
            }
        }, t
    }();

    function ai(t) {
        var e = t.expireDelay,
            n = t.maxEntries,
            i = [],
            r = O((function () {
                return function () {
                    var t = Lt() - e;
                    for (; i.length > 0 && i[i.length - 1].endTime < t;) i.pop()
                }()
            }), 6e4);
        return {
            add: function (t, e) {
                var r = {
                    value: t,
                    startTime: e,
                    endTime: 1 / 0,
                    remove: function () {
                        $t(i, r)
                    },
                    close: function (t) {
                        r.endTime = t
                    }
                };
                return n && i.length >= n && i.pop(), i.unshift(r), r
            },
            find: function (t, e) {
                void 0 === t && (t = 1 / 0), void 0 === e && (e = {
                    returnInactive: !1
                });
                for (var n = 0, r = i; n < r.length; n++) {
                    var s = r[n];
                    if (s.startTime <= t) {
                        if (e.returnInactive || t <= s.endTime) return s.value;
                        break
                    }
                }
            },
            closeActive: function (t) {
                var e = i[0];
                e && e.endTime === 1 / 0 && e.close(t)
            },
            findAll: function (t, e) {
                void 0 === t && (t = 1 / 0), void 0 === e && (e = 0);
                var n = kt(t, e);
                return i.filter((function (e) {
                    return e.startTime <= n && t <= e.endTime
                })).map((function (t) {
                    return t.value
                }))
            },
            reset: function () {
                i = []
            },
            stop: function () {
                D(r)
            }
        }
    }
    var oi;
    var li = new WeakMap;

    function ci(t) {
        return oi || (oi = function (t) {
            return new Z((function (e) {
                var n = he(XMLHttpRequest.prototype, "open", hi).stop,
                    i = he(XMLHttpRequest.prototype, "send", (function (n) {
                        ! function (t, e, n) {
                            var i = t.target,
                                r = t.handlingStack,
                                s = li.get(i);
                            if (!s) return;
                            var a = s;
                            a.state = "start", a.startClocks = Ot(), a.isAborted = !1, a.xhr = i, a.handlingStack = r;
                            var o = !1,
                                l = he(i, "onreadystatechange", (function () {
                                    i.readyState === XMLHttpRequest.DONE && c()
                                })).stop,
                                c = function () {
                                    if (h(), l(), !o) {
                                        o = !0;
                                        var t = s;
                                        t.state = "complete", t.duration = It(a.startClocks.timeStamp, Pt()), t.status = i.status, n.notify(z(t))
                                    }
                                },
                                h = te(e, i, "loadend", c).stop;
                            n.notify(a)
                        }(n, t, e)
                    }), {
                        computeHandlingStack: !0
                    }).stop,
                    r = he(XMLHttpRequest.prototype, "abort", ui).stop;
                return function () {
                    n(), i(), r()
                }
            }))
        }(t)), oi
    }

    function hi(t) {
        var e = t.target,
            n = t.parameters,
            i = n[0],
            r = n[1];
        li.set(e, {
            state: "open",
            method: String(i).toUpperCase(),
            url: de(String(r))
        })
    }

    function ui(t) {
        var e = t.target,
            n = li.get(e);
        n && (n.isAborted = !0)
    }
    var di = 1;

    function pi(t, e, n) {
        var i = function (t, e) {
            return {
                clearTracingIfNeeded: cn,
                traceFetch: function (n) {
                    return hn(t, n, e, (function (t) {
                        var e;
                        if (n.input instanceof Request && !(null === (e = n.init) || void 0 === e ? void 0 : e.headers)) n.input = new Request(n.input), Object.keys(t).forEach((function (e) {
                            n.input.headers.append(e, t[e])
                        }));
                        else {
                            n.init = z(n.init);
                            var i = [];
                            n.init.headers instanceof Headers ? n.init.headers.forEach((function (t, e) {
                                i.push([e, t])
                            })) : Array.isArray(n.init.headers) ? n.init.headers.forEach((function (t) {
                                i.push(t)
                            })) : n.init.headers && Object.keys(n.init.headers).forEach((function (t) {
                                i.push([t, n.init.headers[t]])
                            })), n.init.headers = i.concat(S(t))
                        }
                    }))
                },
                traceXhr: function (n, i) {
                    return hn(t, n, e, (function (t) {
                        Object.keys(t).forEach((function (e) {
                            i.setRequestHeader(e, t[e])
                        }))
                    }))
                }
            }
        }(e, n);
        ! function (t, e, n) {
            var i = ci(e).subscribe((function (i) {
                var r = i;
                if (Ln(e, r.url)) switch (r.state) {
                    case "start":
                        n.traceXhr(r, r.xhr), r.requestIndex = fi(), t.notify(7, {
                            requestIndex: r.requestIndex,
                            url: r.url
                        });
                        break;
                    case "complete":
                        n.clearTracingIfNeeded(r), t.notify(8, {
                            duration: r.duration,
                            method: r.method,
                            requestIndex: r.requestIndex,
                            spanId: r.spanId,
                            startClocks: r.startClocks,
                            status: r.status,
                            traceId: r.traceId,
                            traceSampled: r.traceSampled,
                            type: "xhr",
                            url: r.url,
                            xhr: r.xhr,
                            isAborted: r.isAborted,
                            handlingStack: r.handlingStack
                        })
                }
            }))
        }(t, e, i),
            function (t, e, n) {
                var i = ve().subscribe((function (i) {
                    var r = i;
                    if (Ln(e, r.url)) switch (r.state) {
                        case "start":
                            n.traceFetch(r), r.requestIndex = fi(), t.notify(7, {
                                requestIndex: r.requestIndex,
                                url: r.url
                            });
                            break;
                        case "resolve":
                            ! function (t, e) {
                                var n = t.response && function (t) {
                                    try {
                                        return t.clone()
                                    } catch (t) {
                                        return
                                    }
                                }(t.response);
                                n && n.body ? function (t, e, n) {
                                    var i = t.getReader(),
                                        r = [],
                                        s = 0;

                                    function a() {
                                        var t, a;
                                        if (i.cancel().catch(k), n.collectStreamBody) {
                                            var o;
                                            if (1 === r.length) o = r[0];
                                            else {
                                                o = new Uint8Array(s);
                                                var l = 0;
                                                r.forEach((function (t) {
                                                    o.set(t, l), l += t.length
                                                }))
                                            }
                                            t = o.slice(0, n.bytesLimit), a = o.length > n.bytesLimit
                                        }
                                        e(void 0, t, a)
                                    } ! function t() {
                                        i.read().then(m((function (e) {
                                            e.done ? a() : (n.collectStreamBody && r.push(e.value), (s += e.value.length) > n.bytesLimit ? a() : t())
                                        })), m((function (t) {
                                            return e(t)
                                        })))
                                    }()
                                }(n.body, (function () {
                                    e(It(t.startClocks.timeStamp, Pt()))
                                }), {
                                    bytesLimit: Number.POSITIVE_INFINITY,
                                    collectStreamBody: !1
                                }) : e(It(t.startClocks.timeStamp, Pt()))
                            }(r, (function (e) {
                                n.clearTracingIfNeeded(r), t.notify(8, {
                                    duration: e,
                                    method: r.method,
                                    requestIndex: r.requestIndex,
                                    responseType: r.responseType,
                                    spanId: r.spanId,
                                    startClocks: r.startClocks,
                                    status: r.status,
                                    traceId: r.traceId,
                                    traceSampled: r.traceSampled,
                                    type: "fetch",
                                    url: r.url,
                                    response: r.response,
                                    init: r.init,
                                    input: r.input,
                                    isAborted: r.isAborted,
                                    handlingStack: r.handlingStack
                                })
                            }))
                    }
                }))
            }(t, e, i)
    }

    function fi() {
        var t = di;
        return di += 1, t
    }

    function mi(t) {
        return Mt(t) && t < 0 ? void 0 : t
    }

    function gi(t) {
        var e = t.lifeCycle,
            n = t.isChildEvent,
            i = t.onChange,
            r = void 0 === i ? k : i,
            s = {
                errorCount: 0,
                longTaskCount: 0,
                resourceCount: 0,
                actionCount: 0,
                frustrationCount: 0
            },
            a = e.subscribe(13, (function (t) {
                var e;
                if ("view" !== t.type && "vital" !== t.type && n(t)) switch (t.type) {
                    case "error":
                        s.errorCount += 1, r();
                        break;
                    case "action":
                        s.actionCount += 1, t.action.frustration && (s.frustrationCount += t.action.frustration.type.length), r();
                        break;
                    case "long_task":
                        s.longTaskCount += 1, r();
                        break;
                    case "resource":
                        (null === (e = t._dd) || void 0 === e ? void 0 : e.discarded) || (s.resourceCount += 1, r())
                }
            }));
        return {
            stop: function () {
                a.unsubscribe()
            },
            eventCounts: s
        }
    }

    function vi(t, e, n, i, r) {
        return function (t, e, n) {
            var i, r = !1,
                s = P(m((function () {
                    return c({
                        hadActivity: !1
                    })
                })), 100),
                a = void 0 !== n ? P(m((function () {
                    return c({
                        hadActivity: !0,
                        end: Pt()
                    })
                })), n) : void 0,
                o = t.subscribe((function (t) {
                    var e = t.isBusy;
                    L(s), L(i);
                    var n = Pt();
                    e || (i = P(m((function () {
                        return c({
                            hadActivity: !0,
                            end: n
                        })
                    })), 100))
                })),
                l = function () {
                    r = !0, L(s), L(i), L(a), o.unsubscribe()
                };

            function c(t) {
                r || (l(), e(t))
            }
            return {
                stop: l
            }
        }(function (t, e, n) {
            return new Z((function (i) {
                var r, s = [],
                    a = 0;
                s.push(e.subscribe(c), Un(n, {
                    type: On.RESOURCE
                }).subscribe((function (t) {
                    t.some((function (t) {
                        return !yi(n, t.name)
                    })) && c()
                })), t.subscribe(7, (function (t) {
                    yi(n, t.url) || (void 0 === r && (r = t.requestIndex), a += 1, c())
                })), t.subscribe(8, (function (t) {
                    yi(n, t.url) || void 0 === r || t.requestIndex < r || (a -= 1, c())
                })));
                var o, l = (o = c, he(window, "open", o)).stop;
                return function () {
                    l(), s.forEach((function (t) {
                        return t.unsubscribe()
                    }))
                };

                function c() {
                    i.notify({
                        isBusy: a > 0
                    })
                }
            }))
        }(t, e, n), i, r)
    }

    function yi(t, e) {
        return ln(t.excludedActivityUrls, e)
    }

    function bi(t) {
        return window.CSS && window.CSS.escape ? window.CSS.escape(t) : t.replace(/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g, (function (t, e) {
            return e ? "\0" === t ? "�" : "".concat(t.slice(0, -1), "\\").concat(t.charCodeAt(t.length - 1).toString(16), " ") : "\\".concat(t)
        }))
    }

    function xi(t, e) {
        return t.matches ? t.matches(e) : !!t.msMatchesSelector && t.msMatchesSelector(e)
    }

    function _i(t) {
        if (t.parentElement) return t.parentElement;
        for (; t.parentNode;) {
            if (t.parentNode.nodeType === Node.ELEMENT_NODE) return t.parentNode;
            t = t.parentNode
        }
        return null
    }
    var wi = function () {
        function t(t) {
            var e = this;
            this.map = new WeakMap, t && t.forEach((function (t) {
                return e.map.set(t, 1)
            }))
        }
        return t.prototype.add = function (t) {
            return this.map.set(t, 1), this
        }, t.prototype.delete = function (t) {
            return this.map.delete(t)
        }, t.prototype.has = function (t) {
            return this.map.has(t)
        }, t
    }();

    function Si(t) {
        return t.nodeType === Node.TEXT_NODE
    }

    function Mi(t) {
        return t.nodeType === Node.ELEMENT_NODE
    }

    function Ei(t) {
        return Mi(t) && Boolean(t.shadowRoot)
    }

    function Ti(t) {
        var e = t;
        return !!e.host && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE && Mi(e.host)
    }

    function Ci(t, e) {
        for (var n = t.firstChild; n;) e(n), n = n.nextSibling;
        Ei(t) && e(t.shadowRoot)
    }

    function Ai(t) {
        return Ti(t) ? t.host : t.parentNode
    }
    var Ri = {
        IGNORE: "ignore",
        HIDDEN: "hidden",
        ALLOW: en.ALLOW,
        MASK: en.MASK,
        MASK_USER_INPUT: en.MASK_USER_INPUT
    },
        Pi = "data:image/gif;base64,R0lGODlhAQABAIAAAMLCwgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==",
        Li = {
            INPUT: !0,
            OUTPUT: !0,
            TEXTAREA: !0,
            SELECT: !0,
            OPTION: !0,
            DATALIST: !0,
            OPTGROUP: !0
        };

    function Oi(t, e, n) {
        if (n && n.has(t)) return n.get(t);
        var i = Ai(t),
            r = i ? Oi(i, e, n) : e,
            s = Di(Ii(t), r);
        return n && n.set(t, s), s
    }

    function Di(t, e) {
        switch (e) {
            case Ri.HIDDEN:
            case Ri.IGNORE:
                return e
        }
        switch (t) {
            case Ri.ALLOW:
            case Ri.MASK:
            case Ri.MASK_USER_INPUT:
            case Ri.HIDDEN:
            case Ri.IGNORE:
                return t;
            default:
                return e
        }
    }

    function Ii(t) {
        if (Mi(t)) {
            if ("BASE" === t.tagName) return Ri.ALLOW;
            if ("INPUT" === t.tagName) {
                var e = t;
                if ("password" === e.type || "email" === e.type || "tel" === e.type) return Ri.MASK;
                if ("hidden" === e.type) return Ri.MASK;
                var n = e.getAttribute("autocomplete");
                if (n && 0 === n.indexOf("cc-")) return Ri.MASK
            }
            return xi(t, zi(Ri.HIDDEN)) ? Ri.HIDDEN : xi(t, zi(Ri.MASK)) ? Ri.MASK : xi(t, zi(Ri.MASK_USER_INPUT)) ? Ri.MASK_USER_INPUT : xi(t, zi(Ri.ALLOW)) ? Ri.ALLOW : function (t) {
                if ("SCRIPT" === t.nodeName) return !0;
                if ("LINK" === t.nodeName) {
                    var e = r("rel");
                    return /preload|prefetch/i.test(e) && "script" === r("as") || "shortcut icon" === e || "icon" === e
                }
                if ("META" === t.nodeName) {
                    var n = r("name"),
                        i = (e = r("rel"), r("property"));
                    return /^msapplication-tile(image|color)$/.test(n) || "application-name" === n || "icon" === e || "apple-touch-icon" === e || "shortcut icon" === e || "keywords" === n || "description" === n || /^(og|twitter|fb):/.test(i) || /^(og|twitter):/.test(n) || "pinterest" === n || "robots" === n || "googlebot" === n || "bingbot" === n || t.hasAttribute("http-equiv") || "author" === n || "generator" === n || "framework" === n || "publisher" === n || "progid" === n || /^article:/.test(i) || /^product:/.test(i) || "google-site-verification" === n || "yandex-verification" === n || "csrf-token" === n || "p:domain_verify" === n || "verify-v1" === n || "verification" === n || "shopify-checkout-api-token" === n
                }

                function r(e) {
                    return (t.getAttribute(e) || "").toLowerCase()
                }
                return !1
            }(t) ? Ri.IGNORE : void 0
        }
    }

    function ki(t, e) {
        switch (e) {
            case Ri.MASK:
            case Ri.HIDDEN:
            case Ri.IGNORE:
                return !0;
            case Ri.MASK_USER_INPUT:
                return Si(t) ? Ni(t.parentNode) : Ni(t);
            default:
                return !1
        }
    }

    function Ni(t) {
        if (!t || t.nodeType !== t.ELEMENT_NODE) return !1;
        var e = t;
        if ("INPUT" === e.tagName) switch (e.type) {
            case "button":
            case "color":
            case "reset":
            case "submit":
                return !1
        }
        return !!Li[e.tagName]
    }

    function Ui(t, e, n) {
        var i, r = null === (i = t.parentElement) || void 0 === i ? void 0 : i.tagName,
            s = t.textContent || "";
        if (!e || s.trim()) {
            if ("SCRIPT" === r) s = "***";
            else if (n === Ri.HIDDEN) s = "***";
            else if (ki(t, n))
                if ("DATALIST" === r || "SELECT" === r || "OPTGROUP" === r) {
                    if (!s.trim()) return
                } else s = "OPTION" === r ? "***" : s.replace(/\S/g, "x");
            return s
        }
    }

    function zi(t) {
        return "[".concat("data-dd-privacy", '="').concat(t, '"], .').concat("dd-privacy-").concat(t)
    }

    function Fi(t, e, n) {
        var i = e.enablePrivacyForActionName,
            r = e.actionNameAttribute,
            s = $i(t, "data-dd-action-name") || r && $i(t, r);
        return n === Ri.MASK ? s || "Masked Element" : s || Gi(t, r, ji, i) || Gi(t, r, Vi, i) || ""
    }

    function $i(t, e) {
        var n;
        if (function () {
            void 0 === Hi && (Hi = "closest" in HTMLElement.prototype);
            return Hi
        }()) n = t.closest("[".concat(e, "]"));
        else
            for (var i = t; i;) {
                if (i.hasAttribute(e)) {
                    n = i;
                    break
                }
                i = _i(i)
            }
        if (n) return qi(Wi(n.getAttribute(e).trim()))
    }
    var Bi, Hi, ji = [function (t, e, n) {
        if (function () {
            void 0 === Bi && (Bi = "labels" in HTMLInputElement.prototype);
            return Bi
        }()) {
            if ("labels" in t && t.labels && t.labels.length > 0) return Xi(t.labels[0], e)
        } else if (t.id) {
            var i = t.ownerDocument && x(t.ownerDocument.querySelectorAll("label"), (function (e) {
                return e.htmlFor === t.id
            }));
            return i && Xi(i, e, n)
        }
    }, function (t) {
        if ("INPUT" === t.nodeName) {
            var e = t,
                n = e.getAttribute("type");
            if ("button" === n || "submit" === n || "reset" === n) return e.value
        }
    }, function (t, e, n) {
        if ("BUTTON" === t.nodeName || "LABEL" === t.nodeName || "button" === t.getAttribute("role")) return Xi(t, e, n)
    }, function (t) {
        return t.getAttribute("aria-label")
    }, function (t, e, n) {
        var i = t.getAttribute("aria-labelledby");
        if (i) return i.split(/\s+/).map((function (e) {
            return function (t, e) {
                return t.ownerDocument ? t.ownerDocument.getElementById(e) : null
            }(t, e)
        })).filter((function (t) {
            return Boolean(t)
        })).map((function (t) {
            return Xi(t, e, n)
        })).join(" ")
    }, function (t) {
        return t.getAttribute("alt")
    }, function (t) {
        return t.getAttribute("name")
    }, function (t) {
        return t.getAttribute("title")
    }, function (t) {
        return t.getAttribute("placeholder")
    }, function (t, e) {
        if ("options" in t && t.options.length > 0) return Xi(t.options[0], e)
    }],
        Vi = [function (t, e, n) {
            return Xi(t, e, n)
        }];

    function Gi(t, e, n, i) {
        for (var r = t, s = 0; s <= 10 && r && "BODY" !== r.nodeName && "HTML" !== r.nodeName && "HEAD" !== r.nodeName;) {
            for (var a = 0, o = n; a < o.length; a++) {
                var l = (0, o[a])(r, e, i);
                if ("string" == typeof l) {
                    var c = l.trim();
                    if (c) return qi(Wi(c))
                }
            }
            if ("FORM" === r.nodeName) break;
            r = _i(r), s += 1
        }
    }

    function Wi(t) {
        return t.replace(/\s+/g, " ")
    }

    function qi(t) {
        return t.length > 100 ? "".concat(Se(t, 100), " [...]") : t
    }

    function Xi(t, e, n) {
        if (!t.isContentEditable) {
            if ("innerText" in t) {
                var i = t.innerText,
                    r = function (e) {
                        for (var n = t.querySelectorAll(e), r = 0; r < n.length; r += 1) {
                            var s = n[r];
                            if ("innerText" in s) {
                                var a = s.innerText;
                                a && a.trim().length > 0 && (i = i.replace(a, ""))
                            }
                        }
                    };
                return 0 === Pe() && r("script, style"), r("[".concat("data-dd-action-name", "]")), e && r("[".concat(e, "]")), n && r("".concat(zi(Ri.HIDDEN), ", ").concat(zi(Ri.MASK))), i
            }
            return t.textContent
        }
    }
    var Yi, Ki = ["data-dd-action-name", "data-testid", "data-test", "data-qa", "data-cy", "data-test-id", "data-qa-id", "data-testing", "data-component", "data-element", "data-source-file"],
        Zi = [er, function (t) {
            if (t.id && !tr(t.id)) return "#".concat(bi(t.id))
        }],
        Ji = [er, function (t) {
            if ("BODY" === t.tagName) return;
            for (var e = function (t) {
                if (t.classList) return t.classList;
                var e = (t.getAttribute("class") || "").trim();
                return e ? e.split(/\s+/) : []
            }(t), n = 0; n < e.length; n += 1) {
                var i = e[n];
                if (!tr(i)) return "".concat(bi(t.tagName), ".").concat(bi(i))
            }
        }, function (t) {
            return bi(t.tagName)
        }];

    function Qi(t, e) {
        if (function (t) {
            if ("isConnected" in t) return t.isConnected;
            return t.ownerDocument.documentElement.contains(t)
        }(t)) {
            for (var n, i = t; i && "HTML" !== i.nodeName;) {
                var r = ir(i, Zi, rr, e, n);
                if (r) return r;
                n = ir(i, Ji, sr, e, n) || ar(nr(i), n), i = _i(i)
            }
            return n
        }
    }

    function tr(t) {
        return /[0-9]/.test(t)
    }

    function er(t, e) {
        if (e && (r = s(e))) return r;
        for (var n = 0, i = Ki; n < i.length; n++) {
            var r;
            if (r = s(i[n])) return r
        }

        function s(e) {
            if (t.hasAttribute(e)) return "".concat(bi(t.tagName), "[").concat(e, '="').concat(bi(t.getAttribute(e)), '"]')
        }
    }

    function nr(t) {
        for (var e = _i(t).firstElementChild, n = 1; e && e !== t;) e.tagName === t.tagName && (n += 1), e = e.nextElementSibling;
        return "".concat(bi(t.tagName), ":nth-of-type(").concat(n, ")")
    }

    function ir(t, e, n, i, r) {
        for (var s = 0, a = e; s < a.length; s++) {
            var o = (0, a[s])(t, i);
            if (o && n(t, o, r)) return ar(o, r)
        }
    }

    function rr(t, e, n) {
        return 1 === t.ownerDocument.querySelectorAll(ar(e, n)).length
    }

    function sr(t, e, n) {
        var i;
        if (void 0 === n) i = function (t) {
            return xi(t, e)
        };
        else {
            var r = function () {
                if (void 0 === Yi) try {
                    document.querySelector(":scope"), Yi = !0
                } catch (t) {
                    Yi = !1
                }
                return Yi
            }() ? ar("".concat(e, ":scope"), n) : ar(e, n);
            i = function (t) {
                return null !== t.querySelector(r)
            }
        }
        for (var s = _i(t).firstElementChild; s;) {
            if (s !== t && i(s)) return !1;
            s = s.nextElementSibling
        }
        return !0
    }

    function ar(t, e) {
        return e ? "".concat(t, ">").concat(e) : t
    }

    function or(t, e) {
        var n, i = [],
            r = 0;

        function s(t) {
            t.stopObservable.subscribe(a), i.push(t), L(n), n = P(o, 1e3)
        }

        function a() {
            1 === r && i.every((function (t) {
                return t.isStopped()
            })) && (r = 2, e(i))
        }

        function o() {
            L(n), 0 === r && (r = 1, a())
        }
        return s(t), {
            tryAppend: function (t) {
                return 0 === r && (i.length > 0 && (e = i[i.length - 1].event, n = t.event, !(e.target === n.target && (a = e, l = n, Math.sqrt(Math.pow(a.clientX - l.clientX, 2) + Math.pow(a.clientY - l.clientY, 2)) <= 100) && e.timeStamp - n.timeStamp <= 1e3)) ? (o(), !1) : (s(t), !0));
                var e, n, a, l
            },
            stop: function () {
                o()
            }
        }
    }

    function lr() {
        var t = window.getSelection();
        return !t || t.isCollapsed
    }

    function cr(t) {
        return t.target instanceof Element && !1 !== t.isPrimary
    }

    function hr(t, e) {
        if (function (t) {
            if (t.some((function (t) {
                return t.getUserActivity().selection || t.getUserActivity().scroll
            }))) return !1;
            for (var e = 0; e < t.length - 2; e += 1)
                if (t[e + 3 - 1].event.timeStamp - t[e].event.timeStamp <= 1e3) return !0;
            return !1
        }(t)) return e.addFrustration("rage_click"), t.some(ur) && e.addFrustration("dead_click"), e.hasError && e.addFrustration("error_click"), {
            isRage: !0
        };
        var n = t.some((function (t) {
            return t.getUserActivity().selection
        }));
        return t.forEach((function (t) {
            t.hasError && t.addFrustration("error_click"), ur(t) && !n && t.addFrustration("dead_click")
        })), {
            isRage: !1
        }
    }

    function ur(t) {
        return !(t.hasPageActivity || t.getUserActivity().input || t.getUserActivity().scroll) && !xi(t.event.target, 'input:not([type="checkbox"]):not([type="radio"]):not([type="button"]):not([type="submit"]):not([type="reset"]):not([type="range"]),textarea,select,[contenteditable],[contenteditable] *,canvas,a[href],a[href] *')
    }

    function dr(t, e, n) {
        var i, r = ai({
            expireDelay: 3e5
        }),
            s = new Z;
        t.subscribe(10, (function () {
            r.reset()
        })), t.subscribe(5, l);
        var a = function (t, e) {
            var n, i, r = e.onPointerDown,
                s = e.onPointerUp,
                a = {
                    selection: !1,
                    input: !1,
                    scroll: !1
                },
                o = [te(t, window, "pointerdown", (function (t) {
                    cr(t) && (n = lr(), a = {
                        selection: !1,
                        input: !1,
                        scroll: !1
                    }, i = r(t))
                }), {
                    capture: !0
                }), te(t, window, "selectionchange", (function () {
                    n && lr() || (a.selection = !0)
                }), {
                    capture: !0
                }), te(t, window, "scroll", (function () {
                    a.scroll = !0
                }), {
                    capture: !0,
                    passive: !0
                }), te(t, window, "pointerup", (function (t) {
                    if (cr(t) && i) {
                        var e = a;
                        s(i, t, (function () {
                            return e
                        })), i = void 0
                    }
                }), {
                    capture: !0
                }), te(t, window, "input", (function () {
                    a.input = !0
                }), {
                    capture: !0
                })];
            return {
                stop: function () {
                    o.forEach((function (t) {
                        return t.stop()
                    }))
                }
            }
        }(n, {
            onPointerDown: function (i) {
                return function (t, e, n, i) {
                    var r = t.enablePrivacyForActionName ? Oi(i.target, t.defaultPrivacyLevel) : Ri.ALLOW;
                    if (r === Ri.HIDDEN) return;
                    var s = function (t, e, n) {
                        var i = t.target.getBoundingClientRect();
                        return {
                            type: "click",
                            target: {
                                width: Math.round(i.width),
                                height: Math.round(i.height),
                                selector: Qi(t.target, n.actionNameAttribute)
                            },
                            position: {
                                x: Math.round(t.clientX - i.left),
                                y: Math.round(t.clientY - i.top)
                            },
                            name: Fi(t.target, n, e)
                        }
                    }(i, r, t),
                        a = !1;
                    return vi(e, n, t, (function (t) {
                        a = t.hadActivity
                    }), 100), {
                        clickActionBase: s,
                        hadActivityOnPointerDown: function () {
                            return a
                        }
                    }
                }(n, t, e, i)
            },
            onPointerUp: function (i, a, l) {
                var c = i.clickActionBase,
                    h = i.hadActivityOnPointerDown;
                ! function (t, e, n, i, r, s, a, o, l, c) {
                    var h = function t(e, n, i, r, s) {
                        var a, o = ye(),
                            l = Ot(),
                            c = n.add(o, l.relative),
                            h = gi({
                                lifeCycle: e,
                                isChildEvent: function (t) {
                                    return void 0 !== t.action && (Array.isArray(t.action.id) ? y(t.action.id, o) : t.action.id === o)
                                }
                            }),
                            u = 0,
                            d = [],
                            p = new Z;

                        function f(t) {
                            0 === u && (u = 1, (a = t) ? c.close(Nt(a)) : c.remove(), h.stop(), p.notify())
                        }
                        return {
                            event: s,
                            stop: f,
                            stopObservable: p,
                            get hasError() {
                                return h.eventCounts.errorCount > 0
                            },
                            get hasPageActivity() {
                                return void 0 !== a
                            },
                            getUserActivity: i,
                            addFrustration: function (t) {
                                d.push(t)
                            },
                            startClocks: l,
                            isStopped: function () {
                                return 1 === u || 2 === u
                            },
                            clone: function () {
                                return t(e, n, i, r, s)
                            },
                            validate: function (t) {
                                if (f(), 1 === u) {
                                    var n = h.eventCounts,
                                        i = n.resourceCount,
                                        c = n.errorCount,
                                        p = n.longTaskCount,
                                        m = E({
                                            type: "click",
                                            duration: a && It(l.timeStamp, a),
                                            startClocks: l,
                                            id: o,
                                            frustrationTypes: d,
                                            counts: {
                                                resourceCount: i,
                                                errorCount: c,
                                                longTaskCount: p
                                            },
                                            events: null != t ? t : [s],
                                            event: s
                                        }, r);
                                    e.notify(1, m), u = 2
                                }
                            },
                            discard: function () {
                                f(), u = 2
                            }
                        }
                    }(e, i, l, a, o);
                    s(h);
                    var u = vi(e, n, t, (function (t) {
                        t.hadActivity && t.end < h.startClocks.timeStamp ? h.discard() : t.hadActivity ? h.stop(t.end) : c() ? h.stop(h.startClocks.timeStamp) : h.stop()
                    }), 1e4).stop,
                        d = e.subscribe(5, (function (t) {
                            var e = t.endClocks;
                            h.stop(e.timeStamp)
                        })),
                        p = r.subscribe((function () {
                            h.stop()
                        }));
                    h.stopObservable.subscribe((function () {
                        d.unsubscribe(), u(), p.unsubscribe()
                    }))
                }(n, t, e, r, s, o, c, a, l, h)
            }
        }).stop;
        return {
            stop: function () {
                l(), s.notify(), a()
            },
            actionContexts: {
                findActionId: function (t) {
                    return r.findAll(t)
                }
            }
        };

        function o(t) {
            if (!i || !i.tryAppend(t)) {
                var e = t.clone();
                i = or(t, (function (t) {
                    ! function (t, e) {
                        hr(t, e).isRage ? (t.forEach((function (t) {
                            return t.discard()
                        })), e.stop(Pt()), e.validate(t.map((function (t) {
                            return t.event
                        })))) : (e.discard(), t.forEach((function (t) {
                            return t.validate()
                        })))
                    }(t, e)
                }))
            }
        }

        function l() {
            i && i.stop()
        }
    }

    function pr(t, e) {
        var n = fr(t) ? {
            action: {
                id: t.id,
                loading_time: mi(At(t.duration)),
                frustration: {
                    type: t.frustrationTypes
                },
                error: {
                    count: t.counts.errorCount
                },
                long_task: {
                    count: t.counts.longTaskCount
                },
                resource: {
                    count: t.counts.resourceCount
                }
            },
            _dd: {
                action: {
                    target: t.target,
                    position: t.position
                }
            }
        } : void 0,
            i = fr(t) ? void 0 : t.context,
            r = q({
                action: {
                    id: ye(),
                    target: {
                        name: t.name
                    },
                    type: t.type
                },
                date: t.startClocks.timeStamp,
                type: "action",
                view: {
                    in_foreground: e.wasInPageStateAt("active", t.startClocks.relative)
                }
            }, n),
            s = fr(t) ? {
                events: t.events
            } : {};
        return !fr(t) && t.handlingStack && (s.handlingStack = t.handlingStack), {
            customerContext: i,
            rawRumEvent: r,
            startTime: t.startClocks.relative,
            domainContext: s
        }
    }

    function fr(t) {
        return "custom" !== t.type
    }

    function mr(t) {
        var e, n = function (e, n) {
            var i = bt({
                stackTrace: e,
                originalError: n,
                startClocks: Ot(),
                nonErrorPrefix: "Uncaught",
                source: Gn,
                handling: "unhandled"
            });
            t.notify(i)
        },
            i = (e = n, he(window, "onerror", (function (t) {
                var n, i = t.parameters,
                    r = i[0],
                    s = i[1],
                    a = i[2],
                    o = i[3],
                    l = i[4];
                n = l instanceof Error ? st(l) : ft(r, s, a, o), e(n, null != l ? l : r)
            }))).stop,
            r = function (t) {
                return he(window, "onunhandledrejection", (function (e) {
                    var n = e.parameters[0].reason || "Empty reason",
                        i = st(n);
                    t(i, n)
                }))
            }(n).stop;
        return {
            stop: function () {
                i(), r()
            }
        }
    }
    var gr = {};

    function vr(t) {
        var e = t.map((function (t) {
            return gr[t] || (gr[t] = function (t) {
                return new Z((function (e) {
                    var n = r[t];
                    return r[t] = function () {
                        for (var i = [], r = 0; r < arguments.length; r++) i[r] = arguments[r];
                        n.apply(console, i);
                        var s = gt();
                        g((function () {
                            e.notify(yr(i, t, s))
                        }))
                    },
                        function () {
                            r[t] = n
                        }
                }))
            }(t)), gr[t]
        }));
        return J.apply(void 0, e)
    }

    function yr(t, e, n) {
        var r, s, a, o = t.map((function (t) {
            return function (t) {
                if ("string" == typeof t) return X(t);
                if (t instanceof Error) return yt(st(t));
                return N(X(t), void 0, 2)
            }(t)
        })).join(" ");
        if (e === i.error) {
            var l = x(t, (function (t) {
                return t instanceof Error
            }));
            r = l ? vt(st(l)) : void 0, s = xt(l), a = l ? _t(l, "console") : void 0
        }
        return {
            api: e,
            message: o,
            stack: r,
            handlingStack: n,
            fingerprint: s,
            causes: a
        }
    }
    var br = "intervention",
        xr = "csp_violation";

    function _r(t, e) {
        var n = [];
        y(e, xr) && n.push(function (t) {
            return new Z((function (e) {
                return te(t, document, "securitypolicyviolation", (function (t) {
                    e.notify(function (t) {
                        var e = xr,
                            n = "'".concat(t.blockedURI, "' blocked by '").concat(t.effectiveDirective, "' directive");
                        return {
                            type: xr,
                            subtype: t.effectiveDirective,
                            message: "".concat(e, ": ").concat(n),
                            stack: wr(t.effectiveDirective, t.originalPolicy ? "".concat(n, ' of the policy "').concat(Se(t.originalPolicy, 100, "..."), '"') : "no policy", t.sourceFile, t.lineNumber, t.columnNumber),
                            originalReport: t
                        }
                    }(t))
                })).stop
            }))
        }(t));
        var i = e.filter((function (t) {
            return t !== xr
        }));
        return i.length && n.push(function (t) {
            return new Z((function (e) {
                if (window.ReportingObserver) {
                    var n = m((function (t, n) {
                        return t.forEach((function (t) {
                            e.notify(function (t) {
                                var e = t.type,
                                    n = t.body;
                                return {
                                    type: e,
                                    subtype: n.id,
                                    message: "".concat(e, ": ").concat(n.message),
                                    originalReport: t,
                                    stack: wr(n.id, n.message, n.sourceFile, n.lineNumber, n.columnNumber)
                                }
                            }(t))
                        }))
                    })),
                        i = new window.ReportingObserver(n, {
                            types: t,
                            buffered: !0
                        });
                    return i.observe(),
                        function () {
                            i.disconnect()
                        }
                }
            }))
        }(i)), J.apply(void 0, n)
    }

    function wr(t, e, n, i, r) {
        return n ? vt({
            name: t,
            message: e,
            stack: [{
                func: "?",
                url: n,
                line: null != i ? i : void 0,
                column: null != r ? r : void 0
            }]
        }) : void 0
    }

    function Sr(t, e, n, r) {
        var s = new Z;
        return function (t) {
            var e = vr([i.error]).subscribe((function (e) {
                return t.notify({
                    startClocks: Ot(),
                    message: e.message,
                    stack: e.stack,
                    fingerprint: e.fingerprint,
                    source: jn,
                    handling: "handled",
                    handlingStack: e.handlingStack
                })
            }))
        }(s), mr(s),
            function (t, e) {
                var n = _r(t, [xr, br]).subscribe((function (t) {
                    var n = {
                        startClocks: Ot(),
                        message: t.message,
                        stack: t.stack,
                        type: t.subtype,
                        source: Wn,
                        handling: "unhandled",
                        originalError: t.originalReport
                    };
                    return "securitypolicyviolation" === t.originalReport.type && (n.csp = {
                        disposition: t.originalReport.disposition
                    }), e.notify(n)
                }))
            }(e, s), s.subscribe((function (e) {
                return t.notify(14, {
                    error: e
                })
            })),
            function (t, e, n) {
                return t.subscribe(14, (function (i) {
                    var r = i.error,
                        s = i.customerContext,
                        a = i.savedCommonContext;
                    t.notify(12, E({
                        customerContext: s,
                        savedCommonContext: a
                    }, function (t, e, n) {
                        var i = {
                            date: t.startClocks.timeStamp,
                            error: {
                                id: ye(),
                                message: t.message,
                                source: t.source,
                                stack: t.stack,
                                handling_stack: t.handlingStack,
                                type: t.type,
                                handling: t.handling,
                                causes: t.causes,
                                source_type: "browser",
                                fingerprint: t.fingerprint,
                                csp: t.csp
                            },
                            type: "error",
                            view: {
                                in_foreground: e.wasInPageStateAt("active", t.startClocks.relative)
                            }
                        },
                            r = n.findFeatureFlagEvaluations(t.startClocks.relative);
                        r && !B(r) && (i.feature_flags = r);
                        var s = {
                            error: t.originalError,
                            handlingStack: t.handlingStack
                        };
                        return {
                            rawRumEvent: i,
                            startTime: t.startClocks.relative,
                            domainContext: s
                        }
                    }(r, e, n)))
                })), {
                    addError: function (e, n) {
                        var i = e.error,
                            r = e.handlingStack,
                            s = e.startClocks,
                            a = e.context,
                            o = bt({
                                stackTrace: i instanceof Error ? st(i) : void 0,
                                originalError: i,
                                handlingStack: r,
                                startClocks: s,
                                nonErrorPrefix: "Provided",
                                source: Vn,
                                handling: "handled"
                            });
                        t.notify(14, {
                            customerContext: a,
                            savedCommonContext: n,
                            error: o
                        })
                    }
                }
            }(t, n, r)
    }
    var Mr = new wi;

    function Er(t) {
        if (performance && "getEntriesByName" in performance) {
            var e = performance.getEntriesByName(t.url, "resource");
            if (e.length && "toJSON" in e[0]) {
                var n = e.filter((function (t) {
                    return !Mr.has(t)
                })).filter((function (t) {
                    return An(t)
                })).filter((function (e) {
                    return n = e, i = t.startClocks.relative, r = Tr({
                        startTime: t.startClocks.relative,
                        duration: t.duration
                    }), n.startTime >= i - 1 && Tr(n) <= kt(r, 1);
                    var n, i, r
                }));
                return 1 === n.length ? (Mr.add(n[0]), n[0].toJSON()) : void 0
            }
        }
    }

    function Tr(t) {
        return kt(t.startTime, t.duration)
    }

    function Cr(t, e, n) {
        document.readyState === e || "complete" === document.readyState ? n() : te(t, window, "complete" === e ? "load" : "DOMContentLoaded", n, {
            once: !0
        })
    }

    function Ar(t) {
        var e = function (t) {
            var e = t.querySelector("meta[name=dd-trace-id]"),
                n = t.querySelector("meta[name=dd-trace-time]");
            return Rr(e && e.content, n && n.content)
        }(t) || function (t) {
            var e = function (t) {
                for (var e = 0; e < t.childNodes.length; e += 1) {
                    if (n = Pr(t.childNodes[e])) return n
                }
                if (t.body)
                    for (e = t.body.childNodes.length - 1; e >= 0; e -= 1) {
                        var n, i = t.body.childNodes[e];
                        if (n = Pr(i)) return n;
                        if (!Si(i)) break
                    }
            }(t);
            if (!e) return;
            return Rr(we(e, "trace-id"), we(e, "trace-time"))
        }(t);
        if (e && !(e.traceTime <= Rt() - 12e4)) return e.traceId
    }

    function Rr(t, e) {
        var n = e && Number(e);
        if (t && n) return {
            traceId: t,
            traceTime: n
        }
    }

    function Pr(t) {
        if (t && function (t) {
            return t.nodeType === Node.COMMENT_NODE
        }(t)) {
            var e = /^\s*DATADOG;(.*?)\s*$/.exec(t.data);
            if (e) return e[1]
        }
    }

    function Lr() {
        var t = {},
            e = performance.timing;
        for (var n in e)
            if (Mt(e[n])) {
                var i = n,
                    r = e[i];
                t[i] = 0 === r ? 0 : Nt(r)
            } return t
    }

    function Or(t, e) {
        Cr(t, "interactive", (function () {
            var t, n = {
                entryType: On.RESOURCE,
                initiatorType: "initial_document",
                traceId: Ar(document),
                toJSON: function () {
                    return E({}, t, {
                        toJSON: void 0
                    })
                }
            };
            if (zn(On.NAVIGATION) && performance.getEntriesByType(On.NAVIGATION).length > 0) {
                var i = performance.getEntriesByType(On.NAVIGATION)[0];
                t = E(i.toJSON(), n)
            } else {
                var r = Lr();
                t = E(r, {
                    decodedBodySize: 0,
                    encodedBodySize: 0,
                    transferSize: 0,
                    renderBlockingStatus: "non-blocking",
                    duration: r.responseEnd,
                    name: window.location.href,
                    startTime: 0
                }, n)
            }
            e(t)
        }))
    }

    function Dr(t, e, n, i) {
        void 0 === i && (i = Or), t.subscribe(8, (function (i) {
            var r = function (t, e, n) {
                var i = Er(t),
                    r = i ? Tt(i.startTime) : t.startClocks,
                    s = function (t, e) {
                        if (!(t.traceSampled && t.traceId && t.spanId)) return;
                        return {
                            _dd: {
                                span_id: t.spanId.toDecimalString(),
                                trace_id: t.traceId.toDecimalString(),
                                rule_psr: Nr(e)
                            }
                        }
                    }(t, e);
                if (!e.trackResources && !s) return;
                var a = "xhr" === t.type ? "xhr" : "fetch",
                    o = i ? kr(i) : void 0,
                    l = function (t, e, n) {
                        return t.wasInPageStateDuringPeriod("frozen", e.relative, n) ? void 0 : At(n)
                    }(n, r, t.duration),
                    c = q({
                        date: r.timeStamp,
                        resource: {
                            id: ye(),
                            type: a,
                            duration: l,
                            method: t.method,
                            status_code: t.status,
                            url: kn(t.url) ? Nn(t.url) : t.url
                        },
                        type: "resource",
                        _dd: {
                            discarded: !e.trackResources
                        }
                    }, s, o);
                return {
                    startTime: r.relative,
                    rawRumEvent: c,
                    domainContext: {
                        performanceEntry: i,
                        xhr: t.xhr,
                        response: t.response,
                        requestInput: t.input,
                        requestInit: t.init,
                        error: t.error,
                        isAborted: t.isAborted,
                        handlingStack: t.handlingStack
                    }
                }
            }(i, e, n);
            r && t.notify(12, r)
        }));
        var r = Un(e, {
            type: On.RESOURCE,
            buffered: !0
        }).subscribe((function (n) {
            for (var i = 0, r = n; i < r.length; i++) {
                var s = r[i];
                if ("xmlhttprequest" !== (o = s).initiatorType && "fetch" !== o.initiatorType) {
                    var a = Ir(s, e);
                    a && t.notify(12, a)
                }
            }
            var o
        }));
        return i(e, (function (n) {
            var i = Ir(n, e);
            i && t.notify(12, i)
        })), {
            stop: function () {
                r.unsubscribe()
            }
        }
    }

    function Ir(t, e) {
        var n = Tt(t.startTime),
            i = function (t, e) {
                if (!t.traceId) return;
                return {
                    _dd: {
                        trace_id: t.traceId,
                        span_id: dn().toDecimalString(),
                        rule_psr: Nr(e)
                    }
                }
            }(t, e);
        if (e.trackResources || i) {
            var r, s = En(t),
                a = kr(t),
                o = q({
                    date: n.timeStamp,
                    resource: {
                        id: ye(),
                        type: s,
                        url: t.name,
                        status_code: (r = t.responseStatus, 0 === r ? void 0 : r)
                    },
                    type: "resource",
                    _dd: {
                        discarded: !e.trackResources
                    }
                }, i, a);
            return {
                startTime: n.relative,
                rawRumEvent: o,
                domainContext: {
                    performanceEntry: t
                }
            }
        }
    }

    function kr(t) {
        var e, n, i, r, s = t.renderBlockingStatus;
        return {
            resource: E({
                duration: (e = t, n = e.duration, i = e.startTime, r = e.responseEnd, At(0 === n && i < r ? It(i, r) : n)),
                render_blocking_status: s
            }, Pn(t), Cn(t))
        }
    }

    function Nr(t) {
        return Mt(t.traceSampleRate) ? t.traceSampleRate / 100 : void 0
    }

    function Ur(t, e) {
        var n = function (t) {
            (function (t) {
                return t.loadEventEnd <= 0
            })(t) || e(function (t) {
                return {
                    domComplete: t.domComplete,
                    domContentLoaded: t.domContentLoadedEventEnd,
                    domInteractive: t.domInteractive,
                    loadEvent: t.loadEventEnd,
                    firstByte: t.responseStart >= 0 && t.responseStart <= Lt() ? t.responseStart : void 0
                }
            }(t))
        },
            i = k;
        return zn(On.NAVIGATION) ? i = Un(t, {
            type: On.NAVIGATION,
            buffered: !0
        }).subscribe((function (t) {
            return _(t, n)
        })).unsubscribe : function (t, e) {
            Cr(t, "complete", (function () {
                P((function () {
                    return e(Lr())
                }))
            }))
        }(t, n), {
            stop: i
        }
    }

    function zr(t, e, n, i) {
        var r = {},
            s = Ur(e, (function (t) {
                n(t.loadEvent), r.navigationTimings = t, i()
            })).stop,
            a = function (t, e) {
                var n, i;
                return void 0 === e && (e = window), "hidden" === document.visibilityState ? n = 0 : (n = 1 / 0, i = ee(t, e, ["pagehide", "visibilitychange"], (function (t) {
                    "pagehide" !== t.type && "hidden" !== document.visibilityState || (n = t.timeStamp, i())
                }), {
                    capture: !0
                }).stop), {
                    get timeStamp() {
                        return n
                    },
                    stop: function () {
                        null == i || i()
                    }
                }
            }(e),
            o = function (t, e, n) {
                return {
                    stop: t.subscribe(0, (function (t) {
                        var i = x(t, (function (t) {
                            return t.entryType === On.PAINT && "first-contentful-paint" === t.name && t.startTime < e.timeStamp && t.startTime < 6e5
                        }));
                        i && n(i.startTime)
                    })).unsubscribe
                }
            }(t, a, (function (t) {
                r.firstContentfulPaint = t, i()
            })).stop,
            l = function (t, e, n, i, r) {
                var s = 1 / 0,
                    a = ee(e, i, ["pointerdown", "keydown"], (function (t) {
                        s = t.timeStamp
                    }), {
                        capture: !0,
                        once: !0
                    }).stop,
                    o = 0,
                    l = t.subscribe(0, (function (t) {
                        var i = function (t, e) {
                            for (var n = t.length - 1; n >= 0; n -= 1) {
                                var i = t[n];
                                if (e(i, n, t)) return i
                            }
                        }(t, (function (t) {
                            return t.entryType === On.LARGEST_CONTENTFUL_PAINT && t.startTime < s && t.startTime < n.timeStamp && t.startTime < 6e5 && t.size > o
                        }));
                        if (i) {
                            var a = void 0;
                            i.element && (a = Qi(i.element, e.actionNameAttribute)), r({
                                value: i.startTime,
                                targetSelector: a
                            }), o = i.size
                        }
                    })).unsubscribe;
                return {
                    stop: function () {
                        a(), l()
                    }
                }
            }(t, e, a, window, (function (t) {
                r.largestContentfulPaint = t, i()
            })).stop,
            c = function (t, e, n, i) {
                return {
                    stop: t.subscribe(0, (function (t) {
                        var r = x(t, (function (t) {
                            return t.entryType === On.FIRST_INPUT && t.startTime < n.timeStamp
                        }));
                        if (r) {
                            var s = It(r.startTime, r.processingStart),
                                a = void 0;
                            r.target && Mi(r.target) && (a = Qi(r.target, e.actionNameAttribute)), i({
                                delay: s >= 0 ? s : 0,
                                time: r.startTime,
                                targetSelector: a
                            })
                        }
                    })).unsubscribe
                }
            }(t, e, a, (function (t) {
                r.firstInput = t, i()
            })).stop;
        return {
            stop: function () {
                s(), o(), l(), c(), a.stop()
            },
            initialViewMetrics: r
        }
    }

    function Fr(t, e, n, i) {
        if (!zn(On.LAYOUT_SHIFT)) return {
            stop: k
        };
        var r, s, a = 0;
        i({
            value: 0
        });
        var o, l, c, h, u = (c = 0, h = 0, {
            update: function (t) {
                var e;
                return void 0 === o || t.startTime - l >= 1e3 || t.startTime - o >= 5e3 ? (o = l = t.startTime, h = c = t.value, e = !0) : (c += t.value, l = t.startTime, (e = t.value > h) && (h = t.value)), {
                    cumulatedValue: c,
                    isMaxValue: e
                }
            }
        });
        return {
            stop: e.subscribe(0, (function (e) {
                for (var o = 0, l = e; o < l.length; o++) {
                    var c = l[o];
                    if (c.entryType === On.LAYOUT_SHIFT && !c.hadRecentInput) {
                        var h = u.update(c),
                            d = h.cumulatedValue;
                        if (h.isMaxValue) {
                            var p = $r(c.sources);
                            r = p ? new WeakRef(p) : void 0, s = It(n, c.startTime)
                        }
                        if (d > a) {
                            a = d;
                            p = null == r ? void 0 : r.deref();
                            i({
                                value: St(a, 4),
                                targetSelector: p && Qi(p, t.actionNameAttribute),
                                time: s
                            })
                        }
                    }
                }
            })).unsubscribe
        }
    }

    function $r(t) {
        var e;
        if (t) return null === (e = x(t, (function (t) {
            return !!t.node && Mi(t.node)
        }))) || void 0 === e ? void 0 : e.node
    }
    var Br;
    var Hr = 0,
        jr = 1 / 0,
        Vr = 0;
    var Gr, Wr = function () {
        return Br ? Hr : window.performance.interactionCount || 0
    };

    function qr(t, e, n, i) {
        if (!(zn(On.EVENT) && window.PerformanceEventTiming && "interactionId" in PerformanceEventTiming.prototype)) return {
            getInteractionToNextPaint: function () { },
            setViewEnd: k,
            stop: k
        };
        var r, s, a = function (t) {
            "interactionCount" in performance || Br || (Br = new window.PerformanceObserver(m((function (t) {
                t.getEntries().forEach((function (t) {
                    var e = t;
                    e.interactionId && (jr = Math.min(jr, e.interactionId), Vr = Math.max(Vr, e.interactionId), Hr = (Vr - jr) / 7 + 1)
                }))
            })))).observe({
                type: "event",
                buffered: !0,
                durationThreshold: 0
            });
            var e = "initial_load" === t ? 0 : Wr(),
                n = {
                    stopped: !1
                };

            function i() {
                return Wr() - e
            }
            return {
                getViewInteractionCount: function () {
                    return n.stopped ? n.interactionCount : i()
                },
                stopViewInteractionCount: function () {
                    n = {
                        stopped: !0,
                        interactionCount: i()
                    }
                }
            }
        }(n),
            o = a.getViewInteractionCount,
            l = a.stopViewInteractionCount,
            c = 1 / 0,
            h = function (t) {
                var e = [];

                function n() {
                    e.sort((function (t, e) {
                        return e.duration - t.duration
                    })).splice(10)
                }
                return {
                    process: function (t) {
                        var i = e.findIndex((function (e) {
                            return t.interactionId === e.interactionId
                        })),
                            r = e[e.length - 1]; - 1 !== i ? t.duration > e[i].duration && (e[i] = t, n()) : (e.length < 10 || t.duration > r.duration) && (e.push(t), n())
                    },
                    estimateP98Interaction: function () {
                        var n = Math.min(e.length - 1, Math.floor(t() / 50));
                        return e[n]
                    }
                }
            }(o),
            u = -1;
        return {
            getInteractionToNextPaint: function () {
                return u >= 0 ? {
                    value: Math.min(u, 6e4),
                    targetSelector: r,
                    time: s
                } : o() ? {
                    value: 0
                } : void 0
            },
            setViewEnd: function (t) {
                c = t, l()
            },
            stop: i.subscribe(0, (function (n) {
                for (var i = 0, a = n; i < a.length; i++) {
                    var o = a[i];
                    (o.entryType === On.EVENT || o.entryType === On.FIRST_INPUT) && o.interactionId && o.startTime >= e && o.startTime <= c && h.process(o)
                }
                var l = h.estimateP98Interaction();
                l && l.duration !== u && (u = l.duration, s = It(e, l.startTime), r = l.target && Mi(l.target) ? Qi(l.target, t.actionNameAttribute) : void 0)
            })).unsubscribe
        }
    }

    function Xr() {
        var t, e = window.visualViewport;
        return t = e ? e.pageLeft - e.offsetLeft : void 0 !== window.scrollX ? window.scrollX : window.pageXOffset || 0, Math.round(t)
    }

    function Yr() {
        var t, e = window.visualViewport;
        return t = e ? e.pageTop - e.offsetTop : void 0 !== window.scrollY ? window.scrollY : window.pageYOffset || 0, Math.round(t)
    }

    function Kr(t) {
        return Gr || (Gr = function (t) {
            return new Z((function (e) {
                var n = I((function () {
                    e.notify(Zr())
                }), 200).throttled;
                return te(t, window, "resize", n, {
                    capture: !0,
                    passive: !0
                }).stop
            }))
        }(t)), Gr
    }

    function Zr() {
        var t = window.visualViewport;
        return t ? {
            width: Number(t.width * t.scale),
            height: Number(t.height * t.scale)
        } : {
            width: Number(window.innerWidth || 0),
            height: Number(window.innerHeight || 0)
        }
    }

    function Jr(t, e, n, i) {
        void 0 === i && (i = function (t, e) {
            void 0 === e && (e = 1e3);
            return new Z((function (n) {
                if (window.ResizeObserver) {
                    var i = I((function () {
                        var t, e, i, r;
                        n.notify((t = Yr(), e = Zr().height, i = Math.round((document.scrollingElement || document.documentElement).scrollHeight), r = Math.round(e + t), {
                            scrollHeight: i,
                            scrollDepth: r,
                            scrollTop: t
                        }))
                    }), e, {
                        leading: !1,
                        trailing: !0
                    }),
                        r = document.scrollingElement || document.documentElement,
                        s = new ResizeObserver(m(i.throttled));
                    s.observe(r);
                    var a = te(t, window, "scroll", i.throttled, {
                        passive: !0
                    });
                    return function () {
                        i.cancel(), s.unobserve(r), a.stop()
                    }
                }
            }))
        }(t));
        var r = 0,
            s = 0,
            a = 0,
            o = i.subscribe((function (t) {
                var i = t.scrollDepth,
                    o = t.scrollTop,
                    l = t.scrollHeight,
                    c = !1;
                if (i > r && (r = i, c = !0), l > s) {
                    s = l;
                    var h = Lt();
                    a = It(e.relative, h), c = !0
                }
                c && n({
                    maxDepth: Math.min(r, s),
                    maxDepthScrollTop: o,
                    maxScrollHeight: s,
                    maxScrollHeightTime: a
                })
            }));
        return {
            stop: function () {
                return o.unsubscribe()
            }
        }
    }

    function Qr(t, e, n, i, r, s) {
        var a = {},
            o = function (t, e, n, i, r, s) {
                var a = "initial_load" === i,
                    o = !0,
                    l = [];

                function c() {
                    !o && !a && l.length > 0 && s(Math.max.apply(Math, l))
                }
                return {
                    stop: vi(t, e, n, (function (t) {
                        o && (o = !1, t.hadActivity && l.push(It(r.timeStamp, t.end)), c())
                    })).stop,
                    setLoadEvent: function (t) {
                        a && (a = !1, l.push(t), c())
                    }
                }
            }(t, e, n, r, s, (function (t) {
                a.loadingTime = t, i()
            })),
            l = o.stop,
            c = o.setLoadEvent,
            h = Jr(n, s, (function (t) {
                a.scroll = t
            })).stop,
            u = Fr(n, t, s.relative, (function (t) {
                a.cumulativeLayoutShift = t, i()
            })).stop,
            d = qr(n, s.relative, r, t),
            p = d.stop,
            f = d.getInteractionToNextPaint;
        return {
            stop: function () {
                l(), u(), h()
            },
            stopINPTracking: p,
            setLoadEvent: c,
            setViewEnd: d.setViewEnd,
            getCommonViewMetrics: function () {
                return a.interactionToNextPaint = f(), a
            }
        }
    }

    function ts(t, e, n, i, r, s, a) {
        var l, c = new Set,
            h = u("initial_load", Dt(), a);

        function u(r, s, a) {
            var l = function (t, e, n, i, r, s, a) {
                void 0 === s && (s = Ot());
                var l, c, h, u, d = ye(),
                    p = new Z,
                    f = {},
                    m = 0,
                    g = z(i),
                    v = !0;
                a && (c = a.name, h = a.service || void 0, u = a.version || void 0);
                var y = {
                    id: d,
                    name: c,
                    startClocks: s,
                    service: h,
                    version: u
                };
                t.notify(2, y), t.notify(3, y);
                var b = I(B, 3e3, {
                    leading: !1
                }),
                    x = b.throttled,
                    _ = b.cancel,
                    w = Qr(t, e, n, x, r, s),
                    S = w.setLoadEvent,
                    M = w.setViewEnd,
                    E = w.stop,
                    T = w.stopINPTracking,
                    C = w.getCommonViewMetrics,
                    A = "initial_load" === r ? zr(t, n, S, x) : {
                        stop: k,
                        initialViewMetrics: {}
                    },
                    R = A.stop,
                    L = A.initialViewMetrics,
                    N = function (t, e, n) {
                        var i = gi({
                            lifeCycle: t,
                            isChildEvent: function (t) {
                                return t.view.id === e
                            },
                            onChange: n
                        });
                        return {
                            stop: i.stop,
                            eventCounts: i.eventCounts
                        }
                    }(t, d, x),
                    U = N.stop,
                    F = N.eventCounts,
                    $ = O(B, 3e5);

                function B() {
                    _(), m += 1;
                    var e = void 0 === l ? Pt() : l.timeStamp;
                    t.notify(4, {
                        customTimings: f,
                        documentVersion: m,
                        id: d,
                        name: c,
                        service: h,
                        version: u,
                        loadingType: r,
                        location: g,
                        startClocks: s,
                        commonViewMetrics: C(),
                        initialViewMetrics: L,
                        duration: It(s.timeStamp, e),
                        isActive: void 0 === l,
                        sessionIsActive: v,
                        eventCounts: F
                    })
                }
                return B(), {
                    get name() {
                        return c
                    },
                    service: h,
                    version: u,
                    stopObservable: p,
                    end: function (e) {
                        var n, i, r = this;
                        void 0 === e && (e = {}), l || (l = null !== (n = e.endClocks) && void 0 !== n ? n : Ot(), v = null === (i = e.sessionIsActive) || void 0 === i || i, t.notify(5, {
                            endClocks: l
                        }), t.notify(6, {
                            endClocks: l
                        }), D($), M(l.relative), E(), B(), P((function () {
                            r.stop()
                        }), 3e5))
                    },
                    stop: function () {
                        R(), U(), T(), p.notify()
                    },
                    addTiming: function (t, e) {
                        if (!l) {
                            var n = function (t) {
                                return t < 31536e6
                            }(e) ? e : It(s.timeStamp, e);
                            f[function (t) {
                                var e = t.replace(/[^a-zA-Z0-9-_.@$]/g, "_");
                                e !== t && o.warn("Invalid timing name: ".concat(t, ", sanitized to: ").concat(e));
                                return e
                            }(t)] = n, x()
                        }
                    },
                    updateViewName: function (t) {
                        rt(tt.UPDATE_VIEW_NAME) && (c = t, B())
                    }
                }
            }(e, n, i, t, r, s, a);
            return c.add(l), l.stopObservable.subscribe((function () {
                c.delete(l)
            })), l
        }
        return e.subscribe(10, (function () {
            h = u("route_change", void 0, {
                name: h.name,
                service: h.service,
                version: h.version
            })
        })), e.subscribe(9, (function () {
            h.end({
                sessionIsActive: !1
            })
        })), e.subscribe(11, (function (t) {
            t.reason === _n.UNLOADING && h.end()
        })), s && (l = function (t) {
            return t.subscribe((function (t) {
                var e, n, i, r, s = t.oldLocation,
                    a = t.newLocation;
                n = a, (e = s).pathname === n.pathname && (i = n.hash, "" !== (r = i.substring(1)) && document.getElementById(r) || es(n.hash) === es(e.hash)) || (h.end(), h = u("route_change"))
            }))
        }(r)), {
            addTiming: function (t, e) {
                void 0 === e && (e = Pt()), h.addTiming(t, e)
            },
            startView: function (t, e) {
                h.end({
                    endClocks: e
                }), h = u("route_change", e, t)
            },
            updateViewName: function (t) {
                h.updateViewName(t)
            },
            stop: function () {
                l && l.unsubscribe(), h.end(), c.forEach((function (t) {
                    return t.stop()
                }))
            }
        }
    }

    function es(t) {
        var e = t.indexOf("?");
        return e < 0 ? t : t.slice(0, e)
    }

    function ns(t, e, n, i, r, s, a, o, l) {
        return t.subscribe(4, (function (n) {
            return t.notify(12, function (t, e, n, i, r) {
                var s, a, o, l, c, h, u, d, p, f, m, g, v, y, b, x, _ = i.getReplayStats(t.id),
                    w = n.findFeatureFlagEvaluations(t.startClocks.relative),
                    S = r.findAll(t.startClocks.relative, t.duration),
                    M = {
                        _dd: {
                            document_version: t.documentVersion,
                            replay_stats: _,
                            page_states: S,
                            configuration: {
                                start_session_replay_recording_manually: e.startSessionReplayRecordingManually
                            }
                        },
                        date: t.startClocks.timeStamp,
                        type: "view",
                        view: {
                            action: {
                                count: t.eventCounts.actionCount
                            },
                            frustration: {
                                count: t.eventCounts.frustrationCount
                            },
                            cumulative_layout_shift: null === (s = t.commonViewMetrics.cumulativeLayoutShift) || void 0 === s ? void 0 : s.value,
                            cumulative_layout_shift_time: At(null === (a = t.commonViewMetrics.cumulativeLayoutShift) || void 0 === a ? void 0 : a.time),
                            cumulative_layout_shift_target_selector: null === (o = t.commonViewMetrics.cumulativeLayoutShift) || void 0 === o ? void 0 : o.targetSelector,
                            first_byte: At(null === (l = t.initialViewMetrics.navigationTimings) || void 0 === l ? void 0 : l.firstByte),
                            dom_complete: At(null === (c = t.initialViewMetrics.navigationTimings) || void 0 === c ? void 0 : c.domComplete),
                            dom_content_loaded: At(null === (h = t.initialViewMetrics.navigationTimings) || void 0 === h ? void 0 : h.domContentLoaded),
                            dom_interactive: At(null === (u = t.initialViewMetrics.navigationTimings) || void 0 === u ? void 0 : u.domInteractive),
                            error: {
                                count: t.eventCounts.errorCount
                            },
                            first_contentful_paint: At(t.initialViewMetrics.firstContentfulPaint),
                            first_input_delay: At(null === (d = t.initialViewMetrics.firstInput) || void 0 === d ? void 0 : d.delay),
                            first_input_time: At(null === (p = t.initialViewMetrics.firstInput) || void 0 === p ? void 0 : p.time),
                            first_input_target_selector: null === (f = t.initialViewMetrics.firstInput) || void 0 === f ? void 0 : f.targetSelector,
                            interaction_to_next_paint: At(null === (m = t.commonViewMetrics.interactionToNextPaint) || void 0 === m ? void 0 : m.value),
                            interaction_to_next_paint_time: At(null === (g = t.commonViewMetrics.interactionToNextPaint) || void 0 === g ? void 0 : g.time),
                            interaction_to_next_paint_target_selector: null === (v = t.commonViewMetrics.interactionToNextPaint) || void 0 === v ? void 0 : v.targetSelector,
                            is_active: t.isActive,
                            name: t.name,
                            largest_contentful_paint: At(null === (y = t.initialViewMetrics.largestContentfulPaint) || void 0 === y ? void 0 : y.value),
                            largest_contentful_paint_target_selector: null === (b = t.initialViewMetrics.largestContentfulPaint) || void 0 === b ? void 0 : b.targetSelector,
                            load_event: At(null === (x = t.initialViewMetrics.navigationTimings) || void 0 === x ? void 0 : x.loadEvent),
                            loading_time: mi(At(t.commonViewMetrics.loadingTime)),
                            loading_type: t.loadingType,
                            long_task: {
                                count: t.eventCounts.longTaskCount
                            },
                            resource: {
                                count: t.eventCounts.resourceCount
                            },
                            time_spent: At(t.duration)
                        },
                        feature_flags: w && !B(w) ? w : void 0,
                        display: t.commonViewMetrics.scroll ? {
                            scroll: {
                                max_depth: t.commonViewMetrics.scroll.maxDepth,
                                max_depth_scroll_top: t.commonViewMetrics.scroll.maxDepthScrollTop,
                                max_scroll_height: t.commonViewMetrics.scroll.maxScrollHeight,
                                max_scroll_height_time: At(t.commonViewMetrics.scroll.maxScrollHeightTime)
                            }
                        } : void 0,
                        session: {
                            has_replay: !!_ || void 0,
                            is_active: !!t.sessionIsActive && void 0
                        },
                        privacy: {
                            replay_level: e.defaultPrivacyLevel
                        }
                    };
                B(t.customTimings) || (M.view.custom_timings = function (t, e) {
                    for (var n = {}, i = 0, r = Object.keys(t); i < r.length; i++) {
                        var s = r[i];
                        n[s] = e(t[s])
                    }
                    return n
                }(t.customTimings, At));
                return {
                    rawRumEvent: M,
                    startTime: t.startClocks.relative,
                    domainContext: {
                        location: t.location
                    }
                }
            }(n, e, s, o, a))
        })), ts(n, t, i, e, r, !e.trackViewsManually, l)
    }
    var is = [];

    function rs(t, e, n, i) {
        var r = new Z,
            s = new Z,
            a = Ke(t.sessionStoreStrategyType, e, n);
        is.push((function () {
            return a.stop()
        }));
        var o = ai({
            expireDelay: 144e5
        });

        function l() {
            return {
                id: a.getSession().id,
                trackingType: a.getSession()[e],
                isReplayForced: !!a.getSession().forcedReplay
            }
        }
        return is.push((function () {
            return o.stop()
        })), a.renewObservable.subscribe((function () {
            o.add(l(), Lt()), r.notify()
        })), a.expireObservable.subscribe((function () {
            s.notify(), o.closeActive(Lt())
        })), a.expandOrRenewSession(), o.add(l(), Dt().relative), i.observable.subscribe((function () {
            i.isGranted() ? a.expandOrRenewSession() : a.expire()
        })),
            function (t, e) {
                var n = ee(t, window, ["click", "touchstart", "keydown", "scroll"], e, {
                    capture: !0,
                    passive: !0
                }).stop;
                is.push(n)
            }(t, (function () {
                i.isGranted() && a.expandOrRenewSession()
            })),
            function (t, e) {
                var n = function () {
                    "visible" === document.visibilityState && e()
                },
                    i = te(t, document, "visibilitychange", n).stop;
                is.push(i);
                var r = O(n, 6e4);
                is.push((function () {
                    D(r)
                }))
            }(t, (function () {
                return a.expandSession()
            })),
            function (t, e) {
                var n = te(t, window, "resume", e, {
                    capture: !0
                }).stop;
                is.push(n)
            }(t, (function () {
                return a.restartSession()
            })), {
            findSession: function (t, e) {
                return o.find(t, e)
            },
            renewObservable: r,
            expireObservable: s,
            sessionStateUpdateObservable: a.sessionStateUpdateObservable,
            expire: a.expire,
            updateSessionState: a.updateSessionState
        }
    }

    function ss(t, e, n) {
        var i = rs(t, "rum", (function (e) {
            return function (t, e) {
                var n;
                n = function (t) {
                    return "0" === t || "1" === t || "2" === t
                }(e) ? e : wt(t.sessionSampleRate) ? wt(t.sessionReplaySampleRate) ? "1" : "2" : "0";
                return {
                    trackingType: n,
                    isTracked: as(n)
                }
            }(t, e)
        }), n);
        return i.expireObservable.subscribe((function () {
            e.notify(9)
        })), i.renewObservable.subscribe((function () {
            e.notify(10)
        })), i.sessionStateUpdateObservable.subscribe((function (t) {
            var e = t.previousState,
                n = t.newState;
            if (!e.forcedReplay && n.forcedReplay) {
                var r = i.findSession();
                r && (r.isReplayForced = !0)
            }
        })), {
            findTrackedSession: function (t) {
                var e = i.findSession(t);
                if (e && as(e.trackingType)) return {
                    id: e.id,
                    sessionReplay: "1" === e.trackingType ? 1 : e.isReplayForced ? 2 : 0
                }
            },
            expire: i.expire,
            expireObservable: i.expireObservable,
            setForcedReplay: function () {
                return i.updateSessionState({
                    forcedReplay: "1"
                })
            }
        }
    }

    function as(t) {
        return "2" === t || "1" === t
    }

    function os(t) {
        var e = t.encoder,
            n = t.request,
            i = t.flushController,
            r = t.messageBytesLimit,
            s = {},
            a = i.flushObservable.subscribe((function (t) {
                return function (t) {
                    var i = w(s).join("\n");
                    s = {};
                    var r = wn(t.reason),
                        a = r ? n.sendOnExit : n.send;
                    if (r && e.isAsync) {
                        var o = e.finishSync();
                        o.outputBytesCount && a(ls(o));
                        var l = [o.pendingData, i].filter(Boolean).join("\n");
                        l && a({
                            data: l,
                            bytesCount: A(l)
                        })
                    } else i && e.write(e.isEmpty ? i : "\n".concat(i)), e.finish((function (t) {
                        a(ls(t))
                    }))
                }(t)
            }));

        function l(t, n) {
            var a = N(t),
                l = e.estimateEncodedBytesCount(a);
            l >= r ? o.warn("Discarded a message whose size was bigger than the maximum allowed size ".concat(r, "KB. ").concat("More details:", " ").concat(c, "/#technical-limitations")) : (function (t) {
                return void 0 !== t && void 0 !== s[t]
            }(n) && function (t) {
                var n = s[t];
                delete s[t];
                var r = e.estimateEncodedBytesCount(n);
                i.notifyAfterRemoveMessage(r)
            }(n), function (t, n, r) {
                i.notifyBeforeAddMessage(n), void 0 !== r ? (s[r] = t, i.notifyAfterAddMessage()) : e.write(e.isEmpty ? t : "\n".concat(t), (function (t) {
                    i.notifyAfterAddMessage(t - n)
                }))
            }(a, l, n))
        }
        return {
            flushController: i,
            add: l,
            upsert: l,
            stop: a.unsubscribe
        }
    }

    function ls(t) {
        return {
            data: "string" == typeof t.output ? t.output : new Blob([t.output], {
                type: "text/plain"
            }),
            bytesCount: t.outputBytesCount,
            encoding: t.encoding
        }
    }

    function cs(t, e, n, i, r) {
        0 === e.transportStatus && 0 === e.queuedPayloads.size() && e.bandwidthMonitor.canHandle(t) ? hs(t, e, n, {
            onSuccess: function () {
                return us(0, e, n, i, r)
            },
            onFailure: function () {
                e.queuedPayloads.enqueue(t),
                    function t(e, n, i, r) {
                        if (2 !== e.transportStatus) return;
                        P((function () {
                            hs(e.queuedPayloads.first(), e, n, {
                                onSuccess: function () {
                                    e.queuedPayloads.dequeue(), e.currentBackoffTime = 1e3, us(1, e, n, i, r)
                                },
                                onFailure: function () {
                                    e.currentBackoffTime = Math.min(6e4, 2 * e.currentBackoffTime), t(e, n, i, r)
                                }
                            })
                        }), e.currentBackoffTime)
                    }(e, n, i, r)
            }
        }) : e.queuedPayloads.enqueue(t)
    }

    function hs(t, e, n, i) {
        var r = i.onSuccess,
            s = i.onFailure;
        e.bandwidthMonitor.add(t), n(t, (function (n) {
            e.bandwidthMonitor.remove(t), ! function (t) {
                return "opaque" !== t.type && (0 === t.status && !navigator.onLine || 408 === t.status || 429 === t.status || (e = t.status, e >= 500));
                var e
            }(n) ? (e.transportStatus = 0, r()) : (e.transportStatus = e.bandwidthMonitor.ongoingRequestCount > 0 ? 1 : 2, t.retry = {
                count: t.retry ? t.retry.count + 1 : 1,
                lastFailureStatus: n.status
            }, s())
        }))
    }

    function us(t, e, n, i, r) {
        0 === t && e.queuedPayloads.isFull() && !e.queueFullReported && (r({
            message: "Reached max ".concat(i, " events size queued for upload: ").concat(3, "MiB"),
            source: Hn,
            startClocks: Ot()
        }), e.queueFullReported = !0);
        var s = e.queuedPayloads;
        for (e.queuedPayloads = ds(); s.size() > 0;) cs(s.dequeue(), e, n, i, r)
    }

    function ds() {
        var t = [];
        return {
            bytesCount: 0,
            enqueue: function (e) {
                this.isFull() || (t.push(e), this.bytesCount += e.bytesCount)
            },
            first: function () {
                return t[0]
            },
            dequeue: function () {
                var e = t.shift();
                return e && (this.bytesCount -= e.bytesCount), e
            },
            size: function () {
                return t.length
            },
            isFull: function () {
                return this.bytesCount >= 3145728
            }
        }
    }

    function ps(t, e, n, i) {
        var r = {
            transportStatus: 0,
            currentBackoffTime: 1e3,
            bandwidthMonitor: {
                ongoingRequestCount: 0,
                ongoingByteCount: 0,
                canHandle: function (t) {
                    return 0 === this.ongoingRequestCount || this.ongoingByteCount + t.bytesCount <= 81920 && this.ongoingRequestCount < 32
                },
                add: function (t) {
                    this.ongoingRequestCount += 1, this.ongoingByteCount += t.bytesCount
                },
                remove: function (t) {
                    this.ongoingRequestCount -= 1, this.ongoingByteCount -= t.bytesCount
                }
            },
            queuedPayloads: ds(),
            queueFullReported: !1
        },
            s = function (i, r) {
                return function (t, e, n, i, r) {
                    if (function () {
                        try {
                            return window.Request && "keepalive" in new Request("http://a")
                        } catch (t) {
                            return !1
                        }
                    }() && i.bytesCount < n) {
                        var s = e.build("fetch", i);
                        fetch(s, {
                            method: "POST",
                            body: i.data,
                            keepalive: !0,
                            mode: "cors"
                        }).then(m((function (t) {
                            return null == r ? void 0 : r({
                                status: t.status,
                                type: t.type
                            })
                        })), m((function () {
                            var n = e.build("xhr", i);
                            ms(t, n, i.data, r)
                        })))
                    } else {
                        var a = e.build("xhr", i);
                        ms(t, a, i.data, r)
                    }
                }(t, e, n, i, r)
            };
        return {
            send: function (t) {
                cs(t, r, s, e.trackType, i)
            },
            sendOnExit: function (i) {
                ! function (t, e, n, i) {
                    if (navigator.sendBeacon && i.bytesCount < n) try {
                        var r = e.build("beacon", i);
                        if (navigator.sendBeacon(r, i.data)) return
                    } catch (t) {
                        ! function (t) {
                            fs || (fs = !0, Zt(t))
                        }(t)
                    }
                    var s = e.build("xhr", i);
                    ms(t, s, i.data)
                }(t, e, n, i)
            }
        }
    }
    var fs = !1;

    function ms(t, e, n, i) {
        var r = new XMLHttpRequest;
        r.open("POST", e, !0), n instanceof Blob && r.setRequestHeader("Content-Type", n.type), te(t, r, "loadend", (function () {
            null == i || i({
                status: r.status
            })
        }), {
            once: !0
        }), r.send(n)
    }

    function gs(t) {
        var e, n = t.messagesLimit,
            i = t.bytesLimit,
            r = t.durationLimit,
            s = t.pageExitObservable,
            a = t.sessionExpireObservable,
            o = s.subscribe((function (t) {
                return d(t.reason)
            })),
            l = a.subscribe((function () {
                return d("session_expire")
            })),
            c = new Z((function () {
                return function () {
                    o.unsubscribe(), l.unsubscribe()
                }
            })),
            h = 0,
            u = 0;

        function d(t) {
            if (0 !== u) {
                var e = u,
                    n = h;
                u = 0, h = 0, p(), c.notify({
                    reason: t,
                    messagesCount: e,
                    bytesCount: n
                })
            }
        }

        function p() {
            L(e), e = void 0
        }
        return {
            flushObservable: c,
            get messagesCount() {
                return u
            },
            notifyBeforeAddMessage: function (t) {
                h + t >= i && d("bytes_limit"), u += 1, h += t, void 0 === e && (e = P((function () {
                    d("duration_limit")
                }), r))
            },
            notifyAfterAddMessage: function (t) {
                void 0 === t && (t = 0), h += t, u >= n ? d("messages_limit") : h >= i && d("bytes_limit")
            },
            notifyAfterRemoveMessage: function (t) {
                h -= t, 0 === (u -= 1) && p()
            }
        }
    }

    function vs(t, e, n, i, r, s, a) {
        var o = t.replica,
            l = function (t, e, n, i, r, s, a) {
                void 0 === a && (a = os);
                var o = c(t, e),
                    l = n && c(t, n);

                function c(t, e) {
                    var n = e.endpoint,
                        o = e.encoder;
                    return a({
                        encoder: o,
                        request: ps(t, n, t.batchBytesLimit, i),
                        flushController: gs({
                            messagesLimit: t.batchMessagesLimit,
                            bytesLimit: t.batchBytesLimit,
                            durationLimit: t.flushTimeout,
                            pageExitObservable: r,
                            sessionExpireObservable: s
                        }),
                        messageBytesLimit: t.messageBytesLimit
                    })
                }
                return {
                    flushObservable: o.flushController.flushObservable,
                    add: function (t, e) {
                        void 0 === e && (e = !0), o.add(t), l && e && l.add(n.transformMessage ? n.transformMessage(t) : t)
                    },
                    upsert: function (t, e) {
                        o.upsert(t, e), l && l.upsert(n.transformMessage ? n.transformMessage(t) : t, e)
                    },
                    stop: function () {
                        o.stop(), l && l.stop()
                    }
                }
            }(t, {
                endpoint: t.rumEndpointBuilder,
                encoder: a(2)
            }, o && {
                endpoint: o.rumEndpointBuilder,
                transformMessage: function (t) {
                    return q(t, {
                        application: {
                            id: o.applicationId
                        }
                    })
                },
                encoder: a(3)
            }, i, r, s);
        return e.subscribe(13, (function (t) {
            "view" === t.type ? l.upsert(t, t.view.id) : l.add(t)
        })), n.subscribe((function (e) {
            return l.add(e, function (t) {
                return "datad0g.com" === t.site
            }(t))
        })), l
    }

    function ys(t, e) {
        var n = z(e);
        return new Z((function (i) {
            var r = function (t, e) {
                var n = he(history, "pushState", (function (t) {
                    (0, t.onPostCall)(e)
                })).stop,
                    i = he(history, "replaceState", (function (t) {
                        (0, t.onPostCall)(e)
                    })).stop,
                    r = te(t, window, "popstate", e).stop;
                return {
                    stop: function () {
                        n(), i(), r()
                    }
                }
            }(t, a).stop,
                s = function (t, e) {
                    return te(t, window, "hashchange", e)
                }(t, a).stop;

            function a() {
                if (n.href !== e.href) {
                    var t = z(e);
                    i.notify({
                        newLocation: t,
                        oldLocation: n
                    }), n = t
                }
            }
            return function () {
                r(), s()
            }
        }))
    }
    var bs, xs, _s;

    function ws() {
        0 !== bs.batchCount && (Kt("Customer data measures", bs), Es())
    }

    function Ss(t, e) {
        t.sum += e, t.min = Math.min(t.min, e), t.max = Math.max(t.max, e)
    }

    function Ms(t, e) {
        t.sum += e.sum, t.min = Math.min(t.min, e.min), t.max = Math.max(t.max, e.max)
    }

    function Es() {
        bs = {
            batchCount: 0,
            batchBytesCount: {
                min: 1 / 0,
                max: 0,
                sum: 0
            },
            batchMessagesCount: {
                min: 1 / 0,
                max: 0,
                sum: 0
            },
            globalContextBytes: {
                min: 1 / 0,
                max: 0,
                sum: 0
            },
            userContextBytes: {
                min: 1 / 0,
                max: 0,
                sum: 0
            },
            featureFlagBytes: {
                min: 1 / 0,
                max: 0,
                sum: 0
            }
        }
    }

    function Ts() {
        _s = !1, xs = {
            globalContextBytes: {
                min: 1 / 0,
                max: 0,
                sum: 0
            },
            userContextBytes: {
                min: 1 / 0,
                max: 0,
                sum: 0
            },
            featureFlagBytes: {
                min: 1 / 0,
                max: 0,
                sum: 0
            }
        }
    }

    function Cs(t, e) {
        void 0 === e && (e = 500);
        var n, i = ai({
            expireDelay: 144e5,
            maxEntries: 4e3
        });
        s(As(), Lt());
        var r = ee(t, window, ["pageshow", "focus", "blur", "visibilitychange", "resume", "freeze", "pagehide"], (function (t) {
            s(function (t) {
                if ("freeze" === t.type) return "frozen";
                if ("pagehide" === t.type) return t.persisted ? "frozen" : "terminated";
                return As()
            }(t), t.timeStamp)
        }), {
            capture: !0
        }).stop;

        function s(t, e) {
            void 0 === e && (e = Lt()), t !== n && (n = t, i.closeActive(e), i.add({
                state: n,
                startTime: e
            }, e))
        }
        var a = {
            findAll: function (t, n) {
                var r = i.findAll(t, n);
                if (0 !== r.length) {
                    for (var s = [], a = Math.max(0, r.length - e), o = r.length - 1; o >= a; o--) {
                        var l = r[o],
                            c = It(t, l.startTime);
                        s.push({
                            state: l.state,
                            start: At(c)
                        })
                    }
                    return s
                }
            },
            wasInPageStateAt: function (t, e) {
                return a.wasInPageStateDuringPeriod(t, e, 0)
            },
            wasInPageStateDuringPeriod: function (t, e, n) {
                return i.findAll(e, n).some((function (e) {
                    return e.state === t
                }))
            },
            addPageState: s,
            stop: function () {
                r(), i.stop()
            }
        };
        return a
    }

    function As() {
        return "hidden" === document.visibilityState ? "hidden" : document.hasFocus() ? "active" : "passive"
    }

    function Rs(t, e) {
        var n = window.cookieStore ? function (t) {
            return function (e, n) {
                return te(t, window.cookieStore, "change", (function (t) {
                    var i = x(t.changed, (function (t) {
                        return t.name === e
                    })) || x(t.deleted, (function (t) {
                        return t.name === e
                    }));
                    i && n(i.value)
                })).stop
            }
        }(t) : Ps;
        return new Z((function (t) {
            return n(e, (function (e) {
                return t.notify(e)
            }))
        }))
    }

    function Ps(t, e) {
        var n = we(document.cookie, t),
            i = O((function () {
                var i = we(document.cookie, t);
                i !== n && e(i)
            }), 1e3);
        return function () {
            D(i)
        }
    }

    function Ls(t, e) {
        var n = e.session,
            i = e.viewContext,
            r = e.errorType,
            s = n ? n.id : "no-session-id",
            a = [];
        void 0 !== r && a.push("error-type=".concat(r)), i && (a.push("seed=".concat(i.id)), a.push("from=".concat(i.startClocks.timeStamp)));
        var o, l, c, h = (l = (o = t).site, c = o.subdomain || function (t) {
            switch (t.site) {
                case "datadoghq.com":
                case "datadoghq.eu":
                    return "app";
                case "datad0g.com":
                    return "dd";
                default:
                    return
            }
        }(o), "https://".concat(c ? "".concat(c, ".") : "").concat(l)),
            u = "/rum/replay/sessions/".concat(s);
        return "".concat(h).concat(u, "?").concat(a.join("&"))
    }
    var Os;

    function Ds(t) {
        return Is(t).segments_count
    }

    function Is(t) {
        var e;
        return Os || (Os = new Map), Os.has(t) ? e = Os.get(t) : (e = {
            records_count: 0,
            segments_count: 0,
            segments_total_raw_size: 0
        }, Os.set(t, e), Os.size > 10 && function () {
            if (!Os) return;
            if (Os.keys) Os.delete(Os.keys().next().value);
            else {
                var t = !0;
                Os.forEach((function (e, n) {
                    t && (Os.delete(n), t = !1)
                }))
            }
        }()), e
    }
    var ks = new WeakMap;

    function Ns(t) {
        return ks.has(t)
    }

    function Us(t) {
        return ks.get(t)
    }

    function zs(t, e) {
        var n = t.tagName,
            i = t.value;
        if (ki(t, e)) {
            var r = t.type;
            if ("INPUT" === n && ("button" === r || "submit" === r || "reset" === r)) return i;
            if (!i || "OPTION" === n) return;
            return "***"
        }
        return "OPTION" === n || "SELECT" === n ? t.value : "INPUT" === n || "TEXTAREA" === n ? i : void 0
    }
    var Fs = /url\((?:(')([^']*)'|(")([^"]*)"|([^)]*))\)/gm,
        $s = /^[A-Za-z]+:|^\/\//,
        Bs = /^data:.*,/i;

    function Hs(t, e) {
        return t.replace(Fs, (function (t, n, i, r, s, a) {
            var o = i || s || a;
            if (!e || !o || $s.test(o) || Bs.test(o)) return t;
            var l = n || r || "";
            return "url(".concat(l).concat(function (t, e) {
                try {
                    return pe(t, e).href
                } catch (e) {
                    return t
                }
            }(o, e)).concat(l, ")")
        }))
    }
    var js = /[^a-z1-6-_]/;

    function Vs(t) {
        var e = t.toLowerCase().trim();
        return js.test(e) ? "div" : e
    }

    function Gs(t, e) {
        return "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='".concat(t, "' height='").concat(e, "' style='background-color:silver'%3E%3C/svg%3E")
    }
    var Ws = 2,
        qs = 3,
        Xs = 4,
        Ys = 6,
        Ks = 7,
        Zs = 8,
        Js = 9,
        Qs = 0,
        ta = 1,
        ea = 2,
        na = 3,
        ia = 4,
        ra = 11,
        sa = 0,
        aa = 1,
        oa = 2,
        la = 3,
        ca = 4,
        ha = 5,
        ua = 6,
        da = 7,
        pa = 8,
        fa = 1,
        ma = 2,
        va = 3,
        ya = 4,
        ba = 5,
        xa = 6,
        _a = 7,
        wa = 9,
        Sa = 0,
        Ma = 1;

    function Ea(t) {
        if (void 0 !== t && 0 !== t.length) return t.map((function (t) {
            var e = t.cssRules || t.rules;
            return {
                cssRules: Array.from(e, (function (t) {
                    return t.cssText
                })),
                disabled: t.disabled || void 0,
                media: t.media.length > 0 ? Array.from(t.media) : void 0
            }
        }))
    }

    function Ta(t, e, n, i) {
        if (e === Ri.HIDDEN) return null;
        var r = t.getAttribute(n);
        if (e === Ri.MASK && "data-dd-privacy" !== n && !Ki.includes(n) && n !== i.actionNameAttribute) {
            var s = t.tagName;
            switch (n) {
                case "title":
                case "alt":
                case "placeholder":
                    return "***"
            }
            if ("IMG" === s && ("src" === n || "srcset" === n)) {
                var a = t;
                if (a.naturalWidth > 0) return Gs(a.naturalWidth, a.naturalHeight);
                var o = t.getBoundingClientRect(),
                    l = o.width,
                    c = o.height;
                return l > 0 || c > 0 ? Gs(l, c) : Pi
            }
            if ("SOURCE" === s && ("src" === n || "srcset" === n)) return Pi;
            if ("A" === s && "href" === n) return "***";
            if (r && M(n, "data-")) return "***";
            if ("IFRAME" === s && "srcdoc" === n) return "***"
        }
        return r && "string" == typeof r && kn(r) ? Nn(r) : r
    }

    function Ca(t) {
        if (!t) return null;
        var e;
        try {
            e = t.rules || t.cssRules
        } catch (t) { }
        return e ? Hs(Array.from(e, 2 === Pe() ? Aa : Ra).join(""), t.href) : null
    }

    function Aa(t) {
        if (function (t) {
            return "selectorText" in t
        }(t) && t.selectorText.includes(":")) {
            return t.cssText.replace(/(\[[\w-]+[^\\])(:[^\]]+\])/g, "$1\\$2")
        }
        return Ra(t)
    }

    function Ra(t) {
        return function (t) {
            return "styleSheet" in t
        }(t) && Ca(t.styleSheet) || t.cssText
    }

    function Pa(t, e) {
        var n = function (t, e) {
            switch (t.nodeType) {
                case t.DOCUMENT_NODE:
                    return function (t, e) {
                        return {
                            type: Qs,
                            childNodes: Oa(t, e),
                            adoptedStyleSheets: Ea(t.adoptedStyleSheets)
                        }
                    }(t, e);
                case t.DOCUMENT_FRAGMENT_NODE:
                    return function (t, e) {
                        var n = Ti(t);
                        n && e.serializationContext.shadowRootsController.addShadowRoot(t);
                        return {
                            type: ra,
                            childNodes: Oa(t, e),
                            isShadowRoot: n,
                            adoptedStyleSheets: n ? Ea(t.adoptedStyleSheets) : void 0
                        }
                    }(t, e);
                case t.DOCUMENT_TYPE_NODE:
                    return {
                        type: ta, name: (n = t).name, publicId: n.publicId, systemId: n.systemId
                    };
                case t.ELEMENT_NODE:
                    return function (t, e) {
                        var n, i = Vs(t.tagName),
                            r = (a = t, "svg" === a.tagName || a instanceof SVGElement || void 0),
                            s = Di(Ii(t), e.parentNodePrivacyLevel);
                        var a;
                        if (s === Ri.HIDDEN) {
                            var o = t.getBoundingClientRect(),
                                l = o.width,
                                c = o.height;
                            return {
                                type: ea,
                                tagName: i,
                                attributes: (n = {
                                    rr_width: "".concat(l, "px"),
                                    rr_height: "".concat(c, "px")
                                }, n["data-dd-privacy"] = "hidden", n),
                                childNodes: [],
                                isSVG: r
                            }
                        }
                        if (s === Ri.IGNORE) return;
                        var h = function (t, e, n) {
                            var i;
                            if (e === Ri.HIDDEN) return {};
                            for (var r = {}, s = Vs(t.tagName), a = t.ownerDocument, o = 0; o < t.attributes.length; o += 1) {
                                var l = t.attributes.item(o).name,
                                    c = Ta(t, e, l, n.configuration);
                                null !== c && (r[l] = c)
                            }
                            if (t.value && ("textarea" === s || "select" === s || "option" === s || "input" === s)) {
                                var h = zs(t, e);
                                void 0 !== h && (r.value = h)
                            }
                            if ("option" === s && e === Ri.ALLOW) {
                                var u = t;
                                u.selected && (r.selected = u.selected)
                            }
                            if ("link" === s) {
                                var d, p = Array.from(a.styleSheets).find((function (e) {
                                    return e.href === t.href
                                }));
                                (d = Ca(p)) && p && (r._cssText = d)
                            }
                            "style" === s && t.sheet && (d = Ca(t.sheet)) && (r._cssText = d);
                            var f, m, g = t;
                            if ("input" !== s || "radio" !== g.type && "checkbox" !== g.type || (e === Ri.ALLOW ? r.checked = !!g.checked : ki(g, e) && delete r.checked), "audio" === s || "video" === s) {
                                var v = t;
                                r.rr_mediaState = v.paused ? "paused" : "played"
                            }
                            var y = n.serializationContext;
                            switch (y.status) {
                                case 0:
                                    f = Math.round(t.scrollTop), m = Math.round(t.scrollLeft), (f || m) && y.elementsScrollPositions.set(t, {
                                        scrollTop: f,
                                        scrollLeft: m
                                    });
                                    break;
                                case 1:
                                    y.elementsScrollPositions.has(t) && (f = (i = y.elementsScrollPositions.get(t)).scrollTop, m = i.scrollLeft)
                            }
                            return m && (r.rr_scrollLeft = m), f && (r.rr_scrollTop = f), r
                        }(t, s, e),
                            u = [];
                        if (function (t) {
                            return t.childNodes.length > 0 || Ei(t)
                        }(t) && "style" !== i) {
                            var d = void 0;
                            d = e.parentNodePrivacyLevel === s && e.ignoreWhiteSpace === ("head" === i) ? e : E({}, e, {
                                parentNodePrivacyLevel: s,
                                ignoreWhiteSpace: "head" === i
                            }), u = Oa(t, d)
                        }
                        return {
                            type: ea,
                            tagName: i,
                            attributes: h,
                            childNodes: u,
                            isSVG: r
                        }
                    }(t, e);
                case t.TEXT_NODE:
                    return function (t, e) {
                        var n = Ui(t, e.ignoreWhiteSpace || !1, e.parentNodePrivacyLevel);
                        if (void 0 === n) return;
                        return {
                            type: na,
                            textContent: n
                        }
                    }(t, e);
                case t.CDATA_SECTION_NODE:
                    return {
                        type: ia, textContent: ""
                    }
            }
            var n
        }(t, e);
        if (!n) return null;
        var i = Us(t) || La++,
            r = n;
        return r.id = i,
            function (t, e) {
                ks.set(t, e)
            }(t, i), e.serializedNodeIds && e.serializedNodeIds.add(i), r
    }
    var La = 1;

    function Oa(t, e) {
        var n = [];
        return Ci(t, (function (t) {
            var i = Pa(t, e);
            i && n.push(i)
        })), n
    }

    function Da(t, e, n) {
        return Pa(t, {
            serializationContext: n,
            parentNodePrivacyLevel: e.defaultPrivacyLevel,
            configuration: e
        })
    }

    function Ia(t) {
        return Boolean(t.changedTouches)
    }

    function ka(t) {
        return !0 === t.composed && Ei(t.target) ? t.composedPath()[0] : t.target
    }
    var Na = function (t, e) {
        var n = window.visualViewport,
            i = {
                layoutViewportX: t,
                layoutViewportY: e,
                visualViewportX: t,
                visualViewportY: e
            };
        return n ? (! function (t) {
            return Math.abs(t.pageTop - t.offsetTop - window.scrollY) > 25 || Math.abs(t.pageLeft - t.offsetLeft - window.scrollX) > 25
        }(n) ? (i.visualViewportX = Math.round(t - n.offsetLeft), i.visualViewportY = Math.round(e - n.offsetTop)) : (i.layoutViewportX = Math.round(t + n.offsetLeft), i.layoutViewportY = Math.round(e + n.offsetTop)), i) : i
    },
        Ua = function (t) {
            return {
                scale: t.scale,
                offsetLeft: t.offsetLeft,
                offsetTop: t.offsetTop,
                pageLeft: t.pageLeft,
                pageTop: t.pageTop,
                height: t.height,
                width: t.width
            }
        };

    function za(t, e) {
        return {
            data: E({
                source: t
            }, e),
            type: qs,
            timestamp: Pt()
        }
    }
    var Fa;

    function $a(t, e) {
        var n = I((function (t) {
            var n = ka(t);
            if (Ns(n)) {
                var i = Ba(t);
                if (!i) return;
                var r = {
                    id: Us(n),
                    timeOffset: 0,
                    x: i.x,
                    y: i.y
                };
                e(za(Ia(t) ? ua : aa, {
                    positions: [r]
                }))
            }
        }), 50, {
            trailing: !1
        }),
            i = n.throttled,
            r = n.cancel,
            s = ee(t, document, ["mousemove", "touchmove"], i, {
                capture: !0,
                passive: !0
            }).stop;
        return {
            stop: function () {
                s(), r()
            }
        }
    }

    function Ba(t) {
        var e = Ia(t) ? t.changedTouches[0] : t,
            n = e.clientX,
            i = e.clientY;
        if (window.visualViewport) {
            var r = Na(n, i);
            n = r.visualViewportX, i = r.visualViewportY
        }
        if (Number.isFinite(n) && Number.isFinite(i)) return {
            x: n,
            y: i
        };
        t.isTrusted && Kt("mouse/touch event without x/y")
    }
    var Ha = ((Fa = {}).pointerup = 0, Fa.mousedown = fa, Fa.click = ma, Fa.contextmenu = va, Fa.dblclick = ya, Fa.focus = ba, Fa.blur = xa, Fa.touchstart = _a, Fa.touchend = wa, Fa);

    function ja(t, e, n) {
        return ee(t, document, Object.keys(Ha), (function (i) {
            var r = ka(i);
            if (Oi(r, t.defaultPrivacyLevel) !== Ri.HIDDEN && Ns(r)) {
                var s, a = Us(r),
                    o = Ha[i.type];
                if (o !== xa && o !== ba) {
                    var l = Ba(i);
                    if (!l) return;
                    s = {
                        id: a,
                        type: o,
                        x: l.x,
                        y: l.y
                    }
                } else s = {
                    id: a,
                    type: o
                };
                var c = E({
                    id: n.getIdForEvent(i)
                }, za(oa, s));
                e(c)
            }
        }), {
            capture: !0,
            passive: !0
        })
    }

    function Va(t, e, n, i) {
        void 0 === i && (i = document);
        var r = I((function (i) {
            var r = ka(i);
            if (r && Oi(r, t.defaultPrivacyLevel) !== Ri.HIDDEN && Ns(r)) {
                var s = Us(r),
                    a = r === document ? {
                        scrollTop: Yr(),
                        scrollLeft: Xr()
                    } : {
                        scrollTop: Math.round(r.scrollTop),
                        scrollLeft: Math.round(r.scrollLeft)
                    };
                n.set(r, a), e(za(la, {
                    id: s,
                    x: a.scrollLeft,
                    y: a.scrollTop
                }))
            }
        }), 100),
            s = r.throttled,
            a = r.cancel,
            o = te(t, i, "scroll", s, {
                capture: !0,
                passive: !0
            }).stop;
        return {
            stop: function () {
                o(), a()
            }
        }
    }

    function Ga(t, e) {
        var n = Kr(t).subscribe((function (t) {
            e(za(ca, t))
        }));
        return {
            stop: function () {
                n.unsubscribe()
            }
        }
    }

    function Wa(t, e) {
        var n = window.visualViewport;
        if (!n) return {
            stop: k
        };
        var i = I((function () {
            e({
                data: Ua(n),
                type: Zs,
                timestamp: Pt()
            })
        }), 200, {
            trailing: !1
        }),
            r = i.throttled,
            s = i.cancel,
            a = ee(t, n, ["resize", "scroll"], r, {
                capture: !0,
                passive: !0
            }).stop;
        return {
            stop: function () {
                a(), s()
            }
        }
    }

    function qa(t, e) {
        return ee(t, document, ["play", "pause"], (function (n) {
            var i = ka(n);
            i && Oi(i, t.defaultPrivacyLevel) !== Ri.HIDDEN && Ns(i) && e(za(da, {
                id: Us(i),
                type: "play" === n.type ? Sa : Ma
            }))
        }), {
            capture: !0,
            passive: !0
        })
    }

    function Xa(t) {
        function e(t, e) {
            t && Ns(t.ownerNode) && e(Us(t.ownerNode))
        }
        var n = [he(CSSStyleSheet.prototype, "insertRule", (function (n) {
            var i = n.target,
                r = n.parameters,
                s = r[0],
                a = r[1];
            e(i, (function (e) {
                return t(za(pa, {
                    id: e,
                    adds: [{
                        rule: s,
                        index: a
                    }]
                }))
            }))
        })), he(CSSStyleSheet.prototype, "deleteRule", (function (n) {
            var i = n.target,
                r = n.parameters[0];
            e(i, (function (e) {
                return t(za(pa, {
                    id: e,
                    removes: [{
                        index: r
                    }]
                }))
            }))
        }))];

        function i(i) {
            n.push(he(i.prototype, "insertRule", (function (n) {
                var i = n.target,
                    r = n.parameters,
                    s = r[0],
                    a = r[1];
                e(i.parentStyleSheet, (function (e) {
                    var n = Ya(i);
                    n && (n.push(a || 0), t(za(pa, {
                        id: e,
                        adds: [{
                            rule: s,
                            index: n
                        }]
                    })))
                }))
            })), he(i.prototype, "deleteRule", (function (n) {
                var i = n.target,
                    r = n.parameters[0];
                e(i.parentStyleSheet, (function (e) {
                    var n = Ya(i);
                    n && (n.push(r), t(za(pa, {
                        id: e,
                        removes: [{
                            index: n
                        }]
                    })))
                }))
            })))
        }
        return "undefined" != typeof CSSGroupingRule ? i(CSSGroupingRule) : (i(CSSMediaRule), i(CSSSupportsRule)), {
            stop: function () {
                n.forEach((function (t) {
                    return t.stop()
                }))
            }
        }
    }

    function Ya(t) {
        for (var e = [], n = t; n.parentRule;) {
            var i = Array.from(n.parentRule.cssRules).indexOf(n);
            e.unshift(i), n = n.parentRule
        }
        if (n.parentStyleSheet) {
            var r = Array.from(n.parentStyleSheet.cssRules).indexOf(n);
            return e.unshift(r), e
        }
    }

    function Ka(t, e) {
        return ee(t, window, ["focus", "blur"], (function () {
            e({
                data: {
                    has_focus: document.hasFocus()
                },
                type: Ys,
                timestamp: Pt()
            })
        }))
    }

    function Za(t, e, n) {
        var i = t.subscribe(12, (function (t) {
            var i, r;
            "action" === t.rawRumEvent.type && "click" === t.rawRumEvent.action.type && (null === (r = null === (i = t.rawRumEvent.action.frustration) || void 0 === i ? void 0 : i.type) || void 0 === r ? void 0 : r.length) && "events" in t.domainContext && t.domainContext.events && t.domainContext.events.length && e({
                timestamp: t.rawRumEvent.date,
                type: Js,
                data: {
                    frustrationTypes: t.rawRumEvent.action.frustration.type,
                    recordIds: t.domainContext.events.map((function (t) {
                        return n.getIdForEvent(t)
                    }))
                }
            })
        }));
        return {
            stop: function () {
                i.unsubscribe()
            }
        }
    }

    function Ja(t, e) {
        var n = t.subscribe(5, (function () {
            e({
                timestamp: Pt(),
                type: Ks
            })
        }));
        return {
            stop: function () {
                n.unsubscribe()
            }
        }
    }

    function Qa(t, e, n) {
        void 0 === n && (n = document);
        var i, r = t.defaultPrivacyLevel,
            s = new WeakMap,
            a = n !== document,
            o = ee(t, n, a ? ["change"] : ["input", "change"], (function (t) {
                var e = ka(t);
                (e instanceof HTMLInputElement || e instanceof HTMLTextAreaElement || e instanceof HTMLSelectElement) && c(e)
            }), {
                capture: !0,
                passive: !0
            }).stop;
        if (a) i = k;
        else {
            var l = [ue(HTMLInputElement.prototype, "value", c), ue(HTMLInputElement.prototype, "checked", c), ue(HTMLSelectElement.prototype, "value", c), ue(HTMLTextAreaElement.prototype, "value", c), ue(HTMLSelectElement.prototype, "selectedIndex", c)];
            i = function () {
                l.forEach((function (t) {
                    return t.stop()
                }))
            }
        }
        return {
            stop: function () {
                i(), o()
            }
        };

        function c(t) {
            var e = Oi(t, r);
            if (e !== Ri.HIDDEN) {
                var n, i = t.type;
                if ("radio" === i || "checkbox" === i) {
                    if (ki(t, e)) return;
                    n = {
                        isChecked: t.checked
                    }
                } else {
                    var s = zs(t, e);
                    if (void 0 === s) return;
                    n = {
                        text: s
                    }
                }
                h(t, n);
                var a = t.name;
                "radio" === i && a && t.checked && _(document.querySelectorAll('input[type="radio"][name="'.concat(bi(a), '"]')), (function (e) {
                    e !== t && h(e, {
                        isChecked: !1
                    })
                }))
            }
        }

        function h(t, n) {
            if (Ns(t)) {
                var i = s.get(t);
                i && i.text === n.text && i.isChecked === n.isChecked || (s.set(t, n), e(za(ha, E({
                    id: Us(t)
                }, n))))
            }
        }
    }

    function to(t) {
        var e = k,
            n = [];

        function i() {
            e(), t(n), n = []
        }
        var r = I(i, 16, {
            leading: !1
        }),
            s = r.throttled,
            a = r.cancel;
        return {
            addMutations: function (t) {
                0 === n.length && (e = function (t, e) {
                    if (window.requestIdleCallback && window.cancelIdleCallback) {
                        var n = window.requestIdleCallback(m(t), e);
                        return function () {
                            return window.cancelIdleCallback(n)
                        }
                    }
                    var i = window.requestAnimationFrame(m(t));
                    return function () {
                        return window.cancelAnimationFrame(i)
                    }
                }(s, {
                    timeout: 100
                })), n.push.apply(n, t)
            },
            flush: i,
            stop: function () {
                e(), a()
            }
        }
    }

    function eo(t, e, n, i) {
        var r = Sn();
        if (!r) return {
            stop: k,
            flush: k
        };
        var s = to((function (i) {
            ! function (t, e, n, i) {
                var r = new Map;
                t.filter((function (t) {
                    return "childList" === t.type
                })).forEach((function (t) {
                    t.removedNodes.forEach((function (t) {
                        ! function t(e, n) {
                            Ei(e) && n(e.shadowRoot);
                            Ci(e, (function (e) {
                                return t(e, n)
                            }))
                        }(t, i.removeShadowRoot)
                    }))
                }));
                var s = t.filter((function (t) {
                    return t.target.isConnected && function (t) {
                        for (var e = t; e;) {
                            if (!Ns(e) && !Ti(e)) return !1;
                            e = Ai(e)
                        }
                        return !0
                    }(t.target) && Oi(t.target, n.defaultPrivacyLevel, r) !== Ri.HIDDEN
                })),
                    a = function (t, e, n, i) {
                        for (var r = new Set, s = new Map, a = function (t) {
                            t.addedNodes.forEach((function (t) {
                                r.add(t)
                            })), t.removedNodes.forEach((function (e) {
                                r.has(e) || s.set(e, t.target), r.delete(e)
                            }))
                        }, o = 0, l = t; o < l.length; o++) {
                            var c = l[o];
                            a(c)
                        }
                        var h = Array.from(r);
                        u = h, u.sort((function (t, e) {
                            var n = t.compareDocumentPosition(e);
                            return n & Node.DOCUMENT_POSITION_CONTAINED_BY ? -1 : n & Node.DOCUMENT_POSITION_CONTAINS || n & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : n & Node.DOCUMENT_POSITION_PRECEDING ? -1 : 0
                        }));
                        var u;
                        for (var d = new Set, p = [], f = 0, m = h; f < m.length; f++) {
                            var g = m[f];
                            if (!_(g)) {
                                var v = Oi(g.parentNode, e.defaultPrivacyLevel, i);
                                if (v !== Ri.HIDDEN && v !== Ri.IGNORE) {
                                    var y = Pa(g, {
                                        serializedNodeIds: d,
                                        parentNodePrivacyLevel: v,
                                        serializationContext: {
                                            status: 2,
                                            shadowRootsController: n
                                        },
                                        configuration: e
                                    });
                                    if (y) {
                                        var b = Ai(g);
                                        p.push({
                                            nextId: w(g),
                                            parentId: Us(b),
                                            node: y
                                        })
                                    }
                                }
                            }
                        }
                        var x = [];
                        return s.forEach((function (t, e) {
                            Ns(e) && x.push({
                                parentId: Us(t),
                                id: Us(e)
                            })
                        })), {
                            adds: p,
                            removes: x,
                            hasBeenSerialized: _
                        };

                        function _(t) {
                            return Ns(t) && d.has(Us(t))
                        }

                        function w(t) {
                            for (var e = t.nextSibling; e;) {
                                if (Ns(e)) return Us(e);
                                e = e.nextSibling
                            }
                            return null
                        }
                    }(s.filter((function (t) {
                        return "childList" === t.type
                    })), n, i, r),
                    o = a.adds,
                    l = a.removes,
                    c = a.hasBeenSerialized,
                    h = function (t, e, n) {
                        for (var i, r = [], s = new Set, a = t.filter((function (t) {
                            return !s.has(t.target) && (s.add(t.target), !0)
                        })), o = 0, l = a; o < l.length; o++) {
                            var c = l[o];
                            if (c.target.textContent !== c.oldValue) {
                                var h = Oi(Ai(c.target), e.defaultPrivacyLevel, n);
                                h !== Ri.HIDDEN && h !== Ri.IGNORE && r.push({
                                    id: Us(c.target),
                                    value: null !== (i = Ui(c.target, !1, h)) && void 0 !== i ? i : null
                                })
                            }
                        }
                        return r
                    }(s.filter((function (t) {
                        return "characterData" === t.type && !c(t.target)
                    })), n, r),
                    u = function (t, e, n) {
                        for (var i = [], r = new Map, s = t.filter((function (t) {
                            var e = r.get(t.target);
                            return (!e || !e.has(t.attributeName)) && (e ? e.add(t.attributeName) : r.set(t.target, new Set([t.attributeName])), !0)
                        })), a = new Map, o = 0, l = s; o < l.length; o++) {
                            var c = l[o];
                            if (c.target.getAttribute(c.attributeName) !== c.oldValue) {
                                var h = Oi(c.target, e.defaultPrivacyLevel, n),
                                    u = Ta(c.target, h, c.attributeName, e),
                                    d = void 0;
                                if ("value" === c.attributeName) {
                                    var p = zs(c.target, h);
                                    if (void 0 === p) continue;
                                    d = p
                                } else d = "string" == typeof u ? u : null;
                                var f = a.get(c.target);
                                f || (f = {
                                    id: Us(c.target),
                                    attributes: {}
                                }, i.push(f), a.set(c.target, f)), f.attributes[c.attributeName] = d
                            }
                        }
                        return i
                    }(s.filter((function (t) {
                        return "attributes" === t.type && !c(t.target)
                    })), n, r);
                if (!(h.length || u.length || l.length || o.length)) return;
                e(za(sa, {
                    adds: o,
                    removes: l,
                    texts: h,
                    attributes: u
                }))
            }(i.concat(a.takeRecords()), t, e, n)
        })),
            a = new r(m(s.addMutations));
        return a.observe(i, {
            attributeOldValue: !0,
            attributes: !0,
            characterData: !0,
            characterDataOldValue: !0,
            childList: !0,
            subtree: !0
        }), {
            stop: function () {
                a.disconnect(), s.stop()
            },
            flush: function () {
                s.flush()
            }
        }
    }

    function no(t) {
        var e = t.emit,
            n = t.configuration,
            i = t.lifeCycle;
        if (!e) throw new Error("emit function is required");
        var r, s = function (n) {
            e(n), zt("record", {
                record: n
            });
            var i = t.viewContexts.findView();
            Is(i.id).records_count += 1
        },
            a = (r = new WeakMap, {
                set: function (t, e) {
                    (t !== document || document.scrollingElement) && r.set(t === document ? document.scrollingElement : t, e)
                },
                get: function (t) {
                    return r.get(t)
                },
                has: function (t) {
                    return r.has(t)
                }
            }),
            o = function (t, e, n) {
                var i = new Map,
                    r = {
                        addShadowRoot: function (s) {
                            if (!i.has(s)) {
                                var a = eo(e, t, r, s),
                                    o = Qa(t, e, s),
                                    l = Va(t, e, n, s);
                                i.set(s, {
                                    flush: function () {
                                        return a.flush()
                                    },
                                    stop: function () {
                                        a.stop(), o.stop(), l.stop()
                                    }
                                })
                            }
                        },
                        removeShadowRoot: function (t) {
                            var e = i.get(t);
                            e && (e.stop(), i.delete(t))
                        },
                        stop: function () {
                            i.forEach((function (t) {
                                return (0, t.stop)()
                            }))
                        },
                        flush: function () {
                            i.forEach((function (t) {
                                return (0, t.flush)()
                            }))
                        }
                    };
                return r
            }(n, s, a),
            l = function (t, e, n, i, r, s) {
                var a = function (n, r) {
                    void 0 === n && (n = Pt()), void 0 === r && (r = {
                        status: 0,
                        elementsScrollPositions: t,
                        shadowRootsController: e
                    });
                    var s = Zr(),
                        a = s.width,
                        o = [{
                            data: {
                                height: s.height,
                                href: window.location.href,
                                width: a
                            },
                            type: Xs,
                            timestamp: n
                        }, {
                            data: {
                                has_focus: document.hasFocus()
                            },
                            type: Ys,
                            timestamp: n
                        }, {
                            data: {
                                node: Da(document, i, r),
                                initialOffset: {
                                    left: Xr(),
                                    top: Yr()
                                }
                            },
                            type: Ws,
                            timestamp: n
                        }];
                    return window.visualViewport && o.push({
                        data: Ua(window.visualViewport),
                        type: Zs,
                        timestamp: n
                    }), o
                };
                return s(a()), {
                    stop: n.subscribe(3, (function (n) {
                        r(), s(a(n.startClocks.timeStamp, {
                            shadowRootsController: e,
                            status: 1,
                            elementsScrollPositions: t
                        }))
                    })).unsubscribe
                }
            }(a, o, i, n, c, (function (t) {
                return t.forEach((function (t) {
                    return s(t)
                }))
            })).stop;

        function c() {
            o.flush(), u.flush()
        }
        var h = function () {
            var t = new WeakMap,
                e = 1;
            return {
                getIdForEvent: function (n) {
                    return t.has(n) || t.set(n, e++), t.get(n)
                }
            }
        }(),
            u = eo(s, n, o, document),
            d = [u, $a(n, s), ja(n, s, h), Va(n, s, a, document), Ga(n, s), Qa(n, s), qa(n, s), Xa(s), Ka(n, s), Wa(n, s), Za(i, s, h), Ja(i, (function (t) {
                c(), s(t)
            }))];
        return {
            stop: function () {
                o.stop(), d.forEach((function (t) {
                    return t.stop()
                })), l()
            },
            flushMutations: c,
            shadowRootsController: o
        }
    }

    function io(t) {
        var e = t.context,
            n = t.creationReason,
            i = t.encoder,
            r = 0,
            s = e.view.id,
            a = E({
                start: 1 / 0,
                end: -1 / 0,
                creation_reason: n,
                records_count: 0,
                has_full_snapshot: !1,
                index_in_view: Ds(s),
                source: "browser"
            }, e);
        return function (t) {
            Is(t).segments_count += 1
        }(s), {
            addRecord: function (t, e) {
                a.start = Math.min(a.start, t.timestamp), a.end = Math.max(a.end, t.timestamp), a.records_count += 1, a.has_full_snapshot || (a.has_full_snapshot = t.type === Ws);
                var n = i.isEmpty ? '{"records":[' : ",";
                i.write(n + JSON.stringify(t), (function (t) {
                    e(r += t)
                }))
            },
            flush: function (t) {
                if (i.isEmpty) throw new Error("Empty segment flushed");
                i.write("],".concat(JSON.stringify(a).slice(1), "\n")), i.finish((function (e) {
                    ! function (t, e) {
                        Is(t).segments_total_raw_size += e
                    }(a.view.id, e.rawBytesCount), t(a, e)
                }))
            }
        }
    }
    var ro = 6e4;

    function so(t, e, n, i, r, s) {
        return function (t, e, n, i) {
            var r = {
                status: 0,
                nextSegmentCreationReason: "init"
            },
                s = t.subscribe(3, (function () {
                    o("view_change")
                })).unsubscribe,
                a = t.subscribe(11, (function (t) {
                    o(t.reason)
                })).unsubscribe;

            function o(t) {
                1 === r.status && (r.segment.flush((function (e, i) {
                    var r = function (t, e, n) {
                        var i = new FormData;
                        i.append("segment", new Blob([t], {
                            type: "application/octet-stream"
                        }), "".concat(e.session.id, "-").concat(e.start));
                        var r = E({
                            raw_segment_size: n,
                            compressed_segment_size: t.byteLength
                        }, e),
                            s = JSON.stringify(r);
                        return i.append("event", new Blob([s], {
                            type: "application/json"
                        })), {
                            data: i,
                            bytesCount: t.byteLength
                        }
                    }(i.output, e, i.rawBytesCount);
                    wn(t) ? n.sendOnExit(r) : n.send(r)
                })), L(r.expirationTimeoutId)), r = "stop" !== t ? {
                    status: 0,
                    nextSegmentCreationReason: t
                } : {
                    status: 2
                }
            }
            return {
                addRecord: function (t) {
                    if (2 !== r.status) {
                        if (0 === r.status) {
                            var n = e();
                            if (!n) return;
                            r = {
                                status: 1,
                                segment: io({
                                    encoder: i,
                                    context: n,
                                    creationReason: r.nextSegmentCreationReason
                                }),
                                expirationTimeoutId: P((function () {
                                    o("segment_duration_limit")
                                }), 3e4)
                            }
                        }
                        r.segment.addRecord(t, (function (t) {
                            t > ro && o("segment_bytes_limit")
                        }))
                    }
                },
                stop: function () {
                    o("stop"), s(), a()
                }
            }
        }(t, (function () {
            return function (t, e, n) {
                var i = e.findTrackedSession(),
                    r = n.findView();
                if (!i || !r) return;
                return {
                    application: {
                        id: t
                    },
                    session: {
                        id: i.id
                    },
                    view: {
                        id: r.id
                    }
                }
            }(e.applicationId, n, i)
        }), r, s)
    }

    function ao() {
        return "function" == typeof Array.from && "function" == typeof CSSSupportsRule && "function" == typeof URL.createObjectURL && "forEach" in NodeList.prototype
    }

    function oo(t, e, n, i) {
        var r = e.findTrackedSession(),
            s = function (t, e) {
                if (!ao()) return "browser-not-supported";
                if (!t) return "rum-not-tracked";
                if (0 === t.sessionReplay) return "incorrect-session-plan";
                if (!e) return "replay-not-started"
            }(r, i);
        return Ls(t, {
            viewContext: n.findView(),
            errorType: s,
            session: r
        })
    }

    function lo(t, e, n) {
        var i, r = 0,
            s = [],
            a = 0,
            o = [],
            l = te(t, e, "message", (function (t) {
                var e = t.data;
                if ("wrote" === e.type && e.streamId === n) {
                    r += e.additionalBytesCount, s.push(e.result), i = e.trailer;
                    var a = o.shift();
                    a && a.id === e.id ? a.writeCallback ? a.writeCallback(e.result.byteLength) : a.finishCallback && a.finishCallback() : (l(), Kt("Worker responses received out of order."))
                }
            })).stop;

        function c() {
            var t = 0 === s.length ? new Uint8Array(0) : function (t) {
                for (var e = t.reduce((function (t, e) {
                    return t + e.length
                }), 0), n = new Uint8Array(e), i = 0, r = 0, s = t; r < s.length; r++) {
                    var a = s[r];
                    n.set(a, i), i += a.length
                }
                return n
            }(s.concat(i)),
                e = {
                    rawBytesCount: r,
                    output: t,
                    outputBytesCount: t.byteLength,
                    encoding: "deflate"
                };
            return r = 0, s = [], e
        }

        function h() {
            a > 0 && (e.postMessage({
                action: "reset",
                streamId: n
            }), a = 0)
        }
        return {
            isAsync: !0,
            get isEmpty() {
                return 0 === a
            },
            write: function (t, i) {
                e.postMessage({
                    action: "write",
                    id: a,
                    data: t,
                    streamId: n
                }), o.push({
                    id: a,
                    writeCallback: i,
                    data: t
                }), a += 1
            },
            finish: function (t) {
                h(), o.length ? (o.forEach((function (t) {
                    delete t.writeCallback
                })), o[o.length - 1].finishCallback = function () {
                    return t(c())
                }) : t(c())
            },
            finishSync: function () {
                h();
                var t = o.map((function (t) {
                    return delete t.writeCallback, delete t.finishCallback, t.data
                })).join("");
                return E(c(), {
                    pendingData: t
                })
            },
            estimateEncodedBytesCount: function (t) {
                return t.length / 8
            },
            stop: function () {
                l()
            }
        }
    }

    function co(t) {
        return new Worker(t.workerUrl || URL.createObjectURL(new Blob(['!function(){"use strict";function t(t){for(var e=t.reduce((function(t,e){return t+e.length}),0),a=new Uint8Array(e),n=0,r=0,i=t;r<i.length;r++){var s=i[r];a.set(s,n),n+=s.length}return a}function e(t){for(var e=t.length;--e>=0;)t[e]=0}var a=256,n=286,r=30,i=15,s=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),_=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),h=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),l=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),o=new Array(576);e(o);var d=new Array(60);e(d);var u=new Array(512);e(u);var f=new Array(256);e(f);var c=new Array(29);e(c);var p,g,w,v=new Array(r);function b(t,e,a,n,r){this.static_tree=t,this.extra_bits=e,this.extra_base=a,this.elems=n,this.max_length=r,this.has_stree=t&&t.length}function m(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}e(v);var y=function(t){return t<256?u[t]:u[256+(t>>>7)]},k=function(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255},z=function(t,e,a){t.bi_valid>16-a?(t.bi_buf|=e<<t.bi_valid&65535,k(t,t.bi_buf),t.bi_buf=e>>16-t.bi_valid,t.bi_valid+=a-16):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=a)},x=function(t,e,a){z(t,a[2*e],a[2*e+1])},A=function(t,e){var a=0;do{a|=1&t,t>>>=1,a<<=1}while(--e>0);return a>>>1},E=function(t,e,a){var n,r,s=new Array(16),_=0;for(n=1;n<=i;n++)s[n]=_=_+a[n-1]<<1;for(r=0;r<=e;r++){var h=t[2*r+1];0!==h&&(t[2*r]=A(s[h]++,h))}},Z=function(t){var e;for(e=0;e<n;e++)t.dyn_ltree[2*e]=0;for(e=0;e<r;e++)t.dyn_dtree[2*e]=0;for(e=0;e<19;e++)t.bl_tree[2*e]=0;t.dyn_ltree[512]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0},U=function(t){t.bi_valid>8?k(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0},S=function(t,e,a,n){var r=2*e,i=2*a;return t[r]<t[i]||t[r]===t[i]&&n[e]<=n[a]},R=function(t,e,a){for(var n=t.heap[a],r=a<<1;r<=t.heap_len&&(r<t.heap_len&&S(e,t.heap[r+1],t.heap[r],t.depth)&&r++,!S(e,n,t.heap[r],t.depth));)t.heap[a]=t.heap[r],a=r,r<<=1;t.heap[a]=n},L=function(t,e,n){var r,i,h,l,o=0;if(0!==t.last_lit)do{r=t.pending_buf[t.d_buf+2*o]<<8|t.pending_buf[t.d_buf+2*o+1],i=t.pending_buf[t.l_buf+o],o++,0===r?x(t,i,e):(h=f[i],x(t,h+a+1,e),0!==(l=s[h])&&(i-=c[h],z(t,i,l)),r--,h=y(r),x(t,h,n),0!==(l=_[h])&&(r-=v[h],z(t,r,l)))}while(o<t.last_lit);x(t,256,e)},F=function(t,e){var a,n,r,s=e.dyn_tree,_=e.stat_desc.static_tree,h=e.stat_desc.has_stree,l=e.stat_desc.elems,o=-1;for(t.heap_len=0,t.heap_max=573,a=0;a<l;a++)0!==s[2*a]?(t.heap[++t.heap_len]=o=a,t.depth[a]=0):s[2*a+1]=0;for(;t.heap_len<2;)s[2*(r=t.heap[++t.heap_len]=o<2?++o:0)]=1,t.depth[r]=0,t.opt_len--,h&&(t.static_len-=_[2*r+1]);for(e.max_code=o,a=t.heap_len>>1;a>=1;a--)R(t,s,a);r=l;do{a=t.heap[1],t.heap[1]=t.heap[t.heap_len--],R(t,s,1),n=t.heap[1],t.heap[--t.heap_max]=a,t.heap[--t.heap_max]=n,s[2*r]=s[2*a]+s[2*n],t.depth[r]=(t.depth[a]>=t.depth[n]?t.depth[a]:t.depth[n])+1,s[2*a+1]=s[2*n+1]=r,t.heap[1]=r++,R(t,s,1)}while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],function(t,e){var a,n,r,s,_,h,l=e.dyn_tree,o=e.max_code,d=e.stat_desc.static_tree,u=e.stat_desc.has_stree,f=e.stat_desc.extra_bits,c=e.stat_desc.extra_base,p=e.stat_desc.max_length,g=0;for(s=0;s<=i;s++)t.bl_count[s]=0;for(l[2*t.heap[t.heap_max]+1]=0,a=t.heap_max+1;a<573;a++)(s=l[2*l[2*(n=t.heap[a])+1]+1]+1)>p&&(s=p,g++),l[2*n+1]=s,n>o||(t.bl_count[s]++,_=0,n>=c&&(_=f[n-c]),h=l[2*n],t.opt_len+=h*(s+_),u&&(t.static_len+=h*(d[2*n+1]+_)));if(0!==g){do{for(s=p-1;0===t.bl_count[s];)s--;t.bl_count[s]--,t.bl_count[s+1]+=2,t.bl_count[p]--,g-=2}while(g>0);for(s=p;0!==s;s--)for(n=t.bl_count[s];0!==n;)(r=t.heap[--a])>o||(l[2*r+1]!==s&&(t.opt_len+=(s-l[2*r+1])*l[2*r],l[2*r+1]=s),n--)}}(t,e),E(s,o,t.bl_count)},T=function(t,e,a){var n,r,i=-1,s=e[1],_=0,h=7,l=4;for(0===s&&(h=138,l=3),e[2*(a+1)+1]=65535,n=0;n<=a;n++)r=s,s=e[2*(n+1)+1],++_<h&&r===s||(_<l?t.bl_tree[2*r]+=_:0!==r?(r!==i&&t.bl_tree[2*r]++,t.bl_tree[32]++):_<=10?t.bl_tree[34]++:t.bl_tree[36]++,_=0,i=r,0===s?(h=138,l=3):r===s?(h=6,l=3):(h=7,l=4))},I=function(t,e,a){var n,r,i=-1,s=e[1],_=0,h=7,l=4;for(0===s&&(h=138,l=3),n=0;n<=a;n++)if(r=s,s=e[2*(n+1)+1],!(++_<h&&r===s)){if(_<l)do{x(t,r,t.bl_tree)}while(0!=--_);else 0!==r?(r!==i&&(x(t,r,t.bl_tree),_--),x(t,16,t.bl_tree),z(t,_-3,2)):_<=10?(x(t,17,t.bl_tree),z(t,_-3,3)):(x(t,18,t.bl_tree),z(t,_-11,7));_=0,i=r,0===s?(h=138,l=3):r===s?(h=6,l=3):(h=7,l=4)}},N=!1,O=function(t,e,a,n){z(t,0+(n?1:0),3),function(t,e,a,n){U(t),n&&(k(t,a),k(t,~a)),t.pending_buf.set(t.window.subarray(e,e+a),t.pending),t.pending+=a}(t,e,a,!0)},D=function(t,e,n,r){var i,s,_=0;t.level>0?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,n=4093624447;for(e=0;e<=31;e++,n>>>=1)if(1&n&&0!==t.dyn_ltree[2*e])return 0;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return 1;for(e=32;e<a;e++)if(0!==t.dyn_ltree[2*e])return 1;return 0}(t)),F(t,t.l_desc),F(t,t.d_desc),_=function(t){var e;for(T(t,t.dyn_ltree,t.l_desc.max_code),T(t,t.dyn_dtree,t.d_desc.max_code),F(t,t.bl_desc),e=18;e>=3&&0===t.bl_tree[2*l[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),i=t.opt_len+3+7>>>3,(s=t.static_len+3+7>>>3)<=i&&(i=s)):i=s=n+5,n+4<=i&&-1!==e?O(t,e,n,r):4===t.strategy||s===i?(z(t,2+(r?1:0),3),L(t,o,d)):(z(t,4+(r?1:0),3),function(t,e,a,n){var r;for(z(t,e-257,5),z(t,a-1,5),z(t,n-4,4),r=0;r<n;r++)z(t,t.bl_tree[2*l[r]+1],3);I(t,t.dyn_ltree,e-1),I(t,t.dyn_dtree,a-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,_+1),L(t,t.dyn_ltree,t.dyn_dtree)),Z(t),r&&U(t)},B={_tr_init:function(t){N||(!function(){var t,e,a,l,m,y=new Array(16);for(a=0,l=0;l<28;l++)for(c[l]=a,t=0;t<1<<s[l];t++)f[a++]=l;for(f[a-1]=l,m=0,l=0;l<16;l++)for(v[l]=m,t=0;t<1<<_[l];t++)u[m++]=l;for(m>>=7;l<r;l++)for(v[l]=m<<7,t=0;t<1<<_[l]-7;t++)u[256+m++]=l;for(e=0;e<=i;e++)y[e]=0;for(t=0;t<=143;)o[2*t+1]=8,t++,y[8]++;for(;t<=255;)o[2*t+1]=9,t++,y[9]++;for(;t<=279;)o[2*t+1]=7,t++,y[7]++;for(;t<=287;)o[2*t+1]=8,t++,y[8]++;for(E(o,287,y),t=0;t<r;t++)d[2*t+1]=5,d[2*t]=A(t,5);p=new b(o,s,257,n,i),g=new b(d,_,0,r,i),w=new b(new Array(0),h,0,19,7)}(),N=!0),t.l_desc=new m(t.dyn_ltree,p),t.d_desc=new m(t.dyn_dtree,g),t.bl_desc=new m(t.bl_tree,w),t.bi_buf=0,t.bi_valid=0,Z(t)},_tr_stored_block:O,_tr_flush_block:D,_tr_tally:function(t,e,n){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&n,t.last_lit++,0===e?t.dyn_ltree[2*n]++:(t.matches++,e--,t.dyn_ltree[2*(f[n]+a+1)]++,t.dyn_dtree[2*y(e)]++),t.last_lit===t.lit_bufsize-1},_tr_align:function(t){z(t,2,3),x(t,256,o),function(t){16===t.bi_valid?(k(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},C=function(t,e,a,n){for(var r=65535&t|0,i=t>>>16&65535|0,s=0;0!==a;){a-=s=a>2e3?2e3:a;do{i=i+(r=r+e[n++]|0)|0}while(--s);r%=65521,i%=65521}return r|i<<16|0},H=new Uint32Array(function(){for(var t,e=[],a=0;a<256;a++){t=a;for(var n=0;n<8;n++)t=1&t?3988292384^t>>>1:t>>>1;e[a]=t}return e}()),M=function(t,e,a,n){var r=H,i=n+a;t^=-1;for(var s=n;s<i;s++)t=t>>>8^r[255&(t^e[s])];return-1^t},Y={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},K={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},P=B._tr_init,j=B._tr_stored_block,G=B._tr_flush_block,X=B._tr_tally,W=B._tr_align,q=K.Z_NO_FLUSH,J=K.Z_PARTIAL_FLUSH,Q=K.Z_FULL_FLUSH,V=K.Z_FINISH,$=K.Z_BLOCK,tt=K.Z_OK,et=K.Z_STREAM_END,at=K.Z_STREAM_ERROR,nt=K.Z_DATA_ERROR,rt=K.Z_BUF_ERROR,it=K.Z_DEFAULT_COMPRESSION,st=K.Z_FILTERED,_t=K.Z_HUFFMAN_ONLY,ht=K.Z_RLE,lt=K.Z_FIXED,ot=K.Z_DEFAULT_STRATEGY,dt=K.Z_UNKNOWN,ut=K.Z_DEFLATED,ft=258,ct=262,pt=103,gt=113,wt=666,vt=function(t,e){return t.msg=Y[e],e},bt=function(t){return(t<<1)-(t>4?9:0)},mt=function(t){for(var e=t.length;--e>=0;)t[e]=0},yt=function(t,e,a){return(e<<t.hash_shift^a)&t.hash_mask},kt=function(t){var e=t.state,a=e.pending;a>t.avail_out&&(a=t.avail_out),0!==a&&(t.output.set(e.pending_buf.subarray(e.pending_out,e.pending_out+a),t.next_out),t.next_out+=a,e.pending_out+=a,t.total_out+=a,t.avail_out-=a,e.pending-=a,0===e.pending&&(e.pending_out=0))},zt=function(t,e){G(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,kt(t.strm)},xt=function(t,e){t.pending_buf[t.pending++]=e},At=function(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e},Et=function(t,e){var a,n,r=t.max_chain_length,i=t.strstart,s=t.prev_length,_=t.nice_match,h=t.strstart>t.w_size-ct?t.strstart-(t.w_size-ct):0,l=t.window,o=t.w_mask,d=t.prev,u=t.strstart+ft,f=l[i+s-1],c=l[i+s];t.prev_length>=t.good_match&&(r>>=2),_>t.lookahead&&(_=t.lookahead);do{if(l[(a=e)+s]===c&&l[a+s-1]===f&&l[a]===l[i]&&l[++a]===l[i+1]){i+=2,a++;do{}while(l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&l[++i]===l[++a]&&i<u);if(n=ft-(u-i),i=u-ft,n>s){if(t.match_start=e,s=n,n>=_)break;f=l[i+s-1],c=l[i+s]}}}while((e=d[e&o])>h&&0!=--r);return s<=t.lookahead?s:t.lookahead},Zt=function(t){var e,a,n,r,i,s,_,h,l,o,d=t.w_size;do{if(r=t.window_size-t.lookahead-t.strstart,t.strstart>=d+(d-ct)){t.window.set(t.window.subarray(d,d+d),0),t.match_start-=d,t.strstart-=d,t.block_start-=d,e=a=t.hash_size;do{n=t.head[--e],t.head[e]=n>=d?n-d:0}while(--a);e=a=d;do{n=t.prev[--e],t.prev[e]=n>=d?n-d:0}while(--a);r+=d}if(0===t.strm.avail_in)break;if(s=t.strm,_=t.window,h=t.strstart+t.lookahead,l=r,o=void 0,(o=s.avail_in)>l&&(o=l),a=0===o?0:(s.avail_in-=o,_.set(s.input.subarray(s.next_in,s.next_in+o),h),1===s.state.wrap?s.adler=C(s.adler,_,o,h):2===s.state.wrap&&(s.adler=M(s.adler,_,o,h)),s.next_in+=o,s.total_in+=o,o),t.lookahead+=a,t.lookahead+t.insert>=3)for(i=t.strstart-t.insert,t.ins_h=t.window[i],t.ins_h=yt(t,t.ins_h,t.window[i+1]);t.insert&&(t.ins_h=yt(t,t.ins_h,t.window[i+3-1]),t.prev[i&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=i,i++,t.insert--,!(t.lookahead+t.insert<3)););}while(t.lookahead<ct&&0!==t.strm.avail_in)},Ut=function(t,e){for(var a,n;;){if(t.lookahead<ct){if(Zt(t),t.lookahead<ct&&e===q)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==a&&t.strstart-a<=t.w_size-ct&&(t.match_length=Et(t,a)),t.match_length>=3)if(n=X(t,t.strstart-t.match_start,t.match_length-3),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=3){t.match_length--;do{t.strstart++,t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart}while(0!=--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=yt(t,t.ins_h,t.window[t.strstart+1]);else n=X(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(n&&(zt(t,!1),0===t.strm.avail_out))return 1}return t.insert=t.strstart<2?t.strstart:2,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(zt(t,!1),0===t.strm.avail_out)?1:2},St=function(t,e){for(var a,n,r;;){if(t.lookahead<ct){if(Zt(t),t.lookahead<ct&&e===q)return 1;if(0===t.lookahead)break}if(a=0,t.lookahead>=3&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=2,0!==a&&t.prev_length<t.max_lazy_match&&t.strstart-a<=t.w_size-ct&&(t.match_length=Et(t,a),t.match_length<=5&&(t.strategy===st||3===t.match_length&&t.strstart-t.match_start>4096)&&(t.match_length=2)),t.prev_length>=3&&t.match_length<=t.prev_length){r=t.strstart+t.lookahead-3,n=X(t,t.strstart-1-t.prev_match,t.prev_length-3),t.lookahead-=t.prev_length-1,t.prev_length-=2;do{++t.strstart<=r&&(t.ins_h=yt(t,t.ins_h,t.window[t.strstart+3-1]),a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart)}while(0!=--t.prev_length);if(t.match_available=0,t.match_length=2,t.strstart++,n&&(zt(t,!1),0===t.strm.avail_out))return 1}else if(t.match_available){if((n=X(t,0,t.window[t.strstart-1]))&&zt(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return 1}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(n=X(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<2?t.strstart:2,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(zt(t,!1),0===t.strm.avail_out)?1:2};function Rt(t,e,a,n,r){this.good_length=t,this.max_lazy=e,this.nice_length=a,this.max_chain=n,this.func=r}var Lt=[new Rt(0,0,0,0,(function(t,e){var a=65535;for(a>t.pending_buf_size-5&&(a=t.pending_buf_size-5);;){if(t.lookahead<=1){if(Zt(t),0===t.lookahead&&e===q)return 1;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var n=t.block_start+a;if((0===t.strstart||t.strstart>=n)&&(t.lookahead=t.strstart-n,t.strstart=n,zt(t,!1),0===t.strm.avail_out))return 1;if(t.strstart-t.block_start>=t.w_size-ct&&(zt(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):(t.strstart>t.block_start&&(zt(t,!1),t.strm.avail_out),1)})),new Rt(4,4,8,4,Ut),new Rt(4,5,16,8,Ut),new Rt(4,6,32,32,Ut),new Rt(4,4,16,16,St),new Rt(8,16,32,32,St),new Rt(8,16,128,128,St),new Rt(8,32,128,256,St),new Rt(32,128,258,1024,St),new Rt(32,258,258,4096,St)];function Ft(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=ut,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),mt(this.dyn_ltree),mt(this.dyn_dtree),mt(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),mt(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),mt(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}var Tt=function(t){if(!t||!t.state)return vt(t,at);t.total_in=t.total_out=0,t.data_type=dt;var e=t.state;return e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?42:gt,t.adler=2===e.wrap?0:1,e.last_flush=q,P(e),tt},It=function(t){var e,a=Tt(t);return a===tt&&((e=t.state).window_size=2*e.w_size,mt(e.head),e.max_lazy_match=Lt[e.level].max_lazy,e.good_match=Lt[e.level].good_length,e.nice_match=Lt[e.level].nice_length,e.max_chain_length=Lt[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=2,e.match_available=0,e.ins_h=0),a},Nt=function(t,e,a,n,r,i){if(!t)return at;var s=1;if(e===it&&(e=6),n<0?(s=0,n=-n):n>15&&(s=2,n-=16),r<1||r>9||a!==ut||n<8||n>15||e<0||e>9||i<0||i>lt)return vt(t,at);8===n&&(n=9);var _=new Ft;return t.state=_,_.strm=t,_.wrap=s,_.gzhead=null,_.w_bits=n,_.w_size=1<<_.w_bits,_.w_mask=_.w_size-1,_.hash_bits=r+7,_.hash_size=1<<_.hash_bits,_.hash_mask=_.hash_size-1,_.hash_shift=~~((_.hash_bits+3-1)/3),_.window=new Uint8Array(2*_.w_size),_.head=new Uint16Array(_.hash_size),_.prev=new Uint16Array(_.w_size),_.lit_bufsize=1<<r+6,_.pending_buf_size=4*_.lit_bufsize,_.pending_buf=new Uint8Array(_.pending_buf_size),_.d_buf=1*_.lit_bufsize,_.l_buf=3*_.lit_bufsize,_.level=e,_.strategy=i,_.method=a,It(t)},Ot={deflateInit:function(t,e){return Nt(t,e,ut,15,8,ot)},deflateInit2:Nt,deflateReset:It,deflateResetKeep:Tt,deflateSetHeader:function(t,e){return t&&t.state?2!==t.state.wrap?at:(t.state.gzhead=e,tt):at},deflate:function(t,e){var a,n;if(!t||!t.state||e>$||e<0)return t?vt(t,at):at;var r=t.state;if(!t.output||!t.input&&0!==t.avail_in||r.status===wt&&e!==V)return vt(t,0===t.avail_out?rt:at);r.strm=t;var i=r.last_flush;if(r.last_flush=e,42===r.status)if(2===r.wrap)t.adler=0,xt(r,31),xt(r,139),xt(r,8),r.gzhead?(xt(r,(r.gzhead.text?1:0)+(r.gzhead.hcrc?2:0)+(r.gzhead.extra?4:0)+(r.gzhead.name?8:0)+(r.gzhead.comment?16:0)),xt(r,255&r.gzhead.time),xt(r,r.gzhead.time>>8&255),xt(r,r.gzhead.time>>16&255),xt(r,r.gzhead.time>>24&255),xt(r,9===r.level?2:r.strategy>=_t||r.level<2?4:0),xt(r,255&r.gzhead.os),r.gzhead.extra&&r.gzhead.extra.length&&(xt(r,255&r.gzhead.extra.length),xt(r,r.gzhead.extra.length>>8&255)),r.gzhead.hcrc&&(t.adler=M(t.adler,r.pending_buf,r.pending,0)),r.gzindex=0,r.status=69):(xt(r,0),xt(r,0),xt(r,0),xt(r,0),xt(r,0),xt(r,9===r.level?2:r.strategy>=_t||r.level<2?4:0),xt(r,3),r.status=gt);else{var s=ut+(r.w_bits-8<<4)<<8;s|=(r.strategy>=_t||r.level<2?0:r.level<6?1:6===r.level?2:3)<<6,0!==r.strstart&&(s|=32),s+=31-s%31,r.status=gt,At(r,s),0!==r.strstart&&(At(r,t.adler>>>16),At(r,65535&t.adler)),t.adler=1}if(69===r.status)if(r.gzhead.extra){for(a=r.pending;r.gzindex<(65535&r.gzhead.extra.length)&&(r.pending!==r.pending_buf_size||(r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),kt(t),a=r.pending,r.pending!==r.pending_buf_size));)xt(r,255&r.gzhead.extra[r.gzindex]),r.gzindex++;r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),r.gzindex===r.gzhead.extra.length&&(r.gzindex=0,r.status=73)}else r.status=73;if(73===r.status)if(r.gzhead.name){a=r.pending;do{if(r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),kt(t),a=r.pending,r.pending===r.pending_buf_size)){n=1;break}n=r.gzindex<r.gzhead.name.length?255&r.gzhead.name.charCodeAt(r.gzindex++):0,xt(r,n)}while(0!==n);r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),0===n&&(r.gzindex=0,r.status=91)}else r.status=91;if(91===r.status)if(r.gzhead.comment){a=r.pending;do{if(r.pending===r.pending_buf_size&&(r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),kt(t),a=r.pending,r.pending===r.pending_buf_size)){n=1;break}n=r.gzindex<r.gzhead.comment.length?255&r.gzhead.comment.charCodeAt(r.gzindex++):0,xt(r,n)}while(0!==n);r.gzhead.hcrc&&r.pending>a&&(t.adler=M(t.adler,r.pending_buf,r.pending-a,a)),0===n&&(r.status=pt)}else r.status=pt;if(r.status===pt&&(r.gzhead.hcrc?(r.pending+2>r.pending_buf_size&&kt(t),r.pending+2<=r.pending_buf_size&&(xt(r,255&t.adler),xt(r,t.adler>>8&255),t.adler=0,r.status=gt)):r.status=gt),0!==r.pending){if(kt(t),0===t.avail_out)return r.last_flush=-1,tt}else if(0===t.avail_in&&bt(e)<=bt(i)&&e!==V)return vt(t,rt);if(r.status===wt&&0!==t.avail_in)return vt(t,rt);if(0!==t.avail_in||0!==r.lookahead||e!==q&&r.status!==wt){var _=r.strategy===_t?function(t,e){for(var a;;){if(0===t.lookahead&&(Zt(t),0===t.lookahead)){if(e===q)return 1;break}if(t.match_length=0,a=X(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,a&&(zt(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(zt(t,!1),0===t.strm.avail_out)?1:2}(r,e):r.strategy===ht?function(t,e){for(var a,n,r,i,s=t.window;;){if(t.lookahead<=ft){if(Zt(t),t.lookahead<=ft&&e===q)return 1;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=3&&t.strstart>0&&(n=s[r=t.strstart-1])===s[++r]&&n===s[++r]&&n===s[++r]){i=t.strstart+ft;do{}while(n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&n===s[++r]&&r<i);t.match_length=ft-(i-r),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=3?(a=X(t,1,t.match_length-3),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(a=X(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),a&&(zt(t,!1),0===t.strm.avail_out))return 1}return t.insert=0,e===V?(zt(t,!0),0===t.strm.avail_out?3:4):t.last_lit&&(zt(t,!1),0===t.strm.avail_out)?1:2}(r,e):Lt[r.level].func(r,e);if(3!==_&&4!==_||(r.status=wt),1===_||3===_)return 0===t.avail_out&&(r.last_flush=-1),tt;if(2===_&&(e===J?W(r):e!==$&&(j(r,0,0,!1),e===Q&&(mt(r.head),0===r.lookahead&&(r.strstart=0,r.block_start=0,r.insert=0))),kt(t),0===t.avail_out))return r.last_flush=-1,tt}return e!==V?tt:r.wrap<=0?et:(2===r.wrap?(xt(r,255&t.adler),xt(r,t.adler>>8&255),xt(r,t.adler>>16&255),xt(r,t.adler>>24&255),xt(r,255&t.total_in),xt(r,t.total_in>>8&255),xt(r,t.total_in>>16&255),xt(r,t.total_in>>24&255)):(At(r,t.adler>>>16),At(r,65535&t.adler)),kt(t),r.wrap>0&&(r.wrap=-r.wrap),0!==r.pending?tt:et)},deflateEnd:function(t){if(!t||!t.state)return at;var e=t.state.status;return 42!==e&&69!==e&&73!==e&&91!==e&&e!==pt&&e!==gt&&e!==wt?vt(t,at):(t.state=null,e===gt?vt(t,nt):tt)},deflateSetDictionary:function(t,e){var a=e.length;if(!t||!t.state)return at;var n=t.state,r=n.wrap;if(2===r||1===r&&42!==n.status||n.lookahead)return at;if(1===r&&(t.adler=C(t.adler,e,a,0)),n.wrap=0,a>=n.w_size){0===r&&(mt(n.head),n.strstart=0,n.block_start=0,n.insert=0);var i=new Uint8Array(n.w_size);i.set(e.subarray(a-n.w_size,a),0),e=i,a=n.w_size}var s=t.avail_in,_=t.next_in,h=t.input;for(t.avail_in=a,t.next_in=0,t.input=e,Zt(n);n.lookahead>=3;){var l=n.strstart,o=n.lookahead-2;do{n.ins_h=yt(n,n.ins_h,n.window[l+3-1]),n.prev[l&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=l,l++}while(--o);n.strstart=l,n.lookahead=2,Zt(n)}return n.strstart+=n.lookahead,n.block_start=n.strstart,n.insert=n.lookahead,n.lookahead=0,n.match_length=n.prev_length=2,n.match_available=0,t.next_in=_,t.input=h,t.avail_in=s,n.wrap=r,tt},deflateInfo:"pako deflate (from Nodeca project)"};for(var Dt=new Uint8Array(256),Bt=0;Bt<256;Bt++)Dt[Bt]=Bt>=252?6:Bt>=248?5:Bt>=240?4:Bt>=224?3:Bt>=192?2:1;Dt[254]=Dt[254]=1;var Ct=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},Ht=Object.prototype.toString,Mt=K.Z_NO_FLUSH,Yt=K.Z_SYNC_FLUSH,Kt=K.Z_FULL_FLUSH,Pt=K.Z_FINISH,jt=K.Z_OK,Gt=K.Z_STREAM_END,Xt=K.Z_DEFAULT_COMPRESSION,Wt=K.Z_DEFAULT_STRATEGY,qt=K.Z_DEFLATED;function Jt(){this.options={level:Xt,method:qt,chunkSize:16384,windowBits:15,memLevel:8,strategy:Wt};var t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Ct,this.strm.avail_out=0;var e=Ot.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(e!==jt)throw new Error(Y[e]);if(t.header&&Ot.deflateSetHeader(this.strm,t.header),t.dictionary){var a;if(a="[object ArrayBuffer]"===Ht.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,(e=Ot.deflateSetDictionary(this.strm,a))!==jt)throw new Error(Y[e]);this._dict_set=!0}}function Qt(t,e,a){try{t.postMessage({type:"errored",error:e,streamId:a})}catch(n){t.postMessage({type:"errored",error:String(e),streamId:a})}}function Vt(t){var e=t.strm.adler;return new Uint8Array([3,0,e>>>24&255,e>>>16&255,e>>>8&255,255&e])}Jt.prototype.push=function(t,e){var a,n,r=this.strm,i=this.options.chunkSize;if(this.ended)return!1;for(n=e===~~e?e:!0===e?Pt:Mt,"[object ArrayBuffer]"===Ht.call(t)?r.input=new Uint8Array(t):r.input=t,r.next_in=0,r.avail_in=r.input.length;;)if(0===r.avail_out&&(r.output=new Uint8Array(i),r.next_out=0,r.avail_out=i),(n===Yt||n===Kt)&&r.avail_out<=6)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else{if((a=Ot.deflate(r,n))===Gt)return r.next_out>0&&this.onData(r.output.subarray(0,r.next_out)),a=Ot.deflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===jt;if(0!==r.avail_out){if(n>0&&r.next_out>0)this.onData(r.output.subarray(0,r.next_out)),r.avail_out=0;else if(0===r.avail_in)break}else this.onData(r.output)}return!0},Jt.prototype.onData=function(t){this.chunks.push(t)},Jt.prototype.onEnd=function(t){t===jt&&(this.result=function(t){for(var e=0,a=0,n=t.length;a<n;a++)e+=t[a].length;for(var r=new Uint8Array(e),i=0,s=0,_=t.length;i<_;i++){var h=t[i];r.set(h,s),s+=h.length}return r}(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},function(e){void 0===e&&(e=self);try{var a=new Map;e.addEventListener("message",(function(n){try{var r=function(e,a){switch(a.action){case"init":return{type:"initialized",version:"5.23.3"};case"write":var n=e.get(a.streamId);n||(n=new Jt,e.set(a.streamId,n));var r=n.chunks.length,i=function(t){if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(t);var e,a,n,r,i,s=t.length,_=0;for(r=0;r<s;r++)55296==(64512&(a=t.charCodeAt(r)))&&r+1<s&&56320==(64512&(n=t.charCodeAt(r+1)))&&(a=65536+(a-55296<<10)+(n-56320),r++),_+=a<128?1:a<2048?2:a<65536?3:4;for(e=new Uint8Array(_),i=0,r=0;i<_;r++)55296==(64512&(a=t.charCodeAt(r)))&&r+1<s&&56320==(64512&(n=t.charCodeAt(r+1)))&&(a=65536+(a-55296<<10)+(n-56320),r++),a<128?e[i++]=a:a<2048?(e[i++]=192|a>>>6,e[i++]=128|63&a):a<65536?(e[i++]=224|a>>>12,e[i++]=128|a>>>6&63,e[i++]=128|63&a):(e[i++]=240|a>>>18,e[i++]=128|a>>>12&63,e[i++]=128|a>>>6&63,e[i++]=128|63&a);return e}(a.data);return n.push(i,K.Z_SYNC_FLUSH),{type:"wrote",id:a.id,streamId:a.streamId,result:t(n.chunks.slice(r)),trailer:Vt(n),additionalBytesCount:i.length};case"reset":e.delete(a.streamId)}}(a,n.data);r&&e.postMessage(r)}catch(t){Qt(e,t,n.data&&"streamId"in n.data?n.data.streamId:void 0)}}))}catch(t){Qt(e,t)}}()}();'])))
    }
    var ho = {
        status: 0
    };

    function uo(t, e, n, i) {
        switch (void 0 === i && (i = co), 0 === ho.status && function (t, e, n) {
            void 0 === n && (n = co);
            try {
                var i = n(t),
                    r = te(t, i, "error", (function (n) {
                        fo(t, e, n)
                    })).stop,
                    s = te(t, i, "message", (function (n) {
                        var i, r = n.data;
                        "errored" === r.type ? fo(t, e, r.error, r.streamId) : "initialized" === r.type && (i = r.version, 1 === ho.status && (ho = {
                            status: 3,
                            worker: ho.worker,
                            stop: ho.stop,
                            version: i
                        }))
                    })).stop;
                i.postMessage({
                    action: "init"
                }), P((function () {
                    return function (t) {
                        1 === ho.status && (o.error("".concat(t, " failed to start: a timeout occurred while initializing the Worker")), ho.initializationFailureCallbacks.forEach((function (t) {
                            return t()
                        })), ho = {
                            status: 2
                        })
                    }(e)
                }), 1e4);
                ho = {
                    status: 1,
                    worker: i,
                    stop: function () {
                        r(), s()
                    },
                    initializationFailureCallbacks: []
                }
            } catch (n) {
                fo(t, e, n)
            }
        }(t, e, i), ho.status) {
            case 1:
                return ho.initializationFailureCallbacks.push(n), ho.worker;
            case 3:
                return ho.worker
        }
    }

    function po() {
        return ho.status
    }

    function fo(t, e, n, i) {
        if (1 === ho.status || 0 === ho.status) {
            if (o.error("".concat(e, " failed to start: an error occurred while creating the Worker:"), n), n instanceof Event || n instanceof Error && (y(s = n.message, "Content Security Policy") || y(s, "requires 'TrustedScriptURL'"))) {
                var r = void 0;
                r = t.workerUrl ? "Please make sure the Worker URL ".concat(t.workerUrl, " is correct and CSP is correctly configured.") : "Please make sure CSP is correctly configured.", o.error("".concat(r, " See documentation at ").concat(l, "/integrations/content_security_policy_logs/#use-csp-with-real-user-monitoring-and-session-replay"))
            } else Zt(n);
            1 === ho.status && ho.initializationFailureCallbacks.forEach((function (t) {
                return t()
            })), ho = {
                status: 2
            }
        } else Zt(n, {
            worker_version: 3 === ho.status && ho.version,
            stream_id: i
        });
        var s
    }
    var mo, go, vo, yo, bo = function (t, e, n) {
        void 0 === n && (n = {});
        var i, r, s = H(0),
            a = Q(s.getOrCreateTracker(2)),
            l = Q(s.getOrCreateTracker(1)),
            c = {
                tryToInit: function (t) {
                    i || (i = t)
                },
                update: function (t) {
                    i = t, r.notify()
                },
                isGranted: function () {
                    return i === et.GRANTED
                },
                observable: r = new Z
            };

        function h() {
            return function (t, e, n) {
                return {
                    context: t.getContext(),
                    user: e.getContext(),
                    hasReplay: !!n.isRecording() || void 0
                }
            }(a, l, e)
        }
        var u, d, p = xn(n, h, c, (function (i, r, o) {
            rt(tt.CUSTOM_VITALS) && (y.startDurationVital = m((function (t, e) {
                return Jt({
                    feature: "start-duration-vital"
                }), p.startDurationVital({
                    name: X(t),
                    context: X(e && e.context),
                    details: X(e && e.details)
                })
            })), y.addDurationVital = m((function (t, e) {
                var n;
                Jt({
                    feature: "add-duration-vital"
                }), p.addDurationVital({
                    name: X(t),
                    type: "duration",
                    startClocks: (n = e.startTime, {
                        relative: Nt(n),
                        timeStamp: n
                    }),
                    duration: e.duration,
                    context: X(e && e.context),
                    details: X(e && e.details)
                })
            })), y.stopDurationVital = k), rt(tt.UPDATE_VIEW_NAME) && (y.updateViewName = m((function (t) {
                p.updateViewName(t)
            }))), i.storeContextsAcrossPages && (ie(i, a, "rum", 2), ie(i, l, "rum", 1)), s.setCompressionStatus(r ? 1 : 2);
            var u = t(i, e, s, h, o, r && n.createDeflateEncoder ? function (t) {
                return n.createDeflateEncoder(i, r, t)
            } : re, c);
            return e.onRumStart(u.lifeCycle, i, u.session, u.viewContexts, r), p = function (t, e) {
                return E({
                    init: function (t) {
                        ae("DD_RUM", t)
                    },
                    initConfiguration: t.initConfiguration
                }, e)
            }(p, u), u
        })),
            v = m((function (t) {
                var e = "object" == typeof t ? t : {
                    name: t
                };
                p.startView(e), Jt({
                    feature: "start-view"
                })
            })),
            y = (u = {
                init: m((function (t) {
                    return p.init(t, y)
                })),
                setTrackingConsent: m((function (t) {
                    c.update(t), Jt({
                        feature: "set-tracking-consent",
                        tracking_consent: t
                    })
                })),
                setGlobalContext: m((function (t) {
                    a.setContext(t), Jt({
                        feature: "set-global-context"
                    })
                })),
                getGlobalContext: m((function () {
                    return a.getContext()
                })),
                setGlobalContextProperty: m((function (t, e) {
                    a.setContextProperty(t, e), Jt({
                        feature: "set-global-context"
                    })
                })),
                removeGlobalContextProperty: m((function (t) {
                    return a.removeContextProperty(t)
                })),
                clearGlobalContext: m((function () {
                    return a.clearContext()
                })),
                getInternalContext: m((function (t) {
                    return p.getInternalContext(t)
                })),
                getInitConfiguration: m((function () {
                    return W(p.initConfiguration)
                })),
                addAction: function (t, e) {
                    var n = gt();
                    g((function () {
                        p.addAction({
                            name: X(t),
                            context: X(e),
                            startClocks: Ot(),
                            type: "custom",
                            handlingStack: n
                        }), Jt({
                            feature: "add-action"
                        })
                    }))
                },
                addError: function (t, e) {
                    var n = gt();
                    g((function () {
                        p.addError({
                            error: t,
                            handlingStack: n,
                            context: X(e),
                            startClocks: Ot()
                        }), Jt({
                            feature: "add-error"
                        })
                    }))
                },
                addTiming: m((function (t, e) {
                    p.addTiming(X(t), e)
                })),
                setUser: m((function (t) {
                    (function (t) {
                        var e = "object" === V(t);
                        return e || o.error("Unsupported user:", t), e
                    })(t) && l.setContext(se(t)), Jt({
                        feature: "set-user"
                    })
                })),
                getUser: m((function () {
                    return l.getContext()
                })),
                setUserProperty: m((function (t, e) {
                    var n, i = se((n = {}, n[t] = e, n))[t];
                    l.setContextProperty(t, i), Jt({
                        feature: "set-user"
                    })
                })),
                removeUserProperty: m((function (t) {
                    return l.removeContextProperty(t)
                })),
                clearUser: m((function () {
                    return l.clearContext()
                })),
                startView: v,
                stopSession: m((function () {
                    p.stopSession(), Jt({
                        feature: "stop-session"
                    })
                })),
                addFeatureFlagEvaluation: m((function (t, e) {
                    p.addFeatureFlagEvaluation(X(t), X(e)), Jt({
                        feature: "add-feature-flag-evaluation"
                    })
                })),
                getSessionReplayLink: m((function () {
                    return e.getSessionReplayLink()
                })),
                startSessionReplayRecording: m((function (t) {
                    e.start(t), Jt({
                        feature: "start-session-replay-recording",
                        force: t && t.force
                    })
                })),
                stopSessionReplayRecording: m((function () {
                    return e.stop()
                }))
            }, d = E({
                version: "5.23.3",
                onReady: function (t) {
                    t()
                }
            }, u), Object.defineProperty(d, "_setDebug", {
                get: function () {
                    return f
                },
                enumerable: !1
            }), d);
        return y
    }((function (t, e, n, i, r, s, a) {
        var o = [],
            l = new si;
        l.subscribe(13, (function (t) {
            return zt("rum", t)
        }));
        var c = function (t) {
            var e = Yt("browser-rum-sdk", t);
            if (ce()) {
                var n = oe();
                e.observable.subscribe((function (t) {
                    return n.send("internal_telemetry", t)
                }))
            }
            return e
        }(t);
        c.setContextProvider((function () {
            var e, n;
            return {
                application: {
                    id: t.applicationId
                },
                session: {
                    id: null === (e = f.findTrackedSession()) || void 0 === e ? void 0 : e.id
                },
                view: {
                    id: null === (n = w.findView()) || void 0 === n ? void 0 : n.id
                },
                action: {
                    id: M.findActionId()
                }
            }
        }));
        var h = function (t) {
            l.notify(14, {
                error: t
            }), Kt("Error reported to customer", {
                "error.message": t.message
            })
        },
            u = function (t, e) {
                var n = ai({
                    expireDelay: 144e5
                });
                return t.subscribe(2, (function (t) {
                    var i = t.startClocks;
                    n.add({}, i.relative), e.resetCustomerData()
                })), t.subscribe(6, (function (t) {
                    var e = t.endClocks;
                    n.closeActive(e.relative)
                })), {
                    findFeatureFlagEvaluations: function (t) {
                        return n.find(t)
                    },
                    addFeatureFlagEvaluation: function (t, i) {
                        var r = n.find();
                        r && (r[t] = i, e.updateCustomerData(r))
                    },
                    stop: function () {
                        return e.stop()
                    }
                }
            }(l, n.getOrCreateTracker(0)),
            d = function (t) {
                return new Z((function (e) {
                    var n = ee(t, window, ["visibilitychange", "freeze"], (function (t) {
                        "visibilitychange" === t.type && "hidden" === document.visibilityState ? e.notify({
                            reason: _n.HIDDEN
                        }) : "freeze" === t.type && e.notify({
                            reason: _n.FROZEN
                        })
                    }), {
                        capture: !0
                    }).stop,
                        i = te(t, window, "beforeunload", (function () {
                            e.notify({
                                reason: _n.UNLOADING
                            })
                        })).stop;
                    return function () {
                        n(), i()
                    }
                }))
            }(t),
            p = d.subscribe((function (t) {
                l.notify(11, t)
            }));
        o.push((function () {
            return p.unsubscribe()
        }));
        var f = ce() ? function () {
            var t = {
                id: "00000000-aaaa-0000-aaaa-000000000000",
                sessionReplay: le("records") ? 1 : 0
            };
            return {
                findTrackedSession: function () {
                    return t
                },
                expire: k,
                expireObservable: new Z,
                setForcedReplay: k
            }
        }() : ss(t, l, a);
        if (ce()) ! function (t) {
            var e = oe();
            t.subscribe(13, (function (t) {
                e.send("rum", t)
            }))
        }(l);
        else {
            var g = vs(t, l, c.observable, h, d, f.expireObservable, s);
            o.push((function () {
                return g.stop()
            })),
                function (t, e, n, i, r) {
                    e.enabled && wt(t.customerDataTelemetrySampleRate) && (Es(), Ts(), n.subscribe(13, (function (t) {
                        _s = !0, Ss(xs.globalContextBytes, i.getOrCreateTracker(2).getBytesCount()), Ss(xs.userContextBytes, i.getOrCreateTracker(1).getBytesCount()), Ss(xs.featureFlagBytes, y(["view", "error"], t.type) ? i.getOrCreateTracker(0).getBytesCount() : 0)
                    })), r.subscribe((function (t) {
                        var e = t.bytesCount,
                            n = t.messagesCount;
                        _s && (bs.batchCount += 1, Ss(bs.batchBytesCount, e), Ss(bs.batchMessagesCount, n), Ms(bs.globalContextBytes, xs.globalContextBytes), Ms(bs.userContextBytes, xs.userContextBytes), Ms(bs.featureFlagBytes, xs.featureFlagBytes), Ts())
                    })), O(ws, 1e4))
                }(t, c, l, n, g.flushObservable)
        }
        var v = function () {
            var t = Sn();
            return new Z((function (e) {
                if (t) {
                    var n = new t(m((function () {
                        return e.notify()
                    })));
                    return n.observe(document, {
                        attributes: !0,
                        characterData: !0,
                        childList: !0,
                        subtree: !0
                    }),
                        function () {
                            return n.disconnect()
                        }
                }
            }))
        }(),
            b = ys(t, location),
            x = Cs(t),
            _ = function (t, e, n, i, r, s, a, o, l) {
                var c = function (t) {
                    var e = ai({
                        expireDelay: 144e5
                    });
                    return t.subscribe(2, (function (t) {
                        e.add(function (t) {
                            return {
                                service: t.service,
                                version: t.version,
                                id: t.id,
                                name: t.name,
                                startClocks: t.startClocks
                            }
                        }(t), t.startClocks.relative)
                    })), t.subscribe(6, (function (t) {
                        var n = t.endClocks;
                        e.closeActive(n.relative)
                    })), t.subscribe(4, (function (t) {
                        var n = e.find(t.startClocks.relative);
                        n && t.name && (n.name = t.name)
                    })), t.subscribe(10, (function () {
                        e.reset()
                    })), {
                        findView: function (t) {
                            return e.find(t)
                        },
                        stop: function () {
                            e.stop()
                        }
                    }
                }(t),
                    h = function (t, e, n) {
                        var i, r = ai({
                            expireDelay: 144e5
                        });
                        t.subscribe(2, (function (t) {
                            var e = t.startClocks,
                                s = n.href;
                            r.add(a({
                                url: s,
                                referrer: i || document.referrer
                            }), e.relative), i = s
                        })), t.subscribe(6, (function (t) {
                            var e = t.endClocks;
                            r.closeActive(e.relative)
                        }));
                        var s = e.subscribe((function (t) {
                            var e = t.newLocation,
                                n = r.find();
                            if (n) {
                                var i = Lt();
                                r.closeActive(i), r.add(a({
                                    url: e.href,
                                    referrer: n.referrer
                                }), i)
                            }
                        }));

                        function a(t) {
                            return {
                                url: t.url,
                                referrer: t.referrer
                            }
                        }
                        return {
                            findUrl: function (t) {
                                return r.find(t)
                            },
                            stop: function () {
                                s.unsubscribe(), r.stop()
                            }
                        }
                    }(t, s, n),
                    u = function (t, e, n, i) {
                        t.subscribe(1, (function (e) {
                            return t.notify(12, pr(e, i))
                        }));
                        var r = {
                            findActionId: k
                        };
                        return n.trackUserInteractions && (r = dr(t, e, n).actionContexts), {
                            addAction: function (e, n) {
                                t.notify(12, E({
                                    savedCommonContext: n
                                }, pr(e, i)))
                            },
                            actionContexts: r
                        }
                    }(t, a, e, r),
                    d = u.addAction,
                    p = u.actionContexts,
                    f = function (t) {
                        var e = Zr();
                        return {
                            get: function () {
                                return {
                                    viewport: e
                                }
                            },
                            stop: Kr(t).subscribe((function (t) {
                                e = t
                            })).unsubscribe
                        }
                    }(e),
                    m = function (t, e) {
                        var n;
                        void 0 === e && (e = Rs(t, "datadog-ci-visibility-test-execution-id"));
                        var i = Te("datadog-ci-visibility-test-execution-id") || (null === (n = window.Cypress) || void 0 === n ? void 0 : n.env("traceId")),
                            r = e.subscribe((function (t) {
                                i = t
                            }));
                        return {
                            get: function () {
                                if ("string" == typeof i) return {
                                    test_execution_id: i
                                }
                            },
                            stop: function () {
                                return r.unsubscribe()
                            }
                        }
                    }(e);
                return ii(e, t, i, c, h, p, f, m, o, l), {
                    viewContexts: c,
                    pageStateHistory: r,
                    urlContexts: h,
                    addAction: d,
                    actionContexts: p,
                    stop: function () {
                        m.stop(), f.stop(), r.stop(), h.stop(), c.stop(), r.stop()
                    }
                }
            }(l, t, location, f, x, b, v, i, h),
            w = _.viewContexts,
            S = _.urlContexts,
            M = _.actionContexts,
            T = _.addAction,
            C = _.stop;
        o.push(C), qt.drain();
        var A = ns(l, t, location, v, b, u, x, e, r),
            R = A.addTiming,
            P = A.startView,
            L = A.updateViewName,
            D = A.stop;
        o.push(D);
        var I = Dr(l, t, x).stop;
        o.push(I),
            function (t, e) {
                t.subscribe(0, (function (n) {
                    for (var i = 0, r = n; i < r.length; i++) {
                        var s = r[i];
                        if (s.entryType !== On.LONG_TASK) break;
                        if (!e.trackLongTasks) break;
                        var a = Tt(s.startTime),
                            o = {
                                date: a.timeStamp,
                                long_task: {
                                    id: ye(),
                                    duration: At(s.duration)
                                },
                                type: "long_task",
                                _dd: {
                                    discarded: !1
                                }
                            };
                        t.notify(12, {
                            rawRumEvent: o,
                            startTime: a.relative,
                            domainContext: {
                                performanceEntry: s
                            }
                        })
                    }
                }))
            }(l, t);
        var N = Sr(l, t, x, u).addError;
        pi(l, t, f);
        var U = $n(l, t).stop;
        o.push(U);
        var z = yn(l, x),
            F = function (t, e, n, i, r) {
                return {
                    get: function (s) {
                        var a = n.findView(s),
                            o = r.findUrl(s),
                            l = e.findTrackedSession(s);
                        if (l && a && o) {
                            var c = i.findActionId(s);
                            return {
                                application_id: t,
                                session_id: l.id,
                                user_action: c ? {
                                    id: c
                                } : void 0,
                                view: {
                                    id: a.id,
                                    name: a.name,
                                    referrer: o.referrer,
                                    url: o.url
                                }
                            }
                        }
                    }
                }
            }(t.applicationId, f, w, M, S);
        return {
            addAction: T,
            addError: N,
            addTiming: R,
            addFeatureFlagEvaluation: u.addFeatureFlagEvaluation,
            startView: P,
            updateViewName: L,
            lifeCycle: l,
            viewContexts: w,
            session: f,
            stopSession: function () {
                return f.expire()
            },
            getInternalContext: F.get,
            startDurationVital: z.startDurationVital,
            addDurationVital: z.addDurationVital,
            stop: function () {
                o.forEach((function (t) {
                    return t()
                }))
            }
        }
    }), function (t, e) {
        if (ce() && !le("records") || !ao()) return {
            start: k,
            stop: k,
            getReplayStats: function () { },
            onRumStart: k,
            isRecording: function () {
                return !1
            },
            getSessionReplayLink: function () { }
        };
        var n = {
            status: 1
        },
            i = function () {
                n = {
                    status: 1
                }
            },
            r = function () {
                n = {
                    status: 0
                }
            },
            s = k;
        return {
            start: function (t) {
                return i(t)
            },
            stop: function () {
                return r()
            },
            getSessionReplayLink: function () {
                return s()
            },
            onRumStart: function (a, o, l, c, h) {
                var u;
                o.startSessionReplayRecordingManually && (n = {
                    status: 0
                }), a.subscribe(9, (function () {
                    2 !== n.status && 3 !== n.status || (r(), n = {
                        status: 1
                    })
                })), a.subscribe(11, (function (t) {
                    t.reason === _n.UNLOADING && r()
                })), a.subscribe(10, (function () {
                    1 === n.status && i()
                })), i = function (i) {
                    var s = l.findTrackedSession();
                    s && (0 !== s.sessionReplay || i && i.force) ? 2 !== n.status && 3 !== n.status && (n = {
                        status: 2
                    }, Cr(o, "interactive", (function () {
                        if (2 === n.status) {
                            var i = (u || (h || (h = uo(o, "Datadog Session Replay", (function () {
                                r()
                            }), e)), h && (u = lo(o, h, 1))), u);
                            if (i) {
                                var s = t(a, o, l, c, i).stop;
                                n = {
                                    status: 3,
                                    stopRecording: s
                                }
                            } else n = {
                                status: 0
                            }
                        }
                    })), i && i.force && 0 === s.sessionReplay && l.setForcedReplay()) : n = {
                        status: 1
                    }
                }, r = function () {
                    0 !== n.status && (3 === n.status && n.stopRecording(), n = {
                        status: 0
                    })
                }, s = function () {
                    return oo(o, l, c, 0 !== n.status)
                }, 1 === n.status && i()
            },
            isRecording: function () {
                return 3 === po() && 3 === n.status
            },
            getReplayStats: function (t) {
                return 3 === po() ? function (t) {
                    return null == Os ? void 0 : Os.get(t)
                }(t) : void 0
            }
        }
    }((function (t, e, n, i, r, s) {
        var a, o = [],
            l = s || ps(e, e.sessionReplayEndpointBuilder, ro, (function (e) {
                t.notify(14, {
                    error: e
                }), Kt("Error reported to customer", {
                    "error.message": e.message
                })
            }));
        if (ce()) a = function (t) {
            var e = oe();
            return {
                addRecord: function (n) {
                    var i = t.findView();
                    e.send("record", n, i.id)
                }
            }
        }(i).addRecord;
        else {
            var c = so(t, e, n, i, l, r);
            a = c.addRecord, o.push(c.stop)
        }
        var h = no({
            emit: a,
            configuration: e,
            lifeCycle: t,
            viewContexts: i
        }).stop;
        return o.push(h), {
            stop: function () {
                o.forEach((function (t) {
                    return t()
                }))
            }
        }
    })), {
        startDeflateWorker: uo,
        createDeflateEncoder: lo
    });
    mo = T(), vo = bo, (yo = mo[go = "DD_RUM"]) && !yo.q && yo.version && o.warn("SDK is loaded more than once. This is unsupported and might have unexpected behavior."), mo[go] = vo, yo && yo.q && yo.q.forEach((function (t) {
        return h(t, "onReady callback threw an error:")()
    })),
        function () {
            const {
                dataDogApplicationId: t,
                dataDogClientToken: e,
                dataDogSite: n,
                dataDogService: i,
                dataDogEnv: r
            } = window;
            t && e && n && i && r && bo.init({
                applicationId: t,
                clientToken: e,
                site: n,
                service: i,
                env: r,
                sessionSampleRate: 100,
                sessionReplaySampleRate: 20,
                trackUserInteractions: !0,
                trackResources: !0,
                trackLongTasks: !0,
                defaultPrivacyLevel: "mask-user-input"
            })
        }();
    var xo = n(1),
        _o = n(7),
        wo = n(6),
        So = n(234),
        Mo = n.n(So);
    const Eo = /[^\x20\t\r\n\f]+/g,
        To = /^([^.]*)(?:\.(.+)|)/;
    let Co = !1;
    try {
        var Ao = Object.defineProperty({}, "passive", {
            get: function () {
                return Co = !0
            }
        });
        window.addEventListener("test", null, Ao)
    } catch (t) { }

    function Ro(t, e) {
        const n = t.match(Eo) || [""],
            i = [];
        for (let t = 0; t < n.length; t++) {
            const r = To.exec(n[t]) || [];
            let s = null;
            e && (e._passiveNormalizedCallback ? s = e._passiveNormalizedCallback : e._passiveNormalizedCallback = s = function (t) {
                return e(Oo(t))
            }), i.push({
                type: r[1],
                namespaces: (r[2] || "").split(".").sort(),
                callback: s
            })
        }
        return i
    }

    function Po(t, e) {
        const n = xo.a._data(t, "passiveevents") || [];
        n.push(e), xo.a._data(t, "passiveevents", n), t.addEventListener(e.type, e.callback, {
            passive: !0
        })
    }

    function Lo(t, e) {
        const n = xo.a._data(t, "passiveevents") || [];
        for (let i = n.length - 1; i >= 0; i--) e.type && n[i].type !== e.type || e.callback && n[i].callback !== e.callback || e.namespaces && Mo()(e.namespaces, n[i].namespaces).length !== e.namespaces.length || (t.removeEventListener(n[i].type, n[i].callback, {
            passive: !0
        }), n.splice(i, 1), xo.a._data(t, "passiveevents", n))
    }

    function Oo(t) {
        return new xo.a.Event(t, {
            passive: !0
        })
    }

    function Do(t) {
        return {
            mobileOnly: !1 !== t.mobileOnly,
            enableMq: t.enableMq || null,
            properties: t.properties || null
        }
    }
    Co ? (xo.a.fn.onpassive = function (t, e) {
        const n = Ro(t, e);
        let i = 0;
        for (let t = 0; t < n.length; t++) {
            const e = n[t];
            if (e.type)
                for (let t = 0; t < this.length; t++) Po(this[t], e), i++
        }
        return i && this.on("destroyed", this.offpassive.bind(this, t, e)), this
    }, xo.a.fn.offpassive = function (t, e) {
        const n = Ro(t, e);
        for (let t = 0; t < n.length; t++) {
            const e = n[t];
            for (let t = 0; t < this.length; t++) Lo(this[t], e)
        }
        return this
    }) : (xo.a.fn.onpassive = xo.a.fn.on, xo.a.fn.offpassive = xo.a.fn.off);

    function Io(t, e) {
        let n = null;
        const i = function () {
            n = null
        },
            r = function () {
                n && (t(), requestAnimationFrame(r))
            };
        return function (s, a) {
            n || a && "vh-unit-change" == a.origin || (n = setTimeout(i, e), t(), requestAnimationFrame(r))
        }
    }
    let ko = null;
    const No = (!CSS.supports || !CSS.supports("top", "1lvh")) && wo.a.isMobile() && Yo();
    let Uo = 0,
        zo = 0,
        Fo = Ho(),
        $o = 0,
        Bo = !0;

    function Ho() {
        return matchMedia("(max-aspect-ratio: 13/9)").matches ? 0 : 1
    }

    function jo() {
        const t = Ho();
        t !== Fo && (Fo = t, Uo = 0, zo = 0)
    }

    function Vo() {
        return document.documentElement.clientHeight / 100
    }

    function Go() {
        return Bo && ($o = function () {
            if (!ko) {
                ko = document.createElement("div"), ko.style.width = "1px", ko.style.height = "100vh", ko.style.position = "fixed", ko.style.left = "0", ko.style.top = "0", ko.style.bottom = "0", ko.style.visibility = "hidden", ko.style.contain = "strict", document.body.appendChild(ko);
                new ResizeObserver((function () {
                    Bo = !0
                })).observe(ko)
            }
            return ko
        }().clientHeight / 100, Bo = !1), $o
    }

    function Wo() {
        const t = Vo();
        return No ? (jo(), Uo = Math.max(Uo, t), Uo) : t
    }

    function qo() {
        const t = Math.max(Uo, Go());
        return No ? (jo(), zo = Math.max(zo, t), zo) : t
    }

    function Xo() {
        const t = window.innerHeight / 100;
        return Math.max(Wo(), Math.min(qo(), t))
    }

    function Yo() {
        return Vo() !== Go()
    }
    var Ko = {
        svh: Wo,
        lvh: qo,
        dvh: Xo,
        isDynamic: Yo
    };

    function Zo(t) {
        const e = qo(),
            n = function (t) {
                let e = $(t),
                    n = null;
                for (; e.length && e.get(0) !== document.body && e.get(0) !== document;) {
                    "sticky" === e.css("position") && (n = e.get(0)), e = e.parent()
                }
                return n ? n.parentElement : t
            }(document.elementFromPoint(window.innerWidth / 2, "top" === t ? 200 : e - 200));
        if (!n || $(n).closest(".js-modal").length) return null;
        const i = n.getBoundingClientRect();
        let r = 0;
        i.top < 0 && i.top + i.height < e ? r = 1 : i.top < 0 && i.top + i.height > e && (r = (e * ("top" === t ? .2 : .8) - i.top) / i.height);
        const s = (i.top + i.height * r) / e;
        return $("html").css({
            "scroll-behavior": "initial"
        }), {
            referencePoint: r,
            viewportPoint: s,
            element: n
        }
    }

    function Jo(t) {
        let e = null;
        const n = setTimeout(() => {
            i(), e && cancelAnimationFrame(e)
        }, 250);

        function i() {
            $("html").css({
                "scroll-behavior": ""
            })
        } ! function r() {
            const s = qo(),
                a = t.element.getBoundingClientRect(),
                o = s * t.viewportPoint,
                l = a.top + a.height * t.referencePoint - o;
            if (l) {
                clearTimeout(n);
                const t = $(window).scrollTop() + l;
                $(window).scrollTopInstant(t), i()
            } else e = requestAnimationFrame(r)
        }()
    }
    const Qo = !CSS.supports || !CSS.supports("top", "1lvh");

    function tl() {
        Qo && (document.documentElement.style.setProperty("--svh", Wo() + "px"), document.documentElement.style.setProperty("--lvh", qo() + "px"), document.documentElement.style.setProperty("--dvh", Xo() + "px"))
    }

    function el() {
        document.documentElement.style.removeProperty("--svh"), document.documentElement.style.removeProperty("--lvh"), document.documentElement.style.removeProperty("--dvh")
    }
    let nl = null;
    var il = function (t) {
        nl ? nl.update() : nl = function () {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (t = Do(t), Yo() && (!1 === t.mobileOnly || wo.a.isIOS() || wo.a.isAndroid())) {
                const e = {};
                let n = !0,
                    i = !1,
                    r = !t.enableMq;
                setTimeout(() => {
                    n = !1
                }, 2e3), Object(xo.a)(window).on("pageshow", t => {
                    t.originalEvent.persisted && (n = !0, setTimeout(() => {
                        n = !1
                    }, 2e3))
                });
                const s = function () {
                    e["--svh"] = null, e["--lvh"] = null, e["--dvh"] = null, el(), a()
                },
                    a = function (t, s, a) {
                        const o = r ? Xo() : null;
                        if ((!i || a) && o !== e["--dvh"]) {
                            const i = r && s ? Zo(o > e["--dvh"] ? "bottom" : "top") : null;
                            e["--dvh"] = o, tl(), t && Object(xo.a)(window).trigger("resize", {
                                origin: t
                            }), i && !n ? Jo(i) : Object(xo.a)("html").css({
                                "scroll-behavior": ""
                            })
                        }
                    }.bind(this, null, !1, !0),
                    o = Io(a, 250);
                return t.enableMq && (_o.a.enter(t.enableMq, (function () {
                    r = !0, a()
                })), _o.a.leave(t.enableMq, (function () {
                    r = !1, a()
                }))), Object(xo.a)(window).off("resize.mobilevhunit").on("resize.mobilevhunit", o).on("orientationchange.mobilevhunit", o), Object(xo.a)(document).offpassive("touchstart.mobilevhunit touchend.mobilevhunit touchmove.mobilevhunit").onpassive("touchmove.mobilevhunit", o).onpassive("touchstart.mobilevhunit", () => i = !0).onpassive("touchend.mobilevhunit", () => i = !1), a(), o(), Qo || el(), {
                    update: s
                }
            }
            return el(), {
                update: () => { }
            }
        }(t)
    };
    n(220);

    function rl(t) {
        let {
            isPageLoadEvent: e = !1,
            isAjaxPageLoadEvent: n = !1
        } = t;
        if (e || n) {
            il();
            const t = $(".js-page-content");
            !t.data("smoothScrollerDisabled") && $.fn.scroller && $("body").scroller("setScrollableContent", t.eq(0).parent())
        }
    }

    function sl(t, e) {
        let {
            isPageLoadEvent: n = !1,
            isAjaxPageLoadEvent: i = !1
        } = e;
        t.app()
    }
    $.fn.plugins = function () {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        const e = t.isPageLoadEvent || !1,
            n = t.isAjaxPageLoadEvent || !1,
            i = t.pagePluginsOnly || !1;
        rl({
            isPageLoadEvent: e,
            isAjaxPageLoadEvent: n
        }), i || sl(this, {
            isPageLoadEvent: e,
            isAjaxPageLoadEvent: n
        })
    };
    n(333);
    var al = n(3),
        ol = n.n(al),
        ll = n(12),
        cl = n.n(ll),
        hl = n(22),
        ul = n.n(hl);
    const dl = "function" == typeof Image.prototype.decode && !wo.a.isSafari();
    var pl = {
        oninit(t) {
            this.instance.isInview || this.placeholder(), t()
        },
        onload(t) {
            const e = this.instance.$container;
            if (!this.instance.isLoaded && (e.is("picture, img") || e.children("img").length)) return this.decode(() => {
                this.instance.isLoaded = !0, t()
            }), !1;
            t()
        },
        onshow(t) {
            this.instance.isLoaded = !0, this.show(this.instance.$container), t()
        },
        placeholder() {
            const t = this.instance.$container,
                e = t.attr("width"),
                n = t.attr("height"),
                i = t.attr("src") || "";
            if (t.is("img") && e && n && (!i || -1 !== i.indexOf("px.gif")) && -1 === i.indexOf("<svg")) {
                const i = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="${e}" height="${n}" preserveAspectRatio="xMinYMax meet" viewBox="0 0 ${e} ${n}"></svg>`.replace(/</g, "%3C").replace(/>/g, "%3E");
                t.attr("src", i), requestAnimationFrame(() => {
                    t.trigger("appear")
                })
            }
        },
        shouldUseImageDecoding() {
            if (this.instance.options.decode && dl) {
                const t = this.instance.$container.find("img, source").addBack("img");
                let e = !1;
                for (let n = 0; n < t.length; n++) {
                    const i = t.eq(n),
                        r = i.attr("data-src") || i.attr("data-srcset");
                    if (r && (e = !0), r && -1 !== r.indexOf(".svg")) return !1
                }
                return e
            }
            return !1
        },
        decode(t) {
            if (this.instance.isDecoding) return;
            this.instance.isDecoding = !0;
            const e = this.shouldUseImageDecoding(),
                n = this.instance.$container,
                i = e ? n.clone() : n,
                r = i.find("img").addBack("img");
            this.show(i), e ? r.get(0).decode().then(() => {
                if (!this.instance.isLoaded && this.instance.$container)
                    if (i.is("img")) {
                        const e = this.getElementPlugins(n);
                        this.instance.$container = null, n.replaceWith(i), this.copyPluginDataAttributes(n, i), this.instance.$container = i, i.data("appear", this.instance), this.reinitializeElement(n, i, e), i.on("destroyed", this.instance.destroy.bind(this)), t()
                    } else {
                        const e = n.children(),
                            r = i.children(),
                            s = [];
                        e.each((t, e) => {
                            s.push(this.getElementPlugins($(e)))
                        }), n.empty().append(r), this.copyPluginDataAttributes(e, r), r.each((t, n) => {
                            this.reinitializeElement(e.eq(t), $(n), s[t])
                        }), t()
                    }
            }).catch(() => {
                this.show(this.instance.$container), t()
            }) : r.get(0).complete && r.attr("src") ? t() : r.one("load error", () => {
                this.instance.$container && t()
            })
        },
        show(t) {
            if (!t) return;
            t.find("source, img").addBack("img").each((t, e) => {
                const n = $(e),
                    i = n.data("srcset"),
                    r = n.data("src");
                i && (n.get(0).setAttribute("srcset", i), n.get(0).removeAttribute("data-srcset")), r && (n.get(0).setAttribute("src", r), n.get(0).removeAttribute("data-src"))
            })
        },
        getElementPlugins(t) {
            const e = {};
            return e.container = ul()($.app.getPlugins(t), e => "appear" !== e && $.app.hasPlugin(t, e)), t.is("picture") && (e.img = ul()($.app.getPlugins(t), e => "appear" !== e && $.app.hasPlugin(t, e))), e
        },
        reinitializeElement(t, e, n) {
            if (n.container.length && !t.is(e) && e.app(n.container), e.is("picture") && n.img && n.img.length) {
                e.find("img").app(n.img)
            }
        },
        copyPluginDataAttributes(t, e) {
            for (let n = 0; n < t.length; n++) {
                const i = t.eq(n),
                    r = e.eq(n),
                    s = i.get(0).attributes;
                if (i.is("img"))
                    for (let t = 0; t < s.length; t++) {
                        const e = s[t].name;
                        0 === e.indexOf("data") && "data-src" !== e && "data-srcset" !== e && r.attr(e, i.attr(e))
                    }
            }
        }
    },
        fl = {
            onload(t) {
                const e = this.instance.$container;
                if (!this.instance.isLoaded && e.is("iframe")) {
                    const t = e.data("src");
                    t && e.attr("src", t), this.instance.isLoaded = !0
                }
                t()
            }
        },
        ml = {
            oninit(t) {
                const e = this.instance.$container;
                e.is("img,picture,iframe") && (this.initialSize = [e.width(), e.height()]), t()
            },
            onload(t) {
                const e = this.instance.$container;
                this.instance.isLoaded || e.is("img,picture,iframe") || (this.instance.isLoaded = !0), this.instance.loaded(), t()
            },
            onloaded(t) {
                this.instance.callCallbacks("load"), this.instance.isInview && this.instance.animate(), t()
            },
            onanimate(t) {
                this.instance.isAnimated || (this.instance.isAnimated = !0, this.instance.callCallbacks("animate")), t()
            },
            onshow(t) {
                this.instance.isAnimated || (this.instance.isAnimated = !0, this.instance.callCallbacks("animate")), t()
            },
            onafter(t) {
                if (!this.instance.isCompleted) {
                    this.instance.isCompleted = !0;
                    const t = this.instance.$container,
                        e = this.instance.options;
                    t && (!this.initialSize || this.initialSize[1] === t.height() && this.initialSize[0] === t.width() || t.trigger("appear"), this.instance.callCallbacks("complete"), e.destroyOnEnd && this.instance.destroy())
                }
                t()
            }
        },
        gl = {
            oninit(t) {
                if (Object(xo.a)(window).on("beforeprint." + this.instance.ns, this.instance.show.bind(this.instance)), window.matchMedia) {
                    const t = this.printMediaQuery = window.matchMedia("print");
                    if (t.matches) this.instance.show();
                    else {
                        const e = this.onPrintMediaMatch = this.onPrintMediaMatch.bind(this);
                        t.addListener(e)
                    }
                }
                t()
            },
            ondestroy(t) {
                Object(xo.a)(window).off("beforeprint." + this.instance.ns), this.printMediaQuery && (this.printMediaQuery.removeListener(this.onPrintMediaMatch), this.printMediaQuery = null), t()
            },
            onPrintMediaMatch(t) {
                t.matches && this.instance.show()
            }
        },
        vl = {
            oninit(t) {
                const e = this.instance.$container,
                    n = this.instance.options;
                if (e.get(0) instanceof Element) {
                    const t = n.preloadDistance,
                        i = n.showDistance;
                    this.loadObserver = new IntersectionObserver(this.handleIntersection.bind(this, !1), {
                        rootMargin: "number" == typeof t ? t + "px 0px" : t,
                        threshold: n.threshold
                    }), this.showObserver = new IntersectionObserver(this.handleIntersection.bind(this, !0), {
                        rootMargin: "number" == typeof i ? i + "px 0px" : i,
                        threshold: n.threshold
                    }), this.loadObserver.observe(e.get(0)), this.showObserver.observe(e.get(0))
                }
                t()
            },
            onloaded(t) {
                this.loadObserver && (this.loadObserver.disconnect(), this.loadObserver = null), this.instance.isInview || (this.showObserver.disconnect(), this.showObserver.observe(this.instance.$container.get(0))), t()
            },
            ondestroy(t) {
                this.loadObserver && (this.loadObserver.disconnect(), this.loadObserver = null), this.showObserver && (this.showObserver.disconnect(), this.showObserver = null), t()
            },
            onreset(t) {
                this.instance.isInview && (this.loadObserver.observe(this.instance.$container.get(0)), this.showObserver.observe(this.instance.$container.get(0))), t()
            },
            handleIntersection(t, e) {
                if (!this.instance.isInview) {
                    let n = e[0].isIntersecting;
                    if (!n && (wo.a.isEdge() || wo.a.isIE())) {
                        const t = e[0].boundingClientRect,
                            i = e[0].rootBounds;
                        t.width && t.height && (t.top > 0 && t.top < i.height || t.top + t.height > 0 && t.top + t.height < i.height || t.top < 0 && t.top + t.height > i.height) && (t.left > 0 && t.left < i.width || t.left + t.width > 0 && t.left + t.width < i.width || t.left < 0 && t.left + t.width > i.width) && (n = !0)
                    }
                    n && (t && (this.instance.isInview = !0), this.instance.load())
                }
            }
        },
        yl = {
            oninit(t) {
                const e = this.instance.$container;
                if (this.instance.options.preloadOnIdle && e.get(0) instanceof Element && "function" == typeof window.requestIdleCallback) {
                    const t = e.closest(".modal");
                    t.length && "true" === t.attr("aria-hidden") ? (this.$modal = t, t.one("open.modal." + this.instance.ns, this.startPreloading.bind(this))) : this.startPreloading()
                }
                t()
            },
            startPreloading() {
                const t = this.instance.$container;
                t && t.get(0) instanceof Element && (this.idleHandle = requestIdleCallback(() => {
                    this.instance.load()
                }))
            },
            ondestroy(t) {
                this.$modal && (this.$modal.off("." + this.instance.ns), this.$modal = null), this.idleHandle && "function" == typeof window.cancelIdleCallback && window.cancelIdleCallback(this.idleHandle), t()
            }
        },
        bl = n(5),
        xl = n.n(bl);
    n(38), n(222), n(84);

    function _l(t, e) {
        return e && !$.transition.sequences[e] && ($.transition.sequences[e] = $.transition.generateSequenceIn(e)), {
            reset: function () {
                e ? (t.$container.removeClass(`${e} ${e}--inactive ${e}--active`), t.$container.addClass("is-invisible")) : t.$container.removeClass("is-invisible--js")
            },
            animate: function () {
                return new Promise(n => {
                    e ? t.$container.transition(e, () => {
                        n()
                    }) : n()
                })
            }
        }
    }

    function wl(t) {
        return _l(t, t.options.animationName)
    }
    wl.generate = function (t) {
        return function (e) {
            return _l(e, t)
        }
    };
    var Sl = {
        animation: wl,
        "lazy-plugin": function (t) {
            return {
                animate: function () {
                    return t.$container.app({
                        namespace: "lazy-plugin"
                    }), {}
                }
            }
        },
        "fade-in": wl.generate("fade-in"),
        "image-in": wl.generate("image-in")
    },
        Ml = {
            onload(t) {
                if (!this.instance.isAnimated) {
                    const t = this.instance.options.effects,
                        e = Array.isArray(t) ? t : String(t || "").split(/[\s,]/g);
                    this.effects = ul()(cl()(e, t => {
                        if (t in Sl) {
                            let e = Sl[t](this.instance);
                            return e.reset && e.reset(), e
                        }
                    }))
                }
                t()
            },
            onanimate(t) {
                if (this.instance.isAnimated) t();
                else {
                    const e = this.instance.$container,
                        n = this.instance.options,
                        i = this.effects,
                        r = n.delay;
                    i.length ? (setTimeout(() => {
                        if (!this.instance.$container) return;
                        const t = ul()(cl()(i, t => t.animate && t.animate()));
                        t.length ? Promise.all(t).then(() => this.instance.after()) : this.instance.after()
                    }, r || 16), t()) : (e.removeClass("is-invisible is-invisible--js"), t(), this.instance.after())
                }
            },
            onafter(t) {
                if (!this.instance.isCompleted) {
                    if (this.instance.$container) {
                        const t = this.effects;
                        xl()(t, t => t.finalize ? t.finalize() : null)
                    }
                }
                t()
            }
        },
        El = n(9);
    n(30);
    const Tl = wo.a.isReducedMotion(),
        Cl = [gl, vl, yl, pl, fl, Ml, ml];
    xo.a.fn.appear = ol()(class {
        static get Defaults() {
            return {
                animationName: "",
                effects: "animation",
                preloadDistance: "600px 0px 600px 0px",
                showDistance: Tl ? "100px 0px 100px 0px" : "0px 0px 0px 0px",
                threshold: 0,
                delay: 0,
                onload: null,
                onanimate: null,
                oncomplete: null,
                destroyOnEnd: !0,
                decode: !0,
                preloadOnIdle: !0
            }
        }
        constructor(t, e) {
            this.options = xo.a.extend({}, this.constructor.Defaults, e), this.$container = t, this.$originalContainer = t, this.effects = [], this.isInview = !1, this.isLoaded = !1, this.isAnimated = !1, this.isCompleted = !1, this.ns = Object(El.a)(), this.callbacks = {
                load: this.options.onload ? [this.options.onload] : [],
                animate: this.options.onanimate ? [this.options.onanimate] : [],
                complete: this.options.oncomplete ? [this.options.oncomplete] : []
            }, this.plugins = cl()(Cl, t => {
                const e = Object.create(t);
                return e.instance = this, e
            }), t.on("destroyed", this.destroy.bind(this)), this.trigger("init")
        }
        callCallbacks(t) {
            const e = this.callbacks[t],
                n = this.$container;
            this.callbacks[t] = [];
            for (let t = 0; t < e.length; t++) e[t](n)
        }
        callPlugins(t, e) {
            if (t && t.length)
                for (let n = 0; n < t.length; n++)
                    if (t[n][e]) {
                        const i = this.callPlugins.bind(this, t.slice(n + 1), e);
                        return void t[n][e](i)
                    }
        }
        trigger(t) {
            this.callPlugins(this.plugins, "on" + t)
        }
        destroy() {
            this.$container && (this.trigger("destroy"), this.$temp && this.$temp.remove(), this.$originalContainer.removeData("appear"), this.$container = this.$originalContainer = this.$temp = this.options = null, this.effects = [], this.plugins = null)
        }
        reset() {
            this.$container.addClass("is-invisible");
            const t = this.effects;
            for (let e = 0, n = t.length; e < n; e++) t[e].reset && t[e].reset();
            this.trigger("reset"), this.isInview = !1
        }
        load(t) {
            "function" == typeof t && this.callbacks.load.push(t), this.trigger("load")
        }
        loaded() {
            this.trigger("loaded")
        }
        animate() {
            this.trigger("animate")
        }
        after() {
            this.trigger("after")
        }
        show() {
            const t = this.$container;
            t && (t.removeClass("is-invisible is-invisible--js"), this.isLoaded || (this.isLoaded = !0, this.isInview = !0, this.callCallbacks("load"), this.trigger("show")), this.after())
        }
    }, {
        namespace: "appear",
        api: ["reset", "show", "load", "instance"]
    }), xo.a.event.special.returnkey = {
        delegateType: "keydown",
        bindType: "keydown",
        handle: function (t) {
            var e = t.handleObj,
                n = null;
            if (13 === t.which) return t.type = e.origType, n = e.handler.apply(this, arguments), t.type = e.type, n
        }
    };
    var Al = n(33);
    const Rl = "cookieConsentStatus";
    xo.a.fn.cookieConsent = ol()(class {
        static get Defaults() {
            return {}
        }
        constructor(t, e) {
            this.options = xo.a.extend({}, this.constructor.Defaults, e), this.$container = t, t.on("click", ".js-cookie-consent-accept", this.accept.bind(this)), t.on("click", ".js-cookie-consent-decline", this.decline.bind(this)), 1 === parseInt(Al.a.get(Rl)) ? (this.hide(), this.showContent()) : 0 === parseInt(Al.a.get(Rl)) && this.hide()
        }
        destroy() {
            this.$container = null
        }
        accept() {
            Al.a.set(Rl, "1", 356), this.hide(), this.showContent()
        }
        decline() {
            Al.a.set(Rl, "0", 356), this.hide()
        }
        hide() {
            this.$container.remove(), Object(xo.a)("html").removeClass("with-cookie-consent"), this.destroy()
        }
        showContent() {
            Object(xo.a)(".js-wait-cookie-consent").removeClass("is-hidden"), Object(xo.a)('script[type="text/wait-cookie-consent"]').each((t, e) => {
                "idle" === Object(xo.a)(e).data("wait") ? setTimeout(this.enableScript.bind(this, e), 3e3) : this.enableScript(e)
            })
        }
        enableScript(t) {
            const e = document.createElement("script"),
                n = t.getAttributeNames();
            for (let i = 0; i < n.length; i++) {
                const r = n[i];
                "data-src" === r || "data-async" === r || "data-defer" === r ? e.setAttribute(r.replace("data-", ""), t.getAttribute(r)) : "type" !== r && e.setAttribute(r, t.getAttribute(r))
            }
            e.textContent = t.textContent, document.body.appendChild(e)
        }
    });
    xo.a.fn.browserMessage = ol()(class {
        constructor(t) {
            if (this.$container = t, this.isOutdated() && 1 !== parseInt(Al.a.get("browserMessageStatus"))) {
                t.find(".js-browser-message-close").on("click", this.hide.bind(this)), this.show(), wo.a.isIOS() ? t.addClass("is-ios") : wo.a.isAndroid() && t.addClass("is-android")
            }
        }
        isOutdated() {
            const t = [void 0 !== window.Promise && null !== window.Promise && "[object Promise]" === Object.prototype.toString.call(window.Promise.resolve()), window.CSS && "function" == typeof window.CSS.supports && CSS.supports("color", "var(--fake-var)")];
            for (let e = 0; e < t.length; e++)
                if (!t[e]) return !0;
            return !1
        }
        show() {
            this.$container.attr("aria-hidden", !1).removeClass("is-hidden"), this.$container.find("picture, img").not("picture img").appear()
        }
        hide() {
            Al.a.set("browserMessageStatus", "1"), this.$container.attr("aria-hidden", !0).addClass("is-hidden"), Object(xo.a)(document.documentElement).addClass("is-ready")
        }
    });
    var Pl = n(2),
        Ll = n.n(Pl),
        Ol = n(138),
        Dl = (n(128), n(11)),
        Il = n.n(Dl),
        kl = n(17);
    class Nl {
        static instance(t) {
            const e = t.$container.parent();
            let n = e.data("pluginSyncGroup");
            return n || (n = new Nl(e), e.data("pluginSyncGroup", n)), n
        }
        constructor(t) {
            this.$container = t;
            const e = t.find(".js-popover-sync-background");
            this.$background = e.length ? e : null, this.syncPlugins = [], this.position = new kl.a({
                x: -1,
                y: -1,
                width: 0,
                height: 0,
                opacity: 0
            }, {
                strength: .1,
                update: this.update.bind(this)
            })
        }
        isAnyVisible() {
            const t = this.syncPlugins;
            for (let e = 0; e < t.length; e++)
                if (t[e].willBeVisible) return !0;
            return !1
        }
        refresh() {
            this.position.set({
                opacity: this.isAnyVisible() ? 1 : 0
            })
        }
        set() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            const e = this.position.get();
            t && (e.width && e.height ? this.position.set(t) : this.position.reset(t)), this.refresh()
        }
        add(t) {
            this.syncPlugins.push(t)
        }
        remove(t) {
            const e = this.syncPlugins,
                n = e.indexOf(t); - 1 !== n && e.splice(n, 1)
        }
        update(t) {
            const e = this.syncPlugins;
            for (let n = 0; n < e.length; n++) e[n].isVisible && e[n].setPosition(t);
            this.$background && this.$background.css({
                display: t.opacity ? "block" : "none",
                transform: `translate(${~~t.x}px, ${~~t.y}px) scale(${t.width / 1e3}, ${t.height / 1e3})`,
                opacity: t.opacity
            })
        }
    }
    const Ul = {
        sync: class {
            constructor(t) {
                this.synced = !1, t.options.animationIn = "popover-sync-in", t.options.animationOut = "popover-sync-out", this.popover = t, this.$container = t.$container, this.isVisible = !1, this.willBeVisible = !1, this.$container.addClass("popover--sync"), this.$container.removeClass("is-hidden").addClass("is-invisible"), this.syncGroup = Nl.instance(this), this.syncGroup.add(this)
            }
            onShow() {
                this.isVisible = !0, this.willBeVisible = !0
            }
            onHide() {
                this.willBeVisible = !1, this.syncGroup.refresh()
            }
            onHidden() {
                this.isVisible = !1
            }
            update() {
                const t = this.popover.position;
                this.syncGroup.set({
                    x: t.x,
                    y: t.y,
                    width: t.popBox.width,
                    height: t.popBox.height
                }), this.setSynced()
            }
            setPosition(t) {
                this.isVisible && (this.$container[0].style.transform = `translate(${~~t.x}px, ${~~t.y}px)`)
            }
            setSynced() {
                this.synced || (this.synced = !0, requestAnimationFrame(() => {
                    this.$container.addClass("popover--synced")
                }))
            }
            destroy() {
                this.syncGroup.remove(this)
            }
        },
        filter: class {
            constructor(t) {
                this.popover = t, this.$target = $(t.options.sizeTarget), this.size = t.options.sizeWidth, t.options.variantFlipOrder = {
                    start: "sema",
                    middle: "msea",
                    end: "emsa"
                }
            }
            beforePosition() {
                if (_o.a.matches("lg-down") || "full" === this.size) {
                    const t = this.$target.width();
                    this.popover.$container.css("width", t)
                } else this.popover.$container.css("width", "")
            }
            afterPosition(t) {
                if (_o.a.matches("xl-up") && "fill" === this.size && /(bs|ts)/.test(t.pos)) {
                    const e = t.containerBox.width + t.containerBox.left - t.x;
                    this.popover.$container.css("width", e)
                }
            }
            getPopperContainer() {
                const {
                    left: t,
                    top: e,
                    width: n
                } = this.$target.get(0).getBoundingClientRect();
                return {
                    x: t,
                    y: e,
                    left: t,
                    top: e,
                    bottom: window.innerHeight,
                    right: t + n,
                    width: n,
                    height: window.innerHeight - e
                }
            }
        },
        autoPosition: class {
            constructor(t) {
                this.popover = t
            }
            beforePosition() {
                const t = this.popover.$reference;
                if (t.length) {
                    const e = t.get(0).getBoundingClientRect();
                    let n;
                    n = e.left + e.width / 2 > window.innerWidth / 2 ? "right-middle" : "left-middle", this.popover.popperOptions.position = n
                }
            }
        }
    };
    Ll.a.fn.popover = ol()(class {
        static get Defaults() {
            return {
                position: "bottom-end",
                reference: "",
                eventReference: "",
                trigger: "hover",
                delay: 0,
                eventShow: "show.popover",
                eventShown: "shown.popover",
                eventHide: "hide.popover",
                eventHidden: "hidden.popover",
                eventReferenceShow: "show.popover-target",
                eventReferenceShown: "shown.popover-target",
                eventReferenceHide: "hide.popover-target",
                eventReferenceHidden: "hidden.popover-target",
                animationIn: "popover-in",
                animationOut: "popover-out",
                plugins: "",
                variantFlipOrder: null,
                positionFlipOrder: null,
                closeSelector: ".js-popover-close",
                linkSelector: ".js-popover-link",
                containerSelector: ".js-popover-container",
                parentSelector: "",
                headerAdjustment: !1,
                hideOnScroll: !1,
                trianglePositionAdjustment: 0,
                margin: [0, 0, 0, 0],
                outer: !1,
                ignoreLink: !1
            }
        }
        constructor(t, e) {
            if (this.options = Ll.a.extend({}, this.constructor.Defaults, e), this.options.eventReference = this.options.eventReference || this.options.reference, this.popperOptions = null, this.ns = Object(El.a)(), this.position = null, this.plugins = [], this.isVisible = !1, this.isFocused = !1, this.isMouseOver = !1, this.showTimer = null, this.hideTimer = null, this.ignoreDocumentClick = !1, this.$container = t, this.$reference = this.getReferenceElement(this.options.reference).first(), this.$eventReference = this.getReferenceElement(this.options.eventReference), this.$popoverContainer = this.$container.closest(".js-popover-container"), wo.a.hasHoverSupport() || "hover" !== this.options.trigger || (this.options.trigger = "click"), "hover-strict" === this.options.trigger) {
                if (!wo.a.hasHoverSupport()) return this;
                this.options.trigger = "hover"
            }
            this.initPlugins(), this.init()
        }
        getReferenceElement(t) {
            const e = this.$container.closest(".js-page-content-wrapper").find(t);
            return e.length ? e : Ll()(t)
        }
        getPopperContainer() {
            const t = this.callPlugins("getPopperContainer");
            if (t) return t;
            {
                const t = this.$popoverContainer.get(0),
                    e = document.documentElement.getBoundingClientRect();
                let n = this.options.margin;
                this.options.headerAdjustment && (n[0] = Math.max(0, Ll()(".js-header").height() / 2 - Ll()(window).scrollTop()));
                const i = t ? t.getBoundingClientRect() : {
                    top: 0,
                    left: e.left,
                    right: e.right,
                    width: e.width,
                    height: e.height
                };
                return {
                    left: Math.max(i.left, e.left) + n[3],
                    right: Math.min(i.right, e.right) - n[1],
                    width: Math.min(i.width, e.width) - n[1] - n[3],
                    height: Math.min(i.height, e.height) - n[0] - n[2],
                    top: Math.max(i.top, 0) + n[0],
                    bottom: Math.min(i.top + i.height, e.height) - n[2],
                    x: Math.max(i.left, e.left) + n[3],
                    y: Math.max(i.top, 0) + n[0]
                }
            }
        }
        init() {
            const t = this.options,
                e = this.popperOptions = {
                    container: this.getPopperContainer.bind(this),
                    position: this.options.position,
                    margin: this.$container.hasClass("popover--triangle") ? 0 : this.$reference.height() / -2
                };
            t.variantFlipOrder && (e.variantFlipOrder = t.variantFlipOrder), t.positionFlipOrder && (e.positionFlipOrder = t.positionFlipOrder), this.$container.on("destroyed", this.destroy.bind(this)), "hover" === this.options.trigger ? (this.$eventReference.on("click." + this.ns, this.show.bind(this)).on("mouseenter." + this.ns, this.handleMouseOver.bind(this)).on("mouseover." + this.ns, this.handleMouseOver.bind(this)).on("mouseleave." + this.ns, this.handleMouseLeave.bind(this)).on("focus." + this.ns, this.handleFocus.bind(this)).on("blur." + this.ns, this.handleBlur.bind(this)), this.$container.on("mouseenter." + this.ns, this.handleMouseOver.bind(this)).on("mouseover." + this.ns, this.handleMouseOver.bind(this)).on("mouseleave." + this.ns, this.handleMouseLeave.bind(this))) : "click" === this.options.trigger && (this.$eventReference.on(`click.${this.ns} returnkey.${this.ns}`, this.handleClick.bind(this)), Ll()(document).on("click." + this.ns, this.handleDocumentClick.bind(this)).on("keydown." + this.ns, this.handleDocumentKeydown.bind(this))), this.$container.on("click returnkey", this.options.closeSelector, this.handleCloseClick.bind(this)), this.$container.on("click returnkey", this.options.linkSelector, Il()(this.handleCloseClick.bind(this), 60)), t.hideOnScroll && (this.lastScroll = Ll()(window).scrollTop(), Ll()(window).on("scroll." + this.ns, this.hideOnScroll.bind(this)))
        }
        handleFocus(t) {
            this.isVisible || (this.isFocused = !0, this.isMouseOver = !1, this.show(t))
        }
        handleBlur() {
            this.isFocused && !this.isMouseOver && this.hide()
        }
        handleMouseOver(t) {
            this.isMouseOver = !0, this.isFocused = !1, this.show(t)
        }
        handleMouseLeave() {
            this.isMouseOver && !this.isFocused && this.hide()
        }
        show(t) {
            if (!this.isVisible) {
                let e = !1;
                if (this.options.eventShow) {
                    const t = Ll.a.Event(this.options.eventShow);
                    this.$container.trigger(t), e = t.isDefaultPrevented()
                }
                if (!e && this.options.eventReferenceShow) {
                    const t = Ll.a.Event(this.options.eventReferenceShow);
                    this.$reference.trigger(t), e = t.isDefaultPrevented()
                }
                if (e || (this.isVisible = !0, this.hideTimer ? (clearTimeout(this.hideTimer), this.hideTimer = null, this.onShown(t)) : (this.$reference.addClass("is-active"), this.showTimer || (this.showTimer = setTimeout(this.showAfterDelay.bind(this, t), this.options.delay)))), this.options.outer) {
                    const t = this.$container.find(".js-popover-content").html();
                    Ll()("main").append(`<div class="plan-popover plan-popover--outer js-popover-outer js-popover-outer-${this.ns}">${t}</div></div>`);
                    const e = Ll()(".js-popover-outer-" + this.ns).height();
                    Ll()("main").css("padding-bottom", e), Ll()("main").trigger("resize")
                }
                if (this.options.parentSelector) {
                    const t = this.$container.closest(this.options.parentSelector);
                    t.length && t.append(this.$container)
                }
            }
        }
        showAfterDelay(t) {
            this.showTimer = null, this.$container.transitionstop(() => {
                this.$container.addClass("is-active"), this.$container.transition(this.options.animationIn, {
                    before: this.onShow.bind(this, t),
                    after: this.onShown.bind(this, t)
                })
            })
        }
        hide() {
            if (this.isVisible) {
                let t = !1;
                if (this.options.eventHide) {
                    const e = Ll.a.Event(this.options.eventHide);
                    this.$container.trigger(e), t = e.isDefaultPrevented()
                }
                if (!t && this.options.eventReferenceHide) {
                    const e = Ll.a.Event(this.options.eventReferenceHide);
                    this.$reference.trigger(e), t = e.isDefaultPrevented()
                }
                t || (this.isVisible = !1, this.isMouseOver = !1, this.isFocused = !1, this.showTimer && (clearTimeout(this.showTimer), this.showTimer = null), this.hideTimer || (this.hideTimer = setTimeout(this.hideAfterDelay.bind(this), 16))), this.options.outer && (Ll()(".js-popover-outer-" + this.ns).remove(), Ll()(".js-popover-outer").length || (Ll()("main").css("padding-bottom", ""), Ll()("main").trigger("resize")))
            }
        }
        hideOnScroll() {
            Math.abs(Ll()(window).scrollTop() - this.lastScroll) > 5 && (this.hide(), this.lastScroll = Ll()(window).scrollTop())
        }
        hideAfterDelay() {
            this.hideTimer = null, this.$container.transitionstop(() => {
                this.$container.transition(this.options.animationOut, {
                    before: this.onHide.bind(this, event),
                    after: this.onHidden.bind(this, event)
                })
            })
        }
        handleClick(t) {
            if (wo.a.hasHoverSupport()) "click" == this.options.trigger && t.preventDefault();
            else if (Ll()(t.target).closest("a[href]").length)
                if (this.options.ignoreLinks) t.preventDefault();
                else {
                    if (this.isVisible) return;
                    t.preventDefault()
                } this.isVisible ? this.hide() : (this.show(), this.ignoreDocumentClick = !0, setTimeout(() => {
                    this.ignoreDocumentClick = !1
                }, 16))
        }
        handleCloseClick(t) {
            t.preventDefault(), this.hide()
        }
        onShow() {
            this.callPlugins("onShow"), this.update(), Ll()(window).on("resize." + this.ns, this.update.bind(this))
        }
        onShown() {
            const {
                eventShown: t,
                eventReferenceShown: e
            } = this.options;
            this.$container.trigger(t), this.$reference.trigger(e), this.callPlugins("onShown")
        }
        onHide() {
            this.$reference.removeClass("is-active"), this.callPlugins("onHide"), Ll()(window).off("resize." + this.ns)
        }
        onHidden() {
            const {
                eventHidden: t,
                eventReferenceHidden: e
            } = this.options;
            this.$container.removeClass("is-active").trigger(t), this.position && this.position.pos && this.$container.removeClass("popover--" + this.position.pos), this.$container.trigger(Ll.a.Event(t)), this.$reference.trigger(Ll.a.Event(e)), this.callPlugins("onHidden")
        }
        update() {
            this.position && this.position.pos && this.$container.removeClass("popover--" + this.position.pos), this.callPlugins("beforePosition"), this.popperOptions.container = this.getPopperContainer.bind(this);
            const t = this.$container,
                e = Object(Ol.b)(this.$reference[0], this.$container[0], this.popperOptions) || this.position;
            if (t.hasClass("popover--triangle")) {
                const n = this.options.trianglePositionAdjustment;
                /(ts)|(bs)/.test(e.pos) ? e.x -= n : /(te)|(be)/.test(e.pos) && (e.x += n), /(ls)|(rs)/.test(e.pos) ? e.y -= n : /(le)|(re)/.test(e.pos) && (e.y += n);
                const i = e.refBox.left + e.refBox.width / 2 - (e.x + e.popBox.left),
                    r = e.refBox.top + e.refBox.height / 2 - (e.y + e.popBox.top);
                t[0].style.setProperty("--triangle-left", ~~i + "px"), t[0].style.setProperty("--triangle-top", ~~r + "px")
            } else /(ts)|(bs)/.test(e.pos) ? e.x += e.refBox.width / 2 : /(te)|(be)/.test(e.pos) ? e.x -= e.refBox.width / 2 : /(ls)|(rs)/.test(e.pos) ? e.y += e.refBox.height / 2 : /(le)|(re)/.test(e.pos) && (e.y -= e.refBox.height / 2);
            this.setPosition(e), this.callPlugins("afterPosition", [e]), this.callPlugins("update")
        }
        setPosition(t) {
            this.$container.addClass("popover--" + t.pos), this.$container.css("transform", `translate(${t.x}px, ${t.y}px)`), this.position = t
        }
        handleDocumentClick(t) {
            if ( /*!event.isDefaultPrevented() &&*/ !this.ignoreDocumentClick) {
                const e = Ll()(t.target);
                e.closest(this.$container).length || e.closest(this.$reference).length || e.closest(this.$eventReference).length || e[0] === this.$reference[0] || e[0] === this.$eventReference[0] || this.hide()
            }
        }
        handleDocumentKeydown(t) {
            "Escape" === t.key && this.hide()
        }
        destroy() {
            this.callPlugins("destroy"), Ll()(document).add(window).off("." + this.ns), this.$eventReference.off("." + this.ns), Ll()(window).off("scroll." + this.ns)
        }
        initPlugins() {
            const t = this.options.plugins.split(" "),
                e = [];
            for (let n = 0; n < t.length; n++)
                if (t[n] in Ul) {
                    const i = new Ul[t[n]](this);
                    i && e.push(i)
                } this.plugins = e, this.callPlugins("init")
        }
        callPlugins(t) {
            let e, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            return this.plugins.forEach(i => {
                if ("function" == typeof i[t]) {
                    const r = i[t].apply(i, n);
                    void 0 !== r && (e = r)
                }
            }), e
        }
    }, {
        api: ["hide"]
    });
    var zl = n(39),
        Fl = n.n(zl),
        $l = (n(59), n(8));
    class Bl {
        constructor(t) {
            this.$container = t.$container, this.options = t.options, this.ns = t.ns, this.parent = t
        }
        get items() {
            return this.parent.callPlugins("getItems")
        }
        get itemsStack() {
            return this.parent.callPlugins("getItemsStack")
        }
    }

    function Hl(t, e) {
        let n = -1;
        for (; - 1 !== (n = t.indexOf(e));) t.splice(n, 1);
        return t
    }
    var jl = n(18);
    const Vl = {
        easeOut: [.25, .74, .22, .99],
        easeIn: [.47, .04, .5, -.06],
        easeInOut: [.55, 0, .1, 1],
        easeInOutSubtle: [.25, .1, .25, 1],
        easeOutAlt: [0, 1.18, 1, .31],
        easeLines: [.7, 0, .1, 1],
        linear: "linear",
        get: t => "string" == typeof t ? t in Vl ? Vl[t] : (console.error(`Easing "${t}" not found`), Vl.easeInOut) : t
    };
    var Gl = Vl;
    const Wl = {
        duration: .3,
        delay: 0,
        endDelay: 0,
        repeat: 0,
        easing: "ease"
    },
        ql = t => 1e3 * t,
        Xl = t => t / 1e3,
        Yl = () => { },
        Kl = t => t;

    function Zl(t, e = !0) {
        if (t && "finished" !== t.playState) try {
            t.stop ? t.stop() : (e && t.commitStyles(), t.cancel())
        } catch (t) { }
    }
    const Jl = t => t(),
        Ql = (t, e, n = Wl.duration) => new Proxy({
            animations: t.map(Jl).filter(Boolean),
            duration: n,
            options: e
        }, tc),
        tc = {
            get: (t, e) => {
                const n = t.animations[0];
                switch (e) {
                    case "duration":
                        return t.duration;
                    case "currentTime":
                        return Xl((null == n ? void 0 : n[e]) || 0);
                    case "playbackRate":
                    case "playState":
                        return null == n ? void 0 : n[e];
                    case "finished":
                        return t.finished || (t.finished = Promise.all(t.animations.map(ec)).catch(Yl)), t.finished;
                    case "stop":
                        return () => {
                            t.animations.forEach(t => Zl(t))
                        };
                    case "forEachNative":
                        return e => {
                            t.animations.forEach(n => e(n, t))
                        };
                    default:
                        return void 0 === (null == n ? void 0 : n[e]) ? void 0 : () => t.animations.forEach(t => t[e]())
                }
            },
            set: (t, e, n) => {
                switch (e) {
                    case "currentTime":
                        n = ql(n);
                    case "currentTime":
                    case "playbackRate":
                        for (let i = 0; i < t.animations.length; i++) t.animations[i][e] = n;
                        return !0
                }
                return !1
            }
        },
        ec = t => t.finished,
        nc = t => "object" == typeof t && Boolean(t.createAnimation),
        ic = t => "number" == typeof t,
        rc = t => Array.isArray(t) && !ic(t[0]),
        sc = (t, e, n) => -n * t + n * e + t,
        ac = (t, e, n) => e - t == 0 ? 1 : (n - t) / (e - t);

    function oc(t, e) {
        const n = t[t.length - 1];
        for (let i = 1; i <= e; i++) {
            const r = ac(0, e, i);
            t.push(sc(n, 1, r))
        }
    }
    const lc = (t, e, n) => Math.min(Math.max(n, t), e);

    function cc(t, e = function (t) {
        const e = [0];
        return oc(e, t - 1), e
    }(t.length), n = Kl) {
        const i = t.length,
            r = i - e.length;
        return r > 0 && oc(e, r), r => {
            let s = 0;
            for (; s < i - 2 && !(r < e[s + 1]); s++);
            let a = lc(0, 1, ac(e[s], e[s + 1], r));
            return a = function (t, e) {
                return rc(t) ? t[((t, e, n) => {
                    const i = e - t;
                    return ((n - t) % i + i) % i + t
                })(0, t.length, e)] : t
            }(n, s)(a), sc(t[s], t[s + 1], a)
        }
    }
    const hc = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t;

    function uc(t, e, n, i) {
        if (t === e && n === i) return Kl;
        const r = e => function (t, e, n, i, r) {
            let s, a, o = 0;
            do {
                a = e + (n - e) / 2, s = hc(a, i, r) - t, s > 0 ? n = a : e = a
            } while (Math.abs(s) > 1e-7 && ++o < 12);
            return a
        }(e, 0, 1, t, n);
        return t => 0 === t || 1 === t ? t : hc(r(t), e, i)
    }
    const dc = t => "function" == typeof t,
        pc = t => Array.isArray(t) && ic(t[0]),
        fc = {
            ease: uc(.25, .1, .25, 1),
            "ease-in": uc(.42, 0, 1, 1),
            "ease-in-out": uc(.42, 0, .58, 1),
            "ease-out": uc(0, 0, .58, 1)
        },
        mc = /\((.*?)\)/;

    function gc(t) {
        if (dc(t)) return t;
        if (pc(t)) return uc(...t);
        if (fc[t]) return fc[t];
        if (t.startsWith("steps")) {
            const e = mc.exec(t);
            if (e) {
                const t = e[1].split(",");
                return ((t, e = "end") => n => {
                    const i = (n = "end" === e ? Math.min(n, .999) : Math.max(n, .001)) * t,
                        r = "end" === e ? Math.floor(i) : Math.ceil(i);
                    return lc(0, 1, r / t)
                })(parseFloat(t[0]), t[1].trim())
            }
        }
        return Kl
    }
    class vc {
        constructor(t, e = [0, 1], {
            easing: n,
            duration: i = Wl.duration,
            delay: r = Wl.delay,
            endDelay: s = Wl.endDelay,
            repeat: a = Wl.repeat,
            offset: o,
            direction: l = "normal"
        } = {}) {
            if (this.startTime = null, this.rate = 1, this.t = 0, this.cancelTimestamp = null, this.easing = Kl, this.duration = 0, this.totalDuration = 0, this.repeat = 0, this.playState = "idle", this.finished = new Promise((t, e) => {
                this.resolve = t, this.reject = e
            }), n = n || Wl.easing, nc(n)) {
                const t = n.createAnimation(e);
                n = t.easing, e = t.keyframes || e, i = t.duration || i
            }
            this.repeat = a, this.easing = rc(n) ? Kl : gc(n), this.updateDuration(i);
            const c = cc(e, o, rc(n) ? n.map(gc) : Kl);
            this.tick = e => {
                var n;
                r = r;
                let i = 0;
                i = void 0 !== this.pauseTime ? this.pauseTime : (e - this.startTime) * this.rate, this.t = i, i /= 1e3, i = Math.max(i - r, 0), "finished" === this.playState && void 0 === this.pauseTime && (i = this.totalDuration);
                const a = i / this.duration;
                let o = Math.floor(a),
                    h = a % 1;
                !h && a >= 1 && (h = 1), 1 === h && o--;
                const u = o % 2;
                ("reverse" === l || "alternate" === l && u || "alternate-reverse" === l && !u) && (h = 1 - h);
                const d = i >= this.totalDuration ? 1 : Math.min(h, 1),
                    p = c(this.easing(d));
                t(p);
                void 0 === this.pauseTime && ("finished" === this.playState || i >= this.totalDuration + s) ? (this.playState = "finished", null === (n = this.resolve) || void 0 === n || n.call(this, p)) : "idle" !== this.playState && (this.frameRequestId = requestAnimationFrame(this.tick))
            }, this.play()
        }
        play() {
            const t = performance.now();
            this.playState = "running", void 0 !== this.pauseTime ? this.startTime = t - this.pauseTime : this.startTime || (this.startTime = t), this.cancelTimestamp = this.startTime, this.pauseTime = void 0, this.frameRequestId = requestAnimationFrame(this.tick)
        }
        pause() {
            this.playState = "paused", this.pauseTime = this.t
        }
        finish() {
            this.playState = "finished", this.tick(0)
        }
        stop() {
            var t;
            this.playState = "idle", void 0 !== this.frameRequestId && cancelAnimationFrame(this.frameRequestId), null === (t = this.reject) || void 0 === t || t.call(this, !1)
        }
        cancel() {
            this.stop(), this.tick(this.cancelTimestamp)
        }
        reverse() {
            this.rate *= -1
        }
        commitStyles() { }
        updateDuration(t) {
            this.duration = t, this.totalDuration = t * (this.repeat + 1)
        }
        get currentTime() {
            return this.t
        }
        set currentTime(t) {
            void 0 !== this.pauseTime || 0 === this.rate ? this.pauseTime = t : this.startTime = performance.now() - t / this.rate
        }
        get playbackRate() {
            return this.rate
        }
        set playbackRate(t) {
            this.rate = t
        }
    }
    class yc {
        setAnimation(t) {
            this.animation = t, null == t || t.finished.then(() => this.clearAnimation()).catch(() => { })
        }
        clearAnimation() {
            this.animation = this.generator = void 0
        }
    }
    const bc = new WeakMap;

    function xc(t) {
        return bc.has(t) || bc.set(t, {
            transforms: [],
            values: new Map
        }), bc.get(t)
    }
    const _c = ["", "X", "Y", "Z"],
        wc = {
            x: "translateX",
            y: "translateY",
            z: "translateZ"
        },
        Sc = {
            syntax: "<angle>",
            initialValue: "0deg",
            toDefaultUnit: t => t + "deg"
        },
        Mc = {
            translate: {
                syntax: "<length-percentage>",
                initialValue: "0px",
                toDefaultUnit: t => t + "px"
            },
            rotate: Sc,
            scale: {
                syntax: "<number>",
                initialValue: 1,
                toDefaultUnit: Kl
            },
            skew: Sc
        },
        Ec = new Map,
        Tc = t => "--motion-" + t,
        Cc = ["x", "y", "z"];
    ["translate", "scale", "rotate", "skew"].forEach(t => {
        _c.forEach(e => {
            Cc.push(t + e), Ec.set(Tc(t + e), Mc[t])
        })
    });
    const Ac = (t, e) => Cc.indexOf(t) - Cc.indexOf(e),
        Rc = new Set(Cc),
        Pc = t => Rc.has(t),
        Lc = t => t.sort(Ac).reduce(Oc, "").trim(),
        Oc = (t, e) => `${t} ${e}(var(${Tc(e)}))`,
        Dc = t => t.startsWith("--"),
        Ic = new Set;
    const kc = (t, e) => document.createElement("div").animate(t, e),
        Nc = {
            cssRegisterProperty: () => "undefined" != typeof CSS && Object.hasOwnProperty.call(CSS, "registerProperty"),
            waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate"),
            partialKeyframes: () => {
                try {
                    kc({
                        opacity: [1]
                    })
                } catch (t) {
                    return !1
                }
                return !0
            },
            finished: () => Boolean(kc({
                opacity: [0, 1]
            }, {
                duration: .001
            }).finished),
            linearEasing: () => {
                try {
                    kc({
                        opacity: 0
                    }, {
                        easing: "linear(0, 1)"
                    })
                } catch (t) {
                    return !1
                }
                return !0
            }
        },
        Uc = {},
        zc = {};
    for (const t in Nc) zc[t] = () => (void 0 === Uc[t] && (Uc[t] = Nc[t]()), Uc[t]);
    const Fc = (t, e) => dc(t) ? zc.linearEasing() ? `linear(${((t, e) => { let n = ""; const i = Math.round(e / .015); for (let e = 0; e < i; e++)n += t(ac(0, i - 1, e)) + ", "; return n.substring(0, n.length - 2) })(t, e)})` : Wl.easing : pc(t) ? $c(t) : t,
        $c = ([t, e, n, i]) => `cubic-bezier(${t}, ${e}, ${n}, ${i})`;

    function Bc(t) {
        return wc[t] && (t = wc[t]), Pc(t) ? Tc(t) : t
    }
    const Hc = (t, e) => {
        e = Bc(e);
        let n = Dc(e) ? t.style.getPropertyValue(e) : getComputedStyle(t)[e];
        if (!n && 0 !== n) {
            const t = Ec.get(e);
            t && (n = t.initialValue)
        }
        return n
    },
        jc = (t, e, n) => {
            e = Bc(e), Dc(e) ? t.style.setProperty(e, n) : t.style[e] = n
        };

    function Vc(t, e, n, i = {}, r) {
        const s = window.__MOTION_DEV_TOOLS_RECORD,
            a = !1 !== i.record && s;
        let o, {
            duration: l = Wl.duration,
            delay: c = Wl.delay,
            endDelay: h = Wl.endDelay,
            repeat: u = Wl.repeat,
            easing: d = Wl.easing,
            persist: p = !1,
            direction: f,
            offset: m,
            allowWebkitAcceleration: g = !1
        } = i;
        const v = xc(t),
            y = Pc(e);
        let b = zc.waapi();
        y && ((t, e) => {
            wc[e] && (e = wc[e]);
            const {
                transforms: n
            } = xc(t);
            var i, r;
            r = e, -1 === (i = n).indexOf(r) && i.push(r), t.style.transform = Lc(n)
        })(t, e);
        const x = Bc(e),
            _ = function (t, e) {
                return t.has(e) || t.set(e, new yc), t.get(e)
            }(v.values, x),
            w = Ec.get(x);
        return Zl(_.animation, !(nc(d) && _.generator) && !1 !== i.record), () => {
            const v = () => {
                var e, n;
                return null !== (n = null !== (e = Hc(t, x)) && void 0 !== e ? e : null == w ? void 0 : w.initialValue) && void 0 !== n ? n : 0
            };
            let S = function (t, e) {
                for (let n = 0; n < t.length; n++) null === t[n] && (t[n] = n ? t[n - 1] : e());
                return t
            }((t => Array.isArray(t) ? t : [t])(n), v);
            const M = function (t, e) {
                var n;
                let i = (null == e ? void 0 : e.toDefaultUnit) || Kl;
                const r = t[t.length - 1];
                if ("string" == typeof r) {
                    const t = (null === (n = r.match(/(-?[\d.]+)([a-z%]*)/)) || void 0 === n ? void 0 : n[2]) || "";
                    t && (i = e => e + t)
                }
                return i
            }(S, w);
            if (nc(d)) {
                const t = d.createAnimation(S, "opacity" !== e, v, x, _);
                d = t.easing, S = t.keyframes || S, l = t.duration || l
            }
            if (Dc(x) && (zc.cssRegisterProperty() ? function (t) {
                if (!Ic.has(t)) {
                    Ic.add(t);
                    try {
                        const {
                            syntax: e,
                            initialValue: n
                        } = Ec.has(t) ? Ec.get(t) : {};
                        CSS.registerProperty({
                            name: t,
                            inherits: !1,
                            syntax: e,
                            initialValue: n
                        })
                    } catch (t) { }
                }
            }(x) : b = !1), y && !zc.linearEasing() && (dc(d) || rc(d) && d.some(dc)) && (b = !1), b) {
                w && (S = S.map(t => ic(t) ? w.toDefaultUnit(t) : t)), 1 !== S.length || zc.partialKeyframes() && !a || S.unshift(v());
                const e = {
                    delay: ql(c),
                    duration: ql(l),
                    endDelay: ql(h),
                    easing: rc(d) ? void 0 : Fc(d, l),
                    direction: f,
                    iterations: u + 1,
                    fill: "both"
                };
                o = t.animate({
                    [x]: S,
                    offset: m,
                    easing: rc(d) ? d.map(t => Fc(t, l)) : void 0
                }, e), o.finished || (o.finished = new Promise((t, e) => {
                    o.onfinish = t, o.oncancel = e
                }));
                const n = S[S.length - 1];
                o.finished.then(() => {
                    p || (jc(t, x, n), o.cancel())
                }).catch(Yl), g || (o.playbackRate = 1.000001)
            } else if (r && y) S = S.map(t => "string" == typeof t ? parseFloat(t) : t), 1 === S.length && S.unshift(parseFloat(v())), o = new r(e => {
                jc(t, x, M ? M(e) : e)
            }, S, Object.assign(Object.assign({}, i), {
                duration: l,
                easing: d
            }));
            else {
                const e = S[S.length - 1];
                jc(t, x, w && ic(e) ? w.toDefaultUnit(e) : e)
            }
            return a && s(t, e, S, {
                duration: l,
                delay: c,
                easing: d,
                repeat: u,
                offset: m
            }, "motion-one"), _.setAnimation(o), o
        }
    }
    const Gc = (t, e) => t[e] ? Object.assign(Object.assign({}, t), t[e]) : Object.assign({}, t);

    function Wc(t, e, n) {
        return dc(t) ? t(e, n) : t
    }
    const qc = (Xc = vc, function (t, e, n = {}) {
        const i = (t = function (t, e) {
            var n;
            return "string" == typeof t ? e ? (null !== (n = e[t]) && void 0 !== n || (e[t] = document.querySelectorAll(t)), t = e[t]) : t = document.querySelectorAll(t) : t instanceof Element && (t = [t]), Array.from(t || [])
        }(t)).length;
        Boolean(i), Boolean(e);
        const r = [];
        for (let s = 0; s < i; s++) {
            const a = t[s];
            for (const t in e) {
                const o = Gc(n, t);
                o.delay = Wc(o.delay, s, i);
                const l = Vc(a, t, e[t], o, Xc);
                r.push(l)
            }
        }
        return Ql(r, n, n.duration)
    });
    var Xc;

    function Yc(t, e = {}) {
        return Ql([() => {
            const n = new vc(t, [0, 1], e);
            return n.finished.catch(() => { }), n
        }], e, e.duration)
    }

    function Kc(t, e, n) {
        return (dc(t) ? Yc : qc)(t, e, n)
    }
    var Zc = n(21),
        Jc = n.n(Zc);
    jl.a;
    const Qc = {
        fadeIn: function (t, e) {
            const n = $(t);
            n.removeClass("is-hidden");
            const i = Jc()({
                easing: Gl.easeOut,
                duration: jl.a.slow,
                delay: 0
            }, e);
            return i.easing = Gl.get(i.easing), i.duration = jl.a[i.duration], Kc(n.get(0), {
                opacity: [0, 1]
            }, i)
        },
        fadeOut: function (t, e) {
            const n = $(t);
            n.removeClass("is-hidden");
            const i = Jc()({
                easing: Gl.easeIn,
                duration: jl.a.slow
            }, e);
            return i.easing = Gl.get(i.easing), i.duration = jl.a[i.duration], Kc(n.get(0), {
                opacity: [null, 0]
            }, i)
        },
        none: function () {
            return {
                finished: Promise.resolve(),
                pause: () => null,
                play: () => null,
                finish: () => null,
                cancel: () => null,
                stop: () => null,
                currentTime: 0,
                duration: 0,
                playbackRate: 1,
                playState: "finished"
            }
        },
        textIn: function (t, e, n) {
            const i = $(t);
            i.removeClass("is-hidden");
            let r = {};
            r = n.direction < 0 ? {
                transform: ["translateY(-130%)", "translateY(0%)"]
            } : {
                transform: ["translateY(130%)", "translateY(0%)"]
            };
            const s = Jc()({
                easing: Gl.easeIn,
                duration: jl.a.title
            }, e);
            return s.easing = Gl.get(s.easing), Kc(i.get(0), r, s)
        },
        textOut: function (t, e, n) {
            const i = $(t);
            i.removeClass("is-hidden");
            let r = {};
            r = n.direction < 0 ? {
                transform: ["translateY(0%)", "translateY(130%)"]
            } : {
                transform: ["translateY(0%)", "translateY(-130%)"]
            };
            const s = Jc()({
                easing: Gl.easeIn,
                duration: jl.a.title
            }, e);
            return s.easing = Gl.get(s.easing), Kc(i.get(0), r, s)
        },
        galleryOut: function (t, e, n) {
            let i = $(t);
            const {
                next: r,
                prev: s,
                direction: a
            } = n;
            i.removeClass("is-hidden");
            let o = {};
            a < 0 ? o = {
                clipPath: ["polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)", "polygon(50% 50%, 50% 50%, 50% 50%, 50% 50%)"],
                transform: ["scale(1)", "scale(1.5)"]
            } : (i = $(t).find(".js-image-shade"), o = {
                opacity: [0, 1]
            }, s.zIndex = r.zIndex - 1, s.zIndexAuto = !1);
            const l = Jc()({
                easing: Gl.easeInOut,
                duration: jl.a.slide
            }, e);
            return Kc(i.get(0), o, l)
        },
        galleryIn: function (t, e, n) {
            let i = $(t);
            const {
                next: r,
                prev: s,
                direction: a
            } = n;
            i.removeClass("is-hidden");
            let o = {};
            if (a < 0) i = $(t).find(".js-image-shade"), o = {
                opacity: [1, 0]
            }, r.zIndex = s.zIndex - 1, r.zIndexAuto = !1;
            else {
                const e = $(t).find(".js-image-shade");
                1 == e.css("opacity") && e.css("opacity", 0), o = {
                    clipPath: ["polygon(50% 50%, 50% 50%, 50% 50%, 50% 50%)", "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)"],
                    transform: ["scale(1.5)", "scale(1)"]
                }, r.zIndex = s.zIndex + 1, r.zIndexAuto = !1
            }
            const l = Jc()({
                easing: Gl.easeInOut,
                duration: jl.a.slide
            }, e);
            return Kc(i.get(0), o, l)
        },
        slideIn: function (t, e, n) {
            const i = $(t);
            let r = {};
            r = n.direction < 0 ? {
                clipPath: ["polygon(0% 0%, 0% 0%, 0% 100%, 0% 100%)", "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)"]
            } : {
                clipPath: ["polygon(100% 0%, 100% 0%, 100% 100%, 100% 100%)", "polygon(100% 0%, 0% 0%, 0% 100%, 100% 100%)"]
            }, i.removeClass("is-hidden");
            const s = Jc()({
                easing: Gl.easeOut,
                duration: jl.a.title
            }, e);
            return s.easing = Gl.get(s.easing), Kc(i.get(0), r, s)
        },
        slideOut: function (t, e, n) {
            const i = $(t);
            n.direction;
            let r = {};
            r = {
                transform: ["translateX(0%)"]
            }, i.removeClass("is-hidden");
            const s = Jc()({
                easing: Gl.easeOut,
                duration: jl.a.title
            }, e);
            return s.easing = Gl.get(s.easing), Kc(i.get(0), r, s)
        }
    };
    var th = n(46),
        eh = n.n(th);
    var nh = n(23);
    const ih = {
        controller: class extends Bl {
            init() {
                this.$controller = this.$container.findElement(this.options.controllerSelector) || this.$container, this.$next = this.$container.findElement(this.options.nextSelector) || $(), this.$prev = this.$container.findElement(this.options.prevSelector) || $(), this.$link = this.$container.findElement(this.options.linkSelector) || $()
            }
            enable() {
                this.$next.on(`click.${this.ns} returnkey.${this.ns}`, this.next.bind(this)), this.$prev.on(`click.${this.ns} returnkey.${this.ns}`, this.prev.bind(this)), this.$link.on(`click.${this.ns} returnkey.${this.ns}`, this.handleLinkClick.bind(this));
                const t = this.options.controllerPlugins.split(" ");
                t.includes("tabs") && this.$controller.on("change.tabs." + this.ns, this.handleTabChange.bind(this)), t.includes("carousel") && this.$controller.on("change.carousel." + this.ns, this.handleCarouselChange.bind(this)), t.includes("mobileScrollable") && this.$controller.on("change.mobile-scrollable." + this.ns, this.handleMobileScrollableChange.bind(this)), t.includes("contentAnimation") && this.$controller.on("change.animation." + this.ns, this.handleContentAnimationChange.bind(this))
            }
            disable() {
                this.$controller.off(`change.tabs.${this.ns}, change.carousel.${this.ns}, change.mobile-scrollable.${this.ns}, change.animation.${this.ns}`)
            }
            openByIndex(t, e) {
                this.items[t] ? this.parent.open(this.items[t].id, e) : console.error(`In $.fn.contentAnimation openByIndex(${t}) index out of bounds, there are ${this.items.length} items in the list.`)
            }
            next() {
                const t = this.items.length,
                    e = (this.parent.getIndex() + 1) % t;
                this.parent.isItemAnimating(e) || this.parent.openByIndex(e, {
                    direction: 1
                })
            }
            prev() {
                const t = this.items.length,
                    e = (this.parent.getIndex() + t - 1) % t;
                this.parent.isItemAnimating(e) || this.parent.openByIndex(e, {
                    direction: -1
                })
            }
            handleTabChange(t, e) {
                this.parent.open(e.id)
            }
            handleCarouselChange(t, e) {
                "number" != typeof e.index || isNaN(e.index) || this.openByIndex(e.index)
            }
            handleMobileScrollableChange(t, e) {
                "number" != typeof e.index || isNaN(e.index) || this.openByIndex(e.index)
            }
            handleContentAnimationChange(t, e) {
                this.$container.is(t.currentTarget) || this.parent.open(e.current.id, {
                    direction: e.data.direction
                })
            }
            handleLinkClick(t) {
                const e = $(t.currentTarget),
                    n = e.data("contentAnimationId"),
                    i = e.data("contentAnimationIndex");
                (n || 0 === n) && (this.parent.open(n), t.preventDefault()), "number" != typeof i || isNaN(i) || (this.openByIndex(i), t.preventDefault())
            }
            open(t) {
                const e = this.options.activeLinkClassName,
                    n = this.parent.getIndex(t);
                if (e) {
                    const i = this.$container.findElement(this.options.linkSelector);
                    if (i)
                        for (let r = 0; r < i.length; r++) {
                            const s = i.eq(r),
                                a = s.data("contentAnimationId"),
                                o = s.data("contentAnimationIndex");
                            (t || 0 === t) && a === t || o === n ? s.addClass(e) : s.removeClass(e)
                        }
                }
            }
        },
        events: class extends Bl {
            emit(t, e, n) {
                const i = this.items,
                    r = this.itemsStack.map(t => ({
                        index: t,
                        id: i[t].id,
                        state: i[t].state,
                        element: i[t].$item
                    }));
                e.$item.trigger(t, {
                    current: {
                        index: e.index,
                        id: e.id,
                        state: e.state,
                        element: e.$item
                    },
                    data: n,
                    visible: r
                })
            }
            onClose(t, e) {
                this.emit("close.animation", t, e)
            }
            onClosed(t) {
                this.emit("closed.animation", t), this.emit("appear", t)
            }
            onOpen(t, e) {
                this.emit("open.animation", t, e), this.emit("change.animation", t, e)
            }
            onOpened(t) {
                this.emit("opened.animation", t), this.emit("changed.animation", t), this.emit("appear", t)
            }
            onSwap(t) {
                this.onOpen(t), this.onOpened(t), this.emit("swap.animation", t)
            }
        },
        stack: class extends Bl {
            constructor(t) {
                super(t), this._items = null, this._itemsStack = null
            }
            _findItems() {
                const t = this.$container.find(this.options.itemSelector);
                return cl()(t.toArray(), (t, e) => {
                    const n = Object(xo.a)(t);
                    let i = n.hasClass("is-hidden") ? "invisible" : "visible";
                    return this.options.aria && "true" === n.attr("aria-hidden") && (i = "invisible"), {
                        $item: n,
                        state: i,
                        stackState: i,
                        id: n.data("contentAnimationItem"),
                        index: e,
                        zIndex: 0,
                        zIndexAuto: !0,
                        animation: null
                    }
                })
            }
            getItems() {
                return this._items || (this._items = this._findItems())
            }
            getItemsStack() {
                return this._itemsStack || (this._itemsStack = this.items.filter(t => "visible" === t.state).map(t => t.index)), this._itemsStack
            }
            stackAdd(t) {
                const e = this.itemsStack;
                this.items[t].state = "animating-in", e[e.length - 1] !== t && (Hl(e, t), e.push(t))
            }
            stackRemove(t) {
                t.animation && (t.animation.cancel(), t.animation = null), t.state = "invisible", Hl(this.itemsStack, t.index), this.parent.onClosed(t)
            }
            getIndex(t) {
                if (void 0 === t) return this.getIndex(this.getActiveItemId());
                {
                    const e = this.items;
                    for (let n = 0; n < e.length; n++)
                        if (e[n].id === t) return e[n].index;
                    return -1
                }
            }
            getActiveItemId() {
                const t = this.items,
                    e = this.itemsStack;
                for (let n = e.length - 1; n >= 0; n--)
                    if ("animating-in" === t[e[n]].state || "visible" === t[e[n]].state) return t[e[n]].id;
                return null
            }
            isItemAnimating(t) {
                const e = this.items[this.getIndex(t)];
                if (e) return "animating-in" === e.state || "animating-out" === e.state
            }
            onChange() {
                const t = this.items,
                    e = this.itemsStack;
                let n = -1;
                for (let i = e.length - 1; i >= 0; i--) - 1 !== n ? t[e[i]].state = "invisible" : "visible" === t[e[i]].state && (n = i);
                for (let e = 0; e < t.length; e++) {
                    const n = t[e];
                    "invisible" !== n.stackState && "invisible" === n.state ? this.stackRemove(n) : "invisible" === n.stackState && "invisible" !== n.state && this.parent.onOpened(n), n.stackState = n.state
                }
            }
        },
        animation: class extends Bl {
            open(t, e) {
                const n = this.parent.getIndex(t),
                    i = this.itemsStack,
                    r = this.items,
                    s = -1 !== n ? r[n] : null,
                    a = {
                        open: [],
                        close: []
                    };
                if (s) {
                    if (i[i.length - 1] !== s.index || "animating-in" !== s.state && "visible" !== s.state) {
                        this.parent.stackAdd(n);
                        const t = this.getAnimationName(n, "animating-in");
                        t && a.open.push({
                            item: s,
                            animationName: t,
                            data: e
                        })
                    }
                }
                const o = !!this.options.animations.changeHide;
                if (!s || o) {
                    const s = [].concat(i);
                    for (let i = 0; i < s.length; i++) {
                        const l = r[s[i]];
                        if (!l || l.id !== t)
                            if (!o && i < s.length - 2) this.parent.stackRemove(l);
                            else if ("animating-in" === l.state || "visible" === l.state) {
                                const t = this.getAnimationName(n, "animating-out");
                                t && (l.state = "animating-out", a.close.push({
                                    item: l,
                                    animationName: t,
                                    data: e
                                }))
                            }
                    }
                }
                for (let t = 0; t < a.open.length; t++) {
                    const e = a.open[t],
                        n = a.close.length ? a.close[0].item : null;
                    this.animateOpen(e.item, e.animationName, {
                        current: e.item,
                        next: e.item,
                        prev: n,
                        count: r.length,
                        direction: this.getDirection(n, e.item, r.length, e.data)
                    })
                }
                for (let t = 0; t < a.close.length; t++) {
                    const e = a.close[t],
                        n = a.open.length ? a.open[0].item : null;
                    this.animateClose(e.item, e.animationName, {
                        current: e.item,
                        next: n,
                        prev: e.item,
                        count: r.length,
                        direction: this.getDirection(e.item, n, r.length, e.data)
                    })
                }
                this.parent.onChange()
            }
            swap(t) {
                const e = this.parent.getIndex(t),
                    n = this.itemsStack,
                    i = this.items,
                    r = -1 !== e ? i[e] : null,
                    s = [].concat(n);
                for (let t = 0; t < s.length; t++) {
                    const e = i[s[t]];
                    e.id !== r.id && (e.animation && (e.animation.finish(), e.animation = null), this.parent.stackRemove(e), this.parent.onChange())
                }
                r && (this.parent.stackAdd(e), r.state = "visible", r.animation && (r.animation.finish(), r.animation = null), this.parent.onChange(), this.parent.onSwap(r))
            }
            animateOpen(t, e, n) {
                this.parent.onOpen(t, n), this.animate(t, e, n).then(this.afterAnimateOpen.bind(this, t))
            }
            afterAnimateOpen(t) {
                "animating-in" === t.state && (t.state = "visible", this.parent.onChange(), this.parent.onOpened(t))
            }
            animateClose(t, e, n) {
                this.parent.onClose(t, n), this.animate(t, e, n).then(this.afterAnimateClose.bind(this, t))
            }
            afterAnimateClose(t) {
                "animating-out" === t.state && (t.state = "invisible", this.parent.onChange(), this.parent.onClosed(t))
            }
            animate(t, e, n) {
                const i = "string" == typeof e ? e : e.name,
                    r = "string" == typeof e ? {} : eh()(e, ["name"]);
                if (i in Qc) {
                    const e = Qc[i](t.$item, r, n);
                    return t.animation = e, e.finished.then(() => {
                        const e = (t.$item.attr("style") || "").replace(/(^\s*[a-z][^;]+|;\s*[a-z][^;]+)/g, "");
                        t.$item.attr("style", e).css("z-index", t.zIndex)
                    }), e.finished
                }
                console.warn(`$.fn.contentAnimation couldn't find animation "${i}"`, this.$container.get(0))
            }
            getAnimationName(t, e) {
                const n = this.itemsStack,
                    i = this.options.animations;
                return -1 !== t ? n.length > 1 ? "animating-in" === e ? i.changeShow : i.changeHide : i.show : i.hide
            }
            getDirection(t, e, n, i) {
                if (i && (1 === i.direction || -1 === i.direction)) return i.direction;
                if (n > 2 && t && e) {
                    if (t.index === n - 1 && 0 === e.index) return 1;
                    if (0 === t.index && e.index === n - 1) return -1
                } else if (!t || !e) return 1;
                return e.index > t.index ? 1 : -1
            }
        },
        styles: class extends Bl {
            init() {
                this.items.forEach(t => {
                    this.options.aria && t.$item.attr("aria-hidden", "visible" !== t.state), t.$item.attr("data-content-animation-" + t.state, !0), "visible" === t.state && t.$item.attr("data-content-animation-top", !0), t.visualState = t.state
                })
            }
            enable() {
                this.options.readyClassName && this.parent.$list.addClass(this.options.readyClassName)
            }
            disable() {
                this.options.readyClassName && this.parent.$list.removeClass(this.options.readyClassName)
            }
            onChange() {
                const t = this.items,
                    e = this.itemsStack;
                for (let e = 0; e < t.length; e++) {
                    const n = t[e];
                    n.visualState !== n.state && ("invisible" === n.state ? n.$item.addClass("is-hidden") : "invisible" !== n.state && n.$item.removeClass("is-hidden"), this.options.aria && ("animating-in" === n.state || "visible" === n.state ? n.$item.attr("aria-hidden", !1) : n.$item.attr("aria-hidden", !0)), "animating-in" === n.state || "visible" === n.state ? n.$item.attr("data-content-animation-top", !0) : n.$item.removeAttr("data-content-animation-top"), n.$item.removeAttr("data-content-animation-" + n.visualState).attr("data-content-animation-" + n.state, !0), n.visualState = n.state)
                }
                for (let n = 0; n < t.length; n++) {
                    const i = t[n];
                    i.zIndexAuto && (i.zIndex = e.indexOf(i.index) + 1), i.$item.css("z-index", i.zIndex)
                }
            }
        },
        height: class extends Bl {
            init() {
                this.animation = null, this.maxHeight = 0, this.heightPending = !1, this.heightPendingInView = null
            }
            enable() {
                this.handleResize(), $(window).on("resize." + this.ns, Il()(this.handleResize.bind(this), 60))
            }
            disable() {
                $(window).off("resize." + this.ns), this.parent.$list.css("height", ""), this.animation && (this.animation.stop(), this.parent.$list.css("height", ""), this.animation = null)
            }
            handleResize() {
                if (this.options.fixedHeight)
                    if (this.$container.get(0).offsetParent) {
                        let t = this.maxHeight = 0;
                        this.items.forEach(e => {
                            const n = e.$item.hasClass("is-hidden");
                            e.$item.css("overflow", "hidden"), n && e.$item.removeClass("is-hidden"), t = this.maxHeight = Math.max(t, e.$item.outerHeight()), n && e.$item.addClass("is-hidden"), e.$item.css("overflow", "")
                        }), this.parent.$list.css("height", t), this.heightPending = !1
                    } else this.heightPending = !0, this.waitForInView()
            }
            waitForInView() {
                this.heightPendingInView || (this.heightPendingInView = new nh.a(this.$container, {
                    enter: () => {
                        this.heightPendingInView.destroy(), this.heightPendingInView = null, this.handleResize()
                    }
                }))
            }
            beforeOpen() {
                if (!this.options.fixedHeight) {
                    const t = this.parent.$list;
                    t.css("height", t.outerHeight())
                }
            }
            open(t) {
                if (!this.options.fixedHeight) {
                    const e = this.parent.getIndex(t),
                        n = this.items,
                        i = -1 !== e ? n[e] : null,
                        r = i ? i.$item.outerHeight() : 0;
                    let s = 0;
                    this.items.forEach(t => {
                        t.animation && (s = Math.max(s, t.animation.duration || 0))
                    }), this.animation && this.animation.stop(), this.animation = function (t, e) {
                        const n = $(t);
                        n.removeClass("is-hidden");
                        const i = Jc()({
                            height: 0,
                            easing: Gl.easeInOut,
                            duration: jl.a.slow
                        }, e),
                            r = {
                                height: [n.outerHeight() + "px", i.height + "px"]
                            };
                        return i.easing = Gl.get(i.easing), Kc(n.get(0), r, i)
                    }(this.parent.$list, {
                        height: r,
                        duration: s
                    }), this.animation.finished.then(() => {
                        this.animation = null, this.parent.$list.css("height", "")
                    })
                }
            }
        },
        counter: class extends Bl {
            init() {
                this.$counter = this.$container.findElement(this.options.counterSelector), this.previousIndex = this.parent.getIndex(), this.absoluteIndex = this.previousIndex
            }
            beforeOpen() {
                this.previousIndex = this.parent.getIndex()
            }
            open(t) {
                const e = this.items.length,
                    n = this.previousIndex,
                    i = this.parent.getIndex(t);
                let r = this.absoluteIndex;
                this.absoluteIndex = 0 === i && n === e - 1 ? ++r : i === e - 1 && 0 === n ? --r : r = Math.floor(r / e) * e + i, this.$container.css("--content-animation-index", i), this.$container.css("--content-animation-absolute-index", r);
                const s = this.$counter;
                s && s.text(i + 1)
            }
            swap(t) {
                this.open(t)
            }
        },
        scroll: class extends Bl {
            init() {
                this.fontSize = parseFloat(Object(xo.a)(document).offsetParent().css("font-size"), 10) || 16, this.pageSize = Object(xo.a)(document).height(), this.isSwiping = !1, this.touchStartY = null, this.scrollFreeze = !1, this.scrollFreezeHandle = null
            }
            enable() {
                Object(xo.a)(document).on(`mousewheel.${this.ns} wheel.${this.ns}`, Il()(this.handleMouseWheel.bind(this), 250, {
                    leading: !0,
                    trailing: !1
                })), Object(xo.a)(document).on("touchstart." + this.ns, this.handleTouchStart.bind(this)), Object(xo.a)(document).on("touchmove." + this.ns, this.handleTouchMove.bind(this))
            }
            disable() {
                Object(xo.a)(document).off(`mousewheel.${this.ns} wheel.${this.ns} touchstart.${this.ns} touchmove.${this.ns}`)
            }
            next() {
                const t = this.items.length,
                    e = (this.parent.getIndex() + 1) % t;
                this.parent.open(this.items[e].id, {
                    direction: 1
                })
            }
            prev() {
                const t = this.items.length,
                    e = (this.parent.getIndex() + t - 1) % t;
                this.parent.open(this.items[e].id, {
                    direction: -1
                })
            }
            beforeOpen() {
                this.preventMouseWheel()
            }
            isValidTarget(t) {
                const e = Object(xo.a)(t.target).closest(".modal, input, textarea, select"),
                    n = this.parent.$container.closest(".modal, input, textarea, select");
                return !(e.length && !e.is(n))
            }
            handleMouseWheel(t, e) {
                if (this.scrollFreeze || !this.isValidTarget(t)) return;
                this.getMouseWheelDeltaY(t) < 0 ? this.next() : this.prev()
            }
            getMouseWheelDeltaY(t) {
                const e = t.originalEvent;
                let n = "deltaY" in e ? -1 * e.deltaY : e.wheelDeltaY;
                return 1 === e.deltaMode ? n *= this.fontSize : 2 === e.deltaMode && (n *= this.pageSize), n
            }
            preventMouseWheel() {
                this.scrollFreezeHandle && clearTimeout(this.scrollFreezeHandle), this.scrollFreeze = !0, this.scrollFreezeHandle = setTimeout(() => {
                    this.scrollFreeze = !1, this.scrollFreezeHandle = null
                }, 1250)
            }
            handleTouchStart(t) {
                !this.scrollFreeze && this.isValidTarget(t) && (this.isSwiping = !0, this.touchStartY = this.getInputPosition(t))
            }
            handleTouchMove(t) {
                if (this.scrollFreeze || !this.isSwiping) return;
                const e = this.getInputPosition(t) - this.touchStartY;
                Math.abs(e) > .1 * window.innerHeight && (e < 0 ? this.next() : this.prev())
            }
            getInputPosition(t) {
                const e = (t = t.originalEvent ? t.originalEvent : t).touches ? t.touches[0] : t;
                return e ? e.pageY : 0
            }
        }
    };
    class rh extends $l.a {
        static get Defaults() {
            return xo.a.extend({}, $l.a.Defaults, {
                plugins: "controller events",
                listSelector: ".content-animation",
                readyClassName: "content-animation--ready",
                itemSelector: "[data-content-animation-item]",
                itemData: "contentAnimationItem",
                fixedHeight: !1,
                controllerSelector: null,
                controllerPlugins: "tabs carousel mobileScrollable contentAnimation",
                nextSelector: ".js-content-animation-next",
                prevSelector: ".js-content-animation-prev",
                linkSelector: ".js-content-animation-link",
                activeLinkClassName: "is-active",
                aria: !0,
                counterSelector: ".js-content-animation-counter",
                resetStyles: !0,
                itemsCount: null,
                animations: {
                    show: "textInBottom",
                    changeShow: "textInBottom",
                    changeHide: null,
                    hide: "fadeOut"
                }
            })
        }
        constructor(t, e) {
            return super(t, e), this.open = Il()(this.open.bind(this), 16), this.proxy
        }
        open(t, e) {
            this.callPlugins("beforeOpen", t, e), this.callPlugins("open", t, e)
        }
        swap(t) {
            this.callPlugins("swap", t)
        }
        init() {
            this.plugins = [], this.proxy = new Proxy(this, {
                get: this._getter.bind(this)
            }), this.$list = this.$container.findElement(this.options.listSelector) || this.$container, this.initPlugins()
        }
        _getter(t, e) {
            return e in t ? t[e] : this.callPlugins.bind(this, e)
        }
        enable() {
            super.enable() && this.callPlugins("enable")
        }
        disable() {
            super.disable() && this.callPlugins("disable")
        }
        initPlugins() {
            const t = Fl()(("stack styles animation " + this.options.plugins).split(" ")),
                e = [],
                n = this.proxy;
            for (let i = 0; i < t.length; i++)
                if (t[i] in ih) {
                    const r = new ih[t[i]](n);
                    r && e.push(r)
                } this.plugins = e, this.callPlugins("init")
        }
        callPlugins(t) {
            for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
            let r;
            return this.plugins.forEach(e => {
                if ("function" == typeof e[t]) {
                    const i = e[t].apply(e, n);
                    void 0 !== i && (r = i)
                }
            }), r
        }
        getActiveItemId() {
            return this.callPlugins("getActiveItemId")
        }
    }
    xo.a.fn.contentAnimation = ol()(rh);
    n(135), n(87), n(107), n(68);
    const sh = ["onMaska", "preProcess", "postProcess"];

    function ah(t, e) {
        if (null == t) return {};
        var n, i, r = function (t, e) {
            if (null == t) return {};
            var n, i, r = {},
                s = Object.keys(t);
            for (i = 0; i < s.length; i++) n = s[i], e.indexOf(n) >= 0 || (r[n] = t[n]);
            return r
        }(t, e);
        if (Object.getOwnPropertySymbols) {
            var s = Object.getOwnPropertySymbols(t);
            for (i = 0; i < s.length; i++) n = s[i], e.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(t, n) && (r[n] = t[n])
        }
        return r
    }

    function oh(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(t);
            e && (i = i.filter((function (e) {
                return Object.getOwnPropertyDescriptor(t, e).enumerable
            }))), n.push.apply(n, i)
        }
        return n
    }

    function lh(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = null != arguments[e] ? arguments[e] : {};
            e % 2 ? oh(Object(n), !0).forEach((function (e) {
                ch(t, e, n[e])
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : oh(Object(n)).forEach((function (e) {
                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
            }))
        }
        return t
    }

    function ch(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    /*! maska v2.1.6 | (c) Alexander Shabunevich | Released under the MIT license */
    var hh = Object.defineProperty,
        uh = (t, e, n) => (((t, e, n) => {
            e in t ? hh(t, e, {
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: n
            }) : t[e] = n
        })(t, "symbol" != typeof e ? e + "" : e, n), n);
    const dh = {
        "#": {
            pattern: /[0-9]/
        },
        "@": {
            pattern: /[a-zA-Z]/
        },
        "*": {
            pattern: /[a-zA-Z0-9]/
        }
    };
    class ph {
        constructor() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            var e;
            uh(this, "opts", {}), uh(this, "memo", new Map);
            const n = lh({}, t);
            if (null != n.tokens) {
                n.tokens = n.tokensReplace ? lh({}, n.tokens) : lh(lh({}, dh), n.tokens);
                for (const t of Object.values(n.tokens)) "string" == typeof t.pattern && (t.pattern = new RegExp(t.pattern))
            } else n.tokens = dh;
            Array.isArray(n.mask) && (n.mask.length > 1 ? n.mask.sort((t, e) => t.length - e.length) : n.mask = null != (e = n.mask[0]) ? e : ""), "" === n.mask && (n.mask = null), this.opts = n
        }
        masked(t) {
            return this.process(t, this.findMask(t))
        }
        unmasked(t) {
            return this.process(t, this.findMask(t), !1)
        }
        isEager() {
            return !0 === this.opts.eager
        }
        isReversed() {
            return !0 === this.opts.reversed
        }
        completed(t) {
            const e = this.findMask(t);
            if (null == this.opts.mask || null == e) return !1;
            const n = this.process(t, e).length;
            return "string" == typeof this.opts.mask ? n >= this.opts.mask.length : "function" == typeof this.opts.mask ? n >= e.length : this.opts.mask.filter(t => n >= t.length).length === this.opts.mask.length
        }
        findMask(t) {
            var e, n;
            const i = this.opts.mask;
            if (null == i) return null;
            if ("string" == typeof i) return i;
            if ("function" == typeof i) return i(t);
            const r = this.process(t, null != (e = i.slice(-1).pop()) ? e : "", !1);
            return null != (n = i.find(e => this.process(t, e, !1).length >= r.length)) ? n : ""
        }
        escapeMask(t) {
            const e = [],
                n = [];
            return t.split("").forEach((i, r) => {
                "!" === i && "!" !== t[r - 1] ? n.push(r - n.length) : e.push(i)
            }), {
                mask: e.join(""),
                escaped: n
            }
        }
        process(t, e) {
            let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            var i;
            if (null == e) return t;
            const r = `value=${t},mask=${e},masked=${n ? 1 : 0}`;
            if (this.memo.has(r)) return this.memo.get(r);
            const {
                mask: s,
                escaped: a
            } = this.escapeMask(e), o = [], l = null != this.opts.tokens ? this.opts.tokens : {}, c = this.isReversed() ? -1 : 1, h = this.isReversed() ? "unshift" : "push", u = this.isReversed() ? 0 : s.length - 1, d = this.isReversed() ? () => g > -1 && v > -1 : () => g < s.length && v < t.length, p = t => !this.isReversed() && t <= u || this.isReversed() && t >= u;
            let f, m = -1,
                g = this.isReversed() ? s.length - 1 : 0,
                v = this.isReversed() ? t.length - 1 : 0;
            for (; d();) {
                const e = s.charAt(g),
                    r = l[e],
                    d = null != (null == r ? void 0 : r.transform) ? r.transform(t.charAt(v)) : t.charAt(v);
                if (a.includes(g) || null == r) n && !this.isEager() && o[h](e), d !== e || this.isEager() ? f = e : v += c, this.isEager() || (g += c);
                else {
                    if (null != d.match(r.pattern)) o[h](d), r.repeated ? (-1 === m ? m = g : g === u && g !== m && (g = m - c), u === m && (g -= c)) : r.multiple && (g -= c), g += c;
                    else if (r.multiple) {
                        const t = null != (null == (i = o[v - c]) ? void 0 : i.match(r.pattern)),
                            e = s.charAt(g + c);
                        t && "" !== e && null == l[e] ? (g += c, v -= c) : o[h]("")
                    } else d === f ? f = void 0 : r.optional && (g += c, v -= c);
                    v += c
                }
                if (this.isEager())
                    for (; p(g) && (null == l[s.charAt(g)] || a.includes(g));) n ? o[h](s.charAt(g)) : s.charAt(g) === t.charAt(v) && (v += c), g += c
            }
            return this.memo.set(r, o.join("")), this.memo.get(r)
        }
    }
    const fh = t => JSON.parse(t.replaceAll("'", '"')),
        mh = function (t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const n = lh({}, e);
            return null != t.dataset.maska && "" !== t.dataset.maska && (n.mask = vh(t.dataset.maska)), null != t.dataset.maskaEager && (n.eager = gh(t.dataset.maskaEager)), null != t.dataset.maskaReversed && (n.reversed = gh(t.dataset.maskaReversed)), null != t.dataset.maskaTokensReplace && (n.tokensReplace = gh(t.dataset.maskaTokensReplace)), null != t.dataset.maskaTokens && (n.tokens = yh(t.dataset.maskaTokens)), n
        },
        gh = t => "" === t || Boolean(JSON.parse(t)),
        vh = t => t.startsWith("[") && t.endsWith("]") ? fh(t) : t,
        yh = t => {
            if (t.startsWith("{") && t.endsWith("}")) return fh(t);
            const e = {};
            return t.split("|").forEach(t => {
                const n = t.split(":");
                e[n[0]] = {
                    pattern: new RegExp(n[1]),
                    optional: "optional" === n[2],
                    multiple: "multiple" === n[2],
                    repeated: "repeated" === n[2]
                }
            }), e
        };
    class bh {
        constructor(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            uh(this, "items", new Map), uh(this, "beforeinputEvent", t => {
                const e = t.target,
                    n = this.items.get(e);
                n.isEager() && "inputType" in t && t.inputType.startsWith("delete") && n.unmasked(e.value).length <= 1 && this.setMaskedValue(e, "")
            }), uh(this, "inputEvent", t => {
                if (t instanceof CustomEvent && "input" === t.type && null != t.detail && "object" == typeof t.detail && "masked" in t.detail) return;
                const e = t.target,
                    n = this.items.get(e),
                    i = e.value,
                    r = e.selectionStart,
                    s = e.selectionEnd;
                let a = i;
                if (n.isEager()) {
                    const e = n.masked(i),
                        r = n.unmasked(i);
                    "" === r && "data" in t && null != t.data ? a = t.data : r !== n.unmasked(e) && (a = r)
                }
                if (this.setMaskedValue(e, a), "inputType" in t && (t.inputType.startsWith("delete") || null != r && r < i.length)) try {
                    e.setSelectionRange(r, s)
                } catch { }
            }), this.options = e, "string" == typeof t ? this.init(Array.from(document.querySelectorAll(t)), this.getMaskOpts(e)) : this.init("length" in t ? Array.from(t) : [t], this.getMaskOpts(e))
        }
        destroy() {
            for (const t of this.items.keys()) t.removeEventListener("input", this.inputEvent), t.removeEventListener("beforeinput", this.beforeinputEvent);
            this.items.clear()
        }
        needUpdate(t, e) {
            const n = this.items.get(t),
                i = new ph(mh(t, this.getMaskOpts(e)));
            return JSON.stringify(n.opts) !== JSON.stringify(i.opts)
        }
        getMaskOpts(t) {
            const {
                onMaska: e,
                preProcess: n,
                postProcess: i
            } = t;
            return ah(t, sh)
        }
        init(t, e) {
            for (const n of t) {
                const t = new ph(mh(n, e));
                this.items.set(n, t), "" !== n.value && this.setMaskedValue(n, n.value), n.addEventListener("input", this.inputEvent), n.addEventListener("beforeinput", this.beforeinputEvent)
            }
        }
        setMaskedValue(t, e) {
            const n = this.items.get(t);
            null != this.options.preProcess && (e = this.options.preProcess(e));
            const i = n.masked(e),
                r = {
                    masked: i,
                    unmasked: n.unmasked(n.isEager() ? i : e),
                    completed: n.completed(e)
                };
            e = i, null != this.options.postProcess && (e = this.options.postProcess(e)), t.value = e, t.dataset.maskaValue = e, null != this.options.onMaska && (Array.isArray(this.options.onMaska) ? this.options.onMaska.forEach(t => t(r)) : this.options.onMaska(r)), t.dispatchEvent(new CustomEvent("maska", {
                detail: r
            })), t.dispatchEvent(new CustomEvent("input", {
                detail: r
            }))
        }
    }
    xo.a.fn.inputMask = ol()((function (t, e) {
        const n = t.is("input") ? t : t.find("input");
        new bh(n.get(0), {
            mask: e.mask.trim()
        }), "+7 ### ### ## ##" == e.mask && n.focusin((function () {
            "" == n.val() && n.val("+7 ")
        }))
    }));
    n(228);
    var xh = n(47),
        _h = n.n(xh);

    function wh(t) {
        return ("string" == typeof t ? t : t.attr("class") || "").split(" ").filter(t => 0 === t.indexOf("ui-")).join(" ")
    }
    class Sh extends $l.a {
        static get Defaults() {
            return xo.a.extend({}, $l.a.Defaults, {
                enableMq: null,
                collapsedClassName: "header--collapsed ui-dark",
                expandedClassName: "",
                negativeOffset: 1,
                scrollOffset: 0,
                sticky: !0
            })
        }
        init() {
            this.height = 0, this.visible = !0, this.collapsed = !1, this.scrollPosition = 0, this.offsetPosition = 0, this.themeElements = {
                main: this.$container,
                left: this.$container.find(".js-header-left"),
                right: this.$container.find(".js-header-right")
            }, this.themeClassNames = {
                main: null,
                left: null,
                right: null
            }, this.isSticky = !1, this.transform = 0, this.animation = null
        }
        enable() {
            super.enable() && (this.setSticky(!0), this.handleResize(), this.handleScroll(), Object(xo.a)(window).on("resize." + this.ns, this.handleResize.bind(this)).on("scroll." + this.ns, this.handleScroll.bind(this)).on("close.modal." + this.ns, this.handleModalHide.bind(this)))
        }
        disable() {
            super.disable() && (Object(xo.a)(window).add(document).off("." + this.ns), this.setSticky(!1))
        }
        setSticky(t) {
            this.isSticky = this.options.sticky && t, t ? this.visible || this.collapse() : this.expand()
        }
        handleResize() {
            const t = Math.max(wo.a.isIOS() ? 20 : 1, this.options.negativeOffset);
            this.height = this.$container.outerHeight() + t
        }
        handleScroll() {
            const t = this.options.scrollOffset,
                e = Object(xo.a)(window).scrollTop(),
                n = Math.max(0, e - t),
                i = n - this.scrollPosition,
                r = Math.min(Math.max(this.offsetPosition + i, 0), this.height);
            if (this.isSticky) this.visible && r === this.height && this.collapse(), e < 10 && this.collapsed && this.expand(), this.setTransform(-r);
            else {
                let t = Math.min(Math.max(n, 0), this.height);
                this.setTransform(-t)
            }
            this.offsetPosition = r, this.scrollPosition = n
        }
        setTransform(t) {
            this.transform !== t && (this.visible = t !== -this.height, this.transform = t, this.$container.css("transform", `translateY(${t}px)`))
        }
        collapse() {
            this.collapsed || (this.collapsed = !0, this.themeClassNames = _h()(this.themeElements, (t, e, n) => (t[n] = wh(e), e.removeClass(t[n]), t), {}), this.$container.addClass(this.options.collapsedClassName).removeClass(this.options.expandedClassName))
        }
        expand() {
            this.collapsed && (this.collapsed = !1, this.$container.removeClass(this.options.collapsedClassName).addClass(this.options.expandedClassName), xl()(this.themeElements, (t, e) => {
                t.addClass(this.themeClassNames[e])
            }))
        }
        handleModalShow() {
            this.expand(), this.offsetPosition = 0, this.$container.css("transform", "translateY(0px)")
        }
        handleModalHide() {
            this.scrollPosition && this.collapse()
        }
    }
    xo.a.fn.stickyHeader = ol()(Sh);
    var Mh = n(62);
    class Eh extends $l.a {
        static get Defaults() {
            return xo.a.extend({}, $l.a.Defaults, {
                enableTouch: !1,
                enableOnlyInView: !0,
                enableMq: null,
                showDefaultCursor: !0,
                isModal: !1,
                isClickable: !0,
                showTransition: "fade-in fast",
                hideTransition: "fade-out fast",
                useWindowForMousemove: !0
            })
        }
        init() {
            const t = this.$container;
            this.options;
            this.nsglobal = Object(El.a)(), this.$targetContainer = t.find(".js-cursor-target-container"), this.$targetContainer.length || (this.$targetContainer = t), this.$buttonWrapper = t.find(".js-cursor-button"), this.$buttons = t.find(".js-cursor-button-inner"), this.isVisible = !1, this.isVisibleState = !1, this.isRight = !1, this.$stickyContainer = this.$targetContainer.closest("[data-scroll-sticky]"), this.isInSticky = !!this.$stickyContainer.length, this.$parallaxContainers = this.$buttonWrapper.parents('[data-plugin~="parallax"]').not("[data-scroll-sticky]"), this.isInParallax = !!this.$parallaxContainers.length, this.$scrollParent = t.scrollParent(), this.mouse = {
                x: 0,
                y: 0
            }, this.constraints = {
                width: 0,
                top: 0,
                x: 0,
                y: 0
            }, this.scroll = this.$scrollParent.scrollTop() - this.getStickyScrollAdjustment() - this.getParallaxAdjustment(), this.showTimer = null, this.hideTimer = null, this.cursor = new kl.a({
                mouseX: 0,
                x: 0,
                y: 0
            }, {
                strength: this.options.showDefaultCursor ? .25 : .9,
                update: this.updateStyles.bind(this)
            }), this.options.useWindowForMousemove ? Object(xo.a)(window).on("mousemove." + this.nsglobal, this.handleMouseMove.bind(this)) : this.$targetContainer.on("mousemove." + this.nsglobal, this.handleMouseMove.bind(this))
        }
        enable() {
            if (super.enable()) {
                const t = this.ns;
                Object(xo.a)(window).on("resize." + t, this.handleResize.bind(this)), Object(xo.a)(window).on("scroll." + t, this.handleScroll.bind(this)), this.$targetContainer.on("mouseenter." + t, this.showDelayed.bind(this)).on("mouseleave." + t, this.hideDelayed.bind(this)), this.$container.on("mouseenter." + t, ".js-cursor-hidden-spot", this.hideDelayed.bind(this)).on("mouseleave." + t, ".js-cursor-hidden-spot", this.showDelayed.bind(this)), this.$container.on("mouseenter." + t, ".js-cursor-zoom-spot", this.zoomIn.bind(this)).on("mouseleave." + t, ".js-cursor-zoom-spot", this.zoomOut.bind(this)), this.$buttonWrapper.addClass("is-invisible"), this.options.showDefaultCursor || this.$targetContainer.css("cursor", "none"), this.handleResize()
            }
        }
        disable() {
            if (super.disable()) {
                const t = this.ns;
                this.$container.add(this.$targetContainer).add(window).off("." + t), this.$container.css("cursor", "")
            }
        }
        destroy() {
            super.destroy(), Object(xo.a)(window).add(this.$targetContainer).off("." + this.nsglobal)
        }
        handleMouseMove(t) {
            this.options.useWindowForMousemove ? (this.mouse.x = t.clientX, this.mouse.y = t.clientY) : (this.mouse.x = t.offsetX, this.mouse.y = t.offsetY), this.enabled && (this.checkMousePosition(), this.updateAnimation())
        }
        checkMousePosition() {
            if (this.options.isClickable) {
                const t = Math.floor(this.constraints.targetTop - this.scroll),
                    e = Math.ceil(t + this.constraints.targetHeight),
                    n = this.mouse.y >= t && this.mouse.y < e;
                this.isVisibleState && !n ? this.hideDelayed() : !this.isVisibleState && n && this.showDelayed()
            }
        }
        handleScroll() {
            this.scroll = this.$scrollParent.scrollTop() - this.getStickyScrollAdjustment() - this.getParallaxAdjustment(), this.checkMousePosition(), this.updateAnimation()
        }
        handleResize() {
            this.$buttonWrapper.css("transform", "");
            const t = this.$container.pageOffset(),
                e = this.$targetContainer.pageOffset(),
                n = this.$buttonWrapper.pageOffset();
            this.constraints.width = window.innerWidth, this.constraints.top = t.top, this.constraints.x = n.left, this.constraints.y = t.top - n.top, this.constraints.targetTop = e.top, this.constraints.targetHeight = e.height, this.handleScroll()
        }
        show() {
            this.$buttonWrapper.transitionstop(() => {
                this.isVisible = !0, this.$buttonWrapper.transition(this.options.showTransition)
            })
        }
        hide() {
            this.$buttonWrapper.transitionstop(() => {
                this.$buttonWrapper.transition(this.options.hideTransition, {
                    after: () => {
                        this.$buttonWrapper.removeClass("is-hidden").addClass("is-invisible"), this.isVisible = !1
                    }
                })
            })
        }
        showDelayed() {
            this.hideTimer ? (this.isVisibleState = !0, clearTimeout(this.hideTimer), this.hideTimer = null) : this.isVisibleState || this.showTimer || (this.isVisibleState = !0, this.showTimer = setTimeout(() => {
                this.showTimer = null, this.show()
            }, 16))
        }
        hideDelayed() {
            this.showTimer ? (this.isVisibleState = !1, clearTimeout(this.showTimer), this.showTimer = null) : this.isVisibleState && !this.hideTimer && (this.isVisibleState = !1, this.hideTimer = setTimeout(() => {
                this.hideTimer = null, this.hide()
            }, 16))
        }
        zoomIn() {
            this.$buttonWrapper.addClass("cursor--zoom-in")
        }
        zoomOut() {
            this.$buttonWrapper.removeClass("cursor--zoom-in")
        }
        updateAnimation() {
            this.cursor.set({
                mouseX: this.mouse.x,
                x: this.mouse.x - this.constraints.x,
                y: this.mouse.y - this.constraints.y - (this.constraints.top - this.scroll)
            })
        }
        updateStyles(t) {
            this.isVisible && this.$buttonWrapper.css("transform", `translate(${t.x}px, ${t.y}px)`);
            const e = t.mouseX > this.constraints.width / 2;
            e !== this.isRight && (this.isRight = e, this.$buttonWrapper.toggleClass("cursor--left", !e).toggleClass("cursor--right", e))
        }
        getStickyScrollAdjustment() {
            if (this.isInSticky) {
                const t = this.$stickyContainer.get(0);
                return t.getBoundingClientRect().top - t.parentElement.getBoundingClientRect().top
            }
            return 0
        }
        getParallaxAdjustment() {
            if (this.isInParallax) {
                let t = 0;
                return this.$parallaxContainers.each((e, n) => {
                    t += Object(Mh.a)(n).y
                }), t
            }
            return 0
        }
    }
    xo.a.fn.cursor = ol()(Eh), xo.a.fn.comagicWidget = ol()((function (t, e) {
        const n = e.id;
        t.on("click", t => {
            if (t.preventDefault(), n) try {
                Comagic.openWidget(n)
            } catch (t) {
                console.warn(`Tried triggering CoMagic widget "${e.debug || n}"`), console.warn(t)
            }
        })
    }));
    var Th = n(20);
    xo.a.fn.favourite = ol()(class {
        static get Defaults() {
            return {
                id: null,
                labelActive: "",
                labelInactive: "",
                activeClass: "favourite--active is-active",
                inactiveClass: "",
                wrapperSelector: ".js-favourite-wrapper",
                wrapperRemoveInactive: !1,
                wrapperActiveClass: "",
                wrapperInactiveClass: ""
            }
        }
        constructor(t, e) {
            this.options = xo.a.extend({}, this.constructor.Defaults, e), this.id = this.options.id, this.$container = t, this.$wrapper = t.closest(this.options.wrapperSelector), this.state = this.$container.hasClass(this.options.activeClass), Th.a.add(this), t.on("click returnkey", this.toggleState.bind(this)).on("destroyed", this.destroy.bind(this))
        }
        destroy() {
            Th.a.remove(this)
        }
        update(t, e) {
            if (t === this.id) {
                const {
                    activeClass: t,
                    inactiveClass: n,
                    labelInactive: i,
                    labelActive: r,
                    wrapperRemoveInactive: s,
                    wrapperInactiveClass: a,
                    wrapperActiveClass: o
                } = this.options;
                if (this.state = e, t && this.$container.toggleClass(t, e), n && this.$container.toggleClass(n, !e), r && i && this.$container.attr("aria-label", e ? r : i), !e && s) {
                    const t = this.$wrapper.closest(".js-favourite-list-list");
                    this.$wrapper.closest(t.children()).remove(), this.$wrapper.remove()
                }
                o && this.$wrapper.toggleClass(o, e), a && this.$wrapper.toggleClass(a, !e)
            }
        }
        toggleState() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            t && t.preventDefault(), Th.a.set(this.id, !this.state)
        }
        getState() {
            const {
                activeClass: t,
                inactiveClass: e,
                wrapperInactiveClass: n,
                wrapperActiveClass: i
            } = this.options;
            return t ? this.$container.hasClass(t) : e ? !this.$container.hasClass(e) : i ? this.$wrapper.hasClass(i) : !!n && !this.$wrapper.hasClass(n)
        }
    });
    var Ch = n(142);
    xo.a.fn.favouriteCounter = ol()(class {
        static get Defaults() {
            return {
                activeClass: "",
                inactiveClass: "",
                activeTextClass: "",
                inactiveTextClass: "",
                textSelector: ".js-favourite-counter-text",
                wrapperActiveClass: "",
                wrapperInactiveClass: "",
                wrapperSelector: ".js-favourite-counter-wrapper",
                transchoice: null
            }
        }
        constructor(t, e) {
            this.options = xo.a.extend({}, this.constructor.Defaults, e), this.$container = t, this.$wrapper = t.closest(this.options.wrapperSelector), this.$text = this.options.textSelector ? t.find(this.options.textSelector).addBack(this.options.textSelector) : Object(xo.a)(), this.$text.length || "" === this.options.textSelector || null === this.options.textSelector || (t.is(".btn") ? this.$text = t.find(".btn__text") : this.$text = t), Th.a.add(this), t.on("destroyed", this.destroy.bind(this))
        }
        destroy() {
            Th.a.remove(this)
        }
        update() {
            const t = Th.a.getCount(),
                {
                    activeClass: e,
                    inactiveClass: n,
                    activeTextClass: i,
                    inactiveTextClass: r,
                    wrapperActiveClass: s,
                    wrapperInactiveClass: a
                } = this.options,
                o = this.$container,
                l = this.$wrapper,
                c = this.$text,
                h = t > 0;
            e && o.toggleClass(e, h), n && o.toggleClass(n, !h), i && c.toggleClass(i, h), r && c.toggleClass(r, !h), s && l.toggleClass(s, h), a && l.toggleClass(a, !h), null !== this.options.transchoice ? this.$text.text(Object(Ch.a)(t, this.options.transchoice)) : this.$text.text(t)
        }
    });
    var Ah = n(0),
        Rh = n(25),
        Ph = n(19),
        Lh = n(49),
        Oh = n(36),
        Dh = n(16);
    class Ih extends Oh.a {
        getXYZ(t) {
            let {
                position: e,
                direction: n,
                loops: i
            } = t;
            const r = Object(Dh.a)(Object(Lh.a)(.3, 1, e), 0, 1, .8, 1),
                s = Math.sin(2 * Math.PI * e * n * i) * r,
                a = Math.cos(2 * Math.PI * e * n * i) * r;
            let o = -.1;
            return e > 1 ? o += 1 - Object(Lh.a)(1, 1.5, e) : e > .5 && (o += Object(Lh.a)(.5, 1, e)), [s, o, a]
        }
    }
    const kh = [Math.PI / 180 * -7, Math.PI / 180 * 160, 0],
        Nh = [0, 0, Math.PI / 180 * 27];
    class Uh extends Rh.a {
        static get Defaults() {
            return xo.a.extend(!0, {}, Rh.a.Defaults, {
                lazy: !0,
                debug: !1,
                mouseTracking: !0,
                scrollTracking: !1,
                camera: {
                    position: [0, 10, 100],
                    rotation: [-.12, 0, 0],
                    fov: 40,
                    near: .1,
                    far: 1e3,
                    filmGauge: 90
                },
                cameraOrbitControls: !1
            })
        }
        init() {
            this.$items = Object(xo.a)(".js-visualization-menu-item"), this.progress = new Ah.Tb(1), this.speed = new Ah.Tb(1e3), this.$items.on("mouseenter", this.onMouseLinkEnter.bind(this)), super.init()
        }
        initGUI() {
            super.initGUI(), this.gui && (this.guiProgress = this.gui.add(this.progress, "value", -1, 1).name("progress").onChange(this.updateRotation.bind(this)), this.gui.add(this.speed, "value", 0, 2e3).name("speed"))
        }
        initScene() {
            const t = this.scene = new Ah.Kb;
            this.lines = [new Ph.a({
                curve: Ih,
                scale: [1, 1.1, 1],
                loops: 1.4,
                direction: -1,
                radius: 34,
                lineWidth: .25,
                offset: .712,
                length: .4,
                colorNormal: new Ah.o(1, 101 / 255, 36 / 255),
                colorLight: new Ah.o(1, 101 / 255, 36 / 255),
                colorDark: new Ah.o(1, 38 / 255, 0),
                rotation: kh,
                position: new Ah.ac(0, -29, 0),
                gui: this.gui,
                camera: this.camera,
                progress: this.progress,
                speed: this.speed,
                varyingLoops: 5.81,
                varyingLoopOffset: .175,
                varyingMin: .75,
                varyingMax: 1.2,
                edgeRadius: .15,
                blurCoeficient: 0,
                blurPower: 3,
                tubularSegments: 100
            }), new Ph.a({
                curve: Ih,
                scale: [1, 1.1, 1],
                loops: 1.4,
                direction: -1,
                radius: 34,
                lineWidth: .5,
                offset: .98,
                length: .202,
                colorNormal: new Ah.o(1, 101 / 255, 36 / 255),
                colorLight: new Ah.o(1, 101 / 255, 36 / 255),
                colorDark: new Ah.o(1, 38 / 255, 0),
                rotation: kh,
                position: new Ah.ac(-1.5, -25.94, 0),
                gui: this.gui,
                camera: this.camera,
                progress: this.progress,
                speed: this.speed,
                varyingLoops: 8,
                varyingLoopOffset: .1,
                varyingMin: .75,
                varyingMax: 1,
                edgeRadius: .2,
                blurCoeficient: .32,
                blurPower: 9.5,
                tubularSegments: 100
            }), new Ph.a({
                curve: Ih,
                scale: [1, 1.1, 1],
                loops: 1.4,
                direction: -1,
                radius: 35,
                lineWidth: .5,
                offset: 1.136,
                length: .16,
                colorNormal: new Ah.o(1, 101 / 255, 36 / 255),
                colorLight: new Ah.o(1, 101 / 255, 36 / 255),
                colorDark: new Ah.o(1, 38 / 255, 0),
                rotation: kh,
                position: new Ah.ac(-1.5, -26.4, 0),
                gui: this.gui,
                camera: this.camera,
                progress: this.progress,
                speed: this.speed,
                varyingLoops: 1.5,
                varyingLoopOffset: .66,
                varyingMin: .79,
                varyingMax: 1.6,
                edgeRadius: .2,
                blurCoeficient: .268,
                blurPower: 9.57,
                tubularSegments: 100
            }), new Ph.a({
                curve: Ih,
                scale: [1, 1.1, 1],
                loops: 1.4,
                direction: -1,
                radius: 34,
                lineWidth: .3,
                offset: .7,
                length: .34,
                colorNormal: new Ah.o(189 / 255, 57 / 255, 0),
                colorLight: new Ah.o(1, 173 / 255, .4),
                colorDark: new Ah.o(1, 38 / 255, 0),
                rotation: kh,
                position: new Ah.ac(-1.5, -26.7, 0),
                gui: this.gui,
                camera: this.camera,
                progress: this.progress,
                speed: this.speed,
                varyingLoops: 3.72,
                varyingLoopOffset: .346,
                varyingMin: .6,
                varyingMax: 1.2,
                edgeRadius: .173,
                blurCoeficient: .24,
                blurPower: 5.67,
                tubularSegments: 100
            })], this.group = new Ah.H, t.add(this.group), this.lines.forEach(t => this.group.add(t.getMesh())), this.group.rotation.set(Nh[0], Nh[1], Nh[2]), this.initCylinder(), this.initAnimation()
        }
        initCylinder() {
            const t = 2 * Math.PI * 24 / (2e3 / 424),
                e = new Ah.r(24, 24, t, 60, 1, !0);
            (new Ah.Sb).load("assets/images/media/menu/webgl.webp", t => {
                t.colorSpace = Ah.Jb;
                const n = new Ah.fb({
                    map: t,
                    transparent: !0,
                    side: Ah.x
                }),
                    i = this.cylinder = new Ah.eb(e, n);
                this.group.add(i)
            })
        }
        initAnimation() {
            this.rotationAnimation = new kl.a(0, {
                update: this.updateRotation.bind(this)
            })
        }
        onMouseMove(t) { }
        onMouseMoveAnimated(t) {
            this.updateRotation()
        }
        onMouseLinkEnter(t) {
            const e = Object(xo.a)(t.target).parent().index();
            this.rotationAnimation.set(e)
        }
        updateRotation() {
            if (this.cylinder) {
                const t = this.rotationAnimation.get() * Math.PI / -2 - Math.PI / 180 * 205;
                this.cylinder.rotation.y = kh[1] - .2 * (this.mouseAnimated.x - .5) + t
            }
        }
        onTick(t) {
            this.lines.forEach(e => e.update(t))
        }
    }
    xo.a.fn.visualizationLinesMenu = ol()(Uh);
    xo.a.fn.comagicPosition = ol()(class {
        static get Defaults() {
            return {}
        }
        constructor(t, e) {
            this.options = xo.a.extend({}, this.constructor.Defaults, e), this.$container = t, this.$container.inview({
                enter: this.moveUp.bind(this),
                leave: this.moveBack.bind(this)
            })
        }
        moveUp() {
            const t = Object(xo.a)(".footer").height();
            Object(xo.a)(document.documentElement).css("--footer-tablet-height", t + "px"), Object(xo.a)("html").addClass("is-at-viewport-bottom")
        }
        moveBack() {
            Object(xo.a)("html").removeClass("is-at-viewport-bottom")
        }
    }), xo.a.history = {
        set(t) {
            sessionStorage.setItem("history", t)
        },
        get: () => sessionStorage.getItem("history") || null
    }, xo.a.fn.historyVisible = ol()((function (t, e) {
        const n = xo.a.history.get(),
            i = e.if && e.if === n || e.ifNot && e.ifNot !== n;
        t.toggleClass("is-hidden", !i)
    }));
    xo.a.fn.phonenumber = ol()(class {
        static get Defaults() {
            return {
                phoneTarget: "href"
            }
        }
        constructor(t, e) {
            this.options = xo.a.extend({}, this.constructor.Defaults, e);
            this.$container = t, this.isChanged = !1, this.$container.on("mouseenter touchstart keydown", this.handleChange.bind(this))
        }
        handleChange() {
            if (!this.isChanged) {
                const t = Object(xo.a)('.header a[href*="tel:"]').eq(0).text().trim(),
                    e = this.$container.attr(this.options.phoneTarget);
                "href" === this.options.phoneTarget ? this.$container.attr(this.options.phoneTarget, e + "?phone=" + encodeURIComponent(t)) : this.$container.attr(this.options.phoneTarget, t), this.isChanged = !0
            }
        }
    });
    n(175);
    var zh = n(28);
    $.fn.scrollTopOriginal = $.fn.scrollTop, $.fn.scrollTop = function () {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        const e = $(window).data("smooth-scroll");
        if (e && e.custom && e.isScrollableContent(this)) return e.scrollTop(t, this);
        if ("number" == typeof t) return e && e.custom && this.data("smooth-scroll-last-scroll", t), this.scrollTopOriginal(t);
        {
            const t = this.data("smooth-scroll-last-scroll");
            return 0 === t || t ? t : this.scrollTopOriginal()
        }
    }, $.fn.scrollTopInstant = function () {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        const e = $(window).data("smooth-scroll");
        if ("number" != typeof t || e && e.custom && e.isScrollableContent(this)) return this.scrollTop(t);
        this.get(0) === window ? (document.documentElement.style.scrollBehavior = "initial", this.scrollTopOriginal(t), document.documentElement.style.scrollBehavior = "") : (this.css("scrollBehavior", "initial"), this.scrollTopOriginal(t), this.css("scrollBehavior", ""))
    }, $.fn.scrollTo = function (t, e) {
        const n = $(window).data("smooth-scroll");
        return n && n.custom && n.isScrollableContent(this) ? n.scrollTo(t, e) : this.get(0) === window ? $("html, body").scrollTopOriginal(t) : this.scrollTopOriginal(t)
    }, $.fn.scrollToElement = function (t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
            n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        const i = $(window).data("smooth-scroll"),
            r = $(t),
            s = r.scrollParent();
        if (i && i.custom)
            if (i.isScrollableContent(this)) n ? s.scrollToAnimated(r, e, void 0 === r.data("scrollUseOverlay") || r.data("scrollUseOverlay"), r.data("scrollDuration")) : i.scrollToElement(r, e, n);
            else {
                const t = r.pageOffset().top + (e || 0);
                this.data("smooth-scroll-last-scroll", t)
            }
        else {
            const i = $(t).pageOffset().top + (e || 0);
            $("html").css("scroll-behavior", "initial"), n ? s.scrollToAnimated(r, e) : ($("html").css("scroll-behavior", "initial"), $("html, body").stop().scrollTop(i), requestAnimationFrame(() => {
                $("html").css("scroll-behavior", "")
            }))
        }
    }, $.fn.scrollIntoView = function () {
        let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        const e = $(this);
        let n;
        for (let t = 0; t < e.length; t++)
            if (e[t].offsetParent) {
                n = e.eq(t);
                break
            } if (n) {
                const e = n.scrollParent(),
                    i = n.get(0).getBoundingClientRect(),
                    r = t && "top" in t ? t.top : 20,
                    s = t && "bottom" in t ? t.bottom : 20,
                    a = e.scrollTop(),
                    o = {
                        top: a + i.top - r,
                        bottom: a + i.top + s
                    },
                    l = {
                        top: a,
                        bottom: a + window.innerHeight
                    };
                a !== o.top && (o.top < l.top || o.bottom > l.bottom) && e.scrollToAnimated(o.top)
            }
    }, $.fn.pageOffset = function () {
        const t = $(window).data("smooth-scroll"),
            e = $(this);
        if (!e.length) throw new Error("Can't read element position for non-existing element");
        const n = e.get(0).getBoundingClientRect(),
            i = e.closest("[data-sticky-slider-content-ready]");
        let r = {
            x: 0,
            y: 0
        };
        const s = {
            left: n.left,
            top: n.top,
            width: n.width,
            height: n.height,
            scrollLeft: n.left,
            scrollTop: n.top,
            scrollWidth: n.width,
            scrollHeight: n.height,
            scrollViewportSize: window.innerHeight,
            scrollViewportNatural: !0
        };
        if (i.length) {
            r = Object(Mh.a)(i);
            const t = i.get(0).getBoundingClientRect(),
                e = {
                    x: n.left - t.left,
                    y: n.top - t.top
                };
            s.left -= r.x, s.top -= r.y, s.scrollLeft = t.left - r.x + e.y, s.scrollTop = t.top - r.y + e.x, s.scrollWidth = s.height, s.scrollHeight = s.width, s.scrollViewportSize = window.innerWidth, s.scrollViewportNatural = !1
        }
        if (e.parents('[data-plugin~="parallax"]').not("[data-scroll-sticky]").each((t, e) => {
            const n = Object(Mh.a)(e);
            s.top -= n.y, s.scrollTop -= n.y
        }), t && t.custom) {
            const t = e.closest("[data-scroll-section], [data-scroll-section-id]"),
                n = Object(Mh.a)(t.length ? t : e);
            s.left -= n.x, s.top -= n.y, s.scrollLeft -= n.x, s.scrollTop -= n.y;
            const i = e.closest("[data-scroll-sticky]");
            if (i.length) {
                const t = Object(Mh.a)(i);
                s.left -= t.x, s.top -= t.y, s.scrollLeft -= t.x, s.scrollTop -= t.y
            }
        } else {
            const t = e.scrollParent();
            let n = !1,
                i = e;
            for (; i.length && !i.is("body, .section, .js-page-content-wrapper") && !i.is(t);) {
                if ("fixed" === i.css("position")) {
                    n = !0;
                    break
                }
                i = i.parent()
            }
            if (!n) {
                const e = t.scrollLeft(),
                    n = t.scrollTop();
                s.left += e, s.top += n, s.scrollLeft += e, s.scrollTop += n
            }
            const r = e.closest("[data-scroll-sticky]");
            if (r.length && "sticky" === r.css("position") && "auto" !== r.css("top")) {
                const t = r.parent(),
                    e = r.get(0).getBoundingClientRect().top - t.get(0).getBoundingClientRect().top;
                s.top -= e, s.scrollTop -= e
            }
        }
        return s
    }, $.isCustomScroll = function () {
        const t = $(window).data("smooth-scroll");
        if (t) return !!t.custom;
        if ($.fn.scroller && zh.a) {
            return !$(".js-page-content").data("smoothScrollerDisabled")
        }
        return !1
    };
    const Fh = {
        el: document,
        name: "scroll",
        offset: [0, 0],
        repeat: !1,
        smooth: !1,
        initPosition: {
            x: 0,
            y: 0
        },
        direction: "vertical",
        gestureDirection: "vertical",
        reloadOnContextChange: !1,
        lerp: .1,
        class: "is-inview",
        scrollbarContainer: !1,
        scrollbarClass: "c-scrollbar",
        scrollingClass: "has-scroll-scrolling",
        draggingClass: "has-scroll-dragging",
        smoothClass: "has-scroll-smooth",
        initClass: "has-scroll-init",
        getSpeed: !1,
        getDirection: !1,
        scrollFromAnywhere: !1,
        multiplier: 1,
        firefoxMultiplier: 50,
        touchMultiplier: 2,
        resetNativeScroll: !0,
        tablet: {
            smooth: !1,
            direction: "vertical",
            gestureDirection: "vertical",
            breakpoint: 1024
        },
        smartphone: {
            smooth: !1,
            direction: "vertical",
            gestureDirection: "vertical"
        }
    };
    var $h = class {
        constructor() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            Object.assign(this, Fh, t), this.smartphone = Fh.smartphone, t.smartphone && Object.assign(this.smartphone, t.smartphone), this.tablet = Fh.tablet, t.tablet && Object.assign(this.tablet, t.tablet), this.namespace = "locomotive", this.html = document.documentElement, this.windowHeight = window.innerHeight, this.windowWidth = window.innerWidth, this.windowMiddle = {
                x: this.windowWidth / 2,
                y: this.windowHeight / 2
            }, this.els = {}, this.currentElements = {}, this.listeners = {}, this.hasScrollTicking = !1, this.hasCallEventSet = !1, this.checkScroll = this.checkScroll.bind(this), this.checkResize = this.checkResize.bind(this), this.checkEvent = this.checkEvent.bind(this), this.instance = {
                scroll: {
                    x: 0,
                    y: 0
                },
                limit: {
                    x: this.html.offsetWidth,
                    y: this.html.offsetHeight
                },
                currentElements: this.currentElements
            }, this.isMobile ? this.isTablet ? this.context = "tablet" : this.context = "smartphone" : this.context = "desktop", this.isMobile && (this.direction = this[this.context].direction), "horizontal" === this.direction ? this.directionAxis = "x" : this.directionAxis = "y", this.getDirection && (this.instance.direction = null), this.getDirection && (this.instance.speed = 0), this.html.classList.add(this.initClass), window.addEventListener("resize", this.checkResize, !1)
        }
        init() {
            this.initEvents()
        }
        checkScroll() {
            this.dispatchScroll()
        }
        checkResize() {
            this.resizeTick || (this.resizeTick = !0, requestAnimationFrame(() => {
                this.resize(), this.resizeTick = !1
            }))
        }
        resize() { }
        checkContext() {
            if (!this.reloadOnContextChange) return;
            this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1 || this.windowWidth < this.tablet.breakpoint, this.isTablet = this.isMobile && this.windowWidth >= this.tablet.breakpoint;
            let t = this.context;
            if (this.isMobile ? this.isTablet ? this.context = "tablet" : this.context = "smartphone" : this.context = "desktop", t != this.context) {
                ("desktop" == t ? this.smooth : this[t].smooth) != ("desktop" == this.context ? this.smooth : this[this.context].smooth) && window.location.reload()
            }
        }
        initEvents() {
            this.scrollToEls = this.el.querySelectorAll(`[data-${this.name}-to]`), this.setScrollTo = this.setScrollTo.bind(this), this.scrollToEls.forEach(t => {
                t.addEventListener("click", this.setScrollTo, !1)
            })
        }
        setScrollTo(t) {
            t.preventDefault(), this.scrollTo(t.currentTarget.getAttribute(`data-${this.name}-href`) || t.currentTarget.getAttribute("href"), {
                offset: t.currentTarget.getAttribute(`data-${this.name}-offset`)
            })
        }
        addElements() { }
        detectElements(t) {
            const e = this.instance.scroll.y,
                n = e + this.windowHeight,
                i = this.instance.scroll.x,
                r = i + this.windowWidth;
            Object.entries(this.els).forEach(s => {
                let [a, o] = s;
                if (!o || o.inView && !t || ("horizontal" === this.direction ? r >= o.left && i < o.right && this.setInView(o, a) : n >= o.top && e < o.bottom && this.setInView(o, a)), o && o.inView)
                    if ("horizontal" === this.direction) {
                        let t = o.right - o.left;
                        o.progress = (this.instance.scroll.x - (o.left - this.windowWidth)) / (t + this.windowWidth), (r < o.left || i > o.right) && this.setOutOfView(o, a)
                    } else {
                        let t = o.bottom - o.top;
                        o.progress = (this.instance.scroll.y - (o.top - this.windowHeight)) / (t + this.windowHeight), (n < o.top || e > o.bottom) && this.setOutOfView(o, a)
                    }
            }), this.hasScrollTicking = !1
        }
        setInView(t, e) {
            this.els[e].inView = !0, t.el.classList.add(t.class), this.currentElements[e] = t, t.call && this.hasCallEventSet && (this.dispatchCall(t, "enter"), t.repeat || (this.els[e].call = !1))
        }
        setOutOfView(t, e) {
            this.els[e].inView = !1, Object.keys(this.currentElements).forEach(t => {
                t === e && delete this.currentElements[t]
            }), t.call && this.hasCallEventSet && this.dispatchCall(t, "exit"), t.repeat && t.el.classList.remove(t.class)
        }
        dispatchCall(t, e) {
            this.callWay = e, this.callValue = t.call.split(",").map(t => t.trim()), this.callObj = t, 1 == this.callValue.length && (this.callValue = this.callValue[0]);
            const n = new Event(this.namespace + "call");
            this.el.dispatchEvent(n)
        }
        dispatchScroll() {
            const t = new Event(this.namespace + "scroll");
            this.el.dispatchEvent(t)
        }
        setEvents(t, e) {
            this.listeners[t] || (this.listeners[t] = []);
            const n = this.listeners[t];
            n.push(e), 1 === n.length && this.el.addEventListener(this.namespace + t, this.checkEvent, !1), "call" === t && (this.hasCallEventSet = !0, this.detectElements(!0))
        }
        unsetEvents(t, e) {
            if (!this.listeners[t]) return;
            const n = this.listeners[t],
                i = n.indexOf(e);
            i < 0 || (n.splice(i, 1), 0 === n.index && this.el.removeEventListener(this.namespace + t, this.checkEvent, !1))
        }
        checkEvent(t) {
            const e = t.type.replace(this.namespace, ""),
                n = this.listeners[e];
            n && 0 !== n.length && n.forEach(t => {
                switch (e) {
                    case "scroll":
                        return t(this.instance);
                    case "call":
                        return t(this.callValue, this.callWay, this.callObj);
                    default:
                        return t()
                }
            })
        }
        startScroll() { }
        stopScroll() { }
        setScroll(t, e) {
            this.instance.scroll = {
                x: 0,
                y: 0
            }
        }
        destroy() {
            window.removeEventListener("resize", this.checkResize, !1), Object.keys(this.listeners).forEach(t => {
                this.el.removeEventListener(this.namespace + t, this.checkEvent, !1)
            }), this.listeners = {}, this.scrollToEls.forEach(t => {
                t.removeEventListener("click", this.setScrollTo, !1)
            }), this.html.classList.remove(this.initClass)
        }
    },
        Bh = n(239),
        Hh = n.n(Bh),
        jh = class extends $h {
            constructor() {
                super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}), this.resetNativeScroll && (history.scrollRestoration && (history.scrollRestoration = "manual"), window.scrollTo(0, 0)), window.addEventListener("scroll", this.checkScroll, !1), void 0 === window.smoothscrollPolyfill && (window.smoothscrollPolyfill = Hh.a, window.smoothscrollPolyfill.polyfill())
            }
            init() {
                this.instance.scroll.y = window.pageYOffset, this.addElements(), this.detectElements(), super.init()
            }
            checkScroll() {
                super.checkScroll(), this.getDirection && this.addDirection(), this.getSpeed && (this.addSpeed(), this.speedTs = Date.now()), this.instance.scroll.y = window.pageYOffset, Object.entries(this.els).length && (this.hasScrollTicking || (requestAnimationFrame(() => {
                    this.detectElements()
                }), this.hasScrollTicking = !0))
            }
            addDirection() {
                window.pageYOffset > this.instance.scroll.y ? "down" !== this.instance.direction && (this.instance.direction = "down") : window.pageYOffset < this.instance.scroll.y && "up" !== this.instance.direction && (this.instance.direction = "up")
            }
            addSpeed() {
                window.pageYOffset != this.instance.scroll.y ? this.instance.speed = (window.pageYOffset - this.instance.scroll.y) / Math.max(1, Date.now() - this.speedTs) : this.instance.speed = 0
            }
            resize() {
                Object.entries(this.els).length && (this.windowHeight = window.innerHeight, this.updateElements())
            }
            addElements() {
                this.els = {};
                this.el.querySelectorAll("[data-" + this.name + "]").forEach((t, e) => {
                    t.getBoundingClientRect();
                    let n, i, r, s = t.dataset[this.name + "Class"] || this.class,
                        a = "string" == typeof t.dataset[this.name + "Id"] ? t.dataset[this.name + "Id"] : e,
                        o = "string" == typeof t.dataset[this.name + "Offset"] ? t.dataset[this.name + "Offset"].split(",") : this.offset,
                        l = t.dataset[this.name + "Repeat"],
                        c = t.dataset[this.name + "Call"],
                        h = t.dataset[this.name + "Target"];
                    r = void 0 !== h ? document.querySelector("" + h) : t;
                    const u = r.getBoundingClientRect();
                    n = u.top + this.instance.scroll.y, i = u.left + this.instance.scroll.x;
                    let d = n + r.offsetHeight,
                        p = i + r.offsetWidth;
                    l = "false" != l && (null != l || this.repeat);
                    let f = this.getRelativeOffset(o);
                    n += f[0], d -= f[1];
                    const m = {
                        el: t,
                        targetEl: r,
                        id: a,
                        class: s,
                        top: n,
                        bottom: d,
                        left: i,
                        right: p,
                        offset: o,
                        progress: 0,
                        repeat: l,
                        inView: !1,
                        call: c
                    };
                    this.els[a] = m, t.classList.contains(s) && this.setInView(this.els[a], a)
                })
            }
            updateElements() {
                Object.entries(this.els).forEach(t => {
                    let [e, n] = t;
                    const i = n.targetEl.getBoundingClientRect().top + this.instance.scroll.y,
                        r = i + n.targetEl.offsetHeight,
                        s = this.getRelativeOffset(n.offset);
                    this.els[e].top = i + s[0], this.els[e].bottom = r - s[1]
                }), this.hasScrollTicking = !1
            }
            getRelativeOffset(t) {
                let e = [0, 0];
                if (t)
                    for (var n = 0; n < t.length; n++) "string" == typeof t[n] ? t[n].includes("%") ? e[n] = parseInt(t[n].replace("%", "") * this.windowHeight / 100) : e[n] = parseInt(t[n]) : e[n] = t[n];
                return e
            }
            scrollTo(t) {
                let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    n = parseInt(e.offset) || 0;
                const i = !!e.callback && e.callback;
                if ("string" == typeof t) {
                    if ("top" === t) t = this.html;
                    else if ("bottom" === t) t = this.html.offsetHeight - window.innerHeight;
                    else if (!(t = document.querySelector(t))) return
                } else if ("number" == typeof t) t = parseInt(t);
                else if (!t || !t.tagName) return void console.warn("`target` parameter is not valid");
                n = "number" != typeof t ? t.getBoundingClientRect().top + n + this.instance.scroll.y : t + n;
                const r = () => parseInt(window.pageYOffset) === parseInt(n);
                if (i) {
                    if (r()) return void i();
                    {
                        let t = function () {
                            r() && (window.removeEventListener("scroll", t), i())
                        };
                        window.addEventListener("scroll", t)
                    }
                }
                window.scrollTo({
                    top: n,
                    behavior: 0 === e.duration ? "auto" : "smooth"
                })
            }
            update() {
                this.addElements(), this.detectElements()
            }
            destroy() {
                super.destroy(), window.removeEventListener("scroll", this.checkScroll, !1)
            }
        },
        Vh = n(240),
        Gh = n.n(Vh);

    function Wh(t, e, n) {
        return (1 - n) * t + n * e
    }

    function qh(t) {
        const e = {};
        if (!window.getComputedStyle) return;
        const n = getComputedStyle(t),
            i = n.transform || n.webkitTransform || n.mozTransform;
        let r = i.match(/^matrix3d\((.+)\)$/);
        return r ? (e.x = r ? parseFloat(r[1].split(", ")[12]) : 0, e.y = r ? parseFloat(r[1].split(", ")[13]) : 0) : (r = i.match(/^matrix\((.+)\)$/), e.x = r ? parseFloat(r[1].split(", ")[4]) : 0, e.y = r ? parseFloat(r[1].split(", ")[5]) : 0), e
    }

    function Xh(t) {
        let e = [];
        for (; t && t !== document; t = t.parentNode) e.push(t);
        return e
    }
    var Yh = n(241),
        Kh = n.n(Yh);

    function Zh(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(t);
            e && (i = i.filter((function (e) {
                return Object.getOwnPropertyDescriptor(t, e).enumerable
            }))), n.push.apply(n, i)
        }
        return n
    }

    function Jh(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = null != arguments[e] ? arguments[e] : {};
            e % 2 ? Zh(Object(n), !0).forEach((function (e) {
                Qh(t, e, n[e])
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Zh(Object(n)).forEach((function (e) {
                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
            }))
        }
        return t
    }

    function Qh(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }
    const tu = 38,
        eu = 40,
        nu = 32,
        iu = 9,
        ru = 33,
        su = 34,
        au = 36,
        ou = 35;
    var lu = class extends $h {
        constructor() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            history.scrollRestoration && (history.scrollRestoration = "manual"), window.scrollTo(0, 0), super(t), this.inertia && (this.lerp = .1 * this.inertia), this.isScrolling = !1, this.isDraggingScrollbar = !1, this.isTicking = !1, this.hasScrollTicking = !1, this.parallaxElements = {}, this.stop = !1, this.scrollbarContainer = t.scrollbarContainer, this.checkKey = this.checkKey.bind(this), window.addEventListener("keydown", this.checkKey, !1)
        }
        init() {
            this.html.classList.add(this.smoothClass), this.html.setAttribute(`data-${this.name}-direction`, this.direction), this.instance = Jh({
                delta: {
                    x: this.initPosition.x,
                    y: this.initPosition.y
                },
                scroll: {
                    x: this.initPosition.x,
                    y: this.initPosition.y
                }
            }, this.instance), this.vs = new Gh.a({
                el: this.scrollFromAnywhere ? document : this.el,
                mouseMultiplier: navigator.platform.indexOf("Win") > -1 ? 1 : .4,
                firefoxMultiplier: this.firefoxMultiplier,
                touchMultiplier: this.touchMultiplier,
                useKeyboard: !1,
                passive: !0
            }), this.vs.on(t => {
                this.stop || this.isDraggingScrollbar || requestAnimationFrame(() => {
                    this.updateDelta(t), this.animatingScroll ? (this.stopScrolling(), this.startScrolling()) : this.isScrolling || this.startScrolling()
                })
            }), this.setScrollLimit(), this.initScrollBar(), this.addSections(), this.addElements(), this.checkScroll(!0), this.transformElements(!0, !0), super.init()
        }
        setScrollLimit() {
            if (this.instance.limit.y = this.el.offsetHeight - this.windowHeight, "horizontal" === this.direction) {
                let t = 0,
                    e = this.el.children;
                for (let n = 0; n < e.length; n++) t += e[n].offsetWidth;
                this.instance.limit.x = t - this.windowWidth
            }
        }
        startScrolling() {
            this.startScrollTs = Date.now(), this.lastTime = Date.now() - 16, this.isScrolling = !0, this.checkScroll(), this.html.classList.add(this.scrollingClass)
        }
        stopScrolling() {
            cancelAnimationFrame(this.checkScrollRaf), this.startScrollTs = void 0, this.scrollToRaf && (cancelAnimationFrame(this.scrollToRaf), this.scrollToRaf = null), this.isScrolling = !1, this.instance.scroll.y = Math.round(this.instance.scroll.y), this.html.classList.remove(this.scrollingClass)
        }
        checkKey(t) {
            if (this.stop) t.keyCode == iu && requestAnimationFrame(() => {
                this.html.scrollTop = 0, document.body.scrollTop = 0, this.html.scrollLeft = 0, document.body.scrollLeft = 0
            });
            else {
                switch (t.keyCode) {
                    case iu:
                        requestAnimationFrame(() => {
                            this.html.scrollTop = 0, document.body.scrollTop = 0, this.html.scrollLeft = 0, document.body.scrollLeft = 0, this.scrollTo(document.activeElement, {
                                offset: -window.innerHeight / 2
                            })
                        });
                        break;
                    case tu:
                        this.isActiveElementScrollSensitive() && (this.instance.delta[this.directionAxis] -= 240);
                        break;
                    case eu:
                        this.isActiveElementScrollSensitive() && (this.instance.delta[this.directionAxis] += 240);
                        break;
                    case ru:
                        this.instance.delta[this.directionAxis] -= window.innerHeight;
                        break;
                    case su:
                        this.instance.delta[this.directionAxis] += window.innerHeight;
                        break;
                    case au:
                        this.instance.delta[this.directionAxis] -= this.instance.limit[this.directionAxis];
                        break;
                    case ou:
                        this.instance.delta[this.directionAxis] += this.instance.limit[this.directionAxis];
                        break;
                    case nu:
                        this.isActiveElementScrollSensitive() && (t.shiftKey ? this.instance.delta[this.directionAxis] -= window.innerHeight : this.instance.delta[this.directionAxis] += window.innerHeight);
                        break;
                    default:
                        return
                }
                this.instance.delta[this.directionAxis] < 0 && (this.instance.delta[this.directionAxis] = 0), this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis] && (this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis]), this.stopScrolling(), this.startScrolling()
            }
        }
        isActiveElementScrollSensitive() {
            return !(document.activeElement instanceof HTMLInputElement || document.activeElement instanceof HTMLTextAreaElement || document.activeElement instanceof HTMLButtonElement || document.activeElement instanceof HTMLSelectElement)
        }
        checkScroll() {
            let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (t || this.isScrolling || this.isDraggingScrollbar) {
                this.hasScrollTicking || (cancelAnimationFrame(this.checkScrollRaf), this.checkScrollRaf = requestAnimationFrame(() => this.checkScroll()), this.hasScrollTicking = !0), this.deltaTime = this.lastTime ? Date.now() - this.lastTime : 16, this.lastTime = Date.now(), this.updateScroll(this.deltaTime);
                const e = Math.abs(this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]),
                    n = Date.now() - this.startScrollTs;
                if (!this.animatingScroll && n > 100 && (e < .5 && 0 != this.instance.delta[this.directionAxis] || e < .5 && 0 == this.instance.delta[this.directionAxis]) && this.stopScrolling(), Object.entries(this.sections).forEach(e => {
                    let [n, i] = e;
                    i.persistent || this.instance.scroll[this.directionAxis] > i.offset[this.directionAxis] && this.instance.scroll[this.directionAxis] < i.limit[this.directionAxis] ? ("horizontal" === this.direction ? this.transform(i.el, -this.instance.scroll[this.directionAxis], 0) : this.transform(i.el, 0, -this.instance.scroll[this.directionAxis]), i.inView || (i.inView = !0, i.el.style.opacity = 1, i.el.style.pointerEvents = "all", i.el.setAttribute(`data-${this.name}-section-inview`, ""))) : ((i.inView || t) && (i.inView = !1, i.el.style.opacity = 0, i.el.style.pointerEvents = "none", i.el.removeAttribute(`data-${this.name}-section-inview`)), this.transform(i.el, 0, 0))
                }), this.getDirection && this.addDirection(), this.getSpeed && (this.addSpeed(), this.speedTs = Date.now()), this.detectElements(), this.transformElements(), this.hasScrollbar) {
                    const t = this.instance.scroll[this.directionAxis] / this.instance.limit[this.directionAxis] * this.scrollBarLimit[this.directionAxis];
                    "horizontal" === this.direction ? this.transform(this.scrollbarThumb, t, 0) : this.transform(this.scrollbarThumb, 0, t)
                }
                super.checkScroll(), this.hasScrollTicking = !1
            }
        }
        resize() {
            this.windowHeight = window.innerHeight, this.windowWidth = window.innerWidth, this.checkContext(), this.windowMiddle = {
                x: this.windowWidth / 2,
                y: this.windowHeight / 2
            }, this.update()
        }
        updateDelta(t) {
            let e;
            const n = this[this.context] && this[this.context].gestureDirection ? this[this.context].gestureDirection : this.gestureDirection;
            e = "both" === n ? t.deltaX + t.deltaY : "vertical" === n ? t.deltaY : "horizontal" === n ? t.deltaX : t.deltaY;
            const i = new CustomEvent("delta", {
                detail: {
                    current: this.instance.delta[this.directionAxis],
                    next: this.instance.delta[this.directionAxis] - e * this.multiplier,
                    delta: e * this.multiplier
                }
            });
            this.el.dispatchEvent(i), this.instance.delta[this.directionAxis] = i.detail.next, this.instance.delta[this.directionAxis] < 0 && (this.instance.delta[this.directionAxis] = 0), this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis] && (this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis])
        }
        updateScroll(t) {
            t = (t ? Math.max(6, Math.min(32, t)) : 16) / 16, this.isScrolling || this.isDraggingScrollbar ? this.instance.scroll[this.directionAxis] = Wh(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis], this.lerp * t) : this.instance.scroll[this.directionAxis] > this.instance.limit[this.directionAxis] ? this.setScroll(this.instance.scroll[this.directionAxis], this.instance.limit[this.directionAxis]) : this.instance.scroll.y < 0 ? this.setScroll(this.instance.scroll[this.directionAxis], 0) : this.setScroll(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis])
        }
        addDirection() {
            this.instance.delta.y > this.instance.scroll.y ? "down" !== this.instance.direction && (this.instance.direction = "down") : this.instance.delta.y < this.instance.scroll.y && "up" !== this.instance.direction && (this.instance.direction = "up"), this.instance.delta.x > this.instance.scroll.x ? "right" !== this.instance.direction && (this.instance.direction = "right") : this.instance.delta.x < this.instance.scroll.x && "left" !== this.instance.direction && (this.instance.direction = "left")
        }
        addSpeed() {
            this.instance.delta[this.directionAxis] != this.instance.scroll[this.directionAxis] ? this.instance.speed = (this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]) / Math.max(1, Date.now() - this.speedTs) : this.instance.speed = 0
        }
        initScrollBar() {
            if (this.scrollbar = document.createElement("span"), this.scrollbarThumb = document.createElement("span"), this.scrollbar.classList.add("" + this.scrollbarClass), this.scrollbarThumb.classList.add(this.scrollbarClass + "_thumb"), this.scrollbar.append(this.scrollbarThumb), this.scrollbarContainer ? this.scrollbarContainer.append(this.scrollbar) : document.body.append(this.scrollbar), this.getScrollBar = this.getScrollBar.bind(this), this.releaseScrollBar = this.releaseScrollBar.bind(this), this.moveScrollBar = this.moveScrollBar.bind(this), this.scrollbarThumb.addEventListener("mousedown", this.getScrollBar), window.addEventListener("mouseup", this.releaseScrollBar), window.addEventListener("mousemove", this.moveScrollBar), this.hasScrollbar = !1, "horizontal" == this.direction) {
                if (this.instance.limit.x + this.windowWidth <= this.windowWidth) return
            } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight) return;
            this.hasScrollbar = !0, this.scrollbarBCR = this.scrollbar.getBoundingClientRect(), this.scrollbarHeight = this.scrollbarBCR.height, this.scrollbarWidth = this.scrollbarBCR.width, "horizontal" === this.direction ? this.scrollbarThumb.style.width = this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth) + "px" : this.scrollbarThumb.style.height = this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight) + "px", this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect(), this.scrollBarLimit = {
                x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
                y: this.scrollbarHeight - this.scrollbarThumbBCR.height
            }
        }
        reinitScrollBar() {
            if (this.hasScrollbar = !1, "horizontal" == this.direction) {
                if (this.instance.limit.x + this.windowWidth <= this.windowWidth) return
            } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight) return;
            this.hasScrollbar = !0, this.scrollbarBCR = this.scrollbar.getBoundingClientRect(), this.scrollbarHeight = this.scrollbarBCR.height, this.scrollbarWidth = this.scrollbarBCR.width, "horizontal" === this.direction ? this.scrollbarThumb.style.width = this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth) + "px" : this.scrollbarThumb.style.height = this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight) + "px", this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect(), this.scrollBarLimit = {
                x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
                y: this.scrollbarHeight - this.scrollbarThumbBCR.height
            }
        }
        destroyScrollBar() {
            this.scrollbarThumb.removeEventListener("mousedown", this.getScrollBar), window.removeEventListener("mouseup", this.releaseScrollBar), window.removeEventListener("mousemove", this.moveScrollBar), this.scrollbar.remove()
        }
        getScrollBar(t) {
            this.isDraggingScrollbar = !0, this.checkScroll(), this.html.classList.remove(this.scrollingClass), this.html.classList.add(this.draggingClass)
        }
        releaseScrollBar(t) {
            this.isDraggingScrollbar = !1, this.isScrolling && this.html.classList.add(this.scrollingClass), this.html.classList.remove(this.draggingClass)
        }
        moveScrollBar(t) {
            this.isDraggingScrollbar && requestAnimationFrame(() => {
                let e = 100 * (t.clientX - this.scrollbarBCR.left) / this.scrollbarWidth * this.instance.limit.x / 100,
                    n = 100 * (t.clientY - this.scrollbarBCR.top) / this.scrollbarHeight * this.instance.limit.y / 100;
                n > 0 && n < this.instance.limit.y && (this.instance.delta.y = n), e > 0 && e < this.instance.limit.x && (this.instance.delta.x = e)
            })
        }
        addElements() {
            this.els = {}, this.parallaxElements = {};
            this.el.querySelectorAll(`[data-${this.name}]`).forEach((t, e) => {
                const n = Xh(t);
                let i, r, s, a = Object.entries(this.sections).map(t => {
                    let [e, n] = t;
                    return n
                }).find(t => n.includes(t.el)),
                    o = t.dataset[this.name + "Class"] || this.class,
                    l = "string" == typeof t.dataset[this.name + "Id"] ? t.dataset[this.name + "Id"] : "el" + e,
                    c = t.dataset[this.name + "Repeat"],
                    h = t.dataset[this.name + "Call"],
                    u = t.dataset[this.name + "Position"],
                    d = t.dataset[this.name + "Delay"],
                    p = t.dataset[this.name + "Direction"],
                    f = "string" == typeof t.dataset[this.name + "Sticky"],
                    m = !!t.dataset[this.name + "Speed"] && parseFloat(t.dataset[this.name + "Speed"]) / 10,
                    g = "string" == typeof t.dataset[this.name + "Offset"] ? t.dataset[this.name + "Offset"].split(",") : this.offset,
                    v = t.dataset[this.name + "Target"];
                s = void 0 !== v ? document.querySelector("" + v) : t;
                const y = s.getBoundingClientRect();
                null === a || a.inView ? (i = y.top + this.instance.scroll.y - qh(s).y, r = y.left + this.instance.scroll.x - qh(s).x) : (i = y.top - qh(a.el).y - qh(s).y, r = y.left - qh(a.el).x - qh(s).x);
                let b = i + s.offsetHeight,
                    x = r + s.offsetWidth,
                    _ = {
                        x: (x - r) / 2 + r,
                        y: (b - i) / 2 + i
                    };
                if (f) {
                    const e = t.getBoundingClientRect(),
                        n = e.top,
                        a = e.left,
                        o = {
                            x: a - r,
                            y: n - i
                        };
                    i += window.innerHeight, r += window.innerWidth, b = n + s.offsetHeight - t.offsetHeight - o[this.directionAxis], x = a + s.offsetWidth - t.offsetWidth - o[this.directionAxis], _ = {
                        x: (x - r) / 2 + r,
                        y: (b - i) / 2 + i
                    }
                }
                c = "false" != c && (null != c || this.repeat);
                let w = [0, 0];
                if (g)
                    if ("horizontal" === this.direction) {
                        for (var S = 0; S < g.length; S++) "string" == typeof g[S] ? g[S].includes("%") ? w[S] = parseInt(g[S].replace("%", "") * this.windowWidth / 100) : w[S] = parseInt(g[S]) : w[S] = g[S];
                        r += w[0], x -= w[1]
                    } else {
                        for (S = 0; S < g.length; S++) "string" == typeof g[S] ? g[S].includes("%") ? w[S] = parseInt(g[S].replace("%", "") * this.windowHeight / 100) : w[S] = parseInt(g[S]) : w[S] = g[S];
                        i += w[0], b -= w[1]
                    } const M = {
                        el: t,
                        id: l,
                        class: o,
                        section: a,
                        top: i,
                        middle: _,
                        bottom: b,
                        left: r,
                        right: x,
                        offset: g,
                        progress: 0,
                        repeat: c,
                        inView: !1,
                        call: h,
                        speed: m,
                        delay: d,
                        position: u,
                        target: s,
                        direction: p,
                        sticky: f
                    };
                this.els[l] = M, t.classList.contains(o) && this.setInView(this.els[l], l), (!1 !== m || f) && (this.parallaxElements[l] = M)
            })
        }
        addSections() {
            this.sections = {};
            let t = this.el.querySelectorAll(`[data-${this.name}-section]`);
            0 === t.length && (t = [this.el]), t.forEach((t, e) => {
                let n = "string" == typeof t.dataset[this.name + "Id"] ? t.dataset[this.name + "Id"] : "section" + e;
                const i = t.getBoundingClientRect();
                let r = {
                    x: i.left - 1.5 * window.innerWidth - qh(t).x,
                    y: i.top - 1.5 * window.innerHeight - qh(t).y
                },
                    s = {
                        x: r.x + i.width + 2 * window.innerWidth,
                        y: r.y + i.height + 2 * window.innerHeight
                    },
                    a = "string" == typeof t.dataset[this.name + "Persistent"];
                t.setAttribute("data-scroll-section-id", n);
                const o = {
                    el: t,
                    offset: r,
                    limit: s,
                    inView: !1,
                    persistent: a,
                    id: n
                };
                this.sections[n] = o
            })
        }
        transform(t, e, n, i) {
            let r;
            if (i) {
                let s = qh(t);
                r = `matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,${Wh(s.x, e, i)},${Wh(s.y, n, i)},0,1)`
            } else r = `matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,${e},${n},0,1)`;
            t.style.webkitTransform = r, t.style.msTransform = r, t.style.transform = r
        }
        transformElements(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            const n = this.instance.scroll.x + this.windowWidth,
                i = this.instance.scroll.y + this.windowHeight,
                r = {
                    x: this.instance.scroll.x + this.windowMiddle.x,
                    y: this.instance.scroll.y + this.windowMiddle.y
                };
            Object.entries(this.parallaxElements).forEach(s => {
                let [a, o] = s, l = !1;
                if (t && (l = 0), o.inView || e) switch (o.position) {
                    case "top":
                        l = this.instance.scroll[this.directionAxis] * -o.speed;
                        break;
                    case "elementTop":
                        l = (i - o.top) * -o.speed;
                        break;
                    case "bottom":
                        l = (this.instance.limit[this.directionAxis] - i + this.windowHeight) * o.speed;
                        break;
                    case "left":
                        l = this.instance.scroll[this.directionAxis] * -o.speed;
                        break;
                    case "elementLeft":
                        l = (n - o.left) * -o.speed;
                        break;
                    case "right":
                        l = (this.instance.limit[this.directionAxis] - n + this.windowHeight) * o.speed;
                        break;
                    default:
                        l = (r[this.directionAxis] - o.middle[this.directionAxis]) * -o.speed
                }
                o.sticky && (l = o.inView ? "horizontal" === this.direction ? this.instance.scroll.x - o.left + window.innerWidth : this.instance.scroll.y - o.top + window.innerHeight : "horizontal" === this.direction ? this.instance.scroll.x < o.left - window.innerWidth && this.instance.scroll.x < o.left - window.innerWidth / 2 ? 0 : this.instance.scroll.x > o.right && this.instance.scroll.x > o.right + 100 && o.right - o.left + window.innerWidth : this.instance.scroll.y < o.top - window.innerHeight && this.instance.scroll.y < o.top - window.innerHeight / 2 ? 0 : o.bottom - o.top + window.innerHeight), !1 !== l && ("horizontal" === o.direction || "horizontal" === this.direction && "vertical" !== o.direction ? this.transform(o.el, l, 0, !t && o.delay) : this.transform(o.el, 0, l, !t && o.delay))
            })
        }
        scrollTo(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                n = parseInt(e.offset) || 0;
            const i = isNaN(parseInt(e.duration)) ? 1e3 : parseInt(e.duration);
            let r = e.easing || [.25, 0, .35, 1];
            const s = !!e.disableLerp,
                a = !!e.callback && e.callback;
            if (r = Kh()(...r), "string" == typeof t) {
                if ("top" === t) t = 0;
                else if ("bottom" === t) t = this.instance.limit.y;
                else if ("left" === t) t = 0;
                else if ("right" === t) t = this.instance.limit.x;
                else if (!(t = document.querySelector(t))) return
            } else if ("number" == typeof t) t = parseInt(t);
            else if (!t || !t.tagName) return void console.warn("`target` parameter is not valid");
            if ("number" != typeof t) {
                if (!Xh(t).includes(this.el)) return;
                const e = t.getBoundingClientRect(),
                    i = e.top,
                    r = e.left,
                    s = Xh(t).find(t => Object.entries(this.sections).map(t => {
                        let [e, n] = t;
                        return n
                    }).find(e => e.el == t));
                let a = 0;
                a = s ? qh(s)[this.directionAxis] : -this.instance.scroll[this.directionAxis], n = "horizontal" === this.direction ? r + n - a : i + n - a
            } else n = t + n;
            const o = parseFloat(this.instance.delta[this.directionAxis]),
                l = Math.max(0, Math.min(n, this.instance.limit[this.directionAxis])) - o,
                c = t => {
                    s ? "horizontal" === this.direction ? this.setScroll(o + l * t, this.instance.delta.y) : this.setScroll(this.instance.delta.x, o + l * t) : this.instance.delta[this.directionAxis] = o + l * t
                };
            this.animatingScroll = !0, this.stopScrolling(), this.startScrolling();
            const h = Date.now(),
                u = () => {
                    var t = (Date.now() - h) / i;
                    t > 1 ? (c(1), this.animatingScroll = !1, 0 == i && this.update(), a && a()) : (this.scrollToRaf = requestAnimationFrame(u), c(r(t)))
                };
            u()
        }
        update() {
            this.setScrollLimit(), this.addSections(), this.addElements(), this.detectElements(), this.updateScroll(0), this.transformElements(!0), this.reinitScrollBar(), this.checkScroll(!0)
        }
        startScroll() {
            this.stop = !1
        }
        stopScroll() {
            this.stop = !0
        }
        setScroll(t, e) {
            this.instance = Jh(Jh({}, this.instance), {}, {
                scroll: {
                    x: t,
                    y: e
                },
                delta: {
                    x: t,
                    y: e
                },
                speed: 0
            })
        }
        destroy() {
            super.destroy(), this.stopScrolling(), this.html.classList.remove(this.smoothClass), this.vs.destroy(), this.destroyScrollBar(), window.removeEventListener("keydown", this.checkKey, !1)
        }
    };
    var cu = class {
        constructor() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            this.options = t, Object.assign(this, Fh, t), this.smartphone = Fh.smartphone, t.smartphone && Object.assign(this.smartphone, t.smartphone), this.tablet = Fh.tablet, t.tablet && Object.assign(this.tablet, t.tablet), this.smooth || "horizontal" != this.direction || console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible"), this.tablet.smooth || "horizontal" != this.tablet.direction || console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible (tablet)"), this.smartphone.smooth || "horizontal" != this.smartphone.direction || console.warn("🚨 `smooth:false` & `horizontal` direction are not yet compatible (smartphone)"), this.init()
        }
        init() {
            this.options.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1 || window.innerWidth < this.tablet.breakpoint, this.options.isTablet = this.options.isMobile && window.innerWidth >= this.tablet.breakpoint, this.smooth && !this.options.isMobile || this.tablet.smooth && this.options.isTablet || this.smartphone.smooth && this.options.isMobile && !this.options.isTablet ? this.scroll = new lu(this.options) : this.scroll = new jh(this.options), this.scroll.init()
        }
        update() {
            this.scroll.update()
        }
        start() {
            this.scroll.startScroll()
        }
        stop() {
            this.scroll.stopScroll()
        }
        scrollTo(t, e) {
            this.scroll.scrollTo(t, e)
        }
        setScroll(t, e) {
            this.scroll.setScroll(t, e)
        }
        on(t, e) {
            this.scroll.setEvents(t, e)
        }
        off(t, e) {
            this.scroll.unsetEvents(t, e)
        }
        destroy() {
            this.scroll.destroy()
        }
    };
    var hu = n(32),
        uu = n(48),
        du = n(10);
    n(382);
    var pu = n(37);
    Ll.a.smoothScrollCall = {}, Ll.a.fn.scroller = ol()(class {
        constructor(t) {
            if (Ll()(document).on("click." + this.ns, 'a[href*="#"]', this.handleHashLinkClick.bind(this)), !zh.a) return Ll()("html").addClass("no-scroll-smooth"), this.scrollToHash(), this;
            Ll()("html").removeClass("no-scroll-smooth"), this.$container = t, this.$content = null, this.$contentScrollParent = null, this.custom = !1, this.contentQueue = [], this.lastScrollPosition = null, this.ns = Object(El.a)(), this.scrolledToHash = null, this.snapPoints = [], this.gravityWells = [], this.updateGravityWells = this.updateGravityWells.bind(this), this.updateSnapPoints = this.updateSnapPoints.bind(this);
            const e = this.$scrollable = t.is("html, body") ? Ll()(window) : t;
            e.data("smooth-scroll", this);
            const n = t.find(".js-page-content-wrapper").eq(0);
            this.setScrollableContent(n), e.get(0) === window ? requestAnimationFrame(() => {
                this.init()
            }) : e.inview({
                destroyOnEnter: !0,
                enter: this.init.bind(this)
            }), this.updateDebounced = Il()(this.update.bind(this), 60), t.on("appear", this.updateDebounced), t.get(0).addEventListener("load", this.handleLoadEvent.bind(this), !0), Ll()(document).on("keydown." + this.ns, 'input:not([type="button"]), textarea, select', this.handleKeyDownEvent.bind(this)).on("keyup." + this.ns, 'input:not([type="button"]), textarea, select', this.handleKeyUpEvent.bind(this)), t.on("destroyed", this.destroy.bind(this)), Ll.a.fontsready && Ll.a.fontsready.then && Ll.a.fontsready.then(this.updateDebounced)
        }
        destroy() {
            Ll()(document).off("." + this.ns)
        }
        init() {
            const t = setInterval(this.fixScrollPosition.bind(this, !0), 16);
            setTimeout(() => clearInterval(t), 1e3), this.scrollToHash(), window.addEventListener("hashchange", () => {
                document.location.hash && "#" !== document.location.hash && this.fixScrollPosition(!0)
            })
        }
        fixScrollPosition(t) {
            const e = Ll()(window).scrollTopOriginal();
            e && (Ll()(window).scrollTopOriginal(0), t && Ll()(window).scrollTop(e), this.scroller && du.a.run())
        }
        getScrollableContent() {
            return this.$content
        }
        isScrollableContent(t) {
            if (t) {
                const e = this.$contentScrollParent;
                return !(!this.$content || !this.$content.is(t)) || !!e && (e.is(window) ? t[0] === window || t[0] === document.body || t[0] === document.documentElement : e.is(t))
            }
            return !0
        }
        unsetScrollableContent(t) {
            if (zh.a && t && t.length) {
                const e = this.contentQueue,
                    n = e.indexOf(t ? t.get(0) : null);
                if (-1 !== n) {
                    if (t && this.$content && this.$content.length && this.$content.is(t))
                        if (e.length > 1) {
                            const t = Ll()(e[e.length - 2]);
                            e.splice(e.length - 1, 1), this.setScrollableContent(t)
                        } else this.contentQueue = [], this.setScrollableContent(null);
                    e.splice(n, 1)
                }
            }
        }
        setScrollableContent(t) {
            if (zh.a) {
                this.lastScrollPosition = null;
                const e = this.$content;
                if (t && t.length) {
                    const e = this.contentQueue,
                        n = e.indexOf(t.get(0)); - 1 !== n ? e.splice(n + 1) : e.push(t.get(0))
                }
                if (!e || !e.is(t))
                    if (e && e.length && (e.data("smooth-scroll-last-scroll", this.scrollTop()), this.$contentScrollParent.data("smooth-scroll-last-scroll", this.scrollTop())), this.$content = t, this.$contentScrollParent = t ? t.scrollParent() : null, this.scroller && (this.scroller.stop(), this.scroller.destroy(), this.scroller = null, this.$content && this.$content.off("delta." + this.ns)), t && t.length) {
                        this.custom = !0, this.scroller = new cu({
                            lerp: pu.e,
                            el: this.$content.get(0),
                            smooth: !0,
                            smartphone: {
                                smooth: !0
                            },
                            tablet: {
                                breakpoint: 768
                            }
                        }), du.a.add(du.a.QUEUE_MEASURE, this.updateGravityWells), du.a.add(du.a.QUEUE_MEASURE, this.updateSnapPoints), this.gravityWells = this.getGravityWells(), this.setScrollSnapPoints(t.data("snapPoints")), this.updateGravityWells(),
                            function (t) {
                                const e = t.scroll.destroy,
                                    n = t.scroll.resize.bind(t.scroll);
                                window.removeEventListener("resize", t.scroll.checkResize, !1), du.a.add(du.a.QUEUE_MEASURE, n), t.scroll.destroy = function () {
                                    du.a.remove(du.a.QUEUE_MEASURE, n), e.call(this)
                                }, requestAnimationFrame(() => {
                                    du.a.run()
                                })
                            }(this.scroller), this.scroller.stop(), this.scroller.on("call", (function (t, e, n) {
                                t in Ll.a.smoothScrollCall && Ll.a.smoothScrollCall[t] && Ll.a.smoothScrollCall[t](e, n)
                            })), wo.a.isMac() && wo.a.isFirefox() && !this.scroller.scroll.vs.options.mouseMultiplierOverwritten && (this.scroller.scroll.vs.options.mouseMultiplierOverwritten = !0, this.scroller.scroll.vs.options.mouseMultiplier *= 2.5);
                        const e = t.data("smooth-scroll-last-scroll");
                        (e || 0 === e) && (t.data("smooth-scroll-last-scroll", null), t.scrollParent().scrollTop(e)), this.scroller.on("scroll", this.handleScroll.bind(this)), this.$content.on("delta." + this.ns, this.updateGravityWellDelta.bind(this)), this.$content.on("delta." + this.ns, Il()(this.snapToSection.bind(this), 250)), requestAnimationFrame(() => {
                            !this.disabled && this.scroller && (this.scroller.start(), this.handleScroll(!0))
                        })
                    } else du.a.remove(du.a.QUEUE_MEASURE, this.updateGravityWells), du.a.remove(du.a.QUEUE_MEASURE, this.updateSnapPoints), this.custom = !1, this.gravityWells = [], this.setScrollSnapPoints([])
            } else this.custom = !1;
            t && t.length && this.scrollToHash()
        }
        scrollToHash() {
            const t = document.location.hash,
                e = Object(hu.a)(t) ? Ll()(t) : Ll()();
            if (e.length) {
                "none" !== e.css("display") && !e.is(".modal") && "fixed" !== e.css("position") && (zh.a ? (this.fixScrollPosition(!1), t && this.scrolledToHash !== t && (this.scrolledToHash = t, setTimeout(() => {
                    this.scrollToElement(e, 0, !1)
                }, 16))) : t && this.scrolledToHash !== t && (this.scrolledToHash = t, Ll()(window).scrollToElement(e, 0, !1)))
            }
        }
        setDisabled(t) {
            this.disabled = !!t, this.custom && this.scroller && (t ? this.scroller.stop() : this.scroller.start())
        }
        setScrollMultiplier() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            if (this.scroller) {
                const n = this.scroller,
                    i = n.scroll.vs;
                let r = this.initialScrollMultipliers;
                if (r || (this.initialScrollMultipliers = r = Ll.a.extend({}, i.options)), Ll.a.extend(i.options, {
                    mouseMultiplier: r.mouseMultiplier * t,
                    touchMultiplier: r.touchMultiplier * t
                }), 1 !== t) {
                    const t = null !== e ? e : this.scrollTop();
                    n.scroll.instance.delta.y = t, n.scroll.instance.scroll.y = t, n.scroll.stop = !0, requestAnimationFrame(() => {
                        n.scroll.stop = !1
                    })
                }
                du.a.run()
            }
        }
        handleHashLinkClick(t) {
            if (!t.isDefaultPrevented()) {
                const e = Ll()(t.target).closest("a").attr("href").replace(/.*#/, "");
                if (e && Object(hu.a)("#" + e)) {
                    const n = Ll()("#" + e);
                    n && n.length && "fixed" !== n.css("position") && (t.preventDefault(), zh.a ? this.$content.scrollToElement(n) : Ll()(window).scrollToElement(n))
                }
            }
        }
        scrollTo(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e3;
            this.scroller ? this.disabled || this.scroller.scrollTo(t, {
                duration: e
            }) : Ll()(window).scrollTopOriginal(t)
        }
        scrollToElement(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            if (t.length) {
                const i = t.pageOffset().top + e;
                n ? this.scrollTo(i) : this.scrollTop(i)
            }
        }
        scrollTop(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            if (!e || this.isScrollableContent(e)) {
                if ("number" == typeof t) return this.disabled || (this.scroller.setScroll(0, t), this.scroller.scroll.checkScroll(!0)), this;
                if (this.scroller) return this.scroller.scroll.instance.scroll.y
            }
            return 0
        }
        update() {
            this.scroller && !this.disabled && (du.a.run(), this.fixOverScroll())
        }
        fixOverScroll() {
            const t = this.scroller.scroll;
            t.instance.scroll.y > t.instance.limit && (this.scroller.scroll.isScrolling ? requestAnimationFrame(this.fixOverScroll.bind(this)) : this.scrollTo(t.instance.limit))
        }
        handleScroll() {
            let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            const e = this.scrollTop();
            this.updateGravityWellLerp(e), this.disabled || !0 !== t && this.lastScrollPosition === e || (this.lastScrollPosition = e, this.$content.trigger("scroll", {
                custom: !0
            }))
        }
        handleLoadEvent(t) {
            Ll()(t.target).is("img") && this.updateDebounced()
        }
        handleKeyDownEvent(t) {
            this.disabled || 35 != t.which && 36 != t.which && 38 != t.which && 40 != t.which || (this.disabledByKeyboard = !0, this.setDisabled(!0))
        }
        handleKeyUpEvent() {
            this.disabled && this.disabledByKeyboard && this.setDisabled(!1)
        }
        updateGravityWellLerp(t) {
            const e = this.gravityWells,
                n = 100 * Ko.lvh();
            let i = this.scroller.lerp;
            for (let r = 0; r < e.length; r++) {
                const s = e[r].offset - n * pu.d,
                    a = e[r].offset + n * pu.d;
                if (t > s && t < a) {
                    const e = (a - s) / 2;
                    i *= Math.max(0, Math.min(1, (Math.abs(t - (s + e)) / e + pu.c) / (1 + pu.c)))
                }
            }
            this.scroller.scroll.lerp = i
        }
        updateGravityWellDelta(t) {
            const e = t.originalEvent.detail,
                n = this.gravityWells,
                i = Math.sign(e.next - e.current),
                r = 100 * Ko.lvh();
            for (let t = 0; t < n.length; t++) {
                const s = n[t].offset - r * pu.d,
                    a = n[t].offset + r * pu.d,
                    o = Object(uu.a)(Math.min(e.current, e.next), s, a),
                    l = Object(uu.a)(Math.max(e.current, e.next), s, a) - o;
                l && (e.next -= l * i * (1 - pu.b))
            }
        }
        updateGravityWells() {
            const t = 100 * Ko.lvh();
            this.gravityWells.forEach(e => {
                const n = e.$el.pageOffset();
                e.offset = n.scrollTop + n.height * e.element - t * e.viewport, e.$debug && e.$debug.css("top", e.offset + "px")
            })
        }
        getGravityWells() {
            return this.$content.find("[data-scroll-gravity-well]").toArray().map(t => {
                const e = Ll()(t),
                    n = (parseFloat(e.data("scrollGravityWellViewport")) || 0) / 100,
                    i = (parseFloat(e.data("scrollGravityWellElement")) || 0) / 100;
                e.data("scrollGravityWellDebug");
                return {
                    $el: e,
                    viewport: n,
                    element: i,
                    offset: 0,
                    $debug: null
                }
            })
        }
        setScrollSnapPoints() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
            this.$content && this.$content.length ? (this.$content.data("snapPoints", t), this.snapPoints = t.map(t => {
                const e = t.offset ? t.offset.match(/^(-?[\d.]+)vh$/) : null;
                return {
                    element: Ll()(t.reference),
                    offset: e && parseFloat(e[1]) || 0,
                    scrollable: t.scrollable || !1,
                    scroll: 0,
                    scrollEnd: 0,
                    reference: t.reference,
                    offsetText: t.offset
                }
            }), this.updateSnapPoints()) : this.snapPoints = []
        }
        updateSnapPoints() {
            this.snapPoints.forEach((t, e) => {
                const n = t.element.pageOffset();
                t.scroll = n.scrollTop + n.scrollViewportSize * t.offset / 100, t.scrollEnd = t.scroll + n.scrollViewportSize, t.scrollable ? t.scrollEnd = t.scroll + n.height - n.scrollViewportSize : e > 0 && this.snapPoints[e - 1].scrollable && (this.snapPoints[e - 1].scrollEnd = t.scroll - 1)
            })
        }
        snapToSection(t) {
            const e = t.originalEvent.detail,
                n = e.next,
                i = this.snapPoints,
                r = i.length,
                s = 100 * Ko.lvh();
            let a = -1,
                o = Number.MAX_SAFE_INTEGER;
            for (let t = 0; t < r; t++) {
                const l = i[t],
                    c = t > 0 ? i[t - 1] : null,
                    h = t < r - 1 ? i[t + 1] : null;
                let u = Math.abs(l.scroll - n),
                    d = l.scroll;
                if (0 === t && n < l.scroll) break;
                if (t === r - 1 && n > l.scroll) {
                    a = -1;
                    break
                }
                if (l.scrollable && n > l.scroll) {
                    if (n < l.scrollEnd) {
                        a = -1, o = Number.MAX_SAFE_INTEGER;
                        break
                    }
                    u = Math.abs(l.scrollEnd - n), d = l.scrollEnd
                } !l.scrollable && c && c.scrollEnd !== l.scroll && n > c.scrollEnd && n < l.scroll - s / 2 && e.delta > 0 && (u = Number.MAX_SAFE_INTEGER), !l.scrollable && h && h.scrollEnd !== l.scroll && n < h.scroll && n > l.scrollEnd - s / 2 && e.delta < 0 && (u = o = Number.MAX_SAFE_INTEGER), u < o && (o = u, a = d)
            } - 1 !== a && this.scrollTo(a)
        }
        debugSnapPoints() {
            pu.f && this.snapPoints.forEach(t => {
                t.$debug || (t.$debug = Ll()("<div />").css({
                    position: "fixed",
                    left: "0px",
                    top: t.scroll + "px",
                    width: "100%",
                    zIndex: 999,
                    "border-top": "5px solid rgba(255, 0, 0, 0.5)",
                    color: "red",
                    padding: "10px"
                }).text(t.reference + ", " + t.offsetText).appendTo(this.$content))
            })
        }
        updateDebug(t) {
            pu.f && this.snapPoints.forEach(e => {
                e.$debug && e.$debug.css("transform", `translateY(${-t}px)`)
            }), this.gravityWells.forEach(e => {
                e.$debug && e.$debug.css("transform", `translateY(${-t}px)`)
            })
        }
    }, {
        namespace: "smooth-scroll"
    });
    var fu = n(89);
    $.fn.scrollToAnimated = function (t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
            n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
            i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
        const r = $(this).scrollTop();
        let s = 0,
            a = window.innerHeight;
        if ("number" == typeof t) s = t + e;
        else if (t instanceof $) {
            const n = t.pageOffset();
            a = n.scrollViewportSize, s = n.scrollTop + e
        }
        n && (n = Math.abs(r - s) > 2 * a), n ? Object(fu.b)(() => {
            $(this).scrollTopInstant(s), Object(fu.a)()
        }) : $(this).scrollTo(s, i)
    };
    const mu = [];
    let gu = null;

    function vu() {
        mu.forEach(t => t()), gu = requestAnimationFrame(vu)
    }

    function yu(t) {
        mu.push(t), 1 === mu.length && (gu = requestAnimationFrame(vu))
    }

    function bu(t) {
        const e = mu.indexOf(t); - 1 !== e && (mu.splice(e, 1), mu.length || (cancelAnimationFrame(gu), gu = null))
    }
    $.fn.onPreciseScroll = function (t) {
        const e = Object(El.a)();
        if ($.isCustomScroll && $.isCustomScroll()) return this.on("scroll." + e, t), () => {
            this.off("." + e)
        };
        {
            let n = this.scrollTop();
            const i = () => {
                const e = this.scrollTop();
                n !== e && (n = e, t())
            };
            return this.onpassive("scroll." + e, i), yu(i), () => {
                this.offpassive("." + e), bu(i)
            }
        }
    };
    var xu = n(139);

    function _u(t, e) {
        if (t === ~~t) return t;
        const n = Math.pow(10, e);
        return ~~(t * n) / n
    }
    const wu = /-?[\d.]+/g;

    function Su(t, e) {
        const n = [];
        return {
            property: t,
            string: String(e).replace(wu, t => (n.push(parseFloat(t)), "%d")).split("%d"),
            values: n
        }
    }

    function Mu(t) {
        const e = [];
        for (let n in t) "easing" !== n && e.push(Su(n, t[n]));
        return e
    }
    var Eu = n(63);
    const Tu = {
        parallaxFrom: [null, "100", "0"],
        parallaxTo: [null, "0", "100"]
    },
        Cu = /parallax-(-?[\d.]+)(vw|vh|svh|lvh|dvh)?(-(-?[\d.]+))?/i,
        Au = ["opacity", "transform"],
        Ru = ["elementSize", "elementOffset", "viewBoxSize", "viewBoxOffset", "viewportSize"];
    class Pu {
        constructor(t, e) {
            const n = this.options = Object.assign({}, e.options);
            this.$container = e.$container, this.$scrollParent = e.$scrollParent, this.ns = Object(El.a)(), this.parent = e, this.isEnabled = !1, this.hasDynamicProperties = !1, this.constraintsCache = null, this.constraints = null, this.easingName = null, this.easing = n.easing || null, this.clamp = n.clamp || !1, this.updateCallback = null, this.resetCallback = null, this.hwProperties = [], this.resetProperties = {}, this.patternName = "string" == typeof t ? t : "", this.pattern = t, this.points = null, this.positionCache = 0, this.positionEasedCache = 0, this.interpolationCache = null, this.$viewBox = function (t, e) {
                let n = t.parent();
                for (; n.length && !n.is("body") && !n.is(e) && (n = n.parent(), "hidden" !== n.css("overflow") && !n.is("[data-scroll-section]") || "sticky" === n.css("position") || n.data("parallaxEffect") || n.is("[data-scroll-sticky], [data-native-sticky]")););
                return n.is("body") || n.is(e) ? null : n
            }(this.$container, this.$scrollParent), this.$measure = function (t, e) {
                let n = e ? t.closest(e) : $();
                return e && !n.length && (n = t.findElement(e)), !e || n && n.length || console.error("Parallax plugin failed to find measureSelector element\n\tselector:", e, "\n\telement:", t.get(0)), n && n.length ? n : t
            }(this.$container, n.measureSelector)
        }
        init() {
            this.conditional = Object(xu.a)(this.$container, this.options, {
                enable: this.enable.bind(this),
                disable: this.disable.bind(this)
            })
        }
        isValid() {
            return this.conditional.enabled || this.conditional.dynamic
        }
        enable() {
            this.isEnabled || (this.isEnabled = !0, this.parent.checkEnabled())
        }
        disable() {
            this.isEnabled && (this.isEnabled = !1, this.parent.checkEnabled())
        }
        get position() {
            return this.positionEasedCache
        }
        get values() {
            return this.interpolationCache
        }
        set pattern(t) {
            let e = null;
            if ($.isPlainObject(t)) this._pattern = e = t;
            else if ("string" == typeof t) {
                if (!(t in $.fn.parallax.patterns)) throw this._pattern = null, new Error(`Parallax pattern "${t}" doesn't exist\n`, this.$container.get(0));
                this._pattern = e = $.fn.parallax.patterns[t]
            } else "function" == typeof t && (this._pattern = e = t);
            if (e) {
                const t = this.options;
                for (let n in t) n in e && (t[n] = e[n])
            }
        }
        get pattern() {
            return this._pattern
        }
        set easing(t) {
            t ? "function" == typeof t ? (this.easingName = t.name, this._easing = t) : Eu[t] ? (this.easingName = t, this._easing = Eu[t]) : console.warn(`Parallax easing "${t}" not found`) : (this.easingName = null, this._easing = null)
        }
        get easing() {
            return this._easing
        }
        getHWAcceleratedProperties() {
            return this.hwProperties
        }
        getResetProperties() {
            return this.resetProperties
        }
        process(t) {
            const e = [],
                n = [];
            let i = null;
            if ("function" == typeof t) this.hasDynamicProperties = !0, i = t.apply(this, this.parent.datasetOptions);
            else if ($.isPlainObject(t))
                if (i = t, "function" == typeof t.parallax) this.hasDynamicProperties = !0, i = Object.assign({}, i, t.parallax.apply(this, this.parent.datasetOptions));
                else if (this.points) return this.points;
            for (let t in i) {
                const r = i[t];
                if (r) {
                    let i, s = null;
                    if ("easing" === t ? this.easing = r : "update" === t ? this.updateCallback = r : "reset" === t ? this.resetCallback = r : "clamp" === t ? this.clamp = !!r : s = t in Tu ? Tu[t] : t.match(Cu), s) {
                        const [t, a, o, l, c] = s;
                        if ($.isPlainObject(r)) i = r;
                        else try {
                            i = JSON.parse(r)
                        } catch (t) {
                            i = {}
                        }
                        const h = "easing" in i ? i.easing : null;
                        let u = h;
                        if (u && "function" != typeof u && (Eu[u] ? u = Eu[u] : console.warn(`Parallax easing "${u}" not found`)), e.push({
                            viewport: parseFloat(a) / 100,
                            viewportUnit: o ? o.toLowerCase() : "default",
                            element: c ? parseFloat(c) / 100 : null,
                            properties: Mu(i),
                            easing: u,
                            easingName: "function" == typeof h ? "custom" : h,
                            scroll: null
                        }), !n.length)
                            for (let t in i) n.push(t)
                    }
                }
            }
            return this.hwProperties = n.filter(t => Au.includes(t)), this.resetProperties = n.reduce((t, e) => (t[e] = "", t), {}), this.options.debug, e.length >= 2 ? e : (console.error("Parallax plugin failed to process group configuration\n\tfor:", t, "\n\toptions:", i, "\n\telement:", this.$container.get(0)), null)
        }
        getConstraints() {
            const t = this.$measure.pageOffset(),
                e = this.$viewBox,
                n = e ? e.pageOffset() : null,
                i = {
                    elementSize: t.scrollHeight,
                    elementOffset: _u(t.scrollTop, 1),
                    viewBoxSize: n ? n.scrollHeight : null,
                    viewBoxOffset: n ? _u(n.scrollTop, 1) : null,
                    viewportSize: t.scrollViewportSize,
                    viewportSizeList: null
                };
            return t.scrollViewportNatural ? i.viewportSizeList = {
                default: 100 * Ko.lvh(),
                vh: window.innerHeight,
                vw: window.innerWidth,
                svh: 100 * Ko.svh(),
                dvh: 100 * Ko.dvh(),
                lvh: 100 * Ko.lvh()
            } : i.viewportSizeList = {
                default: window.innerWidth,
                vh: window.innerHeight,
                vw: window.innerWidth,
                svh: window.innerWidth,
                dvh: window.innerWidth,
                lvh: window.innerWidth
            }, i
        }
        update() {
            const t = this.getConstraints();
            if (! function (t, e, n) {
                if (t && !e || !t && e) return !0;
                for (let i = 0; i < n.length; i++) {
                    const r = n[i];
                    if (t[r] !== e[r]) return !0
                }
                return !1
            }(t, this.constraintsCache, Ru)) return;
            this.constraintsCache = t;
            const {
                elementSize: e,
                elementOffset: n,
                viewBoxSize: i,
                viewBoxOffset: r,
                viewportSize: s,
                viewportSizeList: a
            } = t, o = this.points = this.process(this.pattern);
            let l = 1 / 0,
                c = -1 / 0;
            for (let t = 0; t < o.length; t++) {
                const i = o[t];
                let r;
                r = null === i.element ? i.viewport * a[i.viewportUnit] : e * i.element + n - i.viewport * a[i.viewportUnit], l = Math.min(l, r), c = Math.max(c, r), i.scroll = r
            }
            o.sort((t, e) => t.scroll - e.scroll);
            const h = Math.max(s, i);
            if (this.constraints = {
                from: l,
                to: c,
                viewFrom: i ? r - h : null,
                viewTo: i ? r + h : null,
                elementSize: e
            }, this.constraints.viewFrom || this.constraints.viewTo) {
                const t = this.$measure.closest("[data-scroll-sticky], [data-native-sticky]");
                if (t.length) {
                    const e = $(t.attr("data-scroll-target"));
                    if (e.length) {
                        const n = t.outerHeight(),
                            i = e.outerHeight();
                        this.constraints.viewTo += i - n
                    }
                }
            }
        }
        interpolate(t) {
            if (!this.constraints) return {};
            const e = this.easing;
            let n = this.getPositionFromScroll(t),
                i = n;
            if (this.clamp && (n = i = Math.min(1, Math.max(0, n))), e && (i = e(null, i, 0, 1, 1)), this.positionCache = n, this.positionEasedCache === i && this.interpolationCache) return this.interpolationCache;
            {
                this.positionEasedCache = i;
                const t = this.getScrollFromPosition(i),
                    e = this.points,
                    n = {};
                let r = e[0],
                    s = e[e.length - 1];
                for (let n = 1; n < e.length - 1; n++) {
                    if (e[n].scroll >= t) {
                        s = e[n];
                        break
                    }
                    r = e[n]
                }
                const a = r.properties,
                    o = s.properties,
                    l = this.getPositionFromScroll(r.scroll);
                let c = (i - l) / (this.getPositionFromScroll(s.scroll) - l);
                r.easing && (c = r.easing(null, c, 0, 1, 1));
                for (let t = 0, e = a.length; t < e; t++) {
                    let e = a[t].values,
                        i = o[t].values,
                        r = [a[t].string[0]];
                    if (e.length)
                        for (let n = 0, s = e.length; n < s; n++) r.push((i[n] - e[n]) * c + e[n]), r.push(a[t].string[n + 1]);
                    else c > .5 && (r = [o[t].string[0]]);
                    n[a[t].property] = r.join("")
                }
                return this.interpolationCache = n, n
            }
        }
        isInView(t) {
            const e = this.constraints;
            return !!e && (null === e.viewFrom || t >= e.viewFrom && t <= e.viewTo)
        }
        getPositionFromScroll(t) {
            const e = this.constraints;
            return (t - e.from) / (e.to - e.from)
        }
        getScrollFromPosition(t) {
            const e = this.constraints;
            return t * (e.to - e.from) + e.from
        }
        triggerUpdate() {
            this.updateCallback && this.updateCallback(this)
        }
        triggerReset() {
            this.interpolationCache && this.hasDynamicProperties && (this.interpolationCache = null), this.resetCallback && this.resetCallback(this)
        }
    }
    Pu.testProperty = function (t, e) {
        return !!(t in Tu && e || t.match(Cu))
    };
    class Lu {
        static get Defaults() {
            return {
                parallaxPattern: null,
                parallaxFrom: null,
                parallaxTo: null,
                clamp: !1,
                measureSelector: null,
                easing: null,
                mobileSmooth: !1,
                enableMq: "md-up",
                enableReducedMotion: !1,
                enableTouch: !0,
                enableHover: !0,
                enableSmoothScroll: !0,
                enableNotSmoothScroll: !0,
                enableMobileSafari: !0,
                useWillChange: !1,
                debug: !1
            }
        }
        constructor(t, e) {
            const n = this.options = Ll.a.extend({}, this.constructor.Defaults, e),
                i = this.$container = Ll()(t);
            this.datasetOptions = Ll.a.extend({}, n, i.get(0).dataset), this.$scrollParent = i.parent().scrollParent(), this.isEnabled = !1, this.inView = !0, this.scroll = 0, this.smoothScroll = null, this.useWillChange = this.options.useWillChange, this.resetProperties = this.resetProperties.bind(this), this.updateConstraints = this.updateConstraints.bind(this), this.updateScroll = this.updateScroll.bind(this), this.updateScrollForced = this.updateScrollForced.bind(this), this.update = this.update.bind(this), this.toggleCSSVisibility = !0, this.groups = [], this.processConfigurationIntoGroups(this.datasetOptions), this.useWillChange && wo.a.isSafari() && (this.useWillChange = !1), this.groups.length ? (this.$container.on("destroyed", this.destroy.bind(this)), this.options.debug && Lu.Debug && (this.debug = new Lu.Debug(this))) : this.destroy()
        }
        checkEnabled() {
            const t = this.groups || [];
            let e = !1;
            for (let n = 0; n < t.length; n++) t[n].isEnabled && (e = !0);
            this.isEnabled !== e && (e ? this.enable() : this.disable(), du.a.schedule())
        }
        removeGroup(t) {
            const e = this.groups.indexOf(t); - 1 !== e && this.groups.splice(e, 1), this.groups.length || this.destroy()
        }
        enable() {
            const t = _o.a.matches("sm-down");
            du.a.add(du.a.QUEUE_RESET, this.resetProperties), du.a.add(du.a.QUEUE_MEASURE, this.updateConstraints), du.a.add(du.a.QUEUE_APPLY, this.updateScrollForced), du.a.run(), this.options.mobileSmooth && t && (this.smoothScroll = new kl.a(this.scroll, {
                strength: "number" == typeof this.options.mobileSmooth ? this.options.mobileSmooth : .15,
                precision: .25,
                update: this.update
            })), this.toggleCSSVisibility = !t, this.detachScroll = this.$scrollParent.onPreciseScroll(this.updateScroll), this.updateConstraints(), this.isEnabled = !0
        }
        disable() {
            this.isEnabled && (du.a.remove(du.a.QUEUE_RESET, this.resetProperties), du.a.remove(du.a.QUEUE_MEASURE, this.updateConstraints), du.a.remove(du.a.QUEUE_APPLY, this.updateScrollForced), this.smoothScroll && (this.smoothScroll.destroy(), this.smoothScroll = null), this.toggleCSSVisibility && this.$container.css("visibility", ""), this.detachScroll(), this.resetProperties(), this.isEnabled = !1)
        }
        destroy() {
            this.disable(), this.$container.removeData("parallaxEffect"), this.$container = this.groups = this.options = null
        }
        refresh() {
            this.isEnabled && (this.resetProperties(), this.updateConstraints(), this.updateScrollForced())
        }
        reset() {
            du.a.run()
        }
        processConfigurationIntoGroups(t) {
            const e = this.groups = [];
            if (t.parallaxPattern) {
                const n = t.parallaxPattern.trim().split(" ");
                for (let t = 0; t < n.length; t++) {
                    n[t].trim() && e.push(new Pu(n[t], this))
                }
            }
            let n = !1;
            for (let e in t)
                if (Pu.testProperty(e, t[e])) {
                    n = !0;
                    break
                } if (n && e.push(new Pu(t, this)), e.length) {
                    const t = [];
                    for (let n = 0; n < e.length; n++) e[n].init(), e[n].isValid() && t.push(e[n]);
                    this.groups = t
                } else console.error("Parallax plugin missing patterns or failed to process configuration\n\tfor:", t)
        }
        resetProperties() {
            this.$container.css(this.getResetProperties())
        }
        updateConstraints() {
            if (!this.$container) return;
            this.resetProperties();
            const t = this.groups;
            let e = [];
            for (let n = 0; n < t.length; n++) t[n].isEnabled && (t[n].update(), e = e.concat(t[n].getHWAcceleratedProperties()));
            this.useWillChange && this.$container.css("will-change", Fl()(e).join(", "))
        }
        getResetProperties() {
            const t = {},
                e = this.groups;
            for (let n = 0; n < e.length; n++) e[n].isEnabled && e[n].triggerReset(), Object.assign(t, e[n].getResetProperties());
            return t
        }
        updateScroll() {
            this.scroll = this.$scrollParent.scrollTop(), this.smoothScroll ? this.smoothScroll.set(this.scroll) : this.update()
        }
        updateScrollForced() {
            this.scroll = this.$scrollParent.scrollTop(), this.smoothScroll && this.smoothScroll.set(this.scroll), this.update()
        }
        update() {
            if (this.isEnabled) {
                const t = this.smoothScroll ? this.smoothScroll.get() : this.scroll,
                    e = this.groups;
                let n = !1;
                for (let i = 0; i < e.length; i++)
                    if (e[i].isEnabled && e[i].isInView(t)) {
                        n = !0;
                        break
                    } if (n) {
                        const n = {};
                        this.toggleCSSVisibility && (n.visibility = "");
                        for (let i = 0; i < e.length; i++)
                            if (e[i].isEnabled) {
                                e[i].triggerUpdate();
                                const r = e[i].interpolate(t);
                                for (let t in r) "transform" === t && n[t] ? n[t] += " " + r[t] : "opacity" === t ? (t in n || (n[t] = 1), n[t] = n[t] * parseFloat(r[t])) : n[t] = r[t]
                            } this.$container.css(n)
                    } else this.inView && this.toggleCSSVisibility && this.$container.css("visibility", "hidden");
                this.inView = n
            }
            this.debug && this.debug.update()
        }
    }
    Ll.a.fn.parallax = ol()(Lu, {
        namespace: "parallax"
    }), Ll.a.fn.parallax.patterns = {}, Lu.Debug = function () { };
    n(383), n(384);

    function Ou(t) {
        const e = t.find(".intro-sticky__sticky-container");
        return Math.ceil(t.height() - e.height()) / window.innerHeight * 100
    }
    $.extend($.fn.parallax.patterns, {
        "intro-image-move": {
            parallax: function () {
                const t = $(".js-intro-title").pageOffset(),
                    e = t.top + t.height / 2 + 20;
                return {
                    "parallax-0-0": {
                        transform: `translateY(0%) translateY(${e}px) scale(1.19)`
                    },
                    [`parallax-${-Ou(this.$measure)}-0`]: {
                        transform: `translateY(-6%) translateY(${e}px) scale(1)`
                    },
                    "parallax-0-100": {
                        transform: `translateY(-20%) translateY(${e}px) scale(1)`
                    }
                }
            }
        },
        "intro-image-clip": {
            clamp: !0,
            parallax: function () {
                return {
                    "parallax-0-0": {
                        "clip-path": "polygon(19% 0%, 80% 0%, 81% 100%, 19% 100%)"
                    },
                    [`parallax-${-Ou(this.$measure)}-0`]: {
                        "clip-path": "polygon(0% 6%, 100% 6%, 100% 100%, 0% 100%)"
                    }
                }
            }
        },
        "intro-text": {
            clamp: !0,
            parallax: function () {
                return {
                    "parallax-0-0": {
                        transform: "translateY(0vh)"
                    },
                    [`parallax-${-Ou(this.$measure)}-0`]: {
                        transform: "translateY(-15vh)"
                    },
                    "parallax-0-100": {
                        transform: "translateY(-40vh)"
                    }
                }
            }
        },
        "intro-button": {
            clamp: !0,
            parallax: function () {
                const t = Ou(this.$measure);
                return {
                    "parallax-0-0": {
                        opacity: 1
                    },
                    [`parallax-${-t}-0`]: {
                        opacity: 1
                    },
                    [`parallax-${-t - 5}-0`]: {
                        opacity: 0
                    }
                }
            }
        },
        "intro-flower": {
            clamp: !0,
            "parallax-0lvh": {
                transform: "translateY(-50%)"
            },
            "parallax-100lvh": {
                transform: "translateY(0%)"
            }
        },
        "architecture-building": {
            enableMq: "md-up",
            parallax() {
                const t = Object(Dh.a)(window.innerWidth, 1600, 2440, 0, 45, !0) + Object(Dh.a)(window.innerWidth, 2440, 2800, 0, 6, !0),
                    e = $(".architecture__inner-text"),
                    n = e.height(),
                    i = parseFloat(e.parent().css("padding-top")) || 0;
                return {
                    "parallax-0-0": {
                        transform: `translateY(0vw) translateY(0vw) translateY(${n + i}px)`
                    },
                    "parallax-0-100": {
                        transform: `translateY(-30vw) translateY(${t}vw) translateY(${n + i}px)`
                    }
                }
            },
            update(t) {
                const e = Object(Dh.a)(t.position, 0, .7, 0, 1, !0);
                this.$container.sequence("setProgress", e)
            }
        },
        "architecture-shade": {
            measureSelector: ".architecture__frame-sticky",
            clamp: !0,
            "parallax-100-100": {
                opacity: 0
            },
            "parallax-0-100": {
                opacity: 1
            }
        },
        "window-image": {
            measureSelector: ".architecture__frame",
            clamp: !0,
            "parallax-20-0": {
                transform: " scale(1.3)"
            },
            "parallax-0-100": {
                transform: "scale(1)"
            }
        },
        "window-image-mobile": {
            clamp: !0,
            enableMq: "sm-down",
            "parallax-100-0": {
                transform: "scale(0.5)"
            },
            "parallax-0-100": {
                transform: "scale(1.2)"
            }
        },
        "architecture-bg": {
            clamp: !0,
            "parallax-100-0": {
                transform: "translateY(15%)"
            },
            "parallax-100-20": {
                transform: "translateY(0%)"
            },
            "parallax-100-80": {
                transform: "translateY(-45%)"
            }
        },
        "architecture-frame": {
            clamp: !0,
            "parallax-100-0": {
                transform: "translateY(15%)"
            },
            "parallax-100-20": {
                transform: "translateY(0%)"
            }
        },
        "architecture-window": {
            measureSelector: ".architecture__frame-sticky",
            clamp: !0,
            enableMq: null,
            parallax: function () {
                const t = this.$container.get(0),
                    e = t.offsetWidth,
                    n = t.offsetHeight,
                    i = 1.3 * Math.max(window.innerWidth / e, 100 * Ko.lvh() / n),
                    r = 1.45 * (window.innerWidth / 100 * (_o.a.matches("xxxxl") ? 31.14 : _o.a.matches("xl-up") ? 33.33 : _o.a.matches("md-up") ? 35 : 55)) / 2 / window.innerHeight * 100,
                    s = _o.a.matches("lg-up") ? 0 : 15;
                return _o.a.matches("sm-down") ? {
                    "parallax-0-0": {
                        transform: "translateY(50%) scale(1)"
                    },
                    "parallax-100-100": {
                        transform: `translateY(50%) scale(${i})`
                    }
                } : {
                    [`parallax-${100 - (s + r)}-0`]: {
                        transform: "translateY(50%) scale(1)"
                    },
                    "parallax-100-100": {
                        transform: `translateY(50%) scale(${i})`
                    }
                }
            }
        },
        "horizontal-scroll": {
            enableMq: null,
            parallax: function () {
                const t = this.$container.get(0);
                return {
                    "parallax-100-100": {
                        transform: "translateX(0px)"
                    },
                    "parallax-0-0": {
                        transform: `translateX(${-Math.max(0, t.scrollWidth - t.offsetWidth)}px)`
                    }
                }
            }
        },
        "joy-map": {
            clamp: !0,
            measureSelector: ".joy-map",
            "parallax-100-0": {
                transform: "translateY(calc(var(--lvh) * 0)"
            },
            "parallax-0-100": {
                transform: "translateY(calc(var(--lvh) * 10))"
            }
        },
        "interiors-image": {
            clamp: !0,
            "parallax-100-0": {
                transform: "translateY(calc(var(--lvh) * 0)"
            },
            "parallax-0-100": {
                transform: "translateY(calc(var(--lvh) * 60)"
            }
        },
        "interiors-card": {
            measureSelector: ".interiors-ceilings-wrapper",
            clamp: !0,
            "parallax-10-0": {
                transform: "translateY(-150%) translateY(calc(var(--lvh) * -70))"
            },
            "parallax-0-100": {
                transform: "translateY(-150%) translateY(calc(var(--lvh) * -130))"
            }
        },
        "interiors-shade": {
            measureSelector: ".interiors-ceilings",
            clamp: !0,
            "parallax-100-50": {
                opacity: 0
            },
            "parallax-100-80": {
                opacity: .8
            }
        },
        apartments: {
            clamp: !0,
            measureSelector: ":root .interiors-ceilings",
            "parallax-100-50": {
                "clip-path": "polygon(50% 50%, 50% 50%, 50% 50%, 50% 50%)",
                "pointer-events": "none"
            },
            "parallax-100-80": {
                "clip-path": "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)",
                "pointer-events": "all"
            }
        },
        "apartments-image": {
            clamp: !0,
            measureSelector: ":root .interiors-ceilings-wrapper",
            "parallax-100-30": {
                transform: "scale(1.2)"
            },
            "parallax-100-80": {
                transform: "scale(1)"
            }
        },
        "apartments-title": {
            measureSelector: ":root .interiors-ceilings",
            "parallax-100-50": {
                progress: 0
            },
            "parallax-100-80": {
                progress: 1
            },
            update() {
                const t = this.progressIsActive || !1,
                    e = this.position > .99;
                e !== t && (this.progressIsActive = e, e ? this.$container.transitionstop(() => {
                    this.$container.transition("title-alt")
                }) : this.$container.transitionstop(() => {
                    this.$container.transition("fade-out", {
                        after: t => t.removeClass("is-hidden").addClass("is-invisible--js")
                    })
                }))
            }
        },
        "apartments-choice": {
            measureSelector: ":root .interiors-ceilings",
            "parallax-100-50": {
                progress: 0
            },
            "parallax-100-80": {
                progress: 1
            },
            update() {
                const t = this.progressIsActive || !1,
                    e = this.position > .99;
                e !== t && (this.progressIsActive = e, e ? this.$container.transitionstop(() => {
                    this.$container.transition("move-up-choice")
                }) : this.$container.transitionstop(() => {
                    this.$container.transition("fade-out", {
                        after: t => t.removeClass("is-hidden").addClass("is-invisible--js")
                    })
                }))
            }
        },
        "new-era-building": {
            clamp: !0,
            "parallax-50-0": {
                transform: "translateY(calc(var(--lvh) * 40))"
            },
            "parallax-50-100": {
                transform: "translateY(calc(var(--lvh) * 0))"
            }
        },
        "new-era-flower": {
            clamp: !0,
            "parallax-100-0": {
                transform: "translateY(calc(var(--lvh) * 0))"
            },
            "parallax-100-100": {
                transform: "translateY(calc(var(--lvh) * 30))"
            }
        }
    });
    n(385), n(386), n(387), n(388);
    var Du = n(29);
    $.extend($.fn.parallax.patterns, {
        "words-fill-in": {
            clamp: !0,
            measureSelector: ".section",
            enableMq: "md-up",
            "parallax-0-0": {
                progress: 0
            },
            "parallax--100-0": {
                progress: 1
            },
            update(t) {
                t.$words || (t.$container.splitLines(), t.$words = t.$container.find(".word"));
                t.$words.each((e, n) => {
                    const i = $(n).data("lineIndex") / (t.$words.eq(-1).data("lineIndex") + 1),
                        r = Object(Dh.a)(t.position, 0, 1, -.2, 1.2),
                        s = Object(Dh.a)(r - i, -.2, .2, .3, 1);
                    $(n).css("opacity", s)
                })
            }
        },
        "words-zoom": {
            measureSelector: ".section",
            enableMq: "md-up",
            clamp: !0,
            easing: "easeInExpo",
            "parallax--100-0": {
                transform: "scale(1)",
                opacity: 1
            },
            "parallax--200-0": {
                transform: "scale(2.8)",
                opacity: 0
            }
        },
        "words-zoom-mob": {
            measureSelector: ".section",
            enableMq: "sm-down",
            clamp: !0,
            "parallax-0-0": {
                transform: "scale(1)",
                opacity: 1
            },
            "parallax--100-0": {
                transform: "scale(2.8)",
                opacity: 0
            }
        },
        "gradient-location-inforgraphic": {
            measureSelector: ".section",
            clamp: !0,
            enableMq: "md-up",
            "parallax-100-0": {
                transform: "translateY(-20%)"
            },
            "parallax--230-0": {
                transform: "translateY(-80%)"
            }
        },
        "gradient-location-inforgraphic-mob": {
            measureSelector: ".section",
            clamp: !0,
            enableMq: "sm-down",
            "parallax-100-0": {
                transform: "translateY(-20%)"
            },
            "parallax--130-0": {
                transform: "translateY(-80%)"
            }
        },
        "infographic-item": {
            measureSelector: ".section",
            easing: "easeInQuad",
            enableMq: "md-up",
            parallax() {
                const t = this.options.scrollSize,
                    e = this.options.scrollOffset || 0,
                    n = this.options.xOffset || 0;
                return {
                    [`parallax-${-1 * e}-0`]: {
                        transform: `scale(${Object(Du.a)(.35, 1.65, 0)}) translateX(${Object(Du.a)(0, -n, 0)}vw)`,
                        opacity: 0
                    },
                    [`parallax-${-1 * (e + .25 * t)}-0`]: {
                        transform: `scale(${Object(Du.a)(.35, 1.65, .25)}) translateX(${Object(Du.a)(0, -n, .25)}vw)`,
                        opacity: 1
                    },
                    [`parallax-${-1 * (e + t)}-0`]: {
                        transform: `scale(${Object(Du.a)(.35, 1.65, 1)}) translateX(${Object(Du.a)(0, -n, 1)}vw)`,
                        opacity: 1
                    },
                    [`parallax-${-1 * (e + 1.25 * t)}-0`]: {
                        transform: `scale(${Object(Du.a)(.35, 1.65, 1.25)}) translateX(${Object(Du.a)(0, -n, 1.25)}vw)`,
                        opacity: 0
                    }
                }
            }
        },
        "infographic-item-mob": {
            measureSelector: ".section",
            easing: "easeInQuad",
            enableMq: "sm-down",
            parallax() {
                const t = this.options.scrollSize,
                    e = this.options.scrollOffsetMob || 0;
                return {
                    [`parallax-${-1 * e}-0`]: {
                        transform: `scale(${Object(Du.a)(.35, 1.65, 0)})`,
                        opacity: 0
                    },
                    [`parallax-${-1 * (e + .15 * t)}-0`]: {
                        transform: `scale(${Object(Du.a)(.35, 1.65, .15)})`,
                        opacity: 1
                    },
                    [`parallax-${-1 * (e + .8 * t)}-0`]: {
                        transform: `scale(${Object(Du.a)(.35, 1.65, .8)})`,
                        opacity: 1
                    },
                    [`parallax-${-1 * (e + 1 * t)}-0`]: {
                        transform: `scale(${Object(Du.a)(.35, 1.65, 1)})`,
                        opacity: 0
                    }
                }
            }
        },
        "district-opacity": {
            measureSelector: ".section",
            clamp: !0,
            enableMq: "md-up",
            "parallax-200-100": {
                opacity: 0,
                easing: "easeOutQuad"
            },
            "parallax-150-100": {
                opacity: 1
            },
            "parallax-100-100": {
                opacity: 1
            },
            "parallax-0-100": {
                opacity: 0
            }
        },
        "district-cursor": {
            measureSelector: ".section",
            clamp: !0,
            enableMq: null,
            "parallax-200-100": {
                opacity: 0,
                "pointer-events": "none"
            },
            "parallax-150-100": {
                opacity: 1,
                "pointer-events": "initial"
            }
        },
        "district-title": {
            clamp: !0,
            enableMq: null,
            "parallax-170-100": {
                progress: 0
            },
            "parallax-171-100": {
                progress: 1
            },
            update(t) {
                const e = t.position > 0;
                this.isVisible !== e && (this.isVisible = e, this.$container.transitionstop(() => {
                    e ? this.$container.transition("title-image") : this.$container.transition("fade-out")
                }))
            }
        },
        "district-text": {
            clamp: !0,
            enableMq: null,
            "parallax-170-100": {
                progress: 0
            },
            "parallax-171-100": {
                progress: 1
            },
            update(t) {
                const e = t.position > 0;
                this.isVisible !== e && (this.isVisible = e, this.$container.transitionstop(() => {
                    e ? this.$container.transition("text", {
                        delay: 600
                    }) : this.$container.transition("fade-out")
                }))
            }
        },
        "district-man": {
            measureSelector: ".section",
            clamp: !0,
            easing: "easeOutQuad",
            enableMq: "md-up",
            "parallax-200-100": {
                transform: "translateY(-50%) translateX(75%) scale(0.5)"
            },
            "parallax-100-100": {
                transform: "translateY(0%) translateX(0%) scale(1)"
            }
        },
        "district-man-mob": {
            measureSelector: ".section",
            clamp: !0,
            easing: "linear",
            enableMq: "sm-down",
            parallax: function () {
                const t = this.$container.closest(".location-infographic__layer");
                return {
                    "parallax-160-100": {
                        transform: `translateY(${innerHeight - t.outerHeight() + .5 * this.$container.outerHeight()}px) translateX(0%) scale(0.5)`
                    },
                    "parallax-100-100": {
                        transform: "translateY(0px) translateX(0%) scale(1)"
                    }
                }
            }
        },
        "beauty-zoom-in": {
            measureSelector: "#videos-sticky-container",
            clamp: !0,
            enableMq: "lg-up",
            "parallax-0-0": {
                transform: "scale(1)"
            },
            "parallax-0-25": {
                transform: "scale(2.8)"
            }
        },
        "beauty-zoom-in-mob": {
            measureSelector: "#videos-sticky-container",
            enableMq: "md-down",
            clamp: !0,
            parallax: function () {
                const t = this.$container.find(".location-beauty__video-center").get(0).offsetWidth,
                    e = this.$container.find(".location-beauty__video-center").get(0).offsetHeight;
                return {
                    "parallax-0-0": {
                        transform: "scale(1)"
                    },
                    "parallax-0-25": {
                        transform: `scale(${Math.max(window.innerWidth / t, 100 * Ko.lvh() / e)})`
                    }
                }
            }
        },
        "future-section": {
            measureSelector: ":root #videos-sticky-container",
            clamp: !0,
            enableMq: "md-up",
            "parallax-0-70": {
                transform: "translateY(0%)"
            },
            "parallax-0-90": {
                transform: "translateY(-100%)"
            }
        },
        "future-section-mob": {
            measureSelector: ":root #videos-sticky-container",
            clamp: !0,
            enableMq: "sm-down",
            "parallax-0-55": {
                transform: "translateY(0%)"
            },
            "parallax-0-80": {
                transform: "translateY(-50%)"
            }
        },
        "students-zoom-out": {
            measureSelector: ".section",
            clamp: !0,
            parallax: function () {
                const t = this.$container.get(0).offsetWidth,
                    e = this.$container.get(0).offsetHeight,
                    n = this.$measure.pageOffset(),
                    i = this.$container.pageOffset(),
                    r = Math.max(window.innerWidth / t, 100 * Ko.lvh() / e);
                return {
                    "parallax-0-0": {
                        transform: `translate(${-1 * i.left}px, ${n.top - i.top}px) translateY(-100vh) scale(${r})`
                    },
                    "parallax--100-0": {
                        transform: "translate(0px, 0px) translateY(0vh) scale(1)"
                    }
                }
            }
        },
        "students-text": {
            measureSelector: ".section",
            clamp: !0,
            "parallax-0-0": {
                transform: "translateY(100vh)"
            },
            "parallax--100-0": {
                transform: "translateY(0vh)"
            }
        },
        "modal-open-on-scroll": {
            clamp: !0,
            measureSelector: ".history-modal__sticky-container",
            enableTouch: !1,
            "parallax-0-0": {
                progress: 0
            },
            "parallax-0-50": {
                progress: 1
            },
            update() {
                $("html").hasClass("with-modal") && $("html").hasClass("has-scroll-scrolling") && (this.$container.closest(".js-history-modal").hasClass("is-hidden") || (1 != this.position || this.modalOpened ? 1 != this.position && (this.modalOpened = !1) : (this.modalOpened = !0, this.$container.get(0).click())))
            }
        },
        "button-progress": {
            clamp: !0,
            measureSelector: ".history-modal__sticky-container",
            enableTouch: !1,
            "parallax-0-0": {
                progress: 1
            },
            "parallax-0-50": {
                progress: 0
            },
            update(t) {
                if (0 == t.position) t.$container.css("--progress", "300%");
                else if (t.position > 0 && t.position <= 1) {
                    const e = Math.round(300 * (1 - t.position)) + "%";
                    t.$container.css("--progress", e)
                }
            }
        }
    }), $.extend($.fn.parallax.patterns, {
        "architecture-materials": {
            clamp: !0,
            easing: "easeInOutQuad",
            parallax() {
                const t = this.$container,
                    e = t.find(".architecture-materials__cube-template"),
                    n = t.closest(".architecture-materials__sticky-container"),
                    i = e.find(".architecture-materials__cube-image"),
                    r = $(this.options.placeholder),
                    s = r.get(0).offsetWidth / i.get(0).offsetWidth,
                    a = _o.a.matches("md-up") ? r.offset().top - n.offset().top - i.position().top : r.offset().top - i.offset().top,
                    o = r.offset().left - i.offset().left;
                return _o.a.matches("md-up") ? {
                    "parallax-100-0": {
                        transform: `translate(${o}px, ${a}px)`,
                        rotateNumber: 25,
                        scaleNumber: s
                    },
                    "parallax-100-100": {
                        transform: "translateY(0px, 0px)",
                        rotateNumber: 0,
                        scaleNumber: 1
                    }
                } : {
                    "parallax-100--100": {
                        transform: `translate(${o}px, ${a}px)`,
                        rotateNumber: 25,
                        scaleNumber: s
                    },
                    "parallax-100-75": {
                        transform: "translateY(0px, 0px)",
                        rotateNumber: 0,
                        scaleNumber: 1
                    }
                }
            },
            update(t) {
                const e = this.values && this.values.rotateNumber || 0,
                    n = this.values && this.values.scaleNumber || 1;
                t.$cubes || (t.$cubes = t.$container.find(".architecture-materials__cube-item picture")), this.values && t.$cubes.css({
                    transform: `rotate(${e}deg) scale(${n})`
                })
            }
        },
        "architecture-materials-cube": {
            clamp: !0,
            easing: "easeOutQuad",
            parallax: () => ({
                "parallax-100--100": {
                    transform: "translateY(30%)"
                },
                "parallax-100-0": {
                    transform: "translateY(0%)"
                }
            })
        },
        "architecture-carousel": {
            clamp: !0,
            parallax() {
                const t = this.options.count;
                return {
                    "parallax-0-0": {
                        index: 0
                    },
                    ["parallax-0-" + 50 * t]: {
                        index: t - 1
                    }
                }
            },
            update() {
                if (this.values) {
                    const t = this.values && Math.floor(this.values.index) || 0;
                    t != this.carouselIndex && (this.$container.carousel("open", t), this.carouselIndex = t)
                }
            }
        },
        "architecture-carousel-mob": {
            clamp: !0,
            parallax: () => ({
                "parallax-100-0": {
                    progress: 0
                },
                "parallax-0--75": {
                    progress: 1
                }
            }),
            update() {
                if (this.values) {
                    1 === (this.values && Math.floor(this.values.progress) || 0) ? this.$container.removeClass("architecture-materials__carousel--disabled") : this.$container.addClass("architecture-materials__carousel--disabled")
                }
            }
        },
        "architecture-image": {
            clamp: !0,
            parallax: () => ({
                "parallax-100-0": {
                    "clip-path": "polygon(0% 100%, 100% 100%, 100% 100%, 0% 100%)"
                },
                "parallax-100-100": {
                    "clip-path": "polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)"
                }
            })
        },
        "architecture-building-mob": {
            clamp: !0,
            parallax: () => ({
                "parallax-100-100": {
                    progress: 0,
                    scale: 1
                },
                "parallax-0-100": {
                    progress: 1,
                    scale: 1.05
                }
            }),
            update() {
                if (this.values) {
                    this.$controller || (this.$controller = this.$container.closest(".architecture-buildings__sticky-container"));
                    const t = this.values && Math.floor(this.values.progress) || 0;
                    1 === t && !0 !== this.isShowed ? (this.isShowed = !0, this.$controller.buildingSliderMobile("show")) : 1 !== t && !0 === this.isShowed && (this.isShowed = !1, this.$controller.buildingSliderMobile("hide"))
                }
            }
        },
        "architecture-text-transition": {
            clamp: !0,
            parallax: () => ({
                "parallax-100-0": {
                    progress: 0
                },
                "parallax-100-100": {
                    progress: 1
                }
            }),
            update() {
                if (this.values) {
                    this.$texts || (this.$texts = this.$container.find(".js-text-transition"));
                    const t = this.values && Math.floor(this.values.progress) || 0;
                    1 === t && !0 !== this.isShowed ? (this.isShowed = !0, this.$texts.transitionstop(() => {
                        this.$texts.removeClass("is-hidden--md-up"), this.$texts.transition("text")
                    })) : 1 !== t && !0 === this.isShowed && (this.isShowed = !1, this.$texts.transitionstop(() => {
                        this.$texts.transition("fade-out", {
                            after: () => {
                                this.$texts.addClass("is-hidden--md-up")
                            }
                        })
                    }))
                }
            }
        },
        "architecture-circle-bottom": {
            clamp: !0,
            parallax() {
                const t = this.$container.get(0).getTotalLength();
                return {
                    ["parallax-0-" + (this.$measure.find(".architecture-buildings__sticky").outerHeight() - innerHeight) / this.$measure.outerHeight() * 100]: {
                        "stroke-dasharray": t,
                        "stroke-dashoffset": t
                    },
                    "parallax-100-100": {
                        "stroke-dasharray": t,
                        "stroke-dashoffset": 0
                    }
                }
            }
        }
    }), $.extend($.fn.parallax.patterns, {
        map: {
            clamp: !0,
            parallax: function () {
                const t = this.$container.find(".territory-geographic__map-offset-top").outerHeight(),
                    e = this.$container.find(".territory-geographic__map-offset-bottom").outerHeight(),
                    n = innerWidth / 1440 * 520,
                    i = n - (innerWidth - 2 * n) / 4,
                    r = (t + e) / 2;
                return {
                    "parallax-0-0": {
                        "clip-path": `polygon(${n}px ${t}px, ${innerWidth - n}px ${t}px, ${innerWidth - n}px ${innerHeight - e}px, ${n}px ${innerHeight - e}px)`,
                        index: 0
                    },
                    "parallax-0-50": {
                        "clip-path": `polygon(${i}px ${r}px, ${innerWidth - i}px ${r}px, ${innerWidth - i}px ${innerHeight - r}px, ${i}px ${innerHeight - r}px)`,
                        index: 0
                    },
                    "parallax-0-100": {
                        "clip-path": `polygon(0px 0px, ${innerWidth}px 0px, ${innerWidth}px ${innerHeight}px, 0px ${innerHeight}px)`,
                        index: 1
                    }
                }
            },
            update() {
                const t = this.values && Math.floor(this.values.index) || 0,
                    e = this.$container.geographicMap("getShowedMap");
                1 !== t || e ? 0 === t && e && this.$container.geographicMap("hideMap") : this.$container.geographicMap("showMap")
            }
        },
        "map-image": {
            measureSelector: ".territory-geographic__map",
            clamp: !0,
            parallax: function () {
                const t = this.$container.closest(".territory-geographic__map"),
                    e = t.find(".territory-geographic__map-offset-top").outerHeight(),
                    n = t.find(".territory-geographic__map-offset-bottom").outerHeight(),
                    i = (innerHeight - e - n) / this.$container.outerHeight() * 1.25;
                return {
                    "parallax-0-0": {
                        transform: `translate(0%, 10%) scale(${i})`
                    },
                    "parallax-0-50": {
                        transform: `translate(0%, 0%) scale(${i})`
                    },
                    "parallax-0-100": {
                        transform: "translate(0%, 0%) scale(1)"
                    }
                }
            }
        },
        "map-shadow": {
            measureSelector: ".territory-geographic__map",
            clamp: !0,
            parallax: function () {
                const t = this.$container.closest(".territory-geographic__map"),
                    e = t.find(".territory-geographic__map-offset-top").outerHeight(),
                    n = t.find(".territory-geographic__map-offset-bottom").outerHeight(),
                    i = (innerHeight - e - n) / this.$container.outerHeight() * 1.25;
                return {
                    "parallax-0-0": {
                        transform: `translate(0%, 10%) scale(${i})`,
                        opacity: 1
                    },
                    "parallax-0-50": {
                        transform: `translate(0%, 0%) scale(${i})`,
                        opacity: 1
                    },
                    "parallax-0-100": {
                        transform: "translate(0%, 0%) scale(1)",
                        opacity: 0
                    }
                }
            }
        }
    }), $.extend($.fn.parallax.patterns, {
        "video-zoom-in": {
            clamp: !0,
            parallax: function () {
                const t = $(this.options.placeholder),
                    e = t.get(0).offsetWidth,
                    n = t.get(0).offsetHeight,
                    i = t.pageOffset(),
                    r = this.$container.get(0).offsetWidth,
                    s = n / this.$container.get(0).offsetHeight,
                    a = (r * s - e) / 2,
                    o = a / (r * s) * 100,
                    l = this.$container.pageOffset();
                return {
                    "parallax-0--100": {
                        transform: `translate(${i.left - a}px, ${i.top - l.top}px) scale(${s})`,
                        "clip-path": `polygon(${o}% 0px, ${100 - o}% 0px, ${100 - o}% 100%, ${o}% 100%)`
                    },
                    "parallax-0-0": {
                        transform: "translate(0px, 0px) scale(1)",
                        "clip-path": "polygon(0% 0px, 100% 0px, 100% 100%, 0% 100%)"
                    }
                }
            }
        },
        "video-shadow-in": {
            clamp: !0,
            parallax: function () {
                return {
                    "parallax-0--100": {
                        opacity: 0
                    },
                    "parallax-0-0": {
                        opacity: 1
                    }
                }
            }
        },
        "text-fade-out": {
            clamp: !0,
            parallax: function () {
                return {
                    "parallax-50-50": {
                        opacity: 1
                    },
                    "parallax-0-50": {
                        opacity: 0
                    }
                }
            }
        }
    });
    n(233);
    var Iu = n(61);

    function ku(t, e) {
        if (e) {
            const n = t.includes("?") ? "&" : "?";
            return t + n + e
        }
        return t
    }
    window.preloaderLanding3D = {};
    const Nu = function (t) {
        const e = t.match(/[?&](v=[^&]+)/);
        return e ? e[1] : ""
    }(document.currentScript.src);
    class Uu extends Iu.a {
        constructor(t, e) {
            super(t, e), this.$canvas = this.$container.find(".js-preloader-canvas"), this.$skip = this.$container.find(".js-splash-skip"), this.skipTimer = null, this.isSplashScreenLoaded = !1, this.test = "/splash-v2" === window.location.pathname, this.$skip.on("click", this.complete.bind(this))
        }
        handleComplete() {
            setTimeout(() => {
                this.$canvas.removeClass("preloader__canvas--invisible")
            }, 1200), this.test || (this.skipTimer = setTimeout(() => {
                this.complete()
            }, 12e3)), this.setCookie()
        }
        afterHide() {
            window.preloaderLanding3D.dispose && window.preloaderLanding3D.dispose(), this.skipTimer && (clearTimeout(this.skipTimer), this.skipTimer = null), super.afterHide(), this.$canvas.addClass("preloader__canvas--invisible")
        }
        setup3DLoader() {
            this.isSplashScreenLoaded || (this.isSplashScreenLoaded = !0, this.addLoader(t => {
                let {
                    setProgress: e,
                    setComplete: n
                } = t;
                window.preloaderLanding3D = {
                    setProgress: e,
                    setComplete: n
                }, this.loadSplashScreenScript()
            }, {
                total: 1,
                weight: 1
            }), this.hideComagic())
        }
        hideComagic() {
            Object(xo.a)("html").addClass("comagic-disabled")
        }
        setupLoaders() {
            super.setupLoaders()
        }
        loadSplashScreenScript() {
            const t = document.createElement("script");
            t.async = !0, t.src = ku("assets/javascripts/threejs.js", Nu), t.onload = () => {
                const t = document.createElement("script");
                t.type = "module";
                t.src = ku("assets/javascripts/splash-v2.js", Nu), document.body.appendChild(t)
            }, document.body.appendChild(t)
        }
    }
    xo.a.fn.preloaderLanding = ol()(Uu);
    var zu = n(15),
        Fu = n.n(zu),
        $u = {
            install(t) {
                this.barba = t
            },
            init() {
                this.barba.hooks.once(this.once.bind(this)), this.barba.hooks.after(this.after.bind(this))
            },
            once() {
                const t = Object(xo.a)(".js-preloader").not(".modal .js-preloader").not(".is-hidden");
                t.length ? (Object(xo.a)("body").plugins({
                    isPageLoadEvent: !0,
                    isAjaxPageLoadEvent: !1,
                    pagePluginsOnly: !0
                }), t.one("complete.preloader", () => {
                    Object(xo.a)("body").plugins({
                        isPageLoadEvent: !0,
                        isAjaxPageLoadEvent: !1
                    })
                }).app()) : Object(xo.a)("body").plugins({
                    isPageLoadEvent: !0,
                    isAjaxPageLoadEvent: !1
                })
            },
            after() {
                requestAnimationFrame(() => {
                    Object(xo.a)("body").plugins({
                        isPageLoadEvent: !0,
                        isAjaxPageLoadEvent: !0
                    })
                });
                const t = Object(xo.a)("main").data("history");
                t && xo.a.history.set(t)
            }
        },
        Bu = n(149),
        Hu = n.n(Bu);
    const ju = /<link[^>]+rel=("stylesheet"|'stylesheet')[^>]+>/g,
        Vu = /href=("([^"]+)"|'([^']+)')/,
        Gu = /<style([^>]*?)>([\s\S]*?)<\/style>/g,
        Wu = /type=("([^"]+)"|'([^']+)')/;
    const qu = /(<script([^>]+src=("([^"]+)"|'([^']+)'))?[^>]*>)([\s\S]*?)<\/script>/g,
        Xu = /<script[^>]*data-ajax-page-no-cache/;
    var Yu = n(42);
    $.ajaxSetup({
        cache: !0
    });
    var Ku = {
        install(t) {
            this.barba = t, this.stylesheetsRemove = []
        },
        init() {
            this.scripts = cl()($("script").toArray(), t => {
                const e = t.getAttribute("src");
                return {
                    content: t.textContent,
                    src: e ? e.replace(document.location.origin, "") : ""
                }
            }), this.barba.hooks.before(this.before.bind(this)), this.barba.hooks.afterLeave(this.afterLeave.bind(this)), this.barba.hooks.after(this.after.bind(this))
        },
        before() {
            this.stylesheets = cl()($('link[rel="stylesheet"], style:not([type]), style[type="text/css"]').toArray(), t => {
                if ("style" == t.localName) return {
                    content: t.textContent
                };
                {
                    const e = t.getAttribute("href");
                    return {
                        href: e,
                        url: e.replace(document.location.origin, "")
                    }
                }
            })
        },
        afterLeave(t) {
            const e = !!t.preserveStylesheets,
                n = function (t) {
                    const e = [];
                    return t.replace(Gu, (t, n, i) => {
                        const r = n.match(Wu);
                        r && "text/css" !== r[2] && "text/css" !== r[3] || e.push({
                            html: t,
                            content: i
                        })
                    }), t.replace(ju, t => {
                        const n = t.match(Vu);
                        n && e.push({
                            html: t,
                            href: n[2] || n[3],
                            url: (n[2] || n[3]).replace(document.location.origin, "")
                        })
                    }), e
                }(t.next.html),
                i = function (t) {
                    const e = [];
                    return t.replace(qu, (t, n, i, r, s, a, o) => {
                        const l = s || a,
                            c = t.match(/<script[^>]*[\s\r\n\t]type="([^"]+)"/),
                            h = !!t.match(Xu);
                        (!c || "application/javascript" === c[1] && "text/javascript" === c[1]) && (o && o.match(/browser-sync/) || l && l.match(/(google-analytics|mc\.yandex\.ru\/metrika\/tag\.js)/) || (l ? e.push({
                            id: h ? Object(El.a)() : null,
                            src: l.replace(document.location.origin, ""),
                            async: !!n.match(/\basync\b/),
                            defer: !!n.match(/\bdefer\b/)
                        }) : e.push({
                            id: h ? Object(El.a)() : null,
                            content: o
                        })))
                    }), e
                }(t.next.html),
                r = function (t) {
                    const e = t.match(/(lang="([^"]+)"|lang='([^']+)'|lang=([a-z]+))/);
                    return e ? e[2] || e[3] || e[4] : document.documentElement.lang
                }(t.next.html);
            r && (document.documentElement.lang = r, Object(Al.b)("hl", r)), e ? this.stylesheetsRemove = [] : (this.stylesheetsRemove = Hu()(this.stylesheets, n, t => t.url || t.content), Yu.f.length && (this.stylesheetsRemove = this.stylesheetsRemove.filter(t => {
                let {
                    href: e
                } = t;
                return !Yu.f.some(t => "string" == typeof t ? e === t : t instanceof RegExp && t.test(e))
            })));
            const s = Hu()(n, this.stylesheets, t => t.url || t.content),
                a = Promise.all(cl()(s, t => new Promise(e => {
                    const n = $(t.html);
                    n.is("link") ? n.on("load", e) : e(), $("head").append(n)
                })));
            this.stylesheets = n;
            const o = Hu()(i, this.scripts, t => t.id || t.src || t.content);
            this.scripts = this.scripts.concat(o);
            const l = Promise.all(cl()(o, t => {
                if (t.src) return new Promise(e => {
                    $("body").append('<script src="' + t.src + '" type="text/placeholder"><\/script>'), $.getScript(t.src).done(e)
                });
                if (t.content) {
                    try {
                        $("body").append("<script>" + t.content + "<\/script>")
                    } catch (t) {
                        console.error(t)
                    }
                    return Promise.resolve()
                }
            }));
            return Promise.all([a, l])
        },
        after() {
            const t = this.stylesheetsRemove;
            for (let e = 0; e < t.length; e++) t[e].href ? $(`link[href$="${t[e].href}"]`).remove() : $("style").each((function () {
                this.textContent === t[e].content && $(this).remove()
            }))
        }
    },
        Zu = {
            install(t) {
                this.barba = t
            },
            init() {
                this.barba.hooks.after(this.after.bind(this))
            },
            after(t) {
                "function" == typeof ga && (ga("set", "page", t.next.url.path), ga("send", "pageview")), "function" == typeof ym ? ym("hit", t.next.url.path, {
                    title: document.title,
                    referer: t.current.url.path
                }) : "string" == typeof yandexMetrikaCounter && "object" === window[yandexMetrikaCounter] && window[yandexMetrikaCounter] && window[yandexMetrikaCounter].hit(t.next.url.path, {
                    title: document.title,
                    referer: t.current.url.path
                }), "function" == typeof ct_replace && ct_replace()
            }
        };
    const Ju = Fu.a.history.add;

    function Qu() {
        var t;
        Object(xo.a)('[data-barba="container"]').length ? (Fu.a.use(Ku), Fu.a.use(Zu), Fu.a.use($u), Fu.a.use((t = {
            clearCacheUrls: Yu.a
        }, {
            install(e) {
                this.barba = e, this.clearCacheUrls = t.clearCacheUrls || []
            },
            init() {
                this.barba.hooks.before(this.before.bind(this)), this.barba.cache.clear = this.clearCache.bind(this)
            },
            clearCache() {
                const t = this.barba.cache;
                let e = [];
                for (let n in t)
                    if (t[n] instanceof Map) {
                        e = t[n].keys();
                        break
                    } for (let n of e) t.delete(n)
            },
            before(t) {
                -1 !== this.clearCacheUrls.indexOf(t.next.url.path) && this.clearCache()
            }
        })), Fu.a.init({
            timeout: Yu.g,
            transitions: Yu.h,
            cacheIgnore: Yu.e,
            prevent: t => {
                if (!t.event.type || "mouseover" !== t.event.type && "touchstart" !== t.event.type) {
                    const e = t.event.defaultPrevented || t.el.getAttribute(Yu.c);
                    return e || "" === e
                } {
                    const e = t.el.getAttribute(Yu.b),
                        n = t.el.getAttribute("href");
                    if (navigator.connection && ("slow-2g" === navigator.connection.effectiveType || "2g" === navigator.connection.effectiveType)) return;
                    if (navigator.deviceMemory && navigator.deviceMemory <= 2) return;
                    return e || "" === e || n && Fu.a.cache.checkHref(n)
                }
            },
            debug: !1
        })) : $u.once()
    }
    Fu.a.history.add = function (t, e) {
        const n = $(window).scrollTop(),
            i = function () {
                for (let t in Fu.a.history)
                    if (Array.isArray(Fu.a.history[t])) return Fu.a.history[t]
            }(),
            r = Fu.a.history.current;
        if (r.scroll.y = n, window.history && window.history.state) {
            const t = window.history.state;
            t.states = [...i], window.history && window.history.replaceState(t, "", r.url)
        }
        Ju.call(this, t, e)
    }, Fu.a.request = function (t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2e3,
            n = arguments.length > 2 ? arguments[2] : void 0;
        return new Promise((i, r) => {
            const s = new XMLHttpRequest;
            s.onreadystatechange = () => {
                if (s.readyState === XMLHttpRequest.DONE)
                    if (200 === s.status) i(s.responseText);
                    else if (s.status) {
                        const e = {
                            status: s.status,
                            statusText: s.statusText
                        };
                        n(t, e), r(e)
                    }
            }, s.ontimeout = () => {
                const i = new Error(`Timeout error [${e}]`);
                n(t, i), r(i)
            }, s.onerror = () => {
                const e = new Error("Fetch error");
                n(t, e), r(e)
            }, s.open("GET", t), s.timeout = e, s.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml"), s.setRequestHeader("x-barba", "yes"), s.setRequestHeader("X-Requested-With", "XMLHttpRequest"), s.send()
        })
    };
    var td = n(141);
    new Date;
    const ed = Object(xo.a)(document.documentElement);
    if (wo.a.hasHoverSupport() || ed.removeClass("has-hover").addClass("no-hover"), ed.addClass(wo.a.isEdge() ? "is-edge" : "is-not-ie-edge"), ed.addClass("is-ready"), wo.a.isIOS()) {
        const t = Object(xo.a)('meta[name="viewport"]');
        t.attr("content", t.attr("content") + ", maximum-scale=1")
    }
    Object(xo.a)(() => {
        td.a ? new Qu : Object(xo.a)("body").plugins({
            isPageLoadEvent: !0,
            isAjaxPageLoadEvent: !1
        })
    })
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return c
    })), n.d(e, "b", (function () {
        return h
    })), n.d(e, "d", (function () {
        return d
    })), n.d(e, "c", (function () {
        return p
    }));
    var i = n(1),
        r = n(40);
    const s = /^[\d\s]+([.,]\d+)?$/;

    function a(t, e, n) {
        const r = t.find(`input[name="${e}"], select[name="${e}"], textarea[name="${e}"]`);
        return r.is(":checkbox, :radio") ? r.filter((t, e) => Object(i.a)(e).val() === n) : r
    }

    function o(t) {
        return "true" === t || "false" === t ? "true" === t : "string" == typeof t && s.test(t) ? parseFloat(t.replace(/[,.\s]/g, "")) : t
    }

    function l(t, e) {
        return "text" !== e.attr("type") || "number" !== t.formatter && "money" !== t.formatter ? t.value : Object(r.a)(t.value, 0, ",", " ")
    }

    function c(t) {
        const e = function (t) {
            return t.find("input[name], input[data-filter-name], select[name], textarea[name]")
        }(t),
            n = [];
        for (let t = 0; t < e.length; t++) {
            const i = e.eq(t),
                r = i.attr("name") || i.attr("data-filter-name"),
                s = i.val(),
                a = i.is(":checkbox, :radio") ? i.prop("checked") : o(i.val()),
                l = o(i.attr("data-reset-value")),
                c = i.data("filterText");
            n.push({
                name: r,
                value: a,
                rawValue: s,
                defaultValue: l,
                text: c,
                resetIgnore: i.data("reset-ignore") || !1,
                hasNonDefaultValue: l !== a && s !== a,
                type: i.data("input-type"),
                formatter: i.data("input-formatter") || !1
            })
        }
        return n
    }

    function h(t, e) {
        const n = [].concat(t);
        return e.forEach(t => {
            let e = null;
            e = t.name.endsWith("[]") ? n.find(e => e.name === t.name && e.rawValue === t.rawValue) : n.find(e => e.name === t.name), e ? Object.assign(e, t) : n.push(t)
        }), n
    }

    function u(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        if (t && "object" == typeof t && !Array.isArray(t)) {
            let n = [];
            for (let i in t) {
                const r = e ? `${e}[${i}]` : i;
                if (t[i] && "object" == typeof t[i]) n = n.concat(u(t[i], r));
                else {
                    const e = t[i];
                    n.push({
                        name: r,
                        rawValue: e,
                        value: e
                    })
                }
            }
            return n
        }
        return t
    }

    function d(t, e) {
        let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        e = u(e);
        let r = Object(i.a)(),
            s = Object(i.a)(),
            o = !0;
        for (let n = 0; n < e.length; n++) {
            const i = e[n],
                c = a(t, i.name, i.rawValue);
            let h;
            c.is(":checkbox, :radio") ? (h = c.prop("checked"), c.prop("checked", i.value)) : c.is("select") ? c.closest(".form-control-select").selectInput("setValue", i.value) : (h = c.val(), c.val(l(i, c))), h !== i.value && (r = r.add(c)), i.value !== i.defaultValue && (o = !1), !0 === i.disabled && (c.disabled = !0), s = s.add(c)
        }
        return n || r.change(), o
    }

    function p(t) {
        const e = [];
        for (let n = 0; n < t.length; n++) {
            const i = t[n],
                r = typeof i.value;
            "boolean" === r ? i.value && e.push(encodeURIComponent(i.name) + "=" + encodeURIComponent(i.rawValue)) : "number" === r ? e.push(encodeURIComponent(i.name) + "=" + i.value) : e.push(encodeURIComponent(i.name) + "=" + encodeURIComponent(String(i.value)))
        }
        return e.join("&")
    }
}, function (t, e, n) {
    t.exports = function () {
        function t(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        function e(e, n, i) {
            return n && t(e.prototype, n), i && t(e, i), e
        }

        function n() {
            return (n = Object.assign || function (t) {
                for (var e = 1; e < arguments.length; e++) {
                    var n = arguments[e];
                    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
                }
                return t
            }).apply(this, arguments)
        }

        function i(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
        }

        function r(t) {
            return (r = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
        }

        function s(t, e) {
            return (s = Object.setPrototypeOf || function (t, e) {
                return t.__proto__ = e, t
            })(t, e)
        }

        function a(t, e, n) {
            return (a = function () {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0
                } catch (t) {
                    return !1
                }
            }() ? Reflect.construct : function (t, e, n) {
                var i = [null];
                i.push.apply(i, e);
                var r = new (Function.bind.apply(t, i));
                return n && s(r, n.prototype), r
            }).apply(null, arguments)
        }

        function o(t) {
            var e = "function" == typeof Map ? new Map : void 0;
            return (o = function (t) {
                if (null === t || -1 === Function.toString.call(t).indexOf("[native code]")) return t;
                if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== e) {
                    if (e.has(t)) return e.get(t);
                    e.set(t, n)
                }

                function n() {
                    return a(t, arguments, r(this).constructor)
                }
                return n.prototype = Object.create(t.prototype, {
                    constructor: {
                        value: n,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), s(n, t)
            })(t)
        }

        function l(t, e) {
            try {
                var n = t()
            } catch (t) {
                return e(t)
            }
            return n && n.then ? n.then(void 0, e) : n
        }
        var c;
        "undefined" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))), "undefined" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))),
            function (t) {
                t[t.off = 0] = "off", t[t.error = 1] = "error", t[t.warning = 2] = "warning", t[t.info = 3] = "info", t[t.debug = 4] = "debug"
            }(c || (c = {}));
        var h = c.off,
            u = function () {
                function t(t) {
                    this.t = t
                }
                t.getLevel = function () {
                    return h
                }, t.setLevel = function (t) {
                    return h = c[t]
                };
                var e = t.prototype;
                return e.error = function () {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    this.i(console.error, c.error, e)
                }, e.warn = function () {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    this.i(console.warn, c.warning, e)
                }, e.info = function () {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    this.i(console.info, c.info, e)
                }, e.debug = function () {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    this.i(console.log, c.debug, e)
                }, e.i = function (e, n, i) {
                    n <= t.getLevel() && e.apply(console, ["[" + this.t + "] "].concat(i))
                }, t
            }(),
            d = E,
            p = b,
            f = y,
            m = x,
            g = M,
            v = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"), "g");

        function y(t, e) {
            for (var n, i = [], r = 0, s = 0, a = "", o = e && e.delimiter || "/", l = e && e.whitelist || void 0, c = !1; null !== (n = v.exec(t));) {
                var h = n[0],
                    u = n[1],
                    d = n.index;
                if (a += t.slice(s, d), s = d + h.length, u) a += u[1], c = !0;
                else {
                    var p = "",
                        f = n[2],
                        m = n[3],
                        g = n[4],
                        y = n[5];
                    if (!c && a.length) {
                        var b = a.length - 1,
                            x = a[b];
                        (!l || l.indexOf(x) > -1) && (p = x, a = a.slice(0, b))
                    }
                    a && (i.push(a), a = "", c = !1);
                    var S = m || g,
                        M = p || o;
                    i.push({
                        name: f || r++,
                        prefix: p,
                        delimiter: M,
                        optional: "?" === y || "*" === y,
                        repeat: "+" === y || "*" === y,
                        pattern: S ? w(S) : "[^" + _(M === o ? M : M + o) + "]+?"
                    })
                }
            }
            return (a || s < t.length) && i.push(a + t.substr(s)), i
        }

        function b(t, e) {
            return function (n, i) {
                var r = t.exec(n);
                if (!r) return !1;
                for (var s = r[0], a = r.index, o = {}, l = i && i.decode || decodeURIComponent, c = 1; c < r.length; c++)
                    if (void 0 !== r[c]) {
                        var h = e[c - 1];
                        o[h.name] = h.repeat ? r[c].split(h.delimiter).map((function (t) {
                            return l(t, h)
                        })) : l(r[c], h)
                    } return {
                        path: s,
                        index: a,
                        params: o
                    }
            }
        }

        function x(t, e) {
            for (var n = new Array(t.length), i = 0; i < t.length; i++) "object" == typeof t[i] && (n[i] = new RegExp("^(?:" + t[i].pattern + ")$", S(e)));
            return function (e, i) {
                for (var r = "", s = i && i.encode || encodeURIComponent, a = !i || !1 !== i.validate, o = 0; o < t.length; o++) {
                    var l = t[o];
                    if ("string" != typeof l) {
                        var c, h = e ? e[l.name] : void 0;
                        if (Array.isArray(h)) {
                            if (!l.repeat) throw new TypeError('Expected "' + l.name + '" to not repeat, but got array');
                            if (0 === h.length) {
                                if (l.optional) continue;
                                throw new TypeError('Expected "' + l.name + '" to not be empty')
                            }
                            for (var u = 0; u < h.length; u++) {
                                if (c = s(h[u], l), a && !n[o].test(c)) throw new TypeError('Expected all "' + l.name + '" to match "' + l.pattern + '"');
                                r += (0 === u ? l.prefix : l.delimiter) + c
                            }
                        } else if ("string" != typeof h && "number" != typeof h && "boolean" != typeof h) {
                            if (!l.optional) throw new TypeError('Expected "' + l.name + '" to be ' + (l.repeat ? "an array" : "a string"))
                        } else {
                            if (c = s(String(h), l), a && !n[o].test(c)) throw new TypeError('Expected "' + l.name + '" to match "' + l.pattern + '", but got "' + c + '"');
                            r += l.prefix + c
                        }
                    } else r += l
                }
                return r
            }
        }

        function _(t) {
            return t.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1")
        }

        function w(t) {
            return t.replace(/([=!:$/()])/g, "\\$1")
        }

        function S(t) {
            return t && t.sensitive ? "" : "i"
        }

        function M(t, e, n) {
            for (var i = (n = n || {}).strict, r = !1 !== n.start, s = !1 !== n.end, a = n.delimiter || "/", o = [].concat(n.endsWith || []).map(_).concat("$").join("|"), l = r ? "^" : "", c = 0; c < t.length; c++) {
                var h = t[c];
                if ("string" == typeof h) l += _(h);
                else {
                    var u = h.repeat ? "(?:" + h.pattern + ")(?:" + _(h.delimiter) + "(?:" + h.pattern + "))*" : h.pattern;
                    e && e.push(h), l += h.optional ? h.prefix ? "(?:" + _(h.prefix) + "(" + u + "))?" : "(" + u + ")?" : _(h.prefix) + "(" + u + ")"
                }
            }
            if (s) i || (l += "(?:" + _(a) + ")?"), l += "$" === o ? "$" : "(?=" + o + ")";
            else {
                var d = t[t.length - 1],
                    p = "string" == typeof d ? d[d.length - 1] === a : void 0 === d;
                i || (l += "(?:" + _(a) + "(?=" + o + "))?"), p || (l += "(?=" + _(a) + "|" + o + ")")
            }
            return new RegExp(l, S(n))
        }

        function E(t, e, n) {
            return t instanceof RegExp ? function (t, e) {
                if (!e) return t;
                var n = t.source.match(/\((?!\?)/g);
                if (n)
                    for (var i = 0; i < n.length; i++) e.push({
                        name: i,
                        prefix: null,
                        delimiter: null,
                        optional: !1,
                        repeat: !1,
                        pattern: null
                    });
                return t
            }(t, e) : Array.isArray(t) ? function (t, e, n) {
                for (var i = [], r = 0; r < t.length; r++) i.push(E(t[r], e, n).source);
                return new RegExp("(?:" + i.join("|") + ")", S(n))
            }(t, e, n) : function (t, e, n) {
                return M(y(t, n), e, n)
            }(t, e, n)
        }
        d.match = function (t, e) {
            var n = [];
            return b(E(t, n, e), n)
        }, d.regexpToFunction = p, d.parse = f, d.compile = function (t, e) {
            return x(y(t, e), e)
        }, d.tokensToFunction = m, d.tokensToRegExp = g;
        var T = {
            container: "container",
            history: "history",
            namespace: "namespace",
            prefix: "data-barba",
            prevent: "prevent",
            wrapper: "wrapper"
        },
            C = new (function () {
                function t() {
                    this.o = T, this.u = new DOMParser
                }
                var e = t.prototype;
                return e.toString = function (t) {
                    return t.outerHTML
                }, e.toDocument = function (t) {
                    return this.u.parseFromString(t, "text/html")
                }, e.toElement = function (t) {
                    var e = document.createElement("div");
                    return e.innerHTML = t, e
                }, e.getHtml = function (t) {
                    return void 0 === t && (t = document), this.toString(t.documentElement)
                }, e.getWrapper = function (t) {
                    return void 0 === t && (t = document), t.querySelector("[" + this.o.prefix + '="' + this.o.wrapper + '"]')
                }, e.getContainer = function (t) {
                    return void 0 === t && (t = document), t.querySelector("[" + this.o.prefix + '="' + this.o.container + '"]')
                }, e.removeContainer = function (t) {
                    document.body.contains(t) && t.parentNode.removeChild(t)
                }, e.addContainer = function (t, e) {
                    var n = this.getContainer();
                    n ? this.s(t, n) : e.appendChild(t)
                }, e.getNamespace = function (t) {
                    void 0 === t && (t = document);
                    var e = t.querySelector("[" + this.o.prefix + "-" + this.o.namespace + "]");
                    return e ? e.getAttribute(this.o.prefix + "-" + this.o.namespace) : null
                }, e.getHref = function (t) {
                    if (t.tagName && "a" === t.tagName.toLowerCase()) {
                        if ("string" == typeof t.href) return t.href;
                        var e = t.getAttribute("href") || t.getAttribute("xlink:href");
                        if (e) return this.resolveUrl(e.baseVal || e)
                    }
                    return null
                }, e.resolveUrl = function () {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    var i = e.length;
                    if (0 === i) throw new Error("resolveUrl requires at least one argument; got none.");
                    var r = document.createElement("base");
                    if (r.href = arguments[0], 1 === i) return r.href;
                    var s = document.getElementsByTagName("head")[0];
                    s.insertBefore(r, s.firstChild);
                    for (var a, o = document.createElement("a"), l = 1; l < i; l++) o.href = arguments[l], r.href = a = o.href;
                    return s.removeChild(r), a
                }, e.s = function (t, e) {
                    e.parentNode.insertBefore(t, e.nextSibling)
                }, t
            }()),
            A = new (function () {
                function t() {
                    this.h = [], this.v = -1
                }
                var i = t.prototype;
                return i.init = function (t, e) {
                    this.l = "barba";
                    var n = {
                        ns: e,
                        scroll: {
                            x: window.scrollX,
                            y: window.scrollY
                        },
                        url: t
                    };
                    this.h.push(n), this.v = 0;
                    var i = {
                        from: this.l,
                        index: 0,
                        states: [].concat(this.h)
                    };
                    window.history && window.history.replaceState(i, "", t)
                }, i.change = function (t, e, n) {
                    if (n && n.state) {
                        var i = n.state,
                            r = i.index;
                        e = this.m(this.v - r), this.replace(i.states), this.v = r
                    } else this.add(t, e);
                    return e
                }, i.add = function (t, e) {
                    var n = this.size,
                        i = this.p(e),
                        r = {
                            ns: "tmp",
                            scroll: {
                                x: window.scrollX,
                                y: window.scrollY
                            },
                            url: t
                        };
                    this.h.push(r), this.v = n;
                    var s = {
                        from: this.l,
                        index: n,
                        states: [].concat(this.h)
                    };
                    switch (i) {
                        case "push":
                            window.history && window.history.pushState(s, "", t);
                            break;
                        case "replace":
                            window.history && window.history.replaceState(s, "", t)
                    }
                }, i.update = function (t, e) {
                    var i = e || this.v,
                        r = n({}, this.get(i), {}, t);
                    this.set(i, r)
                }, i.remove = function (t) {
                    t ? this.h.splice(t, 1) : this.h.pop(), this.v--
                }, i.clear = function () {
                    this.h = [], this.v = -1
                }, i.replace = function (t) {
                    this.h = t
                }, i.get = function (t) {
                    return this.h[t]
                }, i.set = function (t, e) {
                    return this.h[t] = e
                }, i.p = function (t) {
                    var e = "push",
                        n = t,
                        i = T.prefix + "-" + T.history;
                    return n.hasAttribute && n.hasAttribute(i) && (e = n.getAttribute(i)), e
                }, i.m = function (t) {
                    return Math.abs(t) > 1 ? t > 0 ? "forward" : "back" : 0 === t ? "popstate" : t > 0 ? "back" : "forward"
                }, e(t, [{
                    key: "current",
                    get: function () {
                        return this.h[this.v]
                    }
                }, {
                    key: "state",
                    get: function () {
                        return this.h[this.h.length - 1]
                    }
                }, {
                    key: "previous",
                    get: function () {
                        return this.v < 1 ? null : this.h[this.v - 1]
                    }
                }, {
                    key: "size",
                    get: function () {
                        return this.h.length
                    }
                }]), t
            }()),
            R = function (t, e) {
                try {
                    var n = function () {
                        if (!e.next.html) return Promise.resolve(t).then((function (t) {
                            var n = e.next;
                            if (t) {
                                var i = C.toElement(t);
                                n.namespace = C.getNamespace(i), n.container = C.getContainer(i), n.html = t, A.update({
                                    ns: n.namespace
                                });
                                var r = C.toDocument(t);
                                document.title = r.title
                            }
                        }))
                    }();
                    return Promise.resolve(n && n.then ? n.then((function () { })) : void 0)
                } catch (t) {
                    return Promise.reject(t)
                }
            },
            P = d,
            L = {
                __proto__: null,
                update: R,
                nextTick: function () {
                    return new Promise((function (t) {
                        window.requestAnimationFrame(t)
                    }))
                },
                pathToRegexp: P
            },
            O = function () {
                return window.location.origin
            },
            D = function (t) {
                return void 0 === t && (t = window.location.href), I(t).port
            },
            I = function (t) {
                var e, n = t.match(/:\d+/);
                if (null === n) /^http/.test(t) && (e = 80), /^https/.test(t) && (e = 443);
                else {
                    var i = n[0].substring(1);
                    e = parseInt(i, 10)
                }
                var r, s = t.replace(O(), ""),
                    a = {},
                    o = s.indexOf("#");
                o >= 0 && (r = s.slice(o + 1), s = s.slice(0, o));
                var l = s.indexOf("?");
                return l >= 0 && (a = k(s.slice(l + 1)), s = s.slice(0, l)), {
                    hash: r,
                    path: s,
                    port: e,
                    query: a
                }
            },
            k = function (t) {
                return t.split("&").reduce((function (t, e) {
                    var n = e.split("=");
                    return t[n[0]] = n[1], t
                }), {})
            },
            N = function (t) {
                return void 0 === t && (t = window.location.href), t.replace(/(\/#.*|\/|#.*)$/, "")
            },
            U = {
                __proto__: null,
                getHref: function () {
                    return window.location.href
                },
                getOrigin: O,
                getPort: D,
                getPath: function (t) {
                    return void 0 === t && (t = window.location.href), I(t).path
                },
                parse: I,
                parseQuery: k,
                clean: N
            };

        function z(t, e, n) {
            return void 0 === e && (e = 2e3), new Promise((function (i, r) {
                var s = new XMLHttpRequest;
                s.onreadystatechange = function () {
                    if (s.readyState === XMLHttpRequest.DONE)
                        if (200 === s.status) i(s.responseText);
                        else if (s.status) {
                            var e = {
                                status: s.status,
                                statusText: s.statusText
                            };
                            n(t, e), r(e)
                        }
                }, s.ontimeout = function () {
                    var i = new Error("Timeout error [" + e + "]");
                    n(t, i), r(i)
                }, s.onerror = function () {
                    var e = new Error("Fetch error");
                    n(t, e), r(e)
                }, s.open("GET", t), s.timeout = e, s.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml"), s.setRequestHeader("x-barba", "yes"), s.send()
            }))
        }
        var F = function (t) {
            return !!t && ("object" == typeof t || "function" == typeof t) && "function" == typeof t.then
        };

        function $(t, e) {
            return void 0 === e && (e = {}),
                function () {
                    for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    var s = !1,
                        a = new Promise((function (n, r) {
                            e.async = function () {
                                return s = !0,
                                    function (t, e) {
                                        t ? r(t) : n(e)
                                    }
                            };
                            var a = t.apply(e, i);
                            s || (F(a) ? a.then(n, r) : n(a))
                        }));
                    return a
                }
        }
        var B = new (function (t) {
            function e() {
                var e;
                return (e = t.call(this) || this).logger = new u("@barba/core"), e.all = ["ready", "page", "reset", "currentAdded", "currentRemoved", "nextAdded", "nextRemoved", "beforeOnce", "once", "afterOnce", "before", "beforeLeave", "leave", "afterLeave", "beforeEnter", "enter", "afterEnter", "after"], e.registered = new Map, e.init(), e
            }
            i(e, t);
            var n = e.prototype;
            return n.init = function () {
                var t = this;
                this.registered.clear(), this.all.forEach((function (e) {
                    t[e] || (t[e] = function (n, i) {
                        t.registered.has(e) || t.registered.set(e, new Set), t.registered.get(e).add({
                            ctx: i || {},
                            fn: n
                        })
                    })
                }))
            }, n.do = function (t) {
                for (var e = this, n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) i[r - 1] = arguments[r];
                if (this.registered.has(t)) {
                    var s = Promise.resolve();
                    return this.registered.get(t).forEach((function (t) {
                        s = s.then((function () {
                            return $(t.fn, t.ctx).apply(void 0, i)
                        }))
                    })), s.catch((function (n) {
                        e.logger.debug("Hook error [" + t + "]"), e.logger.error(n)
                    }))
                }
                return Promise.resolve()
            }, n.clear = function () {
                var t = this;
                this.all.forEach((function (e) {
                    delete t[e]
                })), this.init()
            }, n.help = function () {
                this.logger.info("Available hooks: " + this.all.join(","));
                var t = [];
                this.registered.forEach((function (e, n) {
                    return t.push(n)
                })), this.logger.info("Registered hooks: " + t.join(","))
            }, e
        }((function () { }))),
            H = function () {
                function t(t) {
                    if (this.P = [], "boolean" == typeof t) this.g = t;
                    else {
                        var e = Array.isArray(t) ? t : [t];
                        this.P = e.map((function (t) {
                            return P(t)
                        }))
                    }
                }
                return t.prototype.checkHref = function (t) {
                    if ("boolean" == typeof this.g) return this.g;
                    var e = I(t).path;
                    return this.P.some((function (t) {
                        return null !== t.exec(e)
                    }))
                }, t
            }(),
            j = function (t) {
                function e(e) {
                    var n;
                    return (n = t.call(this, e) || this).k = new Map, n
                }
                i(e, t);
                var r = e.prototype;
                return r.set = function (t, e, n) {
                    return this.k.set(t, {
                        action: n,
                        request: e
                    }), {
                        action: n,
                        request: e
                    }
                }, r.get = function (t) {
                    return this.k.get(t)
                }, r.getRequest = function (t) {
                    return this.k.get(t).request
                }, r.getAction = function (t) {
                    return this.k.get(t).action
                }, r.has = function (t) {
                    return !this.checkHref(t) && this.k.has(t)
                }, r.delete = function (t) {
                    return this.k.delete(t)
                }, r.update = function (t, e) {
                    var i = n({}, this.k.get(t), {}, e);
                    return this.k.set(t, i), i
                }, e
            }(H),
            V = function () {
                return !window.history.pushState
            },
            G = function (t) {
                return !t.el || !t.href
            },
            W = function (t) {
                var e = t.event;
                return e.which > 1 || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey
            },
            q = function (t) {
                var e = t.el;
                return e.hasAttribute("target") && "_blank" === e.target
            },
            X = function (t) {
                var e = t.el;
                return void 0 !== e.protocol && window.location.protocol !== e.protocol || void 0 !== e.hostname && window.location.hostname !== e.hostname
            },
            Y = function (t) {
                var e = t.el;
                return void 0 !== e.port && D() !== D(e.href)
            },
            K = function (t) {
                var e = t.el;
                return e.getAttribute && "string" == typeof e.getAttribute("download")
            },
            Z = function (t) {
                return t.el.hasAttribute(T.prefix + "-" + T.prevent)
            },
            J = function (t) {
                return Boolean(t.el.closest("[" + T.prefix + "-" + T.prevent + '="all"]'))
            },
            Q = function (t) {
                var e = t.href;
                return N(e) === N() && D(e) === D()
            },
            tt = function (t) {
                function e(e) {
                    var n;
                    return (n = t.call(this, e) || this).suite = [], n.tests = new Map, n.init(), n
                }
                i(e, t);
                var n = e.prototype;
                return n.init = function () {
                    this.add("pushState", V), this.add("exists", G), this.add("newTab", W), this.add("blank", q), this.add("corsDomain", X), this.add("corsPort", Y), this.add("download", K), this.add("preventSelf", Z), this.add("preventAll", J), this.add("sameUrl", Q, !1)
                }, n.add = function (t, e, n) {
                    void 0 === n && (n = !0), this.tests.set(t, e), n && this.suite.push(t)
                }, n.run = function (t, e, n, i) {
                    return this.tests.get(t)({
                        el: e,
                        event: n,
                        href: i
                    })
                }, n.checkLink = function (t, e, n) {
                    var i = this;
                    return this.suite.some((function (r) {
                        return i.run(r, t, e, n)
                    }))
                }, e
            }(H),
            et = function (t) {
                function e(n, i) {
                    var r;
                    void 0 === i && (i = "Barba error");
                    for (var s = arguments.length, a = new Array(s > 2 ? s - 2 : 0), o = 2; o < s; o++) a[o - 2] = arguments[o];
                    return (r = t.call.apply(t, [this].concat(a)) || this).error = n, r.label = i, Error.captureStackTrace && Error.captureStackTrace(function (t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(r), e), r.name = "BarbaError", r
                }
                return i(e, t), e
            }(o(Error)),
            nt = function () {
                function t(t) {
                    void 0 === t && (t = []), this.logger = new u("@barba/core"), this.all = [], this.page = [], this.once = [], this.A = [{
                        name: "namespace",
                        type: "strings"
                    }, {
                        name: "custom",
                        type: "function"
                    }], t && (this.all = this.all.concat(t)), this.update()
                }
                var e = t.prototype;
                return e.add = function (t, e) {
                    switch (t) {
                        case "rule":
                            this.A.splice(e.position || 0, 0, e.value);
                            break;
                        case "transition":
                        default:
                            this.all.push(e)
                    }
                    this.update()
                }, e.resolve = function (t, e) {
                    var n = this;
                    void 0 === e && (e = {});
                    var i = e.once ? this.once : this.page;
                    i = i.filter(e.self ? function (t) {
                        return t.name && "self" === t.name
                    } : function (t) {
                        return !t.name || "self" !== t.name
                    });
                    var r = new Map,
                        s = i.find((function (i) {
                            var s = !0,
                                a = {};
                            return !(!e.self || "self" !== i.name) || (n.A.reverse().forEach((function (e) {
                                s && (s = n.R(i, e, t, a), i.from && i.to && (s = n.R(i, e, t, a, "from") && n.R(i, e, t, a, "to")), i.from && !i.to && (s = n.R(i, e, t, a, "from")), !i.from && i.to && (s = n.R(i, e, t, a, "to")))
                            })), r.set(i, a), s)
                        })),
                        a = r.get(s),
                        o = [];
                    if (o.push(e.once ? "once" : "page"), e.self && o.push("self"), a) {
                        var l, c = [s];
                        Object.keys(a).length > 0 && c.push(a), (l = this.logger).info.apply(l, ["Transition found [" + o.join(",") + "]"].concat(c))
                    } else this.logger.info("No transition found [" + o.join(",") + "]");
                    return s
                }, e.update = function () {
                    var t = this;
                    this.all = this.all.map((function (e) {
                        return t.T(e)
                    })).sort((function (t, e) {
                        return t.priority - e.priority
                    })).reverse().map((function (t) {
                        return delete t.priority, t
                    })), this.page = this.all.filter((function (t) {
                        return void 0 !== t.leave || void 0 !== t.enter
                    })), this.once = this.all.filter((function (t) {
                        return void 0 !== t.once
                    }))
                }, e.R = function (t, e, n, i, r) {
                    var s = !0,
                        a = !1,
                        o = t,
                        l = e.name,
                        c = l,
                        h = l,
                        u = l,
                        d = r ? o[r] : o,
                        p = "to" === r ? n.next : n.current;
                    if (r ? d && d[l] : d[l]) {
                        switch (e.type) {
                            case "strings":
                            default:
                                var f = Array.isArray(d[c]) ? d[c] : [d[c]];
                                p[c] && -1 !== f.indexOf(p[c]) && (a = !0), -1 === f.indexOf(p[c]) && (s = !1);
                                break;
                            case "object":
                                var m = Array.isArray(d[h]) ? d[h] : [d[h]];
                                p[h] ? (p[h].name && -1 !== m.indexOf(p[h].name) && (a = !0), -1 === m.indexOf(p[h].name) && (s = !1)) : s = !1;
                                break;
                            case "function":
                                d[u](n) ? a = !0 : s = !1
                        }
                        a && (r ? (i[r] = i[r] || {}, i[r][l] = o[r][l]) : i[l] = o[l])
                    }
                    return s
                }, e.O = function (t, e, n) {
                    var i = 0;
                    return (t[e] || t.from && t.from[e] || t.to && t.to[e]) && (i += Math.pow(10, n), t.from && t.from[e] && (i += 1), t.to && t.to[e] && (i += 2)), i
                }, e.T = function (t) {
                    var e = this;
                    t.priority = 0;
                    var n = 0;
                    return this.A.forEach((function (i, r) {
                        n += e.O(t, i.name, r + 1)
                    })), t.priority = n, t
                }, t
            }(),
            it = function () {
                function t(t) {
                    void 0 === t && (t = []), this.logger = new u("@barba/core"), this.S = !1, this.store = new nt(t)
                }
                var n = t.prototype;
                return n.get = function (t, e) {
                    return this.store.resolve(t, e)
                }, n.doOnce = function (t) {
                    var e = t.data,
                        n = t.transition;
                    try {
                        var i = function () {
                            r.S = !1
                        },
                            r = this,
                            s = n || {};
                        r.S = !0;
                        var a = l((function () {
                            return Promise.resolve(r.j("beforeOnce", e, s)).then((function () {
                                return Promise.resolve(r.once(e, s)).then((function () {
                                    return Promise.resolve(r.j("afterOnce", e, s)).then((function () { }))
                                }))
                            }))
                        }), (function (t) {
                            r.S = !1, r.logger.debug("Transition error [before/after/once]"), r.logger.error(t)
                        }));
                        return Promise.resolve(a && a.then ? a.then(i) : i())
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, n.doPage = function (t) {
                    var e = t.data,
                        n = t.transition,
                        i = t.page,
                        r = t.wrapper;
                    try {
                        var s = function (t) {
                            if (a) return t;
                            o.S = !1
                        },
                            a = !1,
                            o = this,
                            c = n || {},
                            h = !0 === c.sync || !1;
                        o.S = !0;
                        var u = l((function () {
                            function t() {
                                return Promise.resolve(o.j("before", e, c)).then((function () {
                                    function t(t) {
                                        return Promise.resolve(o.remove(e)).then((function () {
                                            return Promise.resolve(o.j("after", e, c)).then((function () { }))
                                        }))
                                    }
                                    var n = function () {
                                        if (h) return l((function () {
                                            return Promise.resolve(o.add(e, r)).then((function () {
                                                return Promise.resolve(o.j("beforeLeave", e, c)).then((function () {
                                                    return Promise.resolve(o.j("beforeEnter", e, c)).then((function () {
                                                        return Promise.resolve(Promise.all([o.leave(e, c), o.enter(e, c)])).then((function () {
                                                            return Promise.resolve(o.j("afterLeave", e, c)).then((function () {
                                                                return Promise.resolve(o.j("afterEnter", e, c)).then((function () { }))
                                                            }))
                                                        }))
                                                    }))
                                                }))
                                            }))
                                        }), (function (t) {
                                            if (o.M(t)) throw new et(t, "Transition error [sync]")
                                        }));
                                        var t = function (t) {
                                            return l((function () {
                                                var t = function () {
                                                    if (!1 !== n) return Promise.resolve(o.add(e, r)).then((function () {
                                                        return Promise.resolve(o.j("beforeEnter", e, c)).then((function () {
                                                            return Promise.resolve(o.enter(e, c, n)).then((function () {
                                                                return Promise.resolve(o.j("afterEnter", e, c)).then((function () { }))
                                                            }))
                                                        }))
                                                    }))
                                                }();
                                                if (t && t.then) return t.then((function () { }))
                                            }), (function (t) {
                                                if (o.M(t)) throw new et(t, "Transition error [before/after/enter]")
                                            }))
                                        },
                                            n = !1,
                                            s = l((function () {
                                                return Promise.resolve(o.j("beforeLeave", e, c)).then((function () {
                                                    return Promise.resolve(Promise.all([o.leave(e, c), R(i, e)]).then((function (t) {
                                                        return t[0]
                                                    }))).then((function (t) {
                                                        return n = t, Promise.resolve(o.j("afterLeave", e, c)).then((function () { }))
                                                    }))
                                                }))
                                            }), (function (t) {
                                                if (o.M(t)) throw new et(t, "Transition error [before/after/leave]")
                                            }));
                                        return s && s.then ? s.then(t) : t()
                                    }();
                                    return n && n.then ? n.then(t) : t()
                                }))
                            }
                            var n = function () {
                                if (h) return Promise.resolve(R(i, e)).then((function () { }))
                            }();
                            return n && n.then ? n.then(t) : t()
                        }), (function (t) {
                            if (o.S = !1, t.name && "BarbaError" === t.name) throw o.logger.debug(t.label), o.logger.error(t.error), t;
                            throw o.logger.debug("Transition error [page]"), o.logger.error(t), t
                        }));
                        return Promise.resolve(u && u.then ? u.then(s) : s(u))
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, n.once = function (t, e) {
                    try {
                        return Promise.resolve(B.do("once", t, e)).then((function () {
                            return e.once ? $(e.once, e)(t) : Promise.resolve()
                        }))
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, n.leave = function (t, e) {
                    try {
                        return Promise.resolve(B.do("leave", t, e)).then((function () {
                            return e.leave ? $(e.leave, e)(t) : Promise.resolve()
                        }))
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, n.enter = function (t, e, n) {
                    try {
                        return Promise.resolve(B.do("enter", t, e)).then((function () {
                            return e.enter ? $(e.enter, e)(t, n) : Promise.resolve()
                        }))
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, n.add = function (t, e) {
                    try {
                        return C.addContainer(t.next.container, e), B.do("nextAdded", t), Promise.resolve()
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, n.remove = function (t) {
                    try {
                        return C.removeContainer(t.current.container), B.do("currentRemoved", t), Promise.resolve()
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, n.M = function (t) {
                    return t.message ? !/Timeout error|Fetch error/.test(t.message) : !t.status
                }, n.j = function (t, e, n) {
                    try {
                        return Promise.resolve(B.do(t, e, n)).then((function () {
                            return n[t] ? $(n[t], n)(e) : Promise.resolve()
                        }))
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, e(t, [{
                    key: "isRunning",
                    get: function () {
                        return this.S
                    },
                    set: function (t) {
                        this.S = t
                    }
                }, {
                    key: "hasOnce",
                    get: function () {
                        return this.store.once.length > 0
                    }
                }, {
                    key: "hasSelf",
                    get: function () {
                        return this.store.all.some((function (t) {
                            return "self" === t.name
                        }))
                    }
                }, {
                    key: "shouldWait",
                    get: function () {
                        return this.store.all.some((function (t) {
                            return t.to && !t.to.route || t.sync
                        }))
                    }
                }]), t
            }(),
            rt = function () {
                function t(t) {
                    var e = this;
                    this.names = ["beforeLeave", "afterLeave", "beforeEnter", "afterEnter"], this.byNamespace = new Map, 0 !== t.length && (t.forEach((function (t) {
                        e.byNamespace.set(t.namespace, t)
                    })), this.names.forEach((function (t) {
                        B[t](e.L(t))
                    })))
                }
                return t.prototype.L = function (t) {
                    var e = this;
                    return function (n) {
                        var i = t.match(/enter/i) ? n.next : n.current,
                            r = e.byNamespace.get(i.namespace);
                        return r && r[t] ? $(r[t], r)(n) : Promise.resolve()
                    }
                }, t
            }();
        Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function (t) {
            var e = this;
            do {
                if (e.matches(t)) return e;
                e = e.parentElement || e.parentNode
            } while (null !== e && 1 === e.nodeType);
            return null
        });
        var st = {
            container: null,
            html: "",
            namespace: "",
            url: {
                hash: "",
                href: "",
                path: "",
                port: null,
                query: {}
            }
        };
        return new (function () {
            function t() {
                this.version = "2.9.7", this.schemaPage = st, this.Logger = u, this.logger = new u("@barba/core"), this.plugins = [], this.hooks = B, this.dom = C, this.helpers = L, this.history = A, this.request = z, this.url = U
            }
            var i = t.prototype;
            return i.use = function (t, e) {
                var n = this.plugins;
                n.indexOf(t) > -1 ? this.logger.warn("Plugin [" + t.name + "] already installed.") : "function" == typeof t.install ? (t.install(this, e), n.push(t)) : this.logger.warn("Plugin [" + t.name + '] has no "install" method.')
            }, i.init = function (t) {
                var e = void 0 === t ? {} : t,
                    i = e.transitions,
                    r = void 0 === i ? [] : i,
                    s = e.views,
                    a = void 0 === s ? [] : s,
                    o = e.schema,
                    l = void 0 === o ? T : o,
                    c = e.requestError,
                    h = e.timeout,
                    d = void 0 === h ? 2e3 : h,
                    p = e.cacheIgnore,
                    f = void 0 !== p && p,
                    m = e.prefetchIgnore,
                    g = void 0 !== m && m,
                    v = e.preventRunning,
                    y = void 0 !== v && v,
                    b = e.prevent,
                    x = void 0 === b ? null : b,
                    _ = e.debug,
                    w = e.logLevel;
                if (u.setLevel(!0 === (void 0 !== _ && _) ? "debug" : void 0 === w ? "off" : w), this.logger.info(this.version), Object.keys(l).forEach((function (t) {
                    T[t] && (T[t] = l[t])
                })), this.$ = c, this.timeout = d, this.cacheIgnore = f, this.prefetchIgnore = g, this.preventRunning = y, this._ = this.dom.getWrapper(), !this._) throw new Error("[@barba/core] No Barba wrapper found");
                this._.setAttribute("aria-live", "polite"), this.q();
                var S = this.data.current;
                if (!S.container) throw new Error("[@barba/core] No Barba container found");
                if (this.cache = new j(f), this.prevent = new tt(g), this.transitions = new it(r), this.views = new rt(a), null !== x) {
                    if ("function" != typeof x) throw new Error("[@barba/core] Prevent should be a function");
                    this.prevent.add("preventCustom", x)
                }
                this.history.init(S.url.href, S.namespace), this.B = this.B.bind(this), this.U = this.U.bind(this), this.D = this.D.bind(this), this.F(), this.plugins.forEach((function (t) {
                    return t.init()
                }));
                var M = this.data;
                M.trigger = "barba", M.next = M.current, M.current = n({}, this.schemaPage), this.hooks.do("ready", M), this.once(M), this.q()
            }, i.destroy = function () {
                this.q(), this.H(), this.history.clear(), this.hooks.clear(), this.plugins = []
            }, i.force = function (t) {
                window.location.assign(t)
            }, i.go = function (t, e, n) {
                var i;
                if (void 0 === e && (e = "barba"), this.transitions.isRunning) this.force(t);
                else if (!(i = "popstate" === e ? this.history.current && this.url.getPath(this.history.current.url) === this.url.getPath(t) : this.prevent.run("sameUrl", null, null, t)) || this.transitions.hasSelf) return e = this.history.change(t, e, n), n && (n.stopPropagation(), n.preventDefault()), this.page(t, e, i)
            }, i.once = function (t) {
                try {
                    var e = this;
                    return Promise.resolve(e.hooks.do("beforeEnter", t)).then((function () {
                        function n() {
                            return Promise.resolve(e.hooks.do("afterEnter", t)).then((function () { }))
                        }
                        var i = function () {
                            if (e.transitions.hasOnce) {
                                var n = e.transitions.get(t, {
                                    once: !0
                                });
                                return Promise.resolve(e.transitions.doOnce({
                                    transition: n,
                                    data: t
                                })).then((function () { }))
                            }
                        }();
                        return i && i.then ? i.then(n) : n()
                    }))
                } catch (t) {
                    return Promise.reject(t)
                }
            }, i.page = function (t, e, i) {
                try {
                    var r = function () {
                        var t = s.data;
                        return Promise.resolve(s.hooks.do("page", t)).then((function () {
                            var e = l((function () {
                                var e = s.transitions.get(t, {
                                    once: !1,
                                    self: i
                                });
                                return Promise.resolve(s.transitions.doPage({
                                    data: t,
                                    page: a,
                                    transition: e,
                                    wrapper: s._
                                })).then((function () {
                                    s.q()
                                }))
                            }), (function () {
                                0 === u.getLevel() && s.force(t.current.url.href)
                            }));
                            if (e && e.then) return e.then((function () { }))
                        }))
                    },
                        s = this;
                    s.data.next.url = n({
                        href: t
                    }, s.url.parse(t)), s.data.trigger = e;
                    var a = s.cache.has(t) ? s.cache.update(t, {
                        action: "click"
                    }).request : s.cache.set(t, s.request(t, s.timeout, s.onRequestError.bind(s, e)), "click").request,
                        o = function () {
                            if (s.transitions.shouldWait) return Promise.resolve(R(a, s.data)).then((function () { }))
                        }();
                    return Promise.resolve(o && o.then ? o.then(r) : r())
                } catch (t) {
                    return Promise.reject(t)
                }
            }, i.onRequestError = function (t) {
                this.transitions.isRunning = !1;
                for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
                var r = n[0],
                    s = n[1],
                    a = this.cache.getAction(r);
                return this.cache.delete(r), !(this.$ && !1 === this.$(t, a, r, s) || ("click" === a && this.force(r), 1))
            }, i.prefetch = function (t) {
                var e = this;
                this.cache.has(t) || this.cache.set(t, this.request(t, this.timeout, this.onRequestError.bind(this, "barba")).catch((function (t) {
                    e.logger.error(t)
                })), "prefetch")
            }, i.F = function () {
                !0 !== this.prefetchIgnore && (document.addEventListener("mouseover", this.B), document.addEventListener("touchstart", this.B)), document.addEventListener("click", this.U), window.addEventListener("popstate", this.D)
            }, i.H = function () {
                !0 !== this.prefetchIgnore && (document.removeEventListener("mouseover", this.B), document.removeEventListener("touchstart", this.B)), document.removeEventListener("click", this.U), window.removeEventListener("popstate", this.D)
            }, i.B = function (t) {
                var e = this,
                    n = this.I(t);
                if (n) {
                    var i = this.dom.getHref(n);
                    this.prevent.checkHref(i) || this.cache.has(i) || this.cache.set(i, this.request(i, this.timeout, this.onRequestError.bind(this, n)).catch((function (t) {
                        e.logger.error(t)
                    })), "enter")
                }
            }, i.U = function (t) {
                var e = this.I(t);
                if (e) return this.transitions.isRunning && this.preventRunning ? (t.preventDefault(), void t.stopPropagation()) : void this.go(this.dom.getHref(e), e, t)
            }, i.D = function (t) {
                this.go(this.url.getHref(), "popstate", t)
            }, i.I = function (t) {
                for (var e = t.target; e && !this.dom.getHref(e);) e = e.parentNode;
                if (e && !this.prevent.checkLink(e, t, this.dom.getHref(e))) return e
            }, i.q = function () {
                var t = this.url.getHref(),
                    e = {
                        container: this.dom.getContainer(),
                        html: this.dom.getHtml(),
                        namespace: this.dom.getNamespace(),
                        url: n({
                            href: t
                        }, this.url.parse(t))
                    };
                this.C = {
                    current: e,
                    next: n({}, this.schemaPage),
                    trigger: void 0
                }, this.hooks.do("reset", this.data)
            }, e(t, [{
                key: "data",
                get: function () {
                    return this.C
                }
            }, {
                key: "wrapper",
                get: function () {
                    return this._
                }
            }]), t
        }())
    }()
}, function (t, e, n) {
    "use strict";

    function i(t, e, n, i, r) {
        let s = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5];
        const a = i < r ? i : r,
            o = i < r ? r : i,
            l = (t - e) / (n - e) * (r - i) + i;
        return s ? Math.max(a, Math.min(o, l)) : l
    }
    n.d(e, "a", (function () {
        return i
    }))
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return r
    }));
    var i = n(29);
    class r {
        static get Defaults() {
            return {
                strength: .05,
                easing: "lerp",
                duration: 350,
                update: null,
                precision: null,
                autorun: null,
                startCallback: null,
                completeCallback: null
            }
        }
        constructor(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            e = $.extend({}, this.constructor.Defaults, e), this.type = this.getType(t), this.strength = e.strength, this.easing = e.easing, this.duration = e.duration, this.precision = null !== e.precision ? e.precision : 1 === this.type ? 1 / 256 : .001, this.completed = !0, this.updateCallback = e.update, this.startCallback = e.startCallback, this.completeCallback = e.completeCallback, this.rafHandle = null, this.timeLast = 0, this.mode = null !== e.autorun ? e.autorun ? 1 : 0 : this.updateCallback ? 1 : 0, this.update = this.update.bind(this), this.value = {
                start: this.normalize(t),
                current: this.normalize(t),
                target: this.normalize(t),
                keys: 3 === this.type ? Object.keys(t) : []
            }
        }
        destroy() {
            this.updateCallback = null, this.startCallback = null, this.completeCallback = null, this.rafHandle && cancelAnimationFrame(this.rafHandle)
        }
        setStrength(t) {
            this.strength = t
        }
        setDuration(t) {
            this.duration = t
        }
        getType(t) {
            return "string" == typeof t ? 1 : "number" == typeof t ? 2 : Array.isArray(t) ? 4 : 3
        }
        normalize(t, e) {
            const n = this.type;
            return 1 === n ? t : 3 === n ? $.extend({}, e || {}, t) : 4 === n ? [].concat(t) : 2 === n ? t : void 0
        }
        set(t) {
            const e = this.normalize(this.value.target),
                n = this.normalize(t, this.value.target);
            this.value.target !== n && e !== n && (this.completed = !1, this.value.start = e, this.value.target = n, 1 !== this.mode || this.rafHandle || (this.timeLast = Date.now(), this.rafHandle = requestAnimationFrame(this.update)), this.startCallback && this.startCallback())
        }
        reset(t) {
            this.set(t), this.value.start = this.normalize(this.value.target), this.value.target = this.normalize(t, this.value.target), this.value.current = this.normalize(t, this.value.current), this.rafHandle && (cancelAnimationFrame(this.rafHandle), this.rafHandle = null), this.updateCallback && this.updateCallback(this.value.current)
        }
        get() {
            return this.value.current
        }
        getTarget() {
            return this.value.target
        }
        update() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            if (this.rafHandle = null, this.completed) return !1;
            {
                const e = Date.now(),
                    n = 1 === this.mode || null === t ? e - this.timeLast : t;
                return this.timeLast = e, this.constructor.transforms[this.type].call(this, n), this.completed || 1 !== this.mode || (this.rafHandle = requestAnimationFrame(this.update)), this.updateCallback && this.updateCallback(this.value.current), this.completed && this.completeCallback && this.completeCallback(), !0
            }
        }
    }
    r.easings = {
        linear(t, e, n, i) {
            const r = e + (n - t) / this.duration * (i || 16);
            return e < n && r >= n || e > n && r <= n ? n : r
        },
        lerp(t, e, n, r) {
            return Math.abs(n - e) < this.precision ? n : e < n ? Math.min(n, Object(i.a)(e, n, this.strength * (r || 16) / (this.duration / 22))) : Math.max(n, Object(i.a)(e, n, this.strength * (r || 16) / (this.duration / 22)))
        }
    }, r.transforms = {
        3(t) {
            const e = this.value.start,
                n = this.value.current,
                i = this.value.target,
                s = this.value.keys,
                a = r.easings[this.easing];
            let o = !0;
            for (let r = 0; r < s.length; r++) {
                const l = s[r];
                n[l] = a.call(this, e[l], n[l], i[l], t), n[l] !== i[l] && (o = !1)
            }
            this.completed = o
        },
        4(t) {
            const e = this.value.start,
                n = this.value.current,
                i = this.value.target,
                s = r.easings[this.easing];
            let a = !0;
            for (let r = 0; r < n.length; r++) n[r] = s.call(this, e[r], n[r], i[r], t), n[r] !== i[r] && (a = !1);
            this.completed = a
        },
        2(t) {
            const e = this.value.start,
                n = this.value.current,
                i = this.value.target,
                s = r.easings[this.easing];
            this.value.current = s.call(this, e, n, i, t), this.value.current === this.value.target && (this.completed = !0)
        },
        1(t) {
            this.completed = !0
        }
    }
}, function (t, e, n) {
    "use strict";
    e.a = {
        fast: .2,
        normal: .4,
        slow: .8,
        block: 1.4,
        title: 1.5,
        blockMap: 1.6,
        slide: 2,
        preloader: 4
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return X
    }));
    var i = {};
    n.r(i), n.d(i, "ArcCurve", (function () {
        return E
    })), n.d(i, "CatmullRomCurve3", (function () {
        return L
    })), n.d(i, "CubicBezierCurve", (function () {
        return O
    })), n.d(i, "CubicBezierCurve3", (function () {
        return D
    })), n.d(i, "EllipseCurve", (function () {
        return M
    })), n.d(i, "LineCurve", (function () {
        return I
    })), n.d(i, "LineCurve3", (function () {
        return k
    })), n.d(i, "QuadraticBezierCurve", (function () {
        return N
    })), n.d(i, "QuadraticBezierCurve3", (function () {
        return S
    })), n.d(i, "SplineCurve", (function () {
        return U
    }));
    var r = n(0);
    Math.PI, Math.PI;

    function s(t, e, n) {
        return Math.max(e, Math.min(n, t))
    }
    class a {
        constructor(t = 0, e = 0) {
            a.prototype.isVector2 = !0, this.x = t, this.y = e
        }
        get width() {
            return this.x
        }
        set width(t) {
            this.x = t
        }
        get height() {
            return this.y
        }
        set height(t) {
            this.y = t
        }
        set(t, e) {
            return this.x = t, this.y = e, this
        }
        setScalar(t) {
            return this.x = t, this.y = t, this
        }
        setX(t) {
            return this.x = t, this
        }
        setY(t) {
            return this.y = t, this
        }
        setComponent(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + t)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y)
        }
        copy(t) {
            return this.x = t.x, this.y = t.y, this
        }
        add(t) {
            return this.x += t.x, this.y += t.y, this
        }
        addScalar(t) {
            return this.x += t, this.y += t, this
        }
        addVectors(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this
        }
        addScaledVector(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this
        }
        sub(t) {
            return this.x -= t.x, this.y -= t.y, this
        }
        subScalar(t) {
            return this.x -= t, this.y -= t, this
        }
        subVectors(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this
        }
        multiply(t) {
            return this.x *= t.x, this.y *= t.y, this
        }
        multiplyScalar(t) {
            return this.x *= t, this.y *= t, this
        }
        divide(t) {
            return this.x /= t.x, this.y /= t.y, this
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t)
        }
        applyMatrix3(t) {
            const e = this.x,
                n = this.y,
                i = t.elements;
            return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
        }
        min(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
        }
        max(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
        }
        clamp(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
        }
        clampScalar(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
        }
        clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y
        }
        cross(t) {
            return this.x * t.y - this.y * t.x
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }
        angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(s(n, -1, 1))
        }
        distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t) {
            const e = this.x - t.x,
                n = this.y - t.y;
            return e * e + n * n
        }
        manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
        }
        lerpVectors(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
        }
        equals(t) {
            return t.x === this.x && t.y === this.y
        }
        fromArray(t, e = 0) {
            return this.x = t[e], this.y = t[e + 1], this
        }
        toArray(t = [], e = 0) {
            return t[e] = this.x, t[e + 1] = this.y, t
        }
        fromBufferAttribute(t, e) {
            return this.x = t.getX(e), this.y = t.getY(e), this
        }
        rotateAround(t, e) {
            const n = Math.cos(e),
                i = Math.sin(e),
                r = this.x - t.x,
                s = this.y - t.y;
            return this.x = r * n - s * i + t.x, this.y = r * i + s * n + t.y, this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this
        } *[Symbol.iterator]() {
            yield this.x, yield this.y
        }
    }
    class o {
        constructor(t = 0, e = 0, n = 0, i = 1) {
            this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = i
        }
        static slerpFlat(t, e, n, i, r, s, a) {
            let o = n[i + 0],
                l = n[i + 1],
                c = n[i + 2],
                h = n[i + 3];
            const u = r[s + 0],
                d = r[s + 1],
                p = r[s + 2],
                f = r[s + 3];
            if (0 === a) return t[e + 0] = o, t[e + 1] = l, t[e + 2] = c, void (t[e + 3] = h);
            if (1 === a) return t[e + 0] = u, t[e + 1] = d, t[e + 2] = p, void (t[e + 3] = f);
            if (h !== f || o !== u || l !== d || c !== p) {
                let t = 1 - a;
                const e = o * u + l * d + c * p + h * f,
                    n = e >= 0 ? 1 : -1,
                    i = 1 - e * e;
                if (i > Number.EPSILON) {
                    const r = Math.sqrt(i),
                        s = Math.atan2(r, e * n);
                    t = Math.sin(t * s) / r, a = Math.sin(a * s) / r
                }
                const r = a * n;
                if (o = o * t + u * r, l = l * t + d * r, c = c * t + p * r, h = h * t + f * r, t === 1 - a) {
                    const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                    o *= t, l *= t, c *= t, h *= t
                }
            }
            t[e] = o, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h
        }
        static multiplyQuaternionsFlat(t, e, n, i, r, s) {
            const a = n[i],
                o = n[i + 1],
                l = n[i + 2],
                c = n[i + 3],
                h = r[s],
                u = r[s + 1],
                d = r[s + 2],
                p = r[s + 3];
            return t[e] = a * p + c * h + o * d - l * u, t[e + 1] = o * p + c * u + l * h - a * d, t[e + 2] = l * p + c * d + a * u - o * h, t[e + 3] = c * p - a * h - o * u - l * d, t
        }
        get x() {
            return this._x
        }
        set x(t) {
            this._x = t, this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(t) {
            this._y = t, this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(t) {
            this._z = t, this._onChangeCallback()
        }
        get w() {
            return this._w
        }
        set w(t) {
            this._w = t, this._onChangeCallback()
        }
        set(t, e, n, i) {
            return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
        }
        clone() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        }
        copy(t) {
            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
        }
        setFromEuler(t, e) {
            const n = t._x,
                i = t._y,
                r = t._z,
                s = t._order,
                a = Math.cos,
                o = Math.sin,
                l = a(n / 2),
                c = a(i / 2),
                h = a(r / 2),
                u = o(n / 2),
                d = o(i / 2),
                p = o(r / 2);
            switch (s) {
                case "XYZ":
                    this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "YXZ":
                    this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                    break;
                case "ZXY":
                    this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "ZYX":
                    this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p;
                    break;
                case "YZX":
                    this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p;
                    break;
                case "XZY":
                    this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
            }
            return !1 !== e && this._onChangeCallback(), this
        }
        setFromAxisAngle(t, e) {
            const n = e / 2,
                i = Math.sin(n);
            return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
        }
        setFromRotationMatrix(t) {
            const e = t.elements,
                n = e[0],
                i = e[4],
                r = e[8],
                s = e[1],
                a = e[5],
                o = e[9],
                l = e[2],
                c = e[6],
                h = e[10],
                u = n + a + h;
            if (u > 0) {
                const t = .5 / Math.sqrt(u + 1);
                this._w = .25 / t, this._x = (c - o) * t, this._y = (r - l) * t, this._z = (s - i) * t
            } else if (n > a && n > h) {
                const t = 2 * Math.sqrt(1 + n - a - h);
                this._w = (c - o) / t, this._x = .25 * t, this._y = (i + s) / t, this._z = (r + l) / t
            } else if (a > h) {
                const t = 2 * Math.sqrt(1 + a - n - h);
                this._w = (r - l) / t, this._x = (i + s) / t, this._y = .25 * t, this._z = (o + c) / t
            } else {
                const t = 2 * Math.sqrt(1 + h - n - a);
                this._w = (s - i) / t, this._x = (r + l) / t, this._y = (o + c) / t, this._z = .25 * t
            }
            return this._onChangeCallback(), this
        }
        setFromUnitVectors(t, e) {
            let n = t.dot(e) + 1;
            return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
        }
        angleTo(t) {
            return 2 * Math.acos(Math.abs(s(this.dot(t), -1, 1)))
        }
        rotateTowards(t, e) {
            const n = this.angleTo(t);
            if (0 === n) return this;
            const i = Math.min(1, e / n);
            return this.slerp(t, i), this
        }
        identity() {
            return this.set(0, 0, 0, 1)
        }
        invert() {
            return this.conjugate()
        }
        conjugate() {
            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
        }
        dot(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
        normalize() {
            let t = this.length();
            return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
        }
        multiply(t) {
            return this.multiplyQuaternions(this, t)
        }
        premultiply(t) {
            return this.multiplyQuaternions(t, this)
        }
        multiplyQuaternions(t, e) {
            const n = t._x,
                i = t._y,
                r = t._z,
                s = t._w,
                a = e._x,
                o = e._y,
                l = e._z,
                c = e._w;
            return this._x = n * c + s * a + i * l - r * o, this._y = i * c + s * o + r * a - n * l, this._z = r * c + s * l + n * o - i * a, this._w = s * c - n * a - i * o - r * l, this._onChangeCallback(), this
        }
        slerp(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            const n = this._x,
                i = this._y,
                r = this._z,
                s = this._w;
            let a = s * t._w + n * t._x + i * t._y + r * t._z;
            if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
            const o = 1 - a * a;
            if (o <= Number.EPSILON) {
                const t = 1 - e;
                return this._w = t * s + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this
            }
            const l = Math.sqrt(o),
                c = Math.atan2(l, a),
                h = Math.sin((1 - e) * c) / l,
                u = Math.sin(e * c) / l;
            return this._w = s * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this
        }
        slerpQuaternions(t, e, n) {
            return this.copy(t).slerp(e, n)
        }
        random() {
            const t = Math.random(),
                e = Math.sqrt(1 - t),
                n = Math.sqrt(t),
                i = 2 * Math.PI * Math.random(),
                r = 2 * Math.PI * Math.random();
            return this.set(e * Math.cos(i), n * Math.sin(r), n * Math.cos(r), e * Math.sin(i))
        }
        equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        }
        fromArray(t, e = 0) {
            return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
        }
        toArray(t = [], e = 0) {
            return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
        }
        fromBufferAttribute(t, e) {
            return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
        }
        toJSON() {
            return this.toArray()
        }
        _onChange(t) {
            return this._onChangeCallback = t, this
        }
        _onChangeCallback() { } *[Symbol.iterator]() {
            yield this._x, yield this._y, yield this._z, yield this._w
        }
    }
    class l {
        constructor(t = 0, e = 0, n = 0) {
            l.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n
        }
        set(t, e, n) {
            return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
        }
        setScalar(t) {
            return this.x = t, this.y = t, this.z = t, this
        }
        setX(t) {
            return this.x = t, this
        }
        setY(t) {
            return this.y = t, this
        }
        setZ(t) {
            return this.z = t, this
        }
        setComponent(t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + t)
            }
        }
        clone() {
            return new this.constructor(this.x, this.y, this.z)
        }
        copy(t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this
        }
        add(t) {
            return this.x += t.x, this.y += t.y, this.z += t.z, this
        }
        addScalar(t) {
            return this.x += t, this.y += t, this.z += t, this
        }
        addVectors(t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
        }
        addScaledVector(t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
        }
        sub(t) {
            return this.x -= t.x, this.y -= t.y, this.z -= t.z, this
        }
        subScalar(t) {
            return this.x -= t, this.y -= t, this.z -= t, this
        }
        subVectors(t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
        }
        multiply(t) {
            return this.x *= t.x, this.y *= t.y, this.z *= t.z, this
        }
        multiplyScalar(t) {
            return this.x *= t, this.y *= t, this.z *= t, this
        }
        multiplyVectors(t, e) {
            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
        }
        applyEuler(t) {
            return this.applyQuaternion(h.setFromEuler(t))
        }
        applyAxisAngle(t, e) {
            return this.applyQuaternion(h.setFromAxisAngle(t, e))
        }
        applyMatrix3(t) {
            const e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements;
            return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
        }
        applyNormalMatrix(t) {
            return this.applyMatrix3(t).normalize()
        }
        applyMatrix4(t) {
            const e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements,
                s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s, this
        }
        applyQuaternion(t) {
            const e = this.x,
                n = this.y,
                i = this.z,
                r = t.x,
                s = t.y,
                a = t.z,
                o = t.w,
                l = o * e + s * i - a * n,
                c = o * n + a * e - r * i,
                h = o * i + r * n - s * e,
                u = -r * e - s * n - a * i;
            return this.x = l * o + u * -r + c * -a - h * -s, this.y = c * o + u * -s + h * -r - l * -a, this.z = h * o + u * -a + l * -s - c * -r, this
        }
        project(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
        }
        unproject(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
        }
        transformDirection(t) {
            const e = this.x,
                n = this.y,
                i = this.z,
                r = t.elements;
            return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
        }
        divide(t) {
            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t)
        }
        min(t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
        }
        max(t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
        }
        clamp(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
        }
        clampScalar(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
        }
        clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        }
        negate() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
        }
        lerpVectors(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
        }
        cross(t) {
            return this.crossVectors(this, t)
        }
        crossVectors(t, e) {
            const n = t.x,
                i = t.y,
                r = t.z,
                s = e.x,
                a = e.y,
                o = e.z;
            return this.x = i * o - r * a, this.y = r * s - n * o, this.z = n * a - i * s, this
        }
        projectOnVector(t) {
            const e = t.lengthSq();
            if (0 === e) return this.set(0, 0, 0);
            const n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n)
        }
        projectOnPlane(t) {
            return c.copy(this).projectOnVector(t), this.sub(c)
        }
        reflect(t) {
            return this.sub(c.copy(t).multiplyScalar(2 * this.dot(t)))
        }
        angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(s(n, -1, 1))
        }
        distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t) {
            const e = this.x - t.x,
                n = this.y - t.y,
                i = this.z - t.z;
            return e * e + n * n + i * i
        }
        manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        }
        setFromSpherical(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        }
        setFromSphericalCoords(t, e, n) {
            const i = Math.sin(e) * t;
            return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
        }
        setFromCylindrical(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        }
        setFromCylindricalCoords(t, e, n) {
            return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
        }
        setFromMatrixPosition(t) {
            const e = t.elements;
            return this.x = e[12], this.y = e[13], this.z = e[14], this
        }
        setFromMatrixScale(t) {
            const e = this.setFromMatrixColumn(t, 0).length(),
                n = this.setFromMatrixColumn(t, 1).length(),
                i = this.setFromMatrixColumn(t, 2).length();
            return this.x = e, this.y = n, this.z = i, this
        }
        setFromMatrixColumn(t, e) {
            return this.fromArray(t.elements, 4 * e)
        }
        setFromMatrix3Column(t, e) {
            return this.fromArray(t.elements, 3 * e)
        }
        setFromEuler(t) {
            return this.x = t._x, this.y = t._y, this.z = t._z, this
        }
        setFromColor(t) {
            return this.x = t.r, this.y = t.g, this.z = t.b, this
        }
        equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        }
        fromArray(t, e = 0) {
            return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
        }
        toArray(t = [], e = 0) {
            return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
        }
        fromBufferAttribute(t, e) {
            return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
        }
        random() {
            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
        }
        randomDirection() {
            const t = 2 * (Math.random() - .5),
                e = Math.random() * Math.PI * 2,
                n = Math.sqrt(1 - t ** 2);
            return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this
        } *[Symbol.iterator]() {
            yield this.x, yield this.y, yield this.z
        }
    }
    const c = new l,
        h = new o;
    class u {
        constructor(t, e, n, i, r, s, a, o, l, c, h, d, p, f, m, g) {
            u.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== t && this.set(t, e, n, i, r, s, a, o, l, c, h, d, p, f, m, g)
        }
        set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, f, m) {
            const g = this.elements;
            return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = a, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        clone() {
            return (new u).fromArray(this.elements)
        }
        copy(t) {
            const e = this.elements,
                n = t.elements;
            return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
        }
        copyPosition(t) {
            const e = this.elements,
                n = t.elements;
            return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
        }
        setFromMatrix3(t) {
            const e = t.elements;
            return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
        }
        extractBasis(t, e, n) {
            return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
        }
        makeBasis(t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
        }
        extractRotation(t) {
            const e = this.elements,
                n = t.elements,
                i = 1 / d.setFromMatrixColumn(t, 0).length(),
                r = 1 / d.setFromMatrixColumn(t, 1).length(),
                s = 1 / d.setFromMatrixColumn(t, 2).length();
            return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        }
        makeRotationFromEuler(t) {
            const e = this.elements,
                n = t.x,
                i = t.y,
                r = t.z,
                s = Math.cos(n),
                a = Math.sin(n),
                o = Math.cos(i),
                l = Math.sin(i),
                c = Math.cos(r),
                h = Math.sin(r);
            if ("XYZ" === t.order) {
                const t = s * c,
                    n = s * h,
                    i = a * c,
                    r = a * h;
                e[0] = o * c, e[4] = -o * h, e[8] = l, e[1] = n + i * l, e[5] = t - r * l, e[9] = -a * o, e[2] = r - t * l, e[6] = i + n * l, e[10] = s * o
            } else if ("YXZ" === t.order) {
                const t = o * c,
                    n = o * h,
                    i = l * c,
                    r = l * h;
                e[0] = t + r * a, e[4] = i * a - n, e[8] = s * l, e[1] = s * h, e[5] = s * c, e[9] = -a, e[2] = n * a - i, e[6] = r + t * a, e[10] = s * o
            } else if ("ZXY" === t.order) {
                const t = o * c,
                    n = o * h,
                    i = l * c,
                    r = l * h;
                e[0] = t - r * a, e[4] = -s * h, e[8] = i + n * a, e[1] = n + i * a, e[5] = s * c, e[9] = r - t * a, e[2] = -s * l, e[6] = a, e[10] = s * o
            } else if ("ZYX" === t.order) {
                const t = s * c,
                    n = s * h,
                    i = a * c,
                    r = a * h;
                e[0] = o * c, e[4] = i * l - n, e[8] = t * l + r, e[1] = o * h, e[5] = r * l + t, e[9] = n * l - i, e[2] = -l, e[6] = a * o, e[10] = s * o
            } else if ("YZX" === t.order) {
                const t = s * o,
                    n = s * l,
                    i = a * o,
                    r = a * l;
                e[0] = o * c, e[4] = r - t * h, e[8] = i * h + n, e[1] = h, e[5] = s * c, e[9] = -a * c, e[2] = -l * c, e[6] = n * h + i, e[10] = t - r * h
            } else if ("XZY" === t.order) {
                const t = s * o,
                    n = s * l,
                    i = a * o,
                    r = a * l;
                e[0] = o * c, e[4] = -h, e[8] = l * c, e[1] = t * h + r, e[5] = s * c, e[9] = n * h - i, e[2] = i * h - n, e[6] = a * c, e[10] = r * h + t
            }
            return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        }
        makeRotationFromQuaternion(t) {
            return this.compose(f, t, m)
        }
        lookAt(t, e, n) {
            const i = this.elements;
            return y.subVectors(t, e), 0 === y.lengthSq() && (y.z = 1), y.normalize(), g.crossVectors(n, y), 0 === g.lengthSq() && (1 === Math.abs(n.z) ? y.x += 1e-4 : y.z += 1e-4, y.normalize(), g.crossVectors(n, y)), g.normalize(), v.crossVectors(y, g), i[0] = g.x, i[4] = v.x, i[8] = y.x, i[1] = g.y, i[5] = v.y, i[9] = y.y, i[2] = g.z, i[6] = v.z, i[10] = y.z, this
        }
        multiply(t) {
            return this.multiplyMatrices(this, t)
        }
        premultiply(t) {
            return this.multiplyMatrices(t, this)
        }
        multiplyMatrices(t, e) {
            const n = t.elements,
                i = e.elements,
                r = this.elements,
                s = n[0],
                a = n[4],
                o = n[8],
                l = n[12],
                c = n[1],
                h = n[5],
                u = n[9],
                d = n[13],
                p = n[2],
                f = n[6],
                m = n[10],
                g = n[14],
                v = n[3],
                y = n[7],
                b = n[11],
                x = n[15],
                _ = i[0],
                w = i[4],
                S = i[8],
                M = i[12],
                E = i[1],
                T = i[5],
                C = i[9],
                A = i[13],
                R = i[2],
                P = i[6],
                L = i[10],
                O = i[14],
                D = i[3],
                I = i[7],
                k = i[11],
                N = i[15];
            return r[0] = s * _ + a * E + o * R + l * D, r[4] = s * w + a * T + o * P + l * I, r[8] = s * S + a * C + o * L + l * k, r[12] = s * M + a * A + o * O + l * N, r[1] = c * _ + h * E + u * R + d * D, r[5] = c * w + h * T + u * P + d * I, r[9] = c * S + h * C + u * L + d * k, r[13] = c * M + h * A + u * O + d * N, r[2] = p * _ + f * E + m * R + g * D, r[6] = p * w + f * T + m * P + g * I, r[10] = p * S + f * C + m * L + g * k, r[14] = p * M + f * A + m * O + g * N, r[3] = v * _ + y * E + b * R + x * D, r[7] = v * w + y * T + b * P + x * I, r[11] = v * S + y * C + b * L + x * k, r[15] = v * M + y * A + b * O + x * N, this
        }
        multiplyScalar(t) {
            const e = this.elements;
            return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
        }
        determinant() {
            const t = this.elements,
                e = t[0],
                n = t[4],
                i = t[8],
                r = t[12],
                s = t[1],
                a = t[5],
                o = t[9],
                l = t[13],
                c = t[2],
                h = t[6],
                u = t[10],
                d = t[14];
            return t[3] * (+r * o * h - i * l * h - r * a * u + n * l * u + i * a * d - n * o * d) + t[7] * (+e * o * d - e * l * u + r * s * u - i * s * d + i * l * c - r * o * c) + t[11] * (+e * l * h - e * a * d - r * s * h + n * s * d + r * a * c - n * l * c) + t[15] * (-i * a * c - e * o * h + e * a * u + i * s * h - n * s * u + n * o * c)
        }
        transpose() {
            const t = this.elements;
            let e;
            return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
        }
        setPosition(t, e, n) {
            const i = this.elements;
            return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
        }
        invert() {
            const t = this.elements,
                e = t[0],
                n = t[1],
                i = t[2],
                r = t[3],
                s = t[4],
                a = t[5],
                o = t[6],
                l = t[7],
                c = t[8],
                h = t[9],
                u = t[10],
                d = t[11],
                p = t[12],
                f = t[13],
                m = t[14],
                g = t[15],
                v = h * m * l - f * u * l + f * o * d - a * m * d - h * o * g + a * u * g,
                y = p * u * l - c * m * l - p * o * d + s * m * d + c * o * g - s * u * g,
                b = c * f * l - p * h * l + p * a * d - s * f * d - c * a * g + s * h * g,
                x = p * h * o - c * f * o - p * a * u + s * f * u + c * a * m - s * h * m,
                _ = e * v + n * y + i * b + r * x;
            if (0 === _) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const w = 1 / _;
            return t[0] = v * w, t[1] = (f * u * r - h * m * r - f * i * d + n * m * d + h * i * g - n * u * g) * w, t[2] = (a * m * r - f * o * r + f * i * l - n * m * l - a * i * g + n * o * g) * w, t[3] = (h * o * r - a * u * r - h * i * l + n * u * l + a * i * d - n * o * d) * w, t[4] = y * w, t[5] = (c * m * r - p * u * r + p * i * d - e * m * d - c * i * g + e * u * g) * w, t[6] = (p * o * r - s * m * r - p * i * l + e * m * l + s * i * g - e * o * g) * w, t[7] = (s * u * r - c * o * r + c * i * l - e * u * l - s * i * d + e * o * d) * w, t[8] = b * w, t[9] = (p * h * r - c * f * r - p * n * d + e * f * d + c * n * g - e * h * g) * w, t[10] = (s * f * r - p * a * r + p * n * l - e * f * l - s * n * g + e * a * g) * w, t[11] = (c * a * r - s * h * r - c * n * l + e * h * l + s * n * d - e * a * d) * w, t[12] = x * w, t[13] = (c * f * i - p * h * i + p * n * u - e * f * u - c * n * m + e * h * m) * w, t[14] = (p * a * i - s * f * i - p * n * o + e * f * o + s * n * m - e * a * m) * w, t[15] = (s * h * i - c * a * i + c * n * o - e * h * o - s * n * u + e * a * u) * w, this
        }
        scale(t) {
            const e = this.elements,
                n = t.x,
                i = t.y,
                r = t.z;
            return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
        }
        getMaxScaleOnAxis() {
            const t = this.elements,
                e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, i))
        }
        makeTranslation(t, e, n) {
            return t.isVector3 ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1) : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
        }
        makeRotationX(t) {
            const e = Math.cos(t),
                n = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
        }
        makeRotationY(t) {
            const e = Math.cos(t),
                n = Math.sin(t);
            return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
        }
        makeRotationZ(t) {
            const e = Math.cos(t),
                n = Math.sin(t);
            return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }
        makeRotationAxis(t, e) {
            const n = Math.cos(e),
                i = Math.sin(e),
                r = 1 - n,
                s = t.x,
                a = t.y,
                o = t.z,
                l = r * s,
                c = r * a;
            return this.set(l * s + n, l * a - i * o, l * o + i * a, 0, l * a + i * o, c * a + n, c * o - i * s, 0, l * o - i * a, c * o + i * s, r * o * o + n, 0, 0, 0, 0, 1), this
        }
        makeScale(t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
        }
        makeShear(t, e, n, i, r, s) {
            return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this
        }
        compose(t, e, n) {
            const i = this.elements,
                r = e._x,
                s = e._y,
                a = e._z,
                o = e._w,
                l = r + r,
                c = s + s,
                h = a + a,
                u = r * l,
                d = r * c,
                p = r * h,
                f = s * c,
                m = s * h,
                g = a * h,
                v = o * l,
                y = o * c,
                b = o * h,
                x = n.x,
                _ = n.y,
                w = n.z;
            return i[0] = (1 - (f + g)) * x, i[1] = (d + b) * x, i[2] = (p - y) * x, i[3] = 0, i[4] = (d - b) * _, i[5] = (1 - (u + g)) * _, i[6] = (m + v) * _, i[7] = 0, i[8] = (p + y) * w, i[9] = (m - v) * w, i[10] = (1 - (u + f)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
        }
        decompose(t, e, n) {
            const i = this.elements;
            let r = d.set(i[0], i[1], i[2]).length();
            const s = d.set(i[4], i[5], i[6]).length(),
                a = d.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], p.copy(this);
            const o = 1 / r,
                l = 1 / s,
                c = 1 / a;
            return p.elements[0] *= o, p.elements[1] *= o, p.elements[2] *= o, p.elements[4] *= l, p.elements[5] *= l, p.elements[6] *= l, p.elements[8] *= c, p.elements[9] *= c, p.elements[10] *= c, e.setFromRotationMatrix(p), n.x = r, n.y = s, n.z = a, this
        }
        makePerspective(t, e, n, i, r, s, a = 2e3) {
            const o = this.elements,
                l = 2 * r / (e - t),
                c = 2 * r / (n - i),
                h = (e + t) / (e - t),
                u = (n + i) / (n - i);
            let d, p;
            if (2e3 === a) d = -(s + r) / (s - r), p = -2 * s * r / (s - r);
            else {
                if (2001 !== a) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
                d = -s / (s - r), p = -s * r / (s - r)
            }
            return o[0] = l, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = c, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = d, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
        }
        makeOrthographic(t, e, n, i, r, s, a = 2e3) {
            const o = this.elements,
                l = 1 / (e - t),
                c = 1 / (n - i),
                h = 1 / (s - r),
                u = (e + t) * l,
                d = (n + i) * c;
            let p, f;
            if (2e3 === a) p = (s + r) * h, f = -2 * h;
            else {
                if (2001 !== a) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
                p = r * h, f = -1 * h
            }
            return o[0] = 2 * l, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -d, o[2] = 0, o[6] = 0, o[10] = f, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
        }
        equals(t) {
            const e = this.elements,
                n = t.elements;
            for (let t = 0; t < 16; t++)
                if (e[t] !== n[t]) return !1;
            return !0
        }
        fromArray(t, e = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
            return this
        }
        toArray(t = [], e = 0) {
            const n = this.elements;
            return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
        }
    }
    const d = new l,
        p = new u,
        f = new l(0, 0, 0),
        m = new l(1, 1, 1),
        g = new l,
        v = new l,
        y = new l;
    class b {
        constructor() {
            this.type = "Curve", this.arcLengthDivisions = 200
        }
        getPoint() {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        }
        getPointAt(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getPoint(n, e)
        }
        getPoints(t = 5) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return e
        }
        getSpacedPoints(t = 5) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
            return e
        }
        getLength() {
            const t = this.getLengths();
            return t[t.length - 1]
        }
        getLengths(t = this.arcLengthDivisions) {
            if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            const e = [];
            let n, i = this.getPoint(0),
                r = 0;
            e.push(0);
            for (let s = 1; s <= t; s++) n = this.getPoint(s / t), r += n.distanceTo(i), e.push(r), i = n;
            return this.cacheArcLengths = e, e
        }
        updateArcLengths() {
            this.needsUpdate = !0, this.getLengths()
        }
        getUtoTmapping(t, e) {
            const n = this.getLengths();
            let i = 0;
            const r = n.length;
            let s;
            s = e || t * n[r - 1];
            let a, o = 0,
                l = r - 1;
            for (; o <= l;)
                if (i = Math.floor(o + (l - o) / 2), a = n[i] - s, a < 0) o = i + 1;
                else {
                    if (!(a > 0)) {
                        l = i;
                        break
                    }
                    l = i - 1
                } if (i = l, n[i] === s) return i / (r - 1);
            const c = n[i];
            return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
        }
        getTangent(t, e) {
            let n = t - 1e-4,
                i = t + 1e-4;
            n < 0 && (n = 0), i > 1 && (i = 1);
            const r = this.getPoint(n),
                s = this.getPoint(i),
                o = e || (r.isVector2 ? new a : new l);
            return o.copy(s).sub(r).normalize(), o
        }
        getTangentAt(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getTangent(n, e)
        }
        computeFrenetFrames(t, e) {
            const n = new l,
                i = [],
                r = [],
                a = [],
                o = new l,
                c = new u;
            for (let e = 0; e <= t; e++) {
                const n = e / t;
                i[e] = this.getTangentAt(n, new l)
            }
            r[0] = new l, a[0] = new l;
            let h = Number.MAX_VALUE;
            const d = Math.abs(i[0].x),
                p = Math.abs(i[0].y),
                f = Math.abs(i[0].z);
            d <= h && (h = d, n.set(1, 0, 0)), p <= h && (h = p, n.set(0, 1, 0)), f <= h && n.set(0, 0, 1), o.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], o), a[0].crossVectors(i[0], r[0]);
            for (let e = 1; e <= t; e++) {
                if (r[e] = r[e - 1].clone(), a[e] = a[e - 1].clone(), o.crossVectors(i[e - 1], i[e]), o.length() > Number.EPSILON) {
                    o.normalize();
                    const t = Math.acos(s(i[e - 1].dot(i[e]), -1, 1));
                    r[e].applyMatrix4(c.makeRotationAxis(o, t))
                }
                a[e].crossVectors(i[e], r[e])
            }
            if (!0 === e) {
                let e = Math.acos(s(r[0].dot(r[t]), -1, 1));
                e /= t, i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e);
                for (let n = 1; n <= t; n++) r[n].applyMatrix4(c.makeRotationAxis(i[n], e * n)), a[n].crossVectors(i[n], r[n])
            }
            return {
                tangents: i,
                normals: r,
                binormals: a
            }
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions, this
        }
        toJSON() {
            const t = {
                metadata: {
                    version: 4.6,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
        }
        fromJSON(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions, this
        }
    }

    function x(t, e, n, i, r) {
        const s = .5 * (i - e),
            a = .5 * (r - n),
            o = t * t;
        return (2 * n - 2 * i + s + a) * (t * o) + (-3 * n + 3 * i - 2 * s - a) * o + s * t + n
    }

    function _(t, e, n, i) {
        return function (t, e) {
            const n = 1 - t;
            return n * n * e
        }(t, e) + function (t, e) {
            return 2 * (1 - t) * t * e
        }(t, n) + function (t, e) {
            return t * t * e
        }(t, i)
    }

    function w(t, e, n, i, r) {
        return function (t, e) {
            const n = 1 - t;
            return n * n * n * e
        }(t, e) + function (t, e) {
            const n = 1 - t;
            return 3 * n * n * t * e
        }(t, n) + function (t, e) {
            return 3 * (1 - t) * t * t * e
        }(t, i) + function (t, e) {
            return t * t * t * e
        }(t, r)
    }
    class S extends b {
        constructor(t = new l, e = new l, n = new l) {
            super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
        }
        getPoint(t, e = new l) {
            const n = e,
                i = this.v0,
                r = this.v1,
                s = this.v2;
            return n.set(_(t, i.x, r.x, s.x), _(t, i.y, r.y, s.y), _(t, i.z, r.z, s.z)), n
        }
        copy(t) {
            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }
        fromJSON(t) {
            return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }
    }
    class M extends b {
        constructor(t = 0, e = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, a = !1, o = 0) {
            super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = a, this.aRotation = o
        }
        getPoint(t, e) {
            const n = e || new a,
                i = 2 * Math.PI;
            let r = this.aEndAngle - this.aStartAngle;
            const s = Math.abs(r) < Number.EPSILON;
            for (; r < 0;) r += i;
            for (; r > i;) r -= i;
            r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
            const o = this.aStartAngle + t * r;
            let l = this.aX + this.xRadius * Math.cos(o),
                c = this.aY + this.yRadius * Math.sin(o);
            if (0 !== this.aRotation) {
                const t = Math.cos(this.aRotation),
                    e = Math.sin(this.aRotation),
                    n = l - this.aX,
                    i = c - this.aY;
                l = n * t - i * e + this.aX, c = n * e + i * t + this.aY
            }
            return n.set(l, c)
        }
        copy(t) {
            return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }
        toJSON() {
            const t = super.toJSON();
            return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
        }
        fromJSON(t) {
            return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
        }
    }
    class E extends M {
        constructor(t, e, n, i, r, s) {
            super(t, e, n, n, i, r, s), this.isArcCurve = !0, this.type = "ArcCurve"
        }
    }

    function T() {
        let t = 0,
            e = 0,
            n = 0,
            i = 0;

        function r(r, s, a, o) {
            t = r, e = a, n = -3 * r + 3 * s - 2 * a - o, i = 2 * r - 2 * s + a + o
        }
        return {
            initCatmullRom: function (t, e, n, i, s) {
                r(e, n, s * (n - t), s * (i - e))
            },
            initNonuniformCatmullRom: function (t, e, n, i, s, a, o) {
                let l = (e - t) / s - (n - t) / (s + a) + (n - e) / a,
                    c = (n - e) / a - (i - e) / (a + o) + (i - n) / o;
                l *= a, c *= a, r(e, n, l, c)
            },
            calc: function (r) {
                const s = r * r;
                return t + e * r + n * s + i * (s * r)
            }
        }
    }
    const C = new l,
        A = new T,
        R = new T,
        P = new T;
    class L extends b {
        constructor(t = [], e = !1, n = "centripetal", i = .5) {
            super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i
        }
        getPoint(t, e = new l) {
            const n = e,
                i = this.points,
                r = i.length,
                s = (r - (this.closed ? 0 : 1)) * t;
            let a, o, c = Math.floor(s),
                h = s - c;
            this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / r) + 1) * r : 0 === h && c === r - 1 && (c = r - 2, h = 1), this.closed || c > 0 ? a = i[(c - 1) % r] : (C.subVectors(i[0], i[1]).add(i[0]), a = C);
            const u = i[c % r],
                d = i[(c + 1) % r];
            if (this.closed || c + 2 < r ? o = i[(c + 2) % r] : (C.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), o = C), "centripetal" === this.curveType || "chordal" === this.curveType) {
                const t = "chordal" === this.curveType ? .5 : .25;
                let e = Math.pow(a.distanceToSquared(u), t),
                    n = Math.pow(u.distanceToSquared(d), t),
                    i = Math.pow(d.distanceToSquared(o), t);
                n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), A.initNonuniformCatmullRom(a.x, u.x, d.x, o.x, e, n, i), R.initNonuniformCatmullRom(a.y, u.y, d.y, o.y, e, n, i), P.initNonuniformCatmullRom(a.z, u.z, d.z, o.z, e, n, i)
            } else "catmullrom" === this.curveType && (A.initCatmullRom(a.x, u.x, d.x, o.x, this.tension), R.initCatmullRom(a.y, u.y, d.y, o.y, this.tension), P.initCatmullRom(a.z, u.z, d.z, o.z, this.tension));
            return n.set(A.calc(h), R.calc(h), P.calc(h)), n
        }
        copy(t) {
            super.copy(t), this.points = [];
            for (let e = 0, n = t.points.length; e < n; e++) {
                const n = t.points[e];
                this.points.push(n.clone())
            }
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }
        toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
                const n = this.points[e];
                t.points.push(n.toArray())
            }
            return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
        }
        fromJSON(t) {
            super.fromJSON(t), this.points = [];
            for (let e = 0, n = t.points.length; e < n; e++) {
                const n = t.points[e];
                this.points.push((new l).fromArray(n))
            }
            return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
        }
    }
    class O extends b {
        constructor(t = new a, e = new a, n = new a, i = new a) {
            super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
        }
        getPoint(t, e = new a) {
            const n = e,
                i = this.v0,
                r = this.v1,
                s = this.v2,
                o = this.v3;
            return n.set(w(t, i.x, r.x, s.x, o.x), w(t, i.y, r.y, s.y, o.y)), n
        }
        copy(t) {
            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
        }
        fromJSON(t) {
            return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
        }
    }
    class D extends b {
        constructor(t = new l, e = new l, n = new l, i = new l) {
            super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
        }
        getPoint(t, e = new l) {
            const n = e,
                i = this.v0,
                r = this.v1,
                s = this.v2,
                a = this.v3;
            return n.set(w(t, i.x, r.x, s.x, a.x), w(t, i.y, r.y, s.y, a.y), w(t, i.z, r.z, s.z, a.z)), n
        }
        copy(t) {
            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
        }
        fromJSON(t) {
            return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
        }
    }
    class I extends b {
        constructor(t = new a, e = new a) {
            super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = t, this.v2 = e
        }
        getPoint(t, e = new a) {
            const n = e;
            return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
        }
        getPointAt(t, e) {
            return this.getPoint(t, e)
        }
        getTangent(t, e = new a) {
            return e.subVectors(this.v2, this.v1).normalize()
        }
        getTangentAt(t, e) {
            return this.getTangent(t, e)
        }
        copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }
        fromJSON(t) {
            return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }
    }
    class k extends b {
        constructor(t = new l, e = new l) {
            super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = t, this.v2 = e
        }
        getPoint(t, e = new l) {
            const n = e;
            return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
        }
        getPointAt(t, e) {
            return this.getPoint(t, e)
        }
        getTangent(t, e = new l) {
            return e.subVectors(this.v2, this.v1).normalize()
        }
        getTangentAt(t, e) {
            return this.getTangent(t, e)
        }
        copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }
        fromJSON(t) {
            return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }
    }
    class N extends b {
        constructor(t = new a, e = new a, n = new a) {
            super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
        }
        getPoint(t, e = new a) {
            const n = e,
                i = this.v0,
                r = this.v1,
                s = this.v2;
            return n.set(_(t, i.x, r.x, s.x), _(t, i.y, r.y, s.y)), n
        }
        copy(t) {
            return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
        }
        toJSON() {
            const t = super.toJSON();
            return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
        }
        fromJSON(t) {
            return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
        }
    }
    class U extends b {
        constructor(t = []) {
            super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = t
        }
        getPoint(t, e = new a) {
            const n = e,
                i = this.points,
                r = (i.length - 1) * t,
                s = Math.floor(r),
                o = r - s,
                l = i[0 === s ? s : s - 1],
                c = i[s],
                h = i[s > i.length - 2 ? i.length - 1 : s + 1],
                u = i[s > i.length - 3 ? i.length - 1 : s + 2];
            return n.set(x(o, l.x, c.x, h.x, u.x), x(o, l.y, c.y, h.y, u.y)), n
        }
        copy(t) {
            super.copy(t), this.points = [];
            for (let e = 0, n = t.points.length; e < n; e++) {
                const n = t.points[e];
                this.points.push(n.clone())
            }
            return this
        }
        toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
                const n = this.points[e];
                t.points.push(n.toArray())
            }
            return t
        }
        fromJSON(t) {
            super.fromJSON(t), this.points = [];
            for (let e = 0, n = t.points.length; e < n; e++) {
                const n = t.points[e];
                this.points.push((new a).fromArray(n))
            }
            return this
        }
    }
    class z extends r.i {
        constructor() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new S(new r.ac(-1, -1, 0), new r.ac(-1, 1, 0), new r.ac(1, 1, 0)),
                e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 64,
                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 8,
                s = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
            super(), this.type = "TubeGeometry", this.parameters = {
                path: t,
                tubularSegments: e,
                radius: n,
                radialSegments: i,
                closed: s
            };
            const a = t.computeFrenetFrames(e, s);
            this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
            const o = new r.ac,
                l = new r.ac,
                c = new r.Zb;
            let h = new r.ac;
            const u = [],
                d = [],
                p = [],
                f = [];

            function m(r) {
                h = t.getPointAt(r / e, h);
                const s = (t.getRadiusAt ? t.getRadiusAt(r / e) : 1) * n,
                    c = a.normals[r],
                    p = a.binormals[r];
                for (let t = 0; t <= i; t++) {
                    const e = t / i * Math.PI * 2,
                        n = Math.sin(e),
                        r = -Math.cos(e);
                    l.x = r * c.x + n * p.x, l.y = r * c.y + n * p.y, l.z = r * c.z + n * p.z, l.normalize(), d.push(l.x, l.y, l.z), o.x = h.x + s * l.x, o.y = h.y + s * l.y, o.z = h.z + s * l.z, u.push(o.x, o.y, o.z)
                }
            } ! function () {
                for (let t = 0; t < e; t++) m(t);
                m(!1 === s ? e : 0),
                    function () {
                        for (let t = 0; t <= e; t++)
                            for (let n = 0; n <= i; n++) c.x = t / e, c.y = n / i, p.push(c.x, c.y)
                    }(),
                    function () {
                        for (let t = 1; t <= e; t++)
                            for (let e = 1; e <= i; e++) {
                                const n = (i + 1) * (t - 1) + (e - 1),
                                    r = (i + 1) * t + (e - 1),
                                    s = (i + 1) * t + e,
                                    a = (i + 1) * (t - 1) + e;
                                f.push(n, r, a), f.push(r, s, a)
                            }
                    }()
            }(), this.setIndex(f), this.setAttribute("position", new r.B(u, 3)), this.setAttribute("normal", new r.B(d, 3)), this.setAttribute("uv", new r.B(p, 2))
        }
        copy(t) {
            return super.copy(t), this.parameters = Object.assign({}, t.parameters), this
        }
        toJSON() {
            const t = super.toJSON();
            return t.path = this.parameters.path.toJSON(), t
        }
        static fromJSON(t) {
            return new z((new i[t.path.type]).fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed)
        }
    }
    var F = n(43),
        $ = n(237),
        B = n.n($),
        H = n(53),
        j = n.n(H),
        V = n(238),
        G = n.n(V),
        W = n(88),
        q = n.n(W);
    class X {
        constructor(t) {
            t = this.options = Object.assign({
                radius: 10,
                lineWidth: 1,
                colorNormal: 16777215,
                colorLight: 16777215,
                colorDark: 16777215,
                opacity: 1,
                blurCoeficient: .1,
                blurPower: 6,
                scale: [1, 1, 1],
                position: null,
                rotation: null,
                loops: 1,
                direction: 1,
                offset: 0,
                length: 1,
                varyingLoops: 0,
                varyingLoopOffset: .1,
                varyingMin: .25,
                varyingMax: 1,
                particles: 0,
                particleSize: 50,
                speed: null,
                progress: null,
                camera: null,
                gui: null,
                tubularSegments: 200,
                radialSegments: 6,
                debug: !1
            }, t), this.group = new r.H, this.lineCurve = null, this.geometry = null, this.mesh = null, this.lineMaterial = null, this.particleMaterial = null, this.gui = t.gui, this.createGeometryBinded = this.createGeometry.bind(this), this.init()
        }
        init() {
            this.createLine(), this.createParticles(), this.initGUI()
        }
        createLine() {
            (this.mesh = new r.eb(this.createGeometry(), this.createMaterial())).layers.enable(1), this.setPosition(this.options.position), this.setRotation(this.options.rotation), this.group.add(this.mesh)
        }
        createGeometry() {
            const t = this.options.lineWidth,
                e = this.options.radius - t,
                n = this.options.scale,
                i = this.lineCurve = new this.options.curve(Object.assign({}, this.options, {
                    scale: [e * n[0], e * n[1], e * n[2]]
                })),
                r = new z(i, this.options.tubularSegments, t, this.options.radialSegments, !1);
            return this.geometry && (this.mesh.geometry = r), this.geometry = r
        }
        createMaterial() {
            return this.options.debug ? this.lineMaterial = new r.fb({
                color: new r.o(255, 0, 0),
                wireframe: !0
            }) : this.lineMaterial = new r.Nb({
                fragmentShader: j.a,
                vertexShader: B.a,
                transparent: !0,
                side: r.e,
                uniforms: {
                    uTime: new r.Tb(0),
                    uColorNormal: new r.Tb(this.options.colorNormal),
                    uColorLight: new r.Tb(this.options.colorLight),
                    uColorDark: new r.Tb(this.options.colorDark),
                    uAlpha: new r.Tb(this.options.opacity),
                    uCameraPosition: new r.Tb(this.options.camera.position),
                    uCoeficient: new r.Tb(this.options.blurCoeficient),
                    uPower: new r.Tb(this.options.blurPower),
                    uProgress: this.options.progress,
                    uSpeed: this.options.speed
                }
            }), this.lineMaterial
        }
        getParticlePosition(t) {
            const e = this.lineCurve.getPoint(t / this.options.particles);
            return [e.x + Object(F.a)(-.5, .5), e.y + Object(F.a)(-.5, .5), e.z + Object(F.a)(-.5, .5)]
        }
        createParticles() {
            if (this.options.particles) {
                const t = [],
                    e = this.options.particles,
                    n = (new r.Sb).load("assets/images/3d/point.png");
                n.colorSpace = r.Jb;
                for (let n = 0; n < e; n++) {
                    const e = this.getParticlePosition(n);
                    t.push(e[0], e[1], e[2])
                }
                const i = new r.i;
                i.setAttribute("position", new r.B(t, 3));
                const s = r.Mb.points,
                    a = r.Vb.clone(s.uniforms);
                a.scale.value = 1, a.size.value = this.options.particleSize, a.map.value = n, a.diffuse.value = new r.o(this.options.colorNormal), a.opacity.value = 1, a.uCount = new r.Tb(e), a.uTime = new r.Tb(0), a.uProgress = this.options.progress, a.uSpeed = this.options.speed;
                const o = this.particleMaterial = new r.Nb({
                    uniforms: a,
                    defines: {
                        USE_MAP: "",
                        USE_SIZEATTENUATION: !0
                    },
                    vertexShader: G.a,
                    fragmentShader: q.a,
                    blending: r.b,
                    transparent: !0,
                    depthTest: !1
                }),
                    l = new r.wb(i, o);
                this.group.add(l), l.layers.enable(1)
            }
        }
        initGUI() {
            if (this.gui) {
                const t = this.gui.addFolder("Line");
                t.close(), t.add(this.group, "visible"), t.add(this.group.position, "y", -30, 10);
                const e = t.addFolder("Geometry");
                e.add(this.options, "lineWidth", 0, 10).onChange(this.createGeometryBinded), e.add(this.options, "radius", 0, 100).onChange(this.createGeometryBinded), e.add(this.options, "loops", 0, 10).onChange(this.createGeometryBinded), e.add(this.options, "offset", 0, 2).onChange(this.createGeometryBinded), e.add(this.options, "length", 0, 1).onChange(this.createGeometryBinded), e.add(this.options, "varyingLoops", 0, 10).onChange(this.createGeometryBinded), e.add(this.options, "varyingLoopOffset", 0, 1).onChange(this.createGeometryBinded), e.add(this.options, "varyingMin", 0, 2).onChange(this.createGeometryBinded), e.add(this.options, "varyingMax", 0, 2).onChange(this.createGeometryBinded), e.add(this.options, "edgeRadius", 0, .5).onChange(this.createGeometryBinded);
                const n = t.addFolder("Shader");
                this.options.debug || (n.addUniform(this.lineMaterial, "uColorNormal").name("Color normal"), n.addUniform(this.lineMaterial, "uColorLight").name("Color light"), n.addUniform(this.lineMaterial, "uColorDark").name("Color dark"), n.addUniform(this.lineMaterial, "uCoeficient", -1, 1), n.addUniform(this.lineMaterial, "uPower", 0, 30))
            }
        }
        get position() {
            return this.group.position
        }
        get rotation() {
            return this.group.rotation
        }
        setParticleSize(t) {
            this.particleMaterial && (this.particleMaterial.uniforms.size.value = t)
        }
        setPosition(t) {
            Array.isArray(t) ? this.group.position.set(t[0], t[1], t[2]) : t instanceof r.ac && this.group.position.set(t.x, t.y, t.z)
        }
        setRotation(t) {
            Array.isArray(t) ? this.group.rotation.set(t[0], t[1], t[2]) : t instanceof r.ac && this.group.rotation.set(t.x, t.y, t.z)
        }
        update(t) {
            this.options.debug || (this.lineMaterial.uniforms.uTime.value = t), this.particleMaterial && (this.particleMaterial.uniforms.uTime.value = t)
        }
        getMesh() {
            return this.group
        }
    }
}, function (t, e, n) {
    "use strict";
    var i = n(5),
        r = n.n(i),
        s = n(47),
        a = n.n(s);
    e.a = new class {
        constructor() {
            this.instances = [], this.states = {}, this.load()
        }
        add(t) {
            -1 === this.instances.indexOf(t) && (this.instances.push(t), this.updateInstance(t))
        }
        remove(t) {
            const e = this.instances.indexOf(t); - 1 !== e && this.instances.splice(e, 1)
        }
        set(t, e) {
            this.states[t] = e, this.save(), this.update()
        }
        getAll() {
            return a()(this.states, (t, e, n) => (e && t.push(n), t), [])
        }
        getCount() {
            let t = 0;
            const e = this.states;
            for (let n in e) e[n] && t++;
            return t
        }
        updateInstance(t) {
            const e = t.id,
                n = t.state;
            if (void 0 !== e && void 0 !== n) {
                const i = this.states[e] || !1;
                n !== i && t.update(e, i)
            } else t.update(this.states)
        }
        update() {
            r()(this.instances, t => {
                t && this.updateInstance(t)
            })
        }
        save() {
            localStorage.setItem("favourites", JSON.stringify(this.states))
        }
        load() {
            try {
                this.states = JSON.parse(localStorage.getItem("favourites")) || {}, this.update()
            } catch (t) { }
        }
    }
}, function (t, e, n) {
    var i = n(169),
        r = n(58),
        s = n(127),
        a = n(66),
        o = n(119),
        l = n(57),
        c = Object.prototype.hasOwnProperty,
        h = s((function (t, e) {
            if (o(e) || a(e)) r(e, l(e), t);
            else
                for (var n in e) c.call(e, n) && i(t, n, e[n])
        }));
    t.exports = h
}, function (t, e, n) {
    var i = n(206),
        r = n(338),
        s = n(56),
        a = n(26);
    t.exports = function (t, e) {
        return (a(t) ? i : r)(t, s(e, 3))
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return p
    }));
    var i = n(1),
        r = n(3),
        s = n.n(r),
        a = n(5),
        o = n.n(a),
        l = n(140),
        c = n.n(l),
        h = (n(30), n(6)),
        u = n(9),
        d = n(10);
    class p {
        static get Defaults() {
            return {
                enter: null,
                leave: null,
                destroyOnEnter: !1,
                destroyOnLeave: !1,
                threshold: 0,
                distance: 0,
                debug: !1
            }
        }
        constructor(t, e) {
            const n = this.options = i.a.extend({}, this.constructor.Defaults, e);
            this.$container = t, this.isIntersecting = null, this.ns = Object(u.a)(), this.enter = "function" == typeof n.enter ? [n.enter] : [], this.leave = "function" == typeof n.leave ? [n.leave] : [], this.$scrollParent = null, this.constraints = {}, t.on("destroyed." + this.ns, this.destroy.bind(this)), this.createObserver(), h.a.isIOS() && this.createFallbackObserver()
        }
        setOptions(t) {
            t && "function" == typeof t.enter && (this.enter.push(t.enter), this.isIntersecting && t.enter(this.$container), this.createObserver()), t && "function" == typeof t.leave && this.leave.push(t.leave)
        }
        createObserver() {
            if (!this.observer) {
                const t = this.$container,
                    e = this.options;
                this.observer = new IntersectionObserver(this.handleIntersection.bind(this), {
                    rootMargin: "number" == typeof e.distance ? e.distance + "px 0px" : e.distance,
                    threshold: e.threshold
                }), this.observer.observe(t.get(0))
            }
        }
        createFallbackObserver() {
            const t = this.$container.closest(".modal").length,
                e = this.$container.closest(".modal__scroller").length;
            (!t || e) && (this.$scrollParent = this.$container.scrollParent(), this.handleFallbackResize = this.handleFallbackResize.bind(this), this.handleFallbackScroll = this.handleFallbackScroll.bind(this), d.a.add(d.a.QUEUE_MEASURE, this.handleFallbackResize), this.$scrollParent.on("scroll." + this.ns, this.handleFallbackScroll))
        }
        destroy() {
            if (this.observer) {
                const t = this.observer;
                this.observer = null, this.isIntersecting = null, this.$container.data("inview") === this && this.$container.removeData("inview"), t.disconnect(), this.$scrollParent && (this.$scrollParent.off("." + this.ns), d.a.remove(d.a.QUEUE_MEASURE, this.handleFallbackResize))
            }
        }
        handleIntersection(t) {
            let e = c()(t, {
                isIntersecting: !0
            });
            e || !h.a.isEdge() && !h.a.isIE() || o()(t, t => {
                const n = t.boundingClientRect,
                    i = t.rootBounds;
                n.width && n.height && (n.top > 0 && n.top < i.height || n.top + n.height > 0 && n.top + n.height < i.height || n.top < 0 && n.top + n.height > i.height) && (n.left > 0 && n.left < i.width || n.left + n.width > 0 && n.left + n.width < i.width || n.left < 0 && n.left + n.width > i.width) && (e = !0)
            }), this.updateIntersecting(e)
        }
        handleFallbackResize() {
            const t = this.$container.pageOffset(),
                e = "number" == typeof this.options.distance ? this.options.distance : 0;
            this.constraints = {
                from: t.top - t.scrollViewportSize - e,
                to: t.top + t.height + e
            }, this.handleFallbackScroll()
        }
        handleFallbackScroll() {
            const t = this.$scrollParent.scrollTop(),
                e = t >= this.constraints.from && t < this.constraints.to;
            this.updateIntersecting(e)
        }
        updateIntersecting(t) {
            this.isIntersecting !== t && (this.isIntersecting = t, t && this.options.enter ? o()(this.enter, t => t(this.$container)) : !t && this.options.leave && o()(this.leave, t => t(this.$container)), (t && this.options.destroyOnEnter || !t && this.options.destroyOnLeave) && this.destroy())
        }
    }
    i.a.fn.inview = s()(p, {
        namespace: "inview"
    })
}, function (t, e, n) {
    "use strict";
    n.r(e), n.d(e, "default", (function () {
        return u
    }));
    var i = n(1),
        r = n(11),
        s = n.n(r),
        a = n(60),
        o = n.n(a),
        l = n(3),
        c = n.n(l),
        h = (n(52), n(131), n(30), n(9));
    n(59);
    class u {
        static get Defaults() {
            return {
                filtersSelector: ".js-ajax-filters",
                listSelector: ".js-ajax-list",
                counterSelector: ".js-ajax-list-counter",
                emptySelector: ".js-ajax-empty",
                emptyMessageSelector: ".js-ajax-empty-message",
                moreSelector: ".js-load-more",
                paginationSelector: ".js-load-more-pagination",
                templateSelector: 'script[type="text/template"]',
                endpoint: null,
                endpointMethod: "GET",
                endpointFormat: "json",
                removeSiblings: !1,
                reloadOnFilterChange: !1,
                allowNativeSubmit: !1,
                scrollToList: !1,
                scrollThreshold: .25,
                renderStats: !1,
                limitOverride: 0
            }
        }
        constructor(t, e) {
            const n = this.options = i.a.extend({}, this.constructor.Defaults, e),
                r = this.$container = Object(i.a)(t),
                a = this.ns = Object(h.a)(),
                o = this.$list = r.findElement(n.listSelector) || r,
                l = this.$filters = r.findElement(n.filtersSelector) || r,
                c = this.$more = r.findElement(n.moreSelector) || Object(i.a)(),
                u = this.$moreButton = c.find('a, button, [role="button"]').addBack('a, button, [role="button"]'),
                d = this.$pagination = r.findElement(n.paginationSelector) || Object(i.a)();
            if (this.$counter = r.findElement(n.counterSelector) || Object(i.a)(), this.$empty = r.findElement(n.emptySelector) || Object(i.a)(), this.$template = o.findElement(n.templateSelector), this.filterCache, !this.$template) throw console.warn("Template not found for ", this.$container.get(0)), new Error("Template not found. AjaxList requires a template for client-side rendering " + this.options.templateSelector);
            this.$template.template({
                selector: n.templateSelector,
                removeSiblings: n.removeSiblings
            }), this.$counter.length && this.$counter.template({
                removeSiblings: !0
            }), this.loading = !1, this.total = void 0, this.offset = this.getItemCountFromDOM(), d.length && (d.addClass("is-hidden"), c.removeClass("is-hidden")), u.on("click." + a, this.load.bind(this)), r.on("destroyed", this.destroy.bind(this)), this.reloadDebounced = s()(this.reload.bind(this), 16), n.reloadOnFilterChange ? l.on("change." + a, "input[name], textarea[name], select[name]", this.reloadDebounced).on("input." + a, 'input[name][type="search"]', this.reloadDebounced) : l.on("submit." + a, this.reloadDebounced).on("reset." + a, this.reloadDebounced), n.allowNativeSubmit || l.on("submit." + a, t => t.preventDefault())
        }
        destroy() {
            this.xhr && (this.xhr.abort(), this.xhr = null, this.loading = !1, this.$filters.off("." + this.ns), this.$moreButton.off("." + this.ns))
        }
        load() {
            if (this.loading || this.total && this.total <= this.offset || !this.isFiltersValid()) return;
            this.loading = !0;
            const t = this.$moreButton,
                e = this.$empty,
                n = this.options,
                r = this.getFilterValues();
            t.addClass("is-loading"), e.addClass("is-loading"), this.xhr = i.a.ajax({
                url: n.endpoint,
                method: n.endpointMethod,
                data: r,
                dataType: n.endpointFormat
            }).done(this.handleLoadResponse.bind(this, r)).always(this.handleLoadComplete.bind(this))
        }
        handleLoadComplete() {
            const t = this.$moreButton,
                e = this.$empty;
            t.removeClass("is-loading"), e.removeClass("is-loading"), this.loading = !1, this.xhr = null
        }
        handleLoadResponse(t, e) {
            let n, r = this.$more,
                s = this.$list,
                a = this.offset,
                o = e;
            if (this.options.renderStats) this.renderStats(o);
            else {
                if ("total" in e && (n = this.total = e.total), "data" in e && e.data) {
                    let r = a ? "append" : "replace";
                    i.a.fn.template.vars.request = t, i.a.fn.template.vars.offset = a, this.$template.template(r, e.data), i.a.fn.template.vars.offset = null, i.a.fn.template.vars.request = null;
                    let s = 0;
                    s = this.options.limitOverride ? this.options.limitOverride : i.a.isArray(e.data) ? e.data.length : e.data ? 1 : 0, a = this.offset = a + s, !s && n && n > a ? a = this.offset = n : void 0 === n && s && (n = s)
                }
                n ? (this.hideEmptyMessage(), this.$counter.template("replace", {
                    total: n,
                    offset: this.offset
                })) : this.showEmptyMessage(e.message), n && n > a ? r.removeClass("is-hidden") : r.addClass("is-hidden"), s.trigger("loaded.ajaxlist").trigger("appear").trigger("resize"), this.scrollToList()
            }
        }
        getItemCountFromDOM() {
            return this.$list.eq(0).children().not("script, .js-ajax-list-ignore").length
        }
        scrollToList() {
            if (this.options.scrollToList) {
                const t = this.$list;
                i.a.fn.scroller && Object(i.a)("body").scroller("update"), t.each((t, e) => {
                    const n = Object(i.a)(e);
                    if (e.offsetParent) {
                        const t = window.innerHeight,
                            e = t * this.options.scrollThreshold,
                            r = n.get(0).getBoundingClientRect();
                        if (r.height)
                            if (r.top > t - e) {
                                const r = n.pageOffset(),
                                    s = Math.floor(r.top - t + e);
                                Object(i.a)(window).scrollTo(s)
                            } else if (r.top + r.height < e) {
                                const t = Math.floor(n.pageOffset().top);
                                Object(i.a)(window).scrollTo(t)
                            }
                    }
                })
            }
        }
        showEmptyMessage(t) {
            const e = this.$empty,
                n = this.$counter,
                i = this.$list,
                r = this.$more;
            if (e.removeClass("is-hidden"), n.addClass("is-hidden"), r.addClass("is-hidden"), i.addClass("is-hidden"), t && "string" == typeof t) {
                e.find(this.options.emptyMessageSelector).text(t)
            }
        }
        hideEmptyMessage() {
            const t = this.$empty,
                e = this.$counter,
                n = this.$list;
            t.addClass("is-hidden"), e.removeClass("is-hidden"), n.removeClass("is-hidden")
        }
        getFilterValues() {
            let t = this.$filters.serializeObject();
            return t.locale = Object(i.a)("html").attr("lang"), t.offset = this.offset, t
        }
        isFiltersValid() {
            const t = this.$filters.find("input, select, textarea").addBack("input, select, textarea").filter("[name][required]").not(":disabled");
            for (let e = 0; e < t.length; e++) {
                if (!t.eq(e).val()) return !1
            }
            return !0
        }
        reload() {
            const t = this.getFilterValues();
            delete t.offset, delete t.locale, o()(t, this.filterCache) || (this.loading && this.xhr && (this.xhr.abort(), this.xhr = null, this.loading = !1), this.offset = 0, this.load(), this.filterCache = t)
        }
        handleEndpointChange(t) {
            this.offset = 0, this.options.endpoint = t, this.load()
        }
    }
    i.a.fn.ajaxlist = c()(u)
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return F
    }));
    var i = n(1),
        r = n(0),
        s = n(145),
        a = function () {
            var t = 0,
                e = document.createElement("div");

            function n(t) {
                return e.appendChild(t.dom), t
            }

            function i(n) {
                for (var i = 0; i < e.children.length; i++) e.children[i].style.display = i === n ? "block" : "none";
                t = n
            }
            e.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", e.addEventListener("click", (function (n) {
                n.preventDefault(), i(++t % e.children.length)
            }), !1);
            var r = (performance || Date).now(),
                s = r,
                o = 0,
                l = n(new a.Panel("FPS", "#0ff", "#002")),
                c = n(new a.Panel("MS", "#0f0", "#020"));
            if (self.performance && self.performance.memory) var h = n(new a.Panel("MB", "#f08", "#201"));
            return i(0), {
                REVISION: 16,
                dom: e,
                addPanel: n,
                showPanel: i,
                begin: function () {
                    r = (performance || Date).now()
                },
                end: function () {
                    o++;
                    var t = (performance || Date).now();
                    if (c.update(t - r, 200), t >= s + 1e3 && (l.update(1e3 * o / (t - s), 100), s = t, o = 0, h)) {
                        var e = performance.memory;
                        h.update(e.usedJSHeapSize / 1048576, e.jsHeapSizeLimit / 1048576)
                    }
                    return t
                },
                update: function () {
                    r = this.end()
                },
                domElement: e,
                setMode: i
            }
        };
    a.Panel = function (t, e, n) {
        var i = 1 / 0,
            r = 0,
            s = Math.round,
            a = s(window.devicePixelRatio || 1),
            o = 80 * a,
            l = 48 * a,
            c = 3 * a,
            h = 2 * a,
            u = 3 * a,
            d = 15 * a,
            p = 74 * a,
            f = 30 * a,
            m = document.createElement("canvas");
        m.width = o, m.height = l, m.style.cssText = "width:80px;height:48px";
        var g = m.getContext("2d");
        return g.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif", g.textBaseline = "top", g.fillStyle = n, g.fillRect(0, 0, o, l), g.fillStyle = e, g.fillText(t, c, h), g.fillRect(u, d, p, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(u, d, p, f), {
            dom: m,
            update: function (l, v) {
                i = Math.min(i, l), r = Math.max(r, l), g.fillStyle = n, g.globalAlpha = 1, g.fillRect(0, 0, o, d), g.fillStyle = e, g.fillText(s(l) + " " + t + " (" + s(i) + "-" + s(r) + ")", c, h), g.drawImage(m, u + a, d, p - a, f, u, d, p - a, f), g.fillRect(u + p - a, d, a, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(u + p - a, d, a, s((1 - l / v) * f))
            }
        }
    };
    /**
     * lil-gui
     * https://lil-gui.georgealways.com
     * @version 0.17.0
     * @author George Michael Brower
     * @license MIT
     */
    class o {
        constructor(t, e, n, i, r = "div") {
            this.parent = t, this.object = e, this.property = n, this._disabled = !1, this._hidden = !1, this.initialValue = this.getValue(), this.domElement = document.createElement("div"), this.domElement.classList.add("controller"), this.domElement.classList.add(i), this.$name = document.createElement("div"), this.$name.classList.add("name"), o.nextNameID = o.nextNameID || 0, this.$name.id = "lil-gui-name-" + ++o.nextNameID, this.$widget = document.createElement(r), this.$widget.classList.add("widget"), this.$disable = this.$widget, this.domElement.appendChild(this.$name), this.domElement.appendChild(this.$widget), this.parent.children.push(this), this.parent.controllers.push(this), this.parent.$children.appendChild(this.domElement), this._listenCallback = this._listenCallback.bind(this), this.name(n)
        }
        name(t) {
            return this._name = t, this.$name.innerHTML = t, this
        }
        onChange(t) {
            return this._onChange = t, this
        }
        _callOnChange() {
            this.parent._callOnChange(this), void 0 !== this._onChange && this._onChange.call(this, this.getValue()), this._changed = !0
        }
        onFinishChange(t) {
            return this._onFinishChange = t, this
        }
        _callOnFinishChange() {
            this._changed && (this.parent._callOnFinishChange(this), void 0 !== this._onFinishChange && this._onFinishChange.call(this, this.getValue())), this._changed = !1
        }
        reset() {
            return this.setValue(this.initialValue), this._callOnFinishChange(), this
        }
        enable(t = !0) {
            return this.disable(!t)
        }
        disable(t = !0) {
            return t === this._disabled || (this._disabled = t, this.domElement.classList.toggle("disabled", t), this.$disable.toggleAttribute("disabled", t)), this
        }
        show(t = !0) {
            return this._hidden = !t, this.domElement.style.display = this._hidden ? "none" : "", this
        }
        hide() {
            return this.show(!1)
        }
        options(t) {
            const e = this.parent.add(this.object, this.property, t);
            return e.name(this._name), this.destroy(), e
        }
        min(t) {
            return this
        }
        max(t) {
            return this
        }
        step(t) {
            return this
        }
        decimals(t) {
            return this
        }
        listen(t = !0) {
            return this._listening = t, void 0 !== this._listenCallbackID && (cancelAnimationFrame(this._listenCallbackID), this._listenCallbackID = void 0), this._listening && this._listenCallback(), this
        }
        _listenCallback() {
            this._listenCallbackID = requestAnimationFrame(this._listenCallback);
            const t = this.save();
            t !== this._listenPrevValue && this.updateDisplay(), this._listenPrevValue = t
        }
        getValue() {
            return this.object[this.property]
        }
        setValue(t) {
            return this.object[this.property] = t, this._callOnChange(), this.updateDisplay(), this
        }
        updateDisplay() {
            return this
        }
        load(t) {
            return this.setValue(t), this._callOnFinishChange(), this
        }
        save() {
            return this.getValue()
        }
        destroy() {
            this.listen(!1), this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1), this.parent.$children.removeChild(this.domElement)
        }
    }
    class l extends o {
        constructor(t, e, n) {
            super(t, e, n, "boolean", "label"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "checkbox"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$widget.appendChild(this.$input), this.$input.addEventListener("change", () => {
                this.setValue(this.$input.checked), this._callOnFinishChange()
            }), this.$disable = this.$input, this.updateDisplay()
        }
        updateDisplay() {
            return this.$input.checked = this.getValue(), this
        }
    }

    function c(t) {
        let e, n;
        return (e = t.match(/(#|0x)?([a-f0-9]{6})/i)) ? n = e[2] : (e = t.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/)) ? n = parseInt(e[1]).toString(16).padStart(2, 0) + parseInt(e[2]).toString(16).padStart(2, 0) + parseInt(e[3]).toString(16).padStart(2, 0) : (e = t.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) && (n = e[1] + e[1] + e[2] + e[2] + e[3] + e[3]), !!n && "#" + n
    }
    const h = {
        isPrimitive: !0,
        match: t => "string" == typeof t,
        fromHexString: c,
        toHexString: c
    },
        u = {
            isPrimitive: !0,
            match: t => "number" == typeof t,
            fromHexString: t => parseInt(t.substring(1), 16),
            toHexString: t => "#" + t.toString(16).padStart(6, 0)
        },
        d = {
            isPrimitive: !1,
            match: Array.isArray,
            fromHexString(t, e, n = 1) {
                const i = u.fromHexString(t);
                e[0] = (i >> 16 & 255) / 255 * n, e[1] = (i >> 8 & 255) / 255 * n, e[2] = (255 & i) / 255 * n
            },
            toHexString: ([t, e, n], i = 1) => u.toHexString(t * (i = 255 / i) << 16 ^ e * i << 8 ^ n * i << 0)
        },
        p = {
            isPrimitive: !1,
            match: t => Object(t) === t,
            fromHexString(t, e, n = 1) {
                const i = u.fromHexString(t);
                e.r = (i >> 16 & 255) / 255 * n, e.g = (i >> 8 & 255) / 255 * n, e.b = (255 & i) / 255 * n
            },
            toHexString: ({
                r: t,
                g: e,
                b: n
            }, i = 1) => u.toHexString(t * (i = 255 / i) << 16 ^ e * i << 8 ^ n * i << 0)
        },
        f = [h, u, d, p];
    class m extends o {
        constructor(t, e, n, i) {
            var r;
            super(t, e, n, "color"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "color"), this.$input.setAttribute("tabindex", -1), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$text = document.createElement("input"), this.$text.setAttribute("type", "text"), this.$text.setAttribute("spellcheck", "false"), this.$text.setAttribute("aria-labelledby", this.$name.id), this.$display = document.createElement("div"), this.$display.classList.add("display"), this.$display.appendChild(this.$input), this.$widget.appendChild(this.$display), this.$widget.appendChild(this.$text), this._format = (r = this.initialValue, f.find(t => t.match(r))), this._rgbScale = i, this._initialValueHexString = this.save(), this._textFocused = !1, this.$input.addEventListener("input", () => {
                this._setValueFromHexString(this.$input.value)
            }), this.$input.addEventListener("blur", () => {
                this._callOnFinishChange()
            }), this.$text.addEventListener("input", () => {
                const t = c(this.$text.value);
                t && this._setValueFromHexString(t)
            }), this.$text.addEventListener("focus", () => {
                this._textFocused = !0, this.$text.select()
            }), this.$text.addEventListener("blur", () => {
                this._textFocused = !1, this.updateDisplay(), this._callOnFinishChange()
            }), this.$disable = this.$text, this.updateDisplay()
        }
        reset() {
            return this._setValueFromHexString(this._initialValueHexString), this
        }
        _setValueFromHexString(t) {
            if (this._format.isPrimitive) {
                const e = this._format.fromHexString(t);
                this.setValue(e)
            } else this._format.fromHexString(t, this.getValue(), this._rgbScale), this._callOnChange(), this.updateDisplay()
        }
        save() {
            return this._format.toHexString(this.getValue(), this._rgbScale)
        }
        load(t) {
            return this._setValueFromHexString(t), this._callOnFinishChange(), this
        }
        updateDisplay() {
            return this.$input.value = this._format.toHexString(this.getValue(), this._rgbScale), this._textFocused || (this.$text.value = this.$input.value.substring(1)), this.$display.style.backgroundColor = this.$input.value, this
        }
    }
    class g extends o {
        constructor(t, e, n) {
            super(t, e, n, "function"), this.$button = document.createElement("button"), this.$button.appendChild(this.$name), this.$widget.appendChild(this.$button), this.$button.addEventListener("click", t => {
                t.preventDefault(), this.getValue().call(this.object)
            }), this.$button.addEventListener("touchstart", () => { }, {
                passive: !0
            }), this.$disable = this.$button
        }
    }
    class v extends o {
        constructor(t, e, n, i, r, s) {
            super(t, e, n, "number"), this._initInput(), this.min(i), this.max(r);
            const a = void 0 !== s;
            this.step(a ? s : this._getImplicitStep(), a), this.updateDisplay()
        }
        decimals(t) {
            return this._decimals = t, this.updateDisplay(), this
        }
        min(t) {
            return this._min = t, this._onUpdateMinMax(), this
        }
        max(t) {
            return this._max = t, this._onUpdateMinMax(), this
        }
        step(t, e = !0) {
            return this._step = t, this._stepExplicit = e, this
        }
        updateDisplay() {
            const t = this.getValue();
            if (this._hasSlider) {
                let e = (t - this._min) / (this._max - this._min);
                e = Math.max(0, Math.min(e, 1)), this.$fill.style.width = 100 * e + "%"
            }
            return this._inputFocused || (this.$input.value = void 0 === this._decimals ? t : t.toFixed(this._decimals)), this
        }
        _initInput() {
            this.$input = document.createElement("input"), this.$input.setAttribute("type", "number"), this.$input.setAttribute("step", "any"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$widget.appendChild(this.$input), this.$disable = this.$input;
            const t = t => {
                const e = parseFloat(this.$input.value);
                isNaN(e) || (this._snapClampSetValue(e + t), this.$input.value = this.getValue())
            };
            let e, n, i, r, s, a = !1;
            const o = t => {
                if (a) {
                    const i = t.clientX - e,
                        r = t.clientY - n;
                    Math.abs(r) > 5 ? (t.preventDefault(), this.$input.blur(), a = !1, this._setDraggingStyle(!0, "vertical")) : Math.abs(i) > 5 && l()
                }
                if (!a) {
                    const e = t.clientY - i;
                    s -= e * this._step * this._arrowKeyMultiplier(t), r + s > this._max ? s = this._max - r : r + s < this._min && (s = this._min - r), this._snapClampSetValue(r + s)
                }
                i = t.clientY
            },
                l = () => {
                    this._setDraggingStyle(!1, "vertical"), this._callOnFinishChange(), window.removeEventListener("mousemove", o), window.removeEventListener("mouseup", l)
                };
            this.$input.addEventListener("input", () => {
                let t = parseFloat(this.$input.value);
                isNaN(t) || (this._stepExplicit && (t = this._snap(t)), this.setValue(this._clamp(t)))
            }), this.$input.addEventListener("keydown", e => {
                "Enter" === e.code && this.$input.blur(), "ArrowUp" === e.code && (e.preventDefault(), t(this._step * this._arrowKeyMultiplier(e))), "ArrowDown" === e.code && (e.preventDefault(), t(this._step * this._arrowKeyMultiplier(e) * -1))
            }), this.$input.addEventListener("wheel", e => {
                this._inputFocused && (e.preventDefault(), t(this._step * this._normalizeMouseWheel(e)))
            }, {
                passive: !1
            }), this.$input.addEventListener("mousedown", t => {
                e = t.clientX, n = i = t.clientY, a = !0, r = this.getValue(), s = 0, window.addEventListener("mousemove", o), window.addEventListener("mouseup", l)
            }), this.$input.addEventListener("focus", () => {
                this._inputFocused = !0
            }), this.$input.addEventListener("blur", () => {
                this._inputFocused = !1, this.updateDisplay(), this._callOnFinishChange()
            })
        }
        _initSlider() {
            this._hasSlider = !0, this.$slider = document.createElement("div"), this.$slider.classList.add("slider"), this.$fill = document.createElement("div"), this.$fill.classList.add("fill"), this.$slider.appendChild(this.$fill), this.$widget.insertBefore(this.$slider, this.$input), this.domElement.classList.add("hasSlider");
            const t = t => {
                const e = this.$slider.getBoundingClientRect();
                let n = (i = t, r = e.left, s = e.right, a = this._min, (i - r) / (s - r) * (this._max - a) + a);
                var i, r, s, a;
                this._snapClampSetValue(n)
            },
                e = e => {
                    t(e.clientX)
                },
                n = () => {
                    this._callOnFinishChange(), this._setDraggingStyle(!1), window.removeEventListener("mousemove", e), window.removeEventListener("mouseup", n)
                };
            let i, r, s = !1;
            const a = e => {
                e.preventDefault(), this._setDraggingStyle(!0), t(e.touches[0].clientX), s = !1
            },
                o = e => {
                    if (s) {
                        const t = e.touches[0].clientX - i,
                            n = e.touches[0].clientY - r;
                        Math.abs(t) > Math.abs(n) ? a(e) : (window.removeEventListener("touchmove", o), window.removeEventListener("touchend", l))
                    } else e.preventDefault(), t(e.touches[0].clientX)
                },
                l = () => {
                    this._callOnFinishChange(), this._setDraggingStyle(!1), window.removeEventListener("touchmove", o), window.removeEventListener("touchend", l)
                },
                c = this._callOnFinishChange.bind(this);
            let h;
            this.$slider.addEventListener("mousedown", i => {
                this._setDraggingStyle(!0), t(i.clientX), window.addEventListener("mousemove", e), window.addEventListener("mouseup", n)
            }), this.$slider.addEventListener("touchstart", t => {
                t.touches.length > 1 || (this._hasScrollBar ? (i = t.touches[0].clientX, r = t.touches[0].clientY, s = !0) : a(t), window.addEventListener("touchmove", o, {
                    passive: !1
                }), window.addEventListener("touchend", l))
            }, {
                passive: !1
            }), this.$slider.addEventListener("wheel", t => {
                if (Math.abs(t.deltaX) < Math.abs(t.deltaY) && this._hasScrollBar) return;
                t.preventDefault();
                const e = this._normalizeMouseWheel(t) * this._step;
                this._snapClampSetValue(this.getValue() + e), this.$input.value = this.getValue(), clearTimeout(h), h = setTimeout(c, 400)
            }, {
                passive: !1
            })
        }
        _setDraggingStyle(t, e = "horizontal") {
            this.$slider && this.$slider.classList.toggle("active", t), document.body.classList.toggle("lil-gui-dragging", t), document.body.classList.toggle("lil-gui-" + e, t)
        }
        _getImplicitStep() {
            return this._hasMin && this._hasMax ? (this._max - this._min) / 1e3 : .1
        }
        _onUpdateMinMax() {
            !this._hasSlider && this._hasMin && this._hasMax && (this._stepExplicit || this.step(this._getImplicitStep(), !1), this._initSlider(), this.updateDisplay())
        }
        _normalizeMouseWheel(t) {
            let {
                deltaX: e,
                deltaY: n
            } = t;
            return Math.floor(t.deltaY) !== t.deltaY && t.wheelDelta && (e = 0, n = -t.wheelDelta / 120, n *= this._stepExplicit ? 1 : 10), e + -n
        }
        _arrowKeyMultiplier(t) {
            let e = this._stepExplicit ? 1 : 10;
            return t.shiftKey ? e *= 10 : t.altKey && (e /= 10), e
        }
        _snap(t) {
            const e = Math.round(t / this._step) * this._step;
            return parseFloat(e.toPrecision(15))
        }
        _clamp(t) {
            return t < this._min && (t = this._min), t > this._max && (t = this._max), t
        }
        _snapClampSetValue(t) {
            this.setValue(this._clamp(this._snap(t)))
        }
        get _hasScrollBar() {
            const t = this.parent.root.$children;
            return t.scrollHeight > t.clientHeight
        }
        get _hasMin() {
            return void 0 !== this._min
        }
        get _hasMax() {
            return void 0 !== this._max
        }
    }
    class y extends o {
        constructor(t, e, n, i) {
            super(t, e, n, "option"), this.$select = document.createElement("select"), this.$select.setAttribute("aria-labelledby", this.$name.id), this.$display = document.createElement("div"), this.$display.classList.add("display"), this._values = Array.isArray(i) ? i : Object.values(i), this._names = Array.isArray(i) ? i : Object.keys(i), this._names.forEach(t => {
                const e = document.createElement("option");
                e.innerHTML = t, this.$select.appendChild(e)
            }), this.$select.addEventListener("change", () => {
                this.setValue(this._values[this.$select.selectedIndex]), this._callOnFinishChange()
            }), this.$select.addEventListener("focus", () => {
                this.$display.classList.add("focus")
            }), this.$select.addEventListener("blur", () => {
                this.$display.classList.remove("focus")
            }), this.$widget.appendChild(this.$select), this.$widget.appendChild(this.$display), this.$disable = this.$select, this.updateDisplay()
        }
        updateDisplay() {
            const t = this.getValue(),
                e = this._values.indexOf(t);
            return this.$select.selectedIndex = e, this.$display.innerHTML = -1 === e ? t : this._names[e], this
        }
    }
    class b extends o {
        constructor(t, e, n) {
            super(t, e, n, "string"), this.$input = document.createElement("input"), this.$input.setAttribute("type", "text"), this.$input.setAttribute("aria-labelledby", this.$name.id), this.$input.addEventListener("input", () => {
                this.setValue(this.$input.value)
            }), this.$input.addEventListener("keydown", t => {
                "Enter" === t.code && this.$input.blur()
            }), this.$input.addEventListener("blur", () => {
                this._callOnFinishChange()
            }), this.$widget.appendChild(this.$input), this.$disable = this.$input, this.updateDisplay()
        }
        updateDisplay() {
            return this.$input.value = this.getValue(), this
        }
    }
    let x = !1;
    class _ {
        constructor({
            parent: t,
            autoPlace: e = void 0 === t,
            container: n,
            width: i,
            title: r = "Controls",
            injectStyles: s = !0,
            touchStyles: a = !0
        } = {}) {
            if (this.parent = t, this.root = t ? t.root : this, this.children = [], this.controllers = [], this.folders = [], this._closed = !1, this._hidden = !1, this.domElement = document.createElement("div"), this.domElement.classList.add("lil-gui"), this.$title = document.createElement("div"), this.$title.classList.add("title"), this.$title.setAttribute("role", "button"), this.$title.setAttribute("aria-expanded", !0), this.$title.setAttribute("tabindex", 0), this.$title.addEventListener("click", () => this.openAnimated(this._closed)), this.$title.addEventListener("keydown", t => {
                "Enter" !== t.code && "Space" !== t.code || (t.preventDefault(), this.$title.click())
            }), this.$title.addEventListener("touchstart", () => { }, {
                passive: !0
            }), this.$children = document.createElement("div"), this.$children.classList.add("children"), this.domElement.appendChild(this.$title), this.domElement.appendChild(this.$children), this.title(r), a && this.domElement.classList.add("allow-touch-styles"), this.parent) return this.parent.children.push(this), this.parent.folders.push(this), void this.parent.$children.appendChild(this.domElement);
            this.domElement.classList.add("root"), !x && s && (function (t) {
                const e = document.createElement("style");
                e.innerHTML = '.lil-gui{--background-color:#1f1f1f;--text-color:#ebebeb;--title-background-color:#111;--title-text-color:#ebebeb;--widget-color:#424242;--hover-color:#4f4f4f;--focus-color:#595959;--number-color:#2cc9ff;--string-color:#a2db3c;--font-size:11px;--input-font-size:11px;--font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;--font-family-mono:Menlo,Monaco,Consolas,"Droid Sans Mono",monospace;--padding:4px;--spacing:4px;--widget-height:20px;--name-width:45%;--slider-knob-width:2px;--slider-input-width:27%;--color-input-width:27%;--slider-input-min-width:45px;--color-input-min-width:45px;--folder-indent:7px;--widget-padding:0 0 0 3px;--widget-border-radius:2px;--checkbox-size:calc(var(--widget-height)*0.75);--scrollbar-width:5px;background-color:var(--background-color);color:var(--text-color);font-family:var(--font-family);font-size:var(--font-size);font-style:normal;font-weight:400;line-height:1;text-align:left;touch-action:manipulation;user-select:none;-webkit-user-select:none}.lil-gui,.lil-gui *{box-sizing:border-box;margin:0;padding:0}.lil-gui.root{display:flex;flex-direction:column;width:var(--width,245px)}.lil-gui.root>.title{background:var(--title-background-color);color:var(--title-text-color)}.lil-gui.root>.children{overflow-x:hidden;overflow-y:auto}.lil-gui.root>.children::-webkit-scrollbar{background:var(--background-color);height:var(--scrollbar-width);width:var(--scrollbar-width)}.lil-gui.root>.children::-webkit-scrollbar-thumb{background:var(--focus-color);border-radius:var(--scrollbar-width)}.lil-gui.force-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}.lil-gui.autoPlace{max-height:100%;position:fixed;right:15px;top:0;z-index:1001}.lil-gui .controller{align-items:center;display:flex;margin:var(--spacing) 0;padding:0 var(--padding)}.lil-gui .controller.disabled{opacity:.5}.lil-gui .controller.disabled,.lil-gui .controller.disabled *{pointer-events:none!important}.lil-gui .controller>.name{flex-shrink:0;line-height:var(--widget-height);min-width:var(--name-width);padding-right:var(--spacing);white-space:pre}.lil-gui .controller .widget{align-items:center;display:flex;min-height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.string input{color:var(--string-color)}.lil-gui .controller.boolean .widget{cursor:pointer}.lil-gui .controller.color .display{border-radius:var(--widget-border-radius);height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.color input[type=color]{cursor:pointer;height:100%;opacity:0;width:100%}.lil-gui .controller.color input[type=text]{flex-shrink:0;font-family:var(--font-family-mono);margin-left:var(--spacing);min-width:var(--color-input-min-width);width:var(--color-input-width)}.lil-gui .controller.option select{max-width:100%;opacity:0;position:absolute;width:100%}.lil-gui .controller.option .display{background:var(--widget-color);border-radius:var(--widget-border-radius);height:var(--widget-height);line-height:var(--widget-height);max-width:100%;overflow:hidden;padding-left:.55em;padding-right:1.75em;pointer-events:none;position:relative;word-break:break-all}.lil-gui .controller.option .display.active{background:var(--focus-color)}.lil-gui .controller.option .display:after{bottom:0;content:"↕";font-family:lil-gui;padding-right:.375em;position:absolute;right:0;top:0}.lil-gui .controller.option .widget,.lil-gui .controller.option select{cursor:pointer}.lil-gui .controller.number input{color:var(--number-color)}.lil-gui .controller.number.hasSlider input{flex-shrink:0;margin-left:var(--spacing);min-width:var(--slider-input-min-width);width:var(--slider-input-width)}.lil-gui .controller.number .slider{background-color:var(--widget-color);border-radius:var(--widget-border-radius);cursor:ew-resize;height:var(--widget-height);overflow:hidden;padding-right:var(--slider-knob-width);touch-action:pan-y;width:100%}.lil-gui .controller.number .slider.active{background-color:var(--focus-color)}.lil-gui .controller.number .slider.active .fill{opacity:.95}.lil-gui .controller.number .fill{border-right:var(--slider-knob-width) solid var(--number-color);box-sizing:content-box;height:100%}.lil-gui-dragging .lil-gui{--hover-color:var(--widget-color)}.lil-gui-dragging *{cursor:ew-resize!important}.lil-gui-dragging.lil-gui-vertical *{cursor:ns-resize!important}.lil-gui .title{--title-height:calc(var(--widget-height) + var(--spacing)*1.25);-webkit-tap-highlight-color:transparent;text-decoration-skip:objects;cursor:pointer;font-weight:600;height:var(--title-height);line-height:calc(var(--title-height) - 4px);outline:none;padding:0 var(--padding)}.lil-gui .title:before{content:"▾";display:inline-block;font-family:lil-gui;padding-right:2px}.lil-gui .title:active{background:var(--title-background-color);opacity:.75}.lil-gui.root>.title:focus{text-decoration:none!important}.lil-gui.closed>.title:before{content:"▸"}.lil-gui.closed>.children{opacity:0;transform:translateY(-7px)}.lil-gui.closed:not(.transition)>.children{display:none}.lil-gui.transition>.children{overflow:hidden;pointer-events:none;transition-duration:.3s;transition-property:height,opacity,transform;transition-timing-function:cubic-bezier(.2,.6,.35,1)}.lil-gui .children:empty:before{content:"Empty";display:block;font-style:italic;height:var(--widget-height);line-height:var(--widget-height);margin:var(--spacing) 0;opacity:.5;padding:0 var(--padding)}.lil-gui.root>.children>.lil-gui>.title{border-width:0;border-bottom:1px solid var(--widget-color);border-left:0 solid var(--widget-color);border-right:0 solid var(--widget-color);border-top:1px solid var(--widget-color);transition:border-color .3s}.lil-gui.root>.children>.lil-gui.closed>.title{border-bottom-color:transparent}.lil-gui+.controller{border-top:1px solid var(--widget-color);margin-top:0;padding-top:var(--spacing)}.lil-gui .lil-gui .lil-gui>.title{border:none}.lil-gui .lil-gui .lil-gui>.children{border:none;border-left:2px solid var(--widget-color);margin-left:var(--folder-indent)}.lil-gui .lil-gui .controller{border:none}.lil-gui input{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:0;border-radius:var(--widget-border-radius);color:var(--text-color);font-family:var(--font-family);font-size:var(--input-font-size);height:var(--widget-height);outline:none;width:100%}.lil-gui input:disabled{opacity:1}.lil-gui input[type=number],.lil-gui input[type=text]{padding:var(--widget-padding)}.lil-gui input[type=number]:focus,.lil-gui input[type=text]:focus{background:var(--focus-color)}.lil-gui input::-webkit-inner-spin-button,.lil-gui input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.lil-gui input[type=number]{-moz-appearance:textfield}.lil-gui input[type=checkbox]{appearance:none;-webkit-appearance:none;border-radius:var(--widget-border-radius);cursor:pointer;height:var(--checkbox-size);text-align:center;width:var(--checkbox-size)}.lil-gui input[type=checkbox]:checked:before{content:"✓";font-family:lil-gui;font-size:var(--checkbox-size);line-height:var(--checkbox-size)}.lil-gui button{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:1px solid var(--widget-color);border-radius:var(--widget-border-radius);color:var(--text-color);cursor:pointer;font-family:var(--font-family);font-size:var(--font-size);height:var(--widget-height);line-height:calc(var(--widget-height) - 4px);outline:none;text-align:center;text-transform:none;width:100%}.lil-gui button:active{background:var(--focus-color)}@font-face{font-family:lil-gui;src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff")}@media (pointer:coarse){.lil-gui.allow-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}}@media (hover:hover){.lil-gui .controller.color .display:hover:before{border:1px solid #fff9;border-radius:var(--widget-border-radius);bottom:0;content:" ";display:block;left:0;position:absolute;right:0;top:0}.lil-gui .controller.option .display.focus{background:var(--focus-color)}.lil-gui .controller.option .widget:hover .display{background:var(--hover-color)}.lil-gui .controller.number .slider:hover{background-color:var(--hover-color)}body:not(.lil-gui-dragging) .lil-gui .title:hover{background:var(--title-background-color);opacity:.85}.lil-gui .title:focus{text-decoration:underline var(--focus-color)}.lil-gui input:hover{background:var(--hover-color)}.lil-gui input:active{background:var(--focus-color)}.lil-gui input[type=checkbox]:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}.lil-gui button:hover{background:var(--hover-color);border-color:var(--hover-color)}.lil-gui button:focus{border-color:var(--focus-color)}}';
                const n = document.querySelector("head link[rel=stylesheet], head style");
                n ? document.head.insertBefore(e, n) : document.head.appendChild(e)
            }(), x = !0), n ? n.appendChild(this.domElement) : e && (this.domElement.classList.add("autoPlace"), document.body.appendChild(this.domElement)), i && this.domElement.style.setProperty("--width", i + "px"), this.domElement.addEventListener("keydown", t => t.stopPropagation()), this.domElement.addEventListener("keyup", t => t.stopPropagation())
        }
        add(t, e, n, i, r) {
            if (Object(n) === n) return new y(this, t, e, n);
            const s = t[e];
            switch (typeof s) {
                case "number":
                    return new v(this, t, e, n, i, r);
                case "boolean":
                    return new l(this, t, e);
                case "string":
                    return new b(this, t, e);
                case "function":
                    return new g(this, t, e)
            }
            console.error("gui.add failed\n\tproperty:", e, "\n\tobject:", t, "\n\tvalue:", s)
        }
        addColor(t, e, n = 1) {
            return new m(this, t, e, n)
        }
        addFolder(t) {
            return new _({
                parent: this,
                title: t
            })
        }
        load(t, e = !0) {
            return t.controllers && this.controllers.forEach(e => {
                e instanceof g || e._name in t.controllers && e.load(t.controllers[e._name])
            }), e && t.folders && this.folders.forEach(e => {
                e._title in t.folders && e.load(t.folders[e._title])
            }), this
        }
        save(t = !0) {
            const e = {
                controllers: {},
                folders: {}
            };
            return this.controllers.forEach(t => {
                if (!(t instanceof g)) {
                    if (t._name in e.controllers) throw new Error(`Cannot save GUI with duplicate property "${t._name}"`);
                    e.controllers[t._name] = t.save()
                }
            }), t && this.folders.forEach(t => {
                if (t._title in e.folders) throw new Error(`Cannot save GUI with duplicate folder "${t._title}"`);
                e.folders[t._title] = t.save()
            }), e
        }
        open(t = !0) {
            return this._closed = !t, this.$title.setAttribute("aria-expanded", !this._closed), this.domElement.classList.toggle("closed", this._closed), this
        }
        close() {
            return this.open(!1)
        }
        show(t = !0) {
            return this._hidden = !t, this.domElement.style.display = this._hidden ? "none" : "", this
        }
        hide() {
            return this.show(!1)
        }
        openAnimated(t = !0) {
            return this._closed = !t, this.$title.setAttribute("aria-expanded", !this._closed), requestAnimationFrame(() => {
                const e = this.$children.clientHeight;
                this.$children.style.height = e + "px", this.domElement.classList.add("transition");
                const n = t => {
                    t.target === this.$children && (this.$children.style.height = "", this.domElement.classList.remove("transition"), this.$children.removeEventListener("transitionend", n))
                };
                this.$children.addEventListener("transitionend", n);
                const i = t ? this.$children.scrollHeight : 0;
                this.domElement.classList.toggle("closed", !t), requestAnimationFrame(() => {
                    this.$children.style.height = i + "px"
                })
            }), this
        }
        title(t) {
            return this._title = t, this.$title.innerHTML = t, this
        }
        reset(t = !0) {
            return (t ? this.controllersRecursive() : this.controllers).forEach(t => t.reset()), this
        }
        onChange(t) {
            return this._onChange = t, this
        }
        _callOnChange(t) {
            this.parent && this.parent._callOnChange(t), void 0 !== this._onChange && this._onChange.call(this, {
                object: t.object,
                property: t.property,
                value: t.getValue(),
                controller: t
            })
        }
        onFinishChange(t) {
            return this._onFinishChange = t, this
        }
        _callOnFinishChange(t) {
            this.parent && this.parent._callOnFinishChange(t), void 0 !== this._onFinishChange && this._onFinishChange.call(this, {
                object: t.object,
                property: t.property,
                value: t.getValue(),
                controller: t
            })
        }
        destroy() {
            this.parent && (this.parent.children.splice(this.parent.children.indexOf(this), 1), this.parent.folders.splice(this.parent.folders.indexOf(this), 1)), this.domElement.parentElement && this.domElement.parentElement.removeChild(this.domElement), Array.from(this.children).forEach(t => t.destroy())
        }
        controllersRecursive() {
            let t = Array.from(this.controllers);
            return this.folders.forEach(e => {
                t = t.concat(e.controllersRecursive())
            }), t
        }
        foldersRecursive() {
            let t = Array.from(this.folders);
            return this.folders.forEach(e => {
                t = t.concat(e.foldersRecursive())
            }), t
        }
    }
    var w = n(108),
        S = n(143),
        M = n(81),
        E = n(147),
        T = n(148),
        C = (n(76), n(9)),
        A = n(17),
        R = n(48),
        P = n(10);
    class L {
        cosntructor(t) {
            this.reset(t)
        }
        getSize() {
            return this.used
        }
        isFull() {
            return this.used === this.size
        }
        add(t) {
            this.pointer = (this.pointer + 1) % this.size, this.used = Math.min(this.size, this.used + 1), this.values[this.pointer] = t
        }
        getAverage() {
            const t = this.values,
                e = this.used;
            let n = 0;
            for (let i = 0; i < e; i++) n += t[i];
            return e ? n / e : 0
        }
        reset(t) {
            this.size = Math.ceil(t), this.values = new Array(this.size).fill(null), this.used = 0, this.pointer = -1
        }
    }
    class O {
        constructor(t) {
            this.options = t, this.fpsLimit = t.fpsLimit, this.time = 0, this.deltaTimes = new L(2 * this.fpsLimit), this.isFPSReduced = !1, this.isVisualFidelityDegraded = !t.degradeVisualFidelity, this.measureStart = Date.now()
        }
        reset() {
            this.time = Date.now() - 1e3 / this.fpsLimit, this.deltaTimes.reset(2 * this.fpsLimit), this.measureStart = Date.now()
        }
        update() {
            const t = 1e3 / this.fpsLimit,
                e = .1 * t,
                n = Date.now(),
                i = n - this.time;
            return i >= t - e && (this.time = n, this.deltaTimes.add(Math.min(1.5 * t, i)), Date.now() - this.measureStart > 1e3 && this.deltaTimes.getSize() >= 10 && this.deltaTimes.getAverage() > t / 45 * 60 && (this.isVisualFidelityDegraded ? this.fpsLimit = Math.max(this.fpsLimit / 2, 1) : (this.isVisualFidelityDegraded = !0, this.options.degradeVisualFidelity()), this.deltaTimes.reset(Math.max(10, 2 * this.fpsLimit)), this.measureStart = Date.now()), !0)
        }
    }
    var D = n(235),
        I = n.n(D),
        k = n(236),
        N = n.n(k),
        U = n(7);
    const z = !n(6).a.hasHoverSupport();
    class F extends class {
        constructor() {
            this.events = {}
        }
        on(t, e) {
            (this.events[t] || (this.events[t] = [])).push(e)
        }
        one(t, e) {
            const n = () => {
                e.apply(this, arguments), this.off(t, n)
            };
            this.on(t, n)
        }
        off(t, e) {
            this.events[t] && (this.events[t] = this.events[t].filter(t => t !== e))
        }
        emit(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            (this.events[t] || []).forEach(t => {
                t.apply(this, e)
            })
        }
    } {
        static get Defaults() {
            return {
                lazy: !0,
                debug: !0,
                fpsLimit: 60,
                mouseTracking: !1,
                scrollTracking: !1,
                camera: {
                    position: [0, 0, 0],
                    rotation: [0, 0, 0],
                    fov: 90,
                    near: .1,
                    far: 1e3,
                    filmGauge: 35
                },
                bloom: {
                    threshold: 0,
                    strength: .622,
                    radius: .4,
                    exposure: 1
                },
                cameraOrbitControls: !1
            }
        }
        constructor(t, e) {
            super(), this.options = i.a.extend(!0, {}, this.constructor.Defaults, e), this.$container = t, this.$canvas = t.find(".js-visualization-canvas"), this.$scrollParent = t.scrollParent(), this.ns = Object(C.a)(), this.time = 0, this.deltaTime = 0, this.tickRaf = null, this.camera, this.cameraOrbitControls, this.renderer, this.scene, this.size = {
                width: 0,
                height: 0
            }, this.gui = null, this.BLOOM_SCENE = 1, this.mouseClient = {
                x: 0,
                y: 0
            }, this.mouse = {
                x: 0,
                y: 0
            }, this.mouseLast = {
                x: 0,
                y: 0
            }, this.mouseDelta = {
                x: 0,
                y: 0
            }, this.mouseAnimated = {
                x: 0,
                y: 0
            }, this.mouseAnimatedLast = {
                x: 0,
                y: 0
            }, this.mouseAnimatedDelta = {
                x: 0,
                y: 0
            }, this.mouseAnimation = null, this.containerConstraints = {}, this.scrollAbsolute = 0, this.scrollRaw = 0, this.scroll = 0, this.handleResizeBinded = this.handleResize.bind(this), this.startMouseTrackingBinded = this.startMouseTracking.bind(this), this.handleMouseMoveBinded = this.handleMouseMove.bind(this), this.startScrollTrackingBinded = this.startScrollTracking.bind(this), this.handleScrollBinded = this.handleScroll.bind(this), this.startControlsBinded = this.startControls.bind(this), this.stopControlsBinded = this.stopControls.bind(this), this.handleTickBinded = this.handleTick.bind(this), this.rendererDarkenNonBloomedBinded = this.rendererDarkenNonBloomed.bind(this), this.rendererRestoreMaterialBinded = this.rendererRestoreMaterial.bind(this), this.frameLimiter = new O({
                fpsLimit: this.options.fpsLimit,
                degradeVisualFidelity: this.reduceVisualFidelity.bind(this)
            }), t.on("destroyed", this.destroy.bind(this)), this.$canvas.inview({
                enter: this.start.bind(this),
                leave: this.stop.bind(this),
                distance: 100
            });
            (window.requestIdleCallback || setTimeout)(() => {
                this.isInitialized || this.options.lazy || (this.isInitialized = !0, this.init())
            }), this.handleResize()
        }
        init() {
            if (this.initMouseTracking(), this.initScrollTracking(), this.initGUI(), this.initCamera(), this.initScene(), this.initRenderer(), this.initPostprocessing(), this.initControls(), this.initStats(), !this.scene) throw new Error("Visualization `scene` is not defined")
        }
        initScene() {
            throw new Error("Visualization initScene() must be overwritten in sub-class")
        }
        reduceVisualFidelity() { }
        destroy() {
            this.stop(), this.destroyStats()
        }
        handleResize() {
            const t = this.containerConstraints = this.getConstraints(),
                e = t.width,
                n = t.height;
            this.size.width === e && this.size.height === n || (this.size.width = e, this.size.height = n, this.$canvas.css("--visualization-width", e + "px").css("--visualization-height", n + "px"), this.updateCamera(), this.updateRenderer(), this.emit("resize", [this.size]), (this.options.mouseTracking || this.options.scrollTracking) && this.handleScroll(), this.onResize(e, n))
        }
        getConstraints() {
            return this.$canvas.pageOffset()
        }
        onResize(t, e) { }
        initMouseTracking() {
            this.options.mouseTracking && (this.on("start", this.startMouseTrackingBinded), this.on("stop", this.startMouseTrackingBinded), this.mouseAnimation = new A.a({
                x: this.mouse.x,
                y: this.mouse.y
            }, {
                strength: .04,
                update: t => {
                    this.mouseAnimated = t, this.onMouseMoveAnimated(t)
                }
            }), this.handleScroll())
        }
        startMouseTracking() {
            Object(i.a)(document).on("mousemove." + this.ns, this.handleMouseMoveBinded)
        }
        stopMouseTracking() {
            Object(i.a)(document).off("mousemove." + this.ns, this.handleMouseMoveBinded)
        }
        handleMouseMove(t) {
            this.mouseClient.x = t.clientX, this.mouseClient.y = t.clientY, this.updateMousePosition()
        }
        updateMousePosition() {
            const t = this.containerConstraints,
                e = t.left,
                n = t.top - this.scrollAbsolute;
            this.mouse.x = 0 === this.size.width ? 0 : (this.mouseClient.x - e) / this.size.width, this.mouse.y = 0 === this.size.height ? 0 : (this.mouseClient.y - n) / this.size.height, this.onMouseMove(this.mouse), this.mouseAnimation && this.mouseAnimation.set(this.mouse)
        }
        onMouseMove(t) { }
        onMouseMoveAnimated(t) { }
        initScrollTracking() {
            (this.options.mouseTracking || this.options.scrollTracking) && (this.on("start", this.startScrollTracking), this.on("stop", this.stopScrollTracking), z && (this.scrollAnimation = new A.a(this.scrollRaw, {
                strength: .04,
                update: t => {
                    this.scroll = t, this.onScroll(t)
                }
            })), this.handleScroll())
        }
        startScrollTracking() {
            this.$scrollParent.on("scroll." + this.ns, this.handleScrollBinded)
        }
        stopScrollTracking() {
            this.$scrollParent.off("scroll." + this.ns, this.handleScrollBinded)
        }
        handleScroll() {
            this.scrollAbsolute = this.$scrollParent.scrollTop();
            const t = this.calculateScroll();
            this.scrollRaw !== t && (this.scrollRaw = t, z ? this.scrollAnimation && this.scrollAnimation.set(t) : (this.scroll = t, this.onScroll(t))), this.options.mouseTracking && this.updateMousePosition()
        }
        calculateScroll() {
            const t = this.containerConstraints;
            return Object(R.a)((this.scrollAbsolute - (t.scrollTop - t.scrollViewportSize)) / (t.scrollHeight + t.scrollViewportSize), 0, 1)
        }
        onScroll(t) { }
        initRenderer() {
            const t = this.renderer = new r.dc({
                antialias: !0,
                alpha: !0
            });
            if (U.a.matches("md-up") ? t.setPixelRatio(1) : t.setPixelRatio(window.devicePixelRatio), t.setSize(this.size.width, this.size.height), t.autoClear = !1, this.$canvas.append(t.domElement), !1 === t.capabilities.isWebGL2 && !1 === t.extensions.has("ANGLE_instanced_arrays")) throw new Error("WebGL2 is not supported")
        }
        initPostprocessing() {
            const t = this.options.bloom;
            if (t) {
                this.darkMaterial = new r.fb({
                    color: "black"
                }), this.bloomMaterialStore = {}, this.bloomLayer = new r.M, this.bloomLayer.set(this.BLOOM_SCENE);
                const e = this.size,
                    n = new S.a(this.scene, this.camera),
                    i = this.bloomPass = new E.a(new r.Zb(e.width, e.height), t.strength, t.radius, t.threshold),
                    s = this.bloomComposer = new w.a(this.renderer);
                s.renderToScreen = !1, s.setPixelRatio(1), s.addPass(n), s.addPass(i);
                const a = new M.a(new r.Nb({
                    uniforms: {
                        baseTexture: {
                            value: null
                        },
                        bloomTexture: {
                            value: s.renderTarget2.texture
                        }
                    },
                    vertexShader: N.a,
                    fragmentShader: I.a,
                    defines: {}
                }), "baseTexture");
                a.needsSwap = !0;
                const o = this.outputPass = new T.a,
                    l = this.finalComposer = new w.a(this.renderer);
                if (l.addPass(n), l.addPass(a), l.addPass(o), this.gui) {
                    const t = this.gui.addFolder("Bloom effect");
                    t.add(i, "strength", 0, 2), t.add(i, "radius", 0, 2), t.add(i, "threshold", 0, 2)
                }
            }
        }
        updateRenderer() {
            if (this.renderer) {
                const t = this.size;
                this.renderer.setSize(t.width, t.height), this.bloomComposer && (this.bloomPass.setSize(t.width, t.height), this.bloomComposer.setSize(t.width, t.height), this.finalComposer.setSize(t.width, t.height))
            }
        }
        rendererDarkenNonBloomed(t) {
            t.isMesh && !1 === this.bloomLayer.test(t.layers) ? (this.bloomMaterialStore[t.uuid] = t.material, t.material = this.darkMaterial) : t.isPoints && !1 === this.bloomLayer.test(t.layers) && (t.visible = !1)
        }
        rendererRestoreMaterial(t) {
            this.bloomMaterialStore[t.uuid] ? (t.material = this.bloomMaterialStore[t.uuid], delete this.bloomMaterialStore[t.uuid]) : t.isPoints && !1 === this.bloomLayer.test(t.layers) && (t.visible = !0)
        }
        initGUI() {
            this.options.debug && (this.gui = new _, _.prototype.addUniform = function (t, e, n, i, r) {
                let s;
                return s = t.uniforms[e].value && t.uniforms[e].value.isColor ? this.addColor(t.uniforms[e], "value") : this.add(t.uniforms[e], "value", n, i, r), s.name(e), s
            })
        }
        initCamera() {
            const t = this.options.camera,
                e = this.size;
            this.camera = new r.rb(t.fov, e.width / e.height, t.near, t.far), this.camera.filmGauge = t.filmGauge, this.camera.position.set(t.position[0], t.position[1], t.position[2]), this.camera.rotation.set(t.rotation[0], t.rotation[1], t.rotation[2])
        }
        updateCamera() {
            const t = this.size;
            this.camera && (this.camera.aspect = t.width / t.height, this.camera.updateProjectionMatrix())
        }
        initStats() {
            this.options.debug, 0
        }
        destroyStats() {
            this.stats && (Object(i.a)(this.stats.dom).remove(), this.stats = null)
        }
        initControls() {
            if (this.options.cameraOrbitControls && this.options.debug) {
                const t = this.camera,
                    e = this.options.camera;
                this.cameraOrbitControls = new s.a(t, this.renderer.domElement), t.position.set(e.position[0], e.position[1], e.position[2]), t.rotation.set(e.rotation[0], e.rotation[1], e.rotation[2]), this.on("start", this.startControlsBinded), this.on("stop", this.stopControlsBinded)
            }
        }
        startControls() {
            this.$canvas.on("wheel." + this.ns, !1)
        }
        stopControls() {
            this.$canvas.off("wheel." + this.ns)
        }
        start() {
            this.isInitialized || (this.isInitialized = !0, this.init()), this.isRunning || (this.isRunning = !0, P.a.add(P.a.QUEUE_MEASURE, this.handleResizeBinded), this.handleResize(), this.frameLimiter.reset(), this.deltaTime = 1e3 / this.fpsLimit, this.time = performance.now() - this.deltaTime, this.handleTick(), this.emit("start"))
        }
        stop() {
            this.isRunning && (this.isRunning = !1, P.a.remove(P.a.QUEUE_MEASURE, this.handleResizeBinded), cancelAnimationFrame(this.tickRaf), this.emit("stop"))
        }
        handleTick() {
            if (this.isRunning && (this.tickRaf = requestAnimationFrame(this.handleTickBinded), this.frameLimiter.update())) {
                const t = performance.now(),
                    e = t - this.time;
                this.time = t, this.deltaTime = e, this.options.mouseTracking && (this.mouseDelta.x = this.mouse.x - this.mouseLast.x, this.mouseDelta.y = this.mouse.y - this.mouseLast.y, this.mouseLast.x = this.mouse.x, this.mouseLast.y = this.mouse.y, this.mouseAnimatedDelta.x = this.mouseAnimated.x - this.mouseAnimatedLast.x, this.mouseAnimatedDelta.y = this.mouseAnimated.y - this.mouseAnimatedLast.y, this.mouseAnimatedLast.x = this.mouseAnimated.x, this.mouseAnimatedLast.y = this.mouseAnimated.y), this.stats && this.stats.update(), this.emit("tick", [t, e]), this.onTick(t, e), this.render()
            }
        }
        onTick() { }
        render() {
            this.bloomComposer ? (this.scene.traverse(this.rendererDarkenNonBloomedBinded), this.bloomComposer.render(), this.scene.traverse(this.rendererRestoreMaterialBinded), this.finalComposer.render()) : this.renderer.render(this.scene, this.camera)
        }
    }
}, function (t, e) {
    var n = Array.isArray;
    t.exports = n
}, function (t, e) {
    t.exports = function (t) {
        var e = typeof t;
        return null != t && ("object" == e || "function" == e)
    }
}, function (t, e, n) {
    "use strict";
    var i = n(6),
        r = n(37);
    e.a = r.a && !i.a.isReducedMotion() && !i.a.isIOS() && !i.a.isAndroid() && !i.a.isIE() && function () {
        const t = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1 || window.innerWidth < 768,
            e = t && window.innerWidth >= 768;
        return !t && !e
    }()
}, function (t, e, n) {
    "use strict";

    function i(t, e, n) {
        return (1 - n) * t + n * e
    }
    n.d(e, "a", (function () {
        return i
    }))
}, function (t, e, n) {
    "use strict";
    n(1).a.event.special.destroyed = {
        remove: function (t) {
            t.handler && t.handler()
        }
    }
}, function (t, e, n) {
    var i = n(395),
        r = n(165),
        s = /[&<>"']/g,
        a = RegExp(s.source);
    t.exports = function (t) {
        return (t = r(t)) && a.test(t) ? t.replace(s, i) : t
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return s
    }));
    var i = n(2),
        r = n.n(i);

    function s(t) {
        if ("string" != typeof t || !t || "#" === t) return !1;
        try {
            return !!r()(t)
        } catch (t) {
            return !1
        }
    }
}, function (t, e, n) {
    "use strict";

    function i(t, e, n) {
        var i = "";
        if (n) {
            var r = new Date;
            r.setTime(r.getTime() + 24 * n * 60 * 60 * 1e3), i = "; expires=" + r.toUTCString()
        }
        document.cookie = t + "=" + (e || "") + i + "; path=/"
    }
    n.d(e, "b", (function () {
        return i
    })), e.a = {
        set: i,
        get: function (t) {
            for (var e = t + "=", n = document.cookie.split(";"), i = 0; i < n.length; i++) {
                for (var r = n[i];
                    " " == r.charAt(0);) r = r.substring(1, r.length);
                if (0 == r.indexOf(e)) return r.substring(e.length, r.length)
            }
            return null
        }
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "b", (function () {
        return r
    })), n.d(e, "a", (function () {
        return o
    }));
    var i = n(0);
    class r {
        constructor() {
            this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
        }
        setSize() { }
        render() {
            console.error("THREE.Pass: .render() must be implemented in derived pass.")
        }
        dispose() { }
    }
    const s = new i.qb(-1, 1, 1, -1, 0, 1),
        a = new i.i;
    a.setAttribute("position", new i.B([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), a.setAttribute("uv", new i.B([0, 2, 0, 0, 2, 0], 2));
    class o {
        constructor(t) {
            this._mesh = new i.eb(a, t)
        }
        dispose() {
            this._mesh.geometry.dispose()
        }
        render(t) {
            t.render(this._mesh, s)
        }
        get material() {
            return this._mesh.material
        }
        set material(t) {
            this._mesh.material = t
        }
    }
}, function (t, e, n) {
    "use strict";

    function i(t, e) {
        try {
            sessionStorage.setItem(t, JSON.stringify(e))
        } catch (t) {
            console.error(t)
        }
    }

    function r(t) {
        try {
            return JSON.parse(sessionStorage.getItem(t))
        } catch (t) {
            return console.error(t), null
        }
    }
    n.r(e), n.d(e, "save", (function () {
        return i
    })), n.d(e, "read", (function () {
        return r
    })), e.default = {
        save: i,
        read: r
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return a
    }));
    var i = n(0),
        r = n(16),
        s = n(49);
    class a extends i.q {
        constructor(t) {
            super(), this.options = Object.assign({
                scale: [1, 1, 1],
                loops: 1,
                direction: 1,
                offset: 0,
                length: 1,
                varyingLoops: 0,
                varyingLoopOffset: .1,
                varyingMin: .25,
                varyingMax: 1,
                edgeRadius: .1,
                edgeAlignment: "center"
            }, t)
        }
        getXYZ(t) {
            let {
                position: e,
                direction: n,
                loops: i
            } = t;
            const r = Math.sin(2 * Math.PI * e * n * i),
                a = Math.cos(2 * Math.PI * e * n * i);
            let o = i > 1 ? e - .5 : 0;
            return i > 1 && (o += Object(s.a)(.9, 1, e) / 20), [r, o, a]
        }
        getPoint(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new i.ac;
            const {
                scale: n,
                offset: s,
                length: a,
                direction: o,
                loops: l
            } = this.options, c = Object(r.a)(t, 0, 1, s, s + a), [h, u, d] = this.getXYZ({
                t: t,
                position: c,
                direction: o,
                loops: l
            });
            let p = u;
            return "bottom" === this.options.edgeAlignment && (p += (1 - this.getRadiusAt(t)) / -20), e.set(h * n[0], p * n[1], d * n[2])
        }
        getRadiusAt(t) {
            const {
                varyingLoops: e,
                varyingLoopOffset: n,
                varyingMin: i,
                varyingMax: s,
                edgeRadius: a
            } = this.options;
            let o, l = 1;
            return e && (l = Object(r.a)(Math.sin(Math.PI * e * (t + n)), -1, 1, i, s)), o = t < a ? Math.sin(Math.PI / 2 * t * (1 / a)) : t > 1 - a ? Math.sin(Math.PI / 2 * (1 - t) * (1 / a)) : 1, o * l
        }
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return i
    })), n.d(e, "e", (function () {
        return r
    })), n.d(e, "c", (function () {
        return s
    })), n.d(e, "b", (function () {
        return a
    })), n.d(e, "d", (function () {
        return o
    })), n.d(e, "f", (function () {
        return l
    }));
    const i = !0,
        r = .06,
        s = .4,
        a = .4,
        o = .2,
        l = !1
}, function (t, e, n) {
    "use strict";
    var i = n(1),
        r = (n(222), n(12)),
        s = n.n(r),
        a = n(98),
        o = n.n(a),
        l = n(22),
        c = n.n(l),
        h = n(9);
    const u = new RegExp(`(${["-out", "-disappear"].join("|")})`);
    let d = null;

    function p(t, e, n, i) {
        const r = [].concat(t);
        for (; r && r.length;) {
            let t = r.shift()(e, n);
            if (t && t.then) return void t.then(p.bind(this, r, e, n, i))
        }
        i()
    }

    function f(t, e, n) {
        const r = Object(i.a)(e),
            s = Object(h.a)();
        let a = !1,
            o = !1,
            l = !1,
            c = null;
        return r.on("transitionstop." + s, e => {
            r.is(e.target) && (a = !0, r.off("." + s), o || p(t.before, r, n, () => { }), l || p(t.transition, r, n, () => { }), p(t.after, r, n, () => { }), t.duration && r.css("transition-duration", "").css("--transition-duration", ""), c && c())
        }), new Promise(e => {
            c = e, a ? e() : (o = !0, p(t.before, r, n, () => {
                t.transition.length ? (t.duration && r.css("transition-duration", t.duration + "ms").css("--transition-duration", t.duration + "ms"), requestAnimationFrame(() => {
                    setTimeout(() => {
                        a || (l = !0, p(t.transition, r, n, () => {
                            r.transitionend().then(() => {
                                r.off("." + s), p(t.after, r, n, () => {
                                    t.duration && r.css("transition-duration", "").css("--transition-duration", ""), e()
                                })
                            })
                        }))
                    }, t.delay)
                })) : e()
            }))
        })
    }

    function m(t) {
        const e = {
            before: [],
            transition: [],
            after: [],
            delay: 16,
            duration: null
        };
        for (let n = 0, r = t.length; n < r; n++) {
            let r = t[n];
            if ("string" == typeof r) {
                const t = r.split(" ");
                let e = [];
                for (let n = 0; n < t.length; n++) {
                    const r = t[n];
                    r in i.a.transition.sequences || (i.a.transition.sequences[r] = i.a.transition.generateSequenceAuto(r)), e = e.concat(i.a.transition.sequences[r])
                }
                r = e
            }
            if (i.a.isPlainObject(r) && (r = [r]), Array.isArray(r))
                for (let t = 0; t < r.length; t++) i.a.isPlainObject(r[t]) && (r[t].before && e.before.push(r[t].before), r[t].transition && e.transition.push(r[t].transition), r[t].after && e.after.push(r[t].after), r[t].delay && (e.delay = Math.max(e.delay, r[t].delay)), r[t].duration && (e.duration = r[t].duration))
        }
        return e
    }
    i.a.fn.transition = function () {
        const t = [...arguments],
            e = m(t),
            n = t[t.length - 1],
            i = "function" == typeof n ? n : null,
            r = this.toArray().map(f.bind(this, e));
        return i && Promise.all(r).then(i), this
    }, i.a.fn.transitionstop = function (t) {
        const e = Object(i.a)(this);
        return this.trigger("transitionend"), this.trigger("transitionstop"), "function" == typeof t && (d ? d.push(t.bind(this, e)) : (d = [t.bind(this, e)], new Promise(() => {
            let t = d;
            d = null, requestAnimationFrame((function () {
                ! function (t, e) {
                    for (let n = 0, i = t.length; n < i; n++) e(t[n])
                }(t, t => t(e))
            }))
        }))), this
    }, i.a.transition = {
        sequences: {
            show: {
                before: t => t.removeClass("is-hidden is-invisible is-invisible--js is-invisible--md-up-js")
            },
            hide: {
                after: t => t.addClass("is-hidden")
            }
        }
    }, i.a.transition.generateSequence = function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
        return o()(s()(e, t => "string" == typeof t ? t in i.a.transition.sequences ? i.a.transition.sequences[t] : {
            before: e => e.addClass(`animation animation--${t} animation--${t}--inactive disable-transitions`),
            transition: e => e.removeClass(`animation--${t}--inactive disable-transitions`).addClass(`animation--${t}--active`),
            after: e => e.removeClass(`animation animation--${t} animation--${t}--active`)
        } : t))
    }, i.a.transition.generateSequenceIn = function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
        return e.length ? i.a.transition.generateSequence.apply(null, [].concat(e, "show")) : []
    }, i.a.transition.generateSequenceOut = function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
        return e.length ? i.a.transition.generateSequence.apply(null, [].concat(e, "hide")) : []
    }, i.a.transition.generateSequenceAuto = function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
        const r = c()(e, t => "string" == typeof t && !u.test(t)),
            s = c()(e, t => "string" == typeof t && u.test(t)),
            a = c()(e, t => "string" != typeof t);
        return [].concat(i.a.transition.generateSequenceIn(...r), i.a.transition.generateSequenceOut(...s), a)
    }
}, function (t, e, n) {
    var i = n(343);
    t.exports = function (t) {
        return t && t.length ? i(t) : []
    }
}, function (t, e, n) {
    "use strict";
    const i = window.LOCALES && (window.LOCALES.numberThousandSeparator || "" === window.LOCALES.numberThousandSeparator) ? window.LOCALES.numberThousandSeparator : " ",
        r = window.LOCALES && (window.LOCALES.numberDecimalSeparator || "" === window.LOCALES.numberDecimalSeparator) ? window.LOCALES.numberDecimalSeparator : ".",
        s = /(\d)(\d{3})(\.|\s|$)/;
    e.a = function (t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
            n = arguments.length > 2 ? arguments[2] : void 0,
            a = arguments.length > 3 ? arguments[3] : void 0,
            o = parseFloat(t),
            l = "";
        if (o = Math.round(o * Math.pow(10, e)) / Math.pow(10, e), 0 === o) return "0";
        l = e ? o.toFixed(e) : "" + o;
        const c = i || a;
        if (c)
            for (; s.test(l);) l = l.replace(s, "$1" + c + "$2$3");
        return l.replace(".", n || r)
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return o
    }));
    var i = n(1),
        r = (n(30), n(23), n(8)),
        s = n(17),
        a = n(10);
    class o extends r.a {
        static get Defaults() {
            return i.a.extend({}, r.a.Defaults, {
                enableMq: "md-up",
                enableHover: !0,
                enableTouch: !0,
                animated: !1,
                contentSizeSelector: "[data-scroll-sticky]"
            })
        }
        init() {
            this.$contentSizer = this.$container.find(this.options.contentSizeSelector), this.$scrollParent = this.$container.scrollParent(), this.constraints = {}, this.position = 0, this.isVisible = !1, this.imagesLoaded = !1, this.anmation = null, this.stickyContentHeight = 0, this.updateConstraints = this.updateConstraints.bind(this), this.handleAfterResize = this.handleAfterResize.bind(this), this.reset = this.reset.bind(this)
        }
        enable() {
            if (super.enable()) {
                if (a.a.add(a.a.QUEUE_RESET, this.reset, !0), a.a.add(a.a.QUEUE_MEASURE, this.updateConstraints, !0), a.a.add(a.a.QUEUE_APPLY, this.handleAfterResize, !0), this.$scrollParent.on("scroll." + this.ns, this.handleScroll.bind(this)), this.$container.inview({
                    enter: () => {
                        this.isVisible = !0, this.handleResize(), this.handleViewportEnter()
                    },
                    leave: () => {
                        this.isVisible = !1
                    }
                }), this.options.animated) {
                    const t = "boolean" == typeof this.options.animated ? {} : this.options.animated;
                    this.animation = new s.a(this.position, {
                        strength: t.strength || .05,
                        precision: 1e-4,
                        update: this.update.bind(this)
                    })
                }
                return !0
            }
        }
        disable() {
            if (super.disable()) return a.a.remove(a.a.QUEUE_RESET, this.reset), a.a.remove(a.a.QUEUE_MEASURE, this.updateConstraints), a.a.remove(a.a.QUEUE_APPLY, this.handleAfterResize), Object(i.a)(window).add(document).off("." + this.ns), this.$container.inview("destroy"), this.animation && (this.animation.destroy(), this.animation = null, this.update(this.position)), !0
        }
        showAllImages() {
            this.imagesLoaded || (this.imagesLoaded = !0, this.$container.find('[data-plugin~="appear"]').appear("show"))
        }
        handleResize() {
            this.updateConstraints(), this.handleAfterResize(), this.handleScroll(!0)
        }
        getConstraints() {
            const t = this.$container.pageOffset().top,
                e = this.$container.height(),
                n = Math.max(0, e - window.innerHeight),
                i = this.getStickyContentHeight();
            return {
                scrollFrom: t,
                scrollTo: t + n + (i ? window.innerHeight - i : 0),
                distance: n
            }
        }
        updateConstraints() {
            this.constraints = this.getConstraints()
        }
        handleScroll() {
            let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (!this.constraints || !this.isVisible) return;
            const e = this.constraints,
                n = (this.$scrollParent.scrollTop() - e.scrollFrom) / (e.scrollTo - e.scrollFrom),
                i = Math.max(0, Math.min(1, n));
            i === this.position && !0 !== t || (this.position = i, this.animation ? this.animation.set(i) : this.update(i))
        }
        handleAfterResize() {
            this.animation ? this.update(this.animation.get()) : this.update(this.position)
        }
        update(t) { }
        reset() {
            const t = this.$contentSizer;
            if (t.length) {
                t.get(0).style.removeProperty("--sticky-content-height");
                const e = this.getStickyContentHeight();
                e !== this.stickyContentHeight && (this.stickyContentHeight = e, this.$container.get(0).style.setProperty("--sticky-content-height", e + "px"), this.$container.trigger("appear"))
            }
        }
        getStickyContentHeight() {
            return this.$contentSizer.outerHeight()
        }
        handleViewportEnter() {
            this.showAllImages()
        }
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "d", (function () {
        return i
    })), n.d(e, "h", (function () {
        return r
    })), n.d(e, "a", (function () {
        return s
    })), n.d(e, "e", (function () {
        return a
    })), n.d(e, "c", (function () {
        return o
    })), n.d(e, "b", (function () {
        return l
    })), n.d(e, "g", (function () {
        return c
    })), n.d(e, "f", (function () {
        return h
    }));
    const i = !0,
        r = [n(193).default, n(370).default, n(371).default, n(194).default, n(372).default],
        s = ["/logout"],
        a = [],
        o = "data-ajax-page-ignore",
        l = "data-ajax-page-ignore-prefetch",
        c = 2e4,
        h = [/comagic\.ru/]
}, function (t, e, n) {
    "use strict";

    function i(t, e) {
        return Math.random() * (e - t) + t
    }
    n.d(e, "a", (function () {
        return i
    }))
}, function (t, e, n) {
    "use strict";
    var i = n(15),
        r = n.n(i);
    e.a = {
        name: "base",
        config: {
            preserveScroll: !1,
            preserveStylesheets: !1
        },
        beforeOnce(t) { },
        once(t) { },
        afterOnce(t) { },
        before(t) {
            t.scrollableUpdated = !1
        },
        beforeLeave(t) {
            this.config.preserveStylesheets && (t.preserveStylesheets = !0)
        },
        leave(t) { },
        afterLeave(t) { },
        beforeEnter(t) {
            this.bodyScrollPosition = 0, this.config.preserveScroll && (this.bodyScrollPosition = $(window).scrollTop()),
                function (t) {
                    const e = $(t),
                        n = $.fn.scroller ? $("body").scroller("instance") : null,
                        i = $("html");
                    if (n && n.custom) {
                        const t = n.getScrollableContent();
                        n.setScrollableContent(null), t && i.addClass("has-scroll-init has-scroll-smooth").removeClass("no-scroll-smooth")
                    } else {
                        const t = $(window).scrollTop();
                        e.css({
                            transform: "translateZ(0px)"
                        }), requestAnimationFrame(() => {
                            e.css({
                                position: "absolute",
                                left: 0,
                                top: -t + "px",
                                width: "100vw"
                            }).data("scroll", t), i.addClass("disable-smooth-scrolling"), $(window).scrollTop(0), setTimeout(() => {
                                i.removeClass("disable-smooth-scrolling")
                            }, 16)
                        })
                    }
                }(t.current.container), $("html").removeClass("with-modal");
            const e = $(t.next.container);
            e.addClass("page-transition-content"), this.config.preserveScroll && e.css("margin-top", -this.bodyScrollPosition + "px")
        },
        enter(t) { },
        afterEnter(t) { },
        after(t) {
            $(t.current.container).remove(), $(t.next.container).removeClass("page-transition-content").css("margin-top", ""), this.afterUpdateScrollable(t)
        },
        afterUpdateScrollable(t) {
            if (!t.scrollableUpdated) {
                if (t.scrollableUpdated = !0, $.fn.scroller) {
                    const e = $(t.current.container).find(".js-page-content-wrapper").addBack(".js-page-content-wrapper");
                    $("body").scroller("unsetScrollableContent", e)
                }
                if (!this.config.preserveScroll && "back" === t.trigger && r.a.history.current && (this.bodyScrollPosition = r.a.history.current.scroll.y), $(t.next.container).css("margin-top", ""), $.fn.scroller) {
                    const e = $(t.next.container).find(".js-page-content-wrapper").addBack(".js-page-content-wrapper");
                    $("body").scroller("setScrollableContent", e), $("body").scroller("setDisabled", !1)
                }
                $(window).scrollTop(this.bodyScrollPosition || 0)
            }
        },
        extend(t) {
            const e = Object.assign({}, this, t);
            return e.from = Object.assign({}, e.from || {}), e.from.custom = e => {
                let {
                    trigger: n
                } = e;
                return this.isLinkTransitionMatching(n, t.name)
            }, e
        },
        isLinkTransitionMatching(t, e) {
            if (t instanceof HTMLElement) {
                const n = $(t).attr("data-ajax-page-transition");
                return !n || n === e
            }
            return !0
        }
    }
}, function (t, e, n) {
    var i = n(199),
        r = "object" == typeof self && self && self.Object === Object && self,
        s = i || r || Function("return this")();
    t.exports = s
}, function (t, e, n) {
    var i = n(74),
        r = n(347),
        s = n(364),
        a = n(121),
        o = n(58),
        l = n(367),
        c = n(368),
        h = n(226),
        u = c((function (t, e) {
            var n = {};
            if (null == t) return n;
            var c = !1;
            e = i(e, (function (e) {
                return e = a(e, t), c || (c = e.length > 1), e
            })), o(t, h(t), n), c && (n = r(n, 7, l));
            for (var u = e.length; u--;) s(n, e[u]);
            return n
        }));
    t.exports = u
}, function (t, e, n) {
    var i = n(373),
        r = n(75),
        s = n(56),
        a = n(374),
        o = n(26);
    t.exports = function (t, e, n) {
        var l = o(t) ? i : a,
            c = arguments.length < 3;
        return l(t, s(e, 4), n, c, r)
    }
}, function (t, e, n) {
    "use strict";

    function i(t, e, n) {
        return Math.min(Math.max(t, e), n)
    }
    n.d(e, "a", (function () {
        return i
    }))
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return r
    }));
    var i = n(48);

    function r(t, e, n) {
        const r = Object(i.a)((n - t) / (e - t), 0, 1);
        return r * r * (3 - 2 * r)
    }
}, , function (t, e) {
    t.exports = function (t) {
        return null != t && "object" == typeof t
    }
}, function (t, e, n) {
    "use strict";
    var i = n(1),
        r = n(242),
        s = n.n(r),
        a = n(3),
        o = n.n(a),
        l = n(5),
        c = n.n(l),
        h = n(40),
        u = n(142),
        d = n(31),
        p = n.n(d),
        f = n(46),
        m = n.n(f);

    function g(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
            n = t;
        if (n && n.src && (n = n.src), n && "object" == typeof n) {
            let t = "",
                i = !1;
            for (let r in n) {
                const s = n[r];
                1 === Object.keys(n).length ? (t = s, e && (t += " 1w")) : t = i ? `${s} ${r}` : `${t}, ${s} ${r}`, i = !1
            }
            n = t
        } else e && (n += " 1w");
        return p()(n)
    }

    function v(t) {
        let e = t;
        if (e && e.src && (e = e.src), e && "object" == typeof e) {
            let t = "";
            for (let n in e) {
                const i = e[n];
                "1x" != n && t || (t = i)
            }
            e = t
        }
        return p()(e)
    }

    function y(t) {
        let e = t;
        e && e.src && (e = e.src);
        return e && "object" == typeof e && Object.keys(e).length > 1 ? "srcset" : "src"
    }
    var b = n(12),
        x = n.n(b);
    const _ = ["disabled", "readonly", "required", "download", "checked", "loop", "muted", "controls", "playsinline", "disablepictureinpicture", "autoplay"];

    function w(t) {
        return " " + x()(t, (t, e) => t && "object" == typeof t ? `${t}="${JSON.stringify(t)}"` : !0 !== t && !1 !== t ? `${e}="${p()(t)}"` : -1 === _.indexOf(e) ? "autocomplete" === e ? !0 === t ? "on" : "off" : !0 === t ? "true" : "false" : t ? e : void 0).join(" ")
    }

    function S(t, e) {
        if (t && e) {
            return `data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="${t}" height="${e}" preserveAspectRatio="xMinYMax meet" viewBox="0 0 ${t} ${e}"></svg>`.replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s/g, "%20").replace(/"/g, "%22")
        }
        return "assets/images/px.gif"
    }

    function M(t) {
        return "jpg" === t ? "image/jpeg" : "svg" === t ? "image/svg+xml" : "image/" + t
    }
    var E = n(7);

    function T(t) {
        return E.a.getCSSQuery(t + "-up")
    }

    function C(t, e, n, i) {
        let r = "<source ";
        return i && t.width && t.height ? r += `\n            data-srcset="${g(t)}"\n            srcset="${S(t.width, t.height)}"\n        ` : r += i ? `\n                srcset="assets/images/px-2x1.gif"\n                data-srcset="${g(t)}"\n            ` : ` srcset="${g(t)}"`, "string" == typeof e && e.trim() && (r += ` media="${e.trim()}"`), n && (r += ` type="${n}"`), r += ">", r
    }

    function A(t) {
        return "animation" in t ? !1 === t.animation || !0 === t.animation ? "" : t.animation : ""
    }

    function R(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!t) return "";
        const n = !("lazy" in e) || e.lazy,
            i = A(e),
            r = (n ? "appear " : "") + (e["data-plugin"] || "");
        let s = !1,
            a = !1,
            o = `<picture\n            class="${p()(e.class || "")} ${n ? "is-invisible--js is-hidden--no-js" : ""}"\n            ${w(m()(e, ["animation", "class", "img", "alt", "lazy", "width", "height", "data-plugin"]))}\n\n            ${r ? `data-plugin="${p()(r)}"` : ""}\n            draggable="false"\n    `;
        n && i ? o += ` data-appear-animation-name="${p()(i)}"` : i && (o += ` data-reveal="${p()(i)}"`), o += ">";
        let l = t,
            h = l;
        if (t.fallback || t.xs || t.sm || t.md || t.lg || t.xl || t.xxl || t.xxxl) {
            l = t.fallback || t.xs || t.sm || t.md || t.lg || t.xl || t.xxl || t.xxxl, h = l;
            const e = ["xxxl", "xxl", "xl", "lg", "md", "sm", "xs"],
                i = ["webp", "avif", "apng", "jpg", "png", "gif", "svg"];
            c()(i, t => {
                l[t] ? h = l[t] : l.src && l.src[t] && (h = {
                    width: l.width || null,
                    height: l.height || null,
                    src: l.src[t]
                })
            }), c()(e, e => {
                if (t[e] && t[e].width && t[e].height && (s = t[e].width, a = t[e].height), t[e] && t[e] !== h) {
                    let r = !1,
                        s = !1;
                    c()(i, n => {
                        t[e][n] ? r = !0 : t[e].src && t[e].src[n] && (r = !0, s = !0)
                    }), r ? s ? c()(i, i => {
                        if (t[e].src[i]) {
                            const r = {
                                width: t[e].width || null,
                                height: t[e].height || null,
                                src: t[e].src[i]
                            };
                            o += C(r, T(e), M(i), n)
                        }
                    }) : c()(i, i => {
                        t[e].src[i] && (o += C(t[e].src[i], T(e), M(i), n))
                    }) : o += C(t[e], T(e), null, n)
                }
            })
        }
        o += '<img draggable="false" ';
        let u = y(h);
        if (e.img && e.img.sizes && (u = "srcset", delete e.img.sizes), n) {
            const t = l || e,
                n = t.width || !1,
                i = t.height || !1;
            o += `\n            data-${u}="${g(h)}"\n            src="${S(n, i)}"\n        `, "srcset" === u && e.img && e.img.sizes && (o += `\n                srcset="${S(n, i)} 1w"\n            `)
        } else "srcset" === u ? (o += ` src="${v(h)}"`, o += ` srcset="${g(h, !0)}"`) : o += ` src="${g(h)}"`;
        return e.img && e.img.alt || (e.alt ? o += ` alt="${p()(e.alt)}"` : o += ' alt=""'), e.width && e.height ? o += ` width="${e.width}" height="${e.height}"` : s && a && (o += ` width="${s}" height="${a}"`), e.img && (o += w(e.img)), o += "></picture>", o
    }

    function P(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!t) return "";
        const n = !("lazy" in e) || e.lazy,
            i = A(e),
            r = (n ? "appear " : "") + (e["data-plugin"] || "");
        let s = `<img\n            class="${p()(e.class || "")} ${n ? "is-invisible--js is-hidden--no-js" : ""}"\n            ${"alt" in e ? "" : 'alt=""'}\n            draggable="false"\n            data-plugin="${p()(r)}"\n            ${w(m()(e, ["animation", "class", "lazy", "data-plugin"]))}\n    `;
        return n ? (s += t && "object" == typeof t ? ` data-srcset="${g(t)}"` : ` data-src="${g(t)}"`, s += ` src="${S(e.width || 0, e.height || 0)}"`) : t && "object" == typeof t ? (s += ` srcset="${g(t)}}"`, s += ` src="${v(t)}}"`) : s += ` src="${g(t)}"`, n && i ? s += ` data-appear-animation-name="${p()(i)}"` : i && (s += ` data-reveal="${p()(i)}"`), s += ">", s
    }
    const L = {
        each: c.a,
        numberFormat: h.a,
        transchoice: u.a,
        lazyImage: P,
        lazyPicture: R,
        image: function (t, e) {
            return t ? P(t, $.extend({}, e || {}, {
                lazy: !1
            })) : ""
        },
        picture: function (t, e) {
            return t ? R(t, $.extend({}, e || {}, {
                lazy: !1
            })) : ""
        },
        striptags: t => t.replace(/<\/?[^<>]+>/g, "")
    };
    class O {
        static get Defaults() {
            return {
                selector: 'script[type="text/template"]',
                removeSiblings: !1,
                insertMode: "append",
                postFilter: null
            }
        }
        constructor(t, e) {
            const n = i.a.extend({}, this.constructor.Defaults, e),
                r = t.find(n.selector).addBack(n.selector),
                a = !n.removeSiblings && r.prev(),
                o = !n.removeSiblings && r.next(),
                l = n.removeSiblings && r.prev(),
                c = r.parent(),
                h = this.tmplHTML = r.remove().html();
            let u;
            try {
                u = s()(h)
            } catch (t) {
                console.warn("Error parsing template", h), console.error(t)
            }
            this.dataVariableName = r.data("templateVariable") || null, this.$prev = a.length ? a : null, this.$next = o.length ? o : null, this.$parent = c.length ? c : null, this.$last = l.length ? l : null, this.template = u, this.options = n, this.allowHTMLCache = n.removeSiblings, this.replaceHTMLCache = null
        }
        reset() {
            const t = this.$prev,
                e = this.$next,
                n = this.$parent;
            let i = t ? t.next() : null;
            if (!t && e && (i = n.children().eq(0)), i) {
                let t;
                for (; i.length && (!e || !i.is(e));) t = i, i = i.next(), t.remove()
            } else n && !this.allowHTMLCache && n.empty();
            this.$last = null
        }
        compile(t) {
            const e = this.template,
                n = this.options.postFilter,
                r = this.options.insertMode,
                s = this.dataVariableName;
            let a = i.a.isArray(t) ? t : t ? [t] : [],
                o = 0,
                l = a.length,
                c = "";
            for (; o < l; o++) {
                let t = i.a.extend({
                    loop: {
                        index: o + 1,
                        index0: o,
                        first: 0 === o,
                        last: o == l - 1
                    }
                }, i.a.fn.template.vars);
                s ? t[s] = a[o] : t = i.a.extend(t, a[o]);
                try {
                    let n = e(i.a.extend({}, i.a.fn.template.vars, t));
                    "append" === r ? c += n : c = n + c
                } catch (e) {
                    window.console && (console.error("Error rendering template", e), console.error("Template:", this.tmplHTML), console.error("Data:", t))
                }
            }
            return "function" == typeof n && (c = String(n(c))), c
        }
        append(t) {
            const e = this.$parent;
            let n = this.$prev,
                r = this.$next,
                s = this.$last;
            const a = this.options.insertMode,
                o = this.compile(t);
            let l, c = !1;
            try {
                l = Object(i.a)(o), this.$last = "append" === a ? l.eq(-1) : l.eq(0)
            } catch (t) {
                this.$last = null
            }
            s && !s.parent().length && (s = e.children().eq(-1)), n && !n.parent().length && (n = e.children().eq(-1)), r && !r.parent().length && (r = e.children().eq(-1)), s && s.length ? ("append" === a ? s.after(l && l.length ? l : o) : s.before(l && l.length ? l : o), c = !0) : n && n.length ? (n.after(l && l.length ? l : o), c = !0) : r && r.length ? (r.before(l && l.length ? l : o), c = !0) : e && ("append" !== a && this.allowHTMLCache && this.replaceHTMLCache === o || (e.empty(), c = !0, "append" === a ? e.append(l && l.length ? l : o) : e.prepend(l && l.length ? l : o))), c && (this.replaceHTMLCache = o, e.plugins())
        }
        replace(t) {
            this.reset(), this.append(t)
        }
    }
    i.a.fn.template = o()(O), i.a.fn.template.vars = L
}, function (t, e) {
    t.exports = "\nuniform vec3 uColorNormal;\nuniform vec3 uColorDark;\nuniform vec3 uColorLight;\n\nuniform float uAlpha;\n\nuniform float uCoeficient;\nuniform float uPower;\n\n// 1.\n// varying vec2 vUv;\n\n// 2.d Alpha glow calculated in vertex shader\nvarying float vAlpha;\n\nvoid main() {\n    // 1. Fade out in the begining and in the end\n    // float alphaEdge = 0.3;\n    // float alpha = clamp(vUv.x, 0.0, alphaEdge) / alphaEdge * clamp(1.0 - vUv.x, 0.0, alphaEdge) / alphaEdge;\n\n    // 3. Final\n    vec3 color = uColorNormal;\n\n    // Light line color\n    color = mix(color, uColorLight, smoothstep(0.0, 0.0, vAlpha) * 1.0);\n\n    // Dark line color\n    color = mix(color, uColorDark, 1.0 - smoothstep(0.0, 0.15, vAlpha) * 1.0);\n\n\n    gl_FragColor = vec4(color, vAlpha);\n    if (gl_FragColor.a < 0.001) discard;\n}\n"
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return s
    })), n.d(e, "b", (function () {
        return o
    })), n.d(e, "c", (function () {
        return l
    }));
    var i = n(2),
        r = n.n(i);
    n(23);

    function s(t) {
        "undefined" == typeof grecaptcha && t.inview({
            destroyOnEnter: !0,
            enter: () => {
                a(t)
            }
        })
    }

    function a(t) {
        if ("undefined" == typeof grecaptcha) {
            const e = t.data("recaptchaNonce"),
                n = t.data("recaptcha3Key");
            r()(`<script src="https://www.google.com/recaptcha/api.js?render=${n}" ${e ? `nonce="${encodeURIComponent(e)}"` : ""} async>`).appendTo("body")
        }
    }

    function o(t) {
        t.find('input[name="g-recaptcha-token"]').remove()
    }

    function l(t) {
        return new Promise((e, n) => {
            const i = t.data("recaptcha3Key");
            i || console.warn("Google recaptcha V3 site key is not set"), "undefined" != typeof grecaptcha ? grecaptcha.ready(() => {
                grecaptcha.execute(i, {
                    action: "form"
                }).then(n => {
                    ! function (t, e) {
                        if (t.is("a")) {
                            let n = t.attr("href");
                            n && (n = n.replace(/[?&]g-recaptcha-token=[^&]+/, ""), n = n + (n.includes("?") ? "&" : "?") + "g-recaptcha-token=" + e, t.attr("href", n))
                        } else {
                            let n = t.find('input[name="g-recaptcha-token"]');
                            n.length || (n = r()('<input type="hidden" name="g-recaptcha-token" />').appendTo(t)), n.val(e)
                        }
                    }(t, n), e()
                }).catch(t => {
                    console.log(`Google recaptcha execute failed, make sure key "${i}" is registered for the domain "${document.location.host}"`), console.error(t), n(t)
                })
            }) : (a(t), new Promise(t => {
                const e = setInterval(() => {
                    "undefined" != typeof grecaptcha && (clearInterval(e), t())
                }, 60)
            }).then(() => {
                l(t).then(t => {
                    e(t)
                }, t => {
                    n(t)
                })
            }))
        })
    }
}, , function (t, e, n) {
    var i = n(264),
        r = n(308),
        s = n(123),
        a = n(26),
        o = n(317);
    t.exports = function (t) {
        return "function" == typeof t ? t : null == t ? s : "object" == typeof t ? a(t) ? r(t[0], t[1]) : i(t) : o(t)
    }
}, function (t, e, n) {
    var i = n(208),
        r = n(303),
        s = n(66);
    t.exports = function (t) {
        return s(t) ? i(t) : r(t)
    }
}, function (t, e, n) {
    var i = n(169),
        r = n(126);
    t.exports = function (t, e, n, s) {
        var a = !n;
        n || (n = {});
        for (var o = -1, l = e.length; ++o < l;) {
            var c = e[o],
                h = s ? s(n[c], t[c], c, n, t) : void 0;
            void 0 === h && (h = t[c]), a ? r(n, c, h) : i(n, c, h)
        }
        return n
    }
}, function (t, e) {
    $.fn.findElement = function (t) {
        if (!t) return null;
        let e = $(),
            n = null;
        return "string" == typeof t && 0 === t.indexOf(":root ") && (t = t.replace(":root ", ""), n = $(document)), this.each((function () {
            const i = n || $(this);
            e = e.add(i.find(t).addBack(t))
        })), e.length ? e : null
    }
}, function (t, e, n) {
    var i = n(156);
    t.exports = function (t, e) {
        return i(t, e)
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return f
    }));
    var i = n(1),
        r = n(3),
        s = n.n(r),
        a = n(7),
        o = n(23),
        l = n(6),
        c = (n(30), n(33));
    const h = 'iframe[data-plugin*="appear"], img[data-plugin*="appear"], picture[data-plugin*="appear"]';

    function u(t) {
        const e = a.a.matches("md-up") ? ".is-hidden--md-up" : ".is-hidden--sm-down";
        return t.filter((t, n) => 0 === Object(i.a)(n).closest(e).length)
    }

    function d(t, e) {
        const n = e.closest(".modal");
        return t.filter((t, e) => {
            const r = Object(i.a)(e).closest(".modal");
            return !!(!r.length || n.length && r.is(n))
        })
    }

    function p(t, e, n) {
        const r = u(d(function (t) {
            return t.find(h).addBack(h).filter((t, e) => -1 !== i.a.app.getPlugins(e, i.a.app.settings).indexOf("appear"))
        }(t), t).app(["appear"])),
            s = u(d(function (t) {
                return t.find("img").not('[data-plugin*="appear"]').not('picture[data-plugin*="appear"] img')
            }(t), t)),
            a = function (t) {
                return t.find("video").filter((t, e) => {
                    const n = e.getBoundingClientRect();
                    return n && n.height && n.top < window.innerHeight
                })
            }(t),
            o = Date.now();
        let l = r.length + s.length + a.length,
            c = l;
        const p = function (t) {
            if (!t.data("preloaded")) {
                if (t.data("preloaded", !0), c--, "function" == typeof n) {
                    const t = Date.now() - o;
                    n({
                        total: l,
                        progress: l - c,
                        timeRemaining: t / (l - c) * c
                    })
                }
                c || e()
            }
        };
        a.each((t, e) => {
            const n = Object(i.a)(e);
            if (n.find("source[data-src]").each((t, e) => {
                const n = Object(i.a)(e);
                n.attr("src", n.attr("data-src"))
            }).length) {
                const t = Object(i.a)(),
                    r = n.next(),
                    s = n.parent();
                t.append(e), r.length ? r.before(n) : s.append(n)
            }
        }), a.filter((t, e) => e.readyState !== HTMLMediaElement.HAVE_ENOUGH_DATA ? (l--, c--, !1) : (e.load(), !0)).on("canplay", t => {
            p(Object(i.a)(t.target))
        }), r.appear("load", p), s.filter((t, e) => !e.complete || (l--, c--, !1)).on("load error", t => {
            p(Object(i.a)(t.target))
        }), c || e()
    }
    class f {
        static get Defaults() {
            return {
                enableMq: "md-up",
                content: "",
                minDelay: 2e3,
                animationNameIn: "slow fade-in",
                animationNameOut: "slow fade-out",
                reveal: !0,
                autoPreload: !0,
                autoHide: !0,
                showIfSplashScreen: !1,
                hideIfSplashScreen: !1
            }
        }
        constructor(t, e) {
            this.options = i.a.extend({}, this.constructor.Defaults, e), this.$container = t, this.$content = null, this.preloadIntervalHandle = null, this.completeTimerHandle = null, this.preloadState = null, this.readyPromise = i.a.Deferred(), this.isLoading = !1, this.isCompleted = !1, this.loaders = [], t.on("destroyed", this.destroy.bind(this)), this.setOptions(e)
        }
        addLoader(t) {
            var e = this;
            let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const r = {
                promise: i.a.Deferred(),
                progress: 0,
                total: n.total || 1,
                complete: !1,
                weight: "number" == typeof n.weight ? n.weight : null,
                setProgress: function (t) {
                    let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                    null !== n && (r.total = n || 1), r.progress = Math.min(r.total, t), e.update(), r.progress === r.total && (r.complete = !0, r.promise.resolve && r.promise.resolve())
                },
                setComplete: () => {
                    r.progress = r.total, r.complete = !0, this.update(), r.promise.resolve && r.promise.resolve()
                }
            },
                s = t(r);
            this.loaders.push(r), s && s instanceof Promise ? s.then(t => {
                r.promise.resolve(t)
            }) : s && s.then && (r.promise = s)
        }
        setOptions(t) {
            i.a.extend(this.options, t), this.$content = this.getContent(), this.inview && (this.inview.destroy(), this.inview = null), this.checkIfShouldShow() ? this.forceShow() : this.checkIfShouldHide() ? this.forceHide() : this.options.autoPreload && (this.inview = new o.a(this.$container, {
                enter: this.preload.bind(this),
                destroyOnEnter: !0
            }))
        }
        checkIfShouldShow() {
            const t = !this.getCookie();
            return !(!this.options.showIfSplashScreen || !t)

        }
        checkIfShouldHide() {
            const t = !this.getCookie();
            return !(!this.options.hideIfSplashScreen || !t) || !(!this.options.showIfSplashScreen || t)
        }
        getCookie() {
            return c.a.get("introSeen")
        }
        setCookie() {
            c.a.set("introSeen", !0, 1)
        }
        getContent() {
            const t = this.$container;
            if (this.options.content) return Object(i.a)(this.options.content);
            {
                const e = t.closest(".modal");
                return e.length ? e : Object(i.a)(".js-page-content, .header")
            }
        }
        destroy() {
            this.$content = Object(i.a)(), this.destroyTimers(), this.destroyLoaders(), this.inview && (this.inview.destroy(), this.inview = null)
        }
        destroyTimers() {
            this.preloadIntervalHandle && (clearInterval(this.preloadIntervalHandle), this.preloadIntervalHandle = null), this.completeTimerHandle && (clearTimeout(this.completeTimerHandle), this.completeTimerHandle = null)
        }
        destroyLoaders() {
            this.loaders = []
        }
        preload() {
            this.inview && (this.inview.destroy(), this.inview = null), this.isLoading || (this.isLoading = !0, !this.options.enableMq || a.a.matches(this.options.enableMq) ? (this.handleStart(), this.preloadState = {
                progress: 0,
                total: 0
            }, this.preloadIntervalHandle = setInterval(this.update.bind(this), 16), this.setupLoaders(), i.a.when.apply(i.a, this.loaders.map(t => t.promise)).then(() => {
                this.readyPromise.resolve()
            })) : this.readyPromise.resolve(), this.readyPromise.then(this.handleComplete.bind(this)))
        }
        setupContentLoader() {
            this.addLoader(t => {
                let {
                    setProgress: e
                } = t;
                return n = this.$content, r = t => {
                    let {
                        progress: n,
                        total: i
                    } = t;
                    e(n, i)
                }, new Promise(t => {
                    p(Object(i.a)(n), t, r)
                });
                var n, r
            })
        }
        setupTimerLoader() {
            const t = l.a.isReducedMotion() ? 0 : this.options.minDelay;
            t && this.addLoader(e => {
                let {
                    setProgress: n,
                    setComplete: i
                } = e, r = Date.now(), s = setInterval(() => {
                    n((Date.now() - r) / t)
                }, 16);
                setTimeout(() => {
                    clearInterval(s), i()
                }, t)
            }, {
                total: 1,
                weight: 1
            })
        }
        setupLoaders() {
            this.setupContentLoader(), this.setupTimerLoader()
        }
        update() {
            const t = this.loaders,
                e = {
                    progress: 0,
                    total: 0,
                    percentage: 0,
                    complete: !0
                };
            let n = 1;
            const i = [{
                progress: 0,
                total: 0,
                weight: 1
            }];
            for (let r = 0; r < t.length; r++) {
                const s = t[r];
                e.progress += s.progress, e.total += s.total, s.complete || (e.complete = !1), "number" == typeof s.weight ? (n += s.weight, i.push({
                    progress: s.progress,
                    total: s.total,
                    weight: s.weight
                })) : (i[0].progress += s.progress, i[0].total += s.total)
            }
            for (let t = 0; t < i.length; t++) {
                const r = i[t];
                e.percentage += (r.total ? r.progress / r.total : 1) * r.weight / n
            }
            e.percentage = Math.max(0, Math.min(1, e.percentage)), this.$container.trigger("progress.preloader", e).get(0).style.setProperty("--progress", e.percentage)
        }
        handleStart() {
        }
        handleComplete() {
            this.complete()
        }
        complete() {
            if (!this.isCompleted) {
                this.isCompleted = !0, this.isLoading = !1, this.$container.trigger("complete.preloader"), this.destroyTimers(), this.destroyLoaders(), this.options.autoHide && (this.completeTimerHandle = setTimeout(this.hide.bind(this), 60));
                const t = this.options.reveal;
                if (t && "function" == typeof i.a.fn.reveal) {
                    const e = "object" == typeof t ? t : {};
                    this.$content.reveal(e)
                }
                this.readyPromise = i.a.Deferred()
            }
        }
        show() {
            const t = this.$container,
                e = this.options.animationNameIn;
            t.hasClass("is-hidden") && (e ? (this.handleStart(), t.attr("aria-hidden", "false").trigger("open.preloader").transition(e, () => {
                t.trigger("opened.preloader")
            })) : t.attr("aria-hidden", "false").removeClass("is-hidden").trigger("open.preloader").trigger("opened.preloader"))
        }
        hide() {
            const t = this.$container,
                e = this.options.animationNameOut;
            t.hasClass("is-hidden") || (e ? t.trigger("close.preloader").attr("aria-hidden", "true").transition(e, this.afterHide.bind(this)) : (t.trigger("close.preloader").attr("aria-hidden", "true").addClass("is-hidden"), this.afterHide()))
        }
        forceShow() {
            this.$container.attr("aria-hidden", "false").trigger("open.preloader").removeClass("is-hidden"), this.options.autoPreload && this.preload()
        }
        forceHide() {
            this.$container.trigger("close.preloader").attr("aria-hidden", "true").addClass("is-hidden")
        }
        afterHide() {
            this.$container.trigger("closed.preloader"), this.isCompleted = !1, this.update(), this.showComagic()
        }
        showComagic() {
            Object(i.a)("html").hasClass("comagic-disabled") && Object(i.a)("html").removeClass("comagic-disabled")
        }
        ready() {
            return this.readyPromise
        }
    }
    i.a.fn.preloader = s()(f)
}, function (t, e, n) {
    "use strict";

    function i(t) {
        var e = {},
            n = $(t).css("transform");
        if (n) {
            var i = n.match(/^matrix3d\((.+)\)$/);
            if (i) return parseFloat(i[1].split(", ")[13]);
            i = n.match(/^matrix\((.+)\)$/), e.x = i ? parseFloat(i[1].split(", ")[4]) : 0, e.y = i ? parseFloat(i[1].split(", ")[5]) : 0
        } else e.x = 0, e.y = 0;
        return e
    }
    n.d(e, "a", (function () {
        return i
    }))
}, function (t, e, n) {
    "use strict";

    function i(t, e, n, i, r) {
        return 0 === e ? n : i * Math.pow(2, 10 * (e / r - 1)) + n
    }

    function r(t, e, n, i, r) {
        return e === r ? n + i : i * (1 - Math.pow(2, -10 * e / r)) + n
    }

    function s(t, e, n, i, r) {
        return 0 === e ? n : e === r ? n + i : (e /= r / 2) < 1 ? i / 2 * Math.pow(2, 10 * (e - 1)) + n : i / 2 * (2 - Math.pow(2, -10 * --e)) + n
    }

    function a(t, e, n, i, r) {
        const s = e / r;
        return s * s * i + n
    }

    function o(t, e, n, i, r) {
        const s = e / r;
        return (2 * s - s * s) * i + n
    }

    function l(t, e, n, i, r) {
        return i * (e /= r) * e + n
    }

    function c(t, e, n, i, r) {
        return -i * (e /= r) * (e - 2) + n
    }

    function h(t, e, n, i, r) {
        return (e /= r / 2) < 1 ? i / 2 * e * e + n : -i / 2 * (--e * (e - 2) - 1) + n
    }
    n.r(e), n.d(e, "easeInExpo", (function () {
        return i
    })), n.d(e, "easeOutExpo", (function () {
        return r
    })), n.d(e, "easeInOutExpo", (function () {
        return s
    })), n.d(e, "easeSectionInverse", (function () {
        return a
    })), n.d(e, "easeSection", (function () {
        return o
    })), n.d(e, "easeInQuad", (function () {
        return l
    })), n.d(e, "easeOutQuad", (function () {
        return c
    })), n.d(e, "easeInOutQuad", (function () {
        return h
    }))
}, , , function (t, e, n) {
    var i = n(111),
        r = n(161);
    t.exports = function (t) {
        return null != t && r(t.length) && !i(t)
    }
}, function (t, e, n) {
    var i = n(208),
        r = n(350),
        s = n(66);
    t.exports = function (t) {
        return s(t) ? i(t, !0) : r(t)
    }
}, function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(1),
        r = n(3),
        s = n.n(r);
    i.a.fn.inputState = s()((function (t) {
        function e() {
            const e = t.find("input, select, textarea").not("[disabled], [readonly]");
            if (e.length) {
                const n = function (t) {
                    let e = !0;
                    for (let n = 0; n < t.length; n++) {
                        const i = t.eq(n);
                        if (i.is('input[type="date"]')) e = !1;
                        else if (i.is('input[type="checkbox"]')) i.prop("checked") && (e = !1);
                        else if (i.is('input[type="radio"]')) i.prop("checked") && (e = !1);
                        else if (i.is("input, select, textarea")) {
                            (i.val() || "").trim().length ? e = !1 : i.is("select") || "menulist-button" !== i.css("appearance") || (e = !1)
                        }
                    }
                    return !e
                }(e);
                t.find("input, select, textarea").each((t, e) => {
                    e.value
                }), e.is("select") || t.toggleClass("is-focused", e.is(document.activeElement)), t.toggleClass("is-not-empty", n)
            }
        }

        function n() {
            setTimeout(e, 16)
        }
        t.on("input change focus blur", "input, select, textarea, [tabindex]", e), t.closest("form").on("reset", n), n(), setTimeout(e, 600), e()
    })), Object(i.a)(window).on("load", () => {
        Object(i.a)(document.activeElement).is('a, button, [role="button"], input, textarea, select, .modal') || document.activeElement.click()
    })
}, function (t, e, n) {
    "use strict";
    n.r(e), n.d(e, "default", (function () {
        return o
    }));
    var i = n(1),
        r = n(3),
        s = n.n(r),
        a = n(8);
    class o extends a.a {
        static get Defaults() {
            return i.a.extend({}, a.a.Defaults, {
                enableMq: "sm-down",
                listSelector: ".js-mobile-scrollable-list",
                itemSelector: ".mobile-scrollable__item",
                counterSelector: ".js-mobile-scrollable-counter",
                nextSelector: ".js-mobile-scrollable-next",
                prevSelector: ".js-mobile-scrollable-prev"
            })
        }
        open(t) {
            if (this.index !== t) {
                this.index = t, this.isCardsProgrammatic = !0, this.setCounter(t), this.handleChange();
                this.$items.eq(t).get(0).scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "center"
                })
            }
        }
        swap(t) {
            if (this.index !== t) {
                this.index = t, this.isCardsProgrammatic = !0, this.setCounter(t), this.handleChange();
                this.$items.eq(t).get(0).scrollIntoView({
                    behavior: "auto",
                    block: "nearest",
                    inline: "center"
                })
            }
        }
        next() {
            const t = this.$items.length,
                e = (this.index + 1) % t;
            this.open(e), this.triggerEvent("next.mobile-scrollable")
        }
        prev() {
            const t = this.$items.length,
                e = (this.index - 1 + t) % t;
            this.open(e), this.triggerEvent("prev.mobile-scrollable")
        }
        getItems() {
            return this.$items
        }
        init() {
            this.isCardsProgrammatic = !1, this.$scrollable = this.$container.find(this.options.listSelector), this.$counter = this.$container.find(this.options.counterSelector), this.$items = this.$container.find(this.options.itemSelector), this.$next = this.$container.find(this.options.nextSelector), this.$prev = this.$container.find(this.options.prevSelector), this.index = 0
        }
        enable() {
            if (super.enable()) return this.$scrollable.on("scroll." + this.ns, this.handleScroll.bind(this)), this.$scrollable.on("touchstart." + this.ns, this.handleTouchStart.bind(this)), this.$next.on("click." + this.ns, this.next.bind(this)), this.$prev.on("click." + this.ns, this.prev.bind(this)), !0
        }
        disable() {
            if (super.disable()) return this.$scrollable.off("." + this.ns), !0
        }
        destroy() {
            super.destroy()
        }
        handleScroll() {
            if (!this.isCardsProgrammatic) {
                const t = this.$scrollable,
                    e = this.$items.length,
                    n = t.scrollLeft(),
                    i = t.get(0).scrollWidth - t.get(0).offsetWidth,
                    r = i ? Math.round(n / i * (e - 1)) : 0;
                r !== this.index && (this.index = r, this.setCounter(r), this.handleChange())
            }
        }
        handleChange() {
            this.triggerEvent("change.mobile-scrollable")
        }
        triggerEvent(t) {
            this.$container.trigger(t, {
                index: this.index,
                count: this.$items.length
            })
        }
        setCounter(t) {
            this.$counter.text(t + 1), this.$items.removeClass("is-active");
            this.$items.eq(t).addClass("is-active")
        }
        handleTouchStart() {
            this.isCardsProgrammatic = !1
        }
    }
    i.a.fn.mobileScrollable = s()(o, {
        api: ["open", "swap", "next", "prev", "instance", "getItems"]
    })
}, function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(2),
        r = n.n(i),
        s = n(3),
        a = n.n(s),
        o = n(138),
        l = n(9);
    n(38);
    r.a.fn.tooltip = a()(class {
        static get Defaults() {
            return {
                container: document.documentElement.getBoundingClientRect(),
                margin: 10,
                position: "top-middle",
                eventShow: "show.tooltip",
                eventShown: "shown.tooltip",
                eventHide: "hide.tooltip",
                eventHidden: "hidden.tooltip",
                animationIn: "fade-in",
                animationOut: "fade-out",
                nowrap: !1,
                parentSelector: !1,
                class: ""
            }
        }
        constructor(t, e) {
            this.options = r.a.extend({}, this.constructor.Defaults, e), this.popper = null, this.ns = Object(l.a)(), this.id = t.attr("aria-controls") || this.ns, this.$tooltipClass = this.options.class, this.$container = t, this.$tooltip = r()(), this.bindEvents()
        }
        bindEvents() {
            this.$container.on("mouseenter." + this.ns, this.show.bind(this)).on("mouseleave." + this.ns, this.hide.bind(this)).on("destroyed", this.destroy.bind(this))
        }
        createPopper() {
            const t = this.id;
            this.$container.attr("aria-controls", t);
            const e = this.$tooltipClass;
            this.options.nowrap ? this.$tooltip = r()(`<div class="tooltip tooltip--nowrap ${e}" id="${t}"><div class="tooltip__inner"><div class="leading-trim">${this.$container.attr("data-title")}</div></div></div>`) : this.$tooltip = r()(`<div class="tooltip ${e}" id="${t}"><div class="tooltip__inner"><div class="leading-trim">${this.$container.attr("data-title")}</div></div></div>`);
            let n = r()();
            this.options.parentSelector && (n = this.$container.closest(this.options.parentSelector), n.length && n.append(this.$tooltip[0])), n.length || this.$container.after(this.$tooltip[0]), this.popper = Object(o.a)(this.$container[0], this.$tooltip[0], this.options), this.options.animationIn && this.$tooltip.addClass("is-hidden")
        }
        show(t) {
            const e = r.a.Event(this.options.eventShow);
            this.$container.trigger(e), this.popper || this.createPopper(), this.$tooltip.addClass("is-active").transitionstop(() => {
                this.$tooltip.transition(this.options.animationIn, {
                    before: this.onShow.bind(this, t),
                    after: this.onShown.bind(this, t)
                })
            })
        }
        hide(t) {
            const e = r.a.Event(this.options.eventHide);
            this.$container.trigger(e), this.$tooltip.transitionstop(() => {
                this.$tooltip.transition(this.options.animationOut, {
                    after: this.onHidden.bind(this, t)
                })
            })
        }
        onShow() {
            this.updatePopper(), r()(window).on("resize." + this.ns, this.updatePopper.bind(this))
        }
        onShown() {
            const {
                eventShown: t
            } = this.options;
            this.$container.trigger(t)
        }
        onHidden() {
            const {
                eventHidden: t
            } = this.options;
            this.$tooltip.removeClass("is-active"), this.$container.trigger(t), r()(window).off("resize." + this.ns)
        }
        updatePopper() {
            let t = this.popper.update();
            const e = this.$tooltipClass;
            t && t.pos && (this.options.nowrap ? this.$tooltip.attr("class", `tooltip tooltip--nowrap ${e} tooltip--${t.pos}`) : this.$tooltip.attr("class", `tooltip ${e} tooltip--${t.pos}`))
        }
        destroy() {
            r()(window).off("resize." + this.ns), this.$container.off("." + this.ns), this.$tooltip.remove(), this.popper = null
        }
    })
}, function (t, e) {
    t.exports = function (t, e) {
        return t === e || t != t && e != e
    }
}, function (t, e, n) {
    var i = n(275),
        r = n(280);
    t.exports = function (t, e) {
        var n = r(t, e);
        return i(n) ? n : void 0
    }
}, function (t, e, n) {
    var i = n(83),
        r = n(276),
        s = n(277),
        a = i ? i.toStringTag : void 0;
    t.exports = function (t) {
        return null == t ? void 0 === t ? "[object Undefined]" : "[object Null]" : a && a in Object(t) ? r(t) : s(t)
    }
}, function (t, e) {
    t.exports = function (t, e) {
        for (var n = -1, i = null == t ? 0 : t.length, r = Array(i); ++n < i;) r[n] = e(t[n], n, t);
        return r
    }
}, function (t, e, n) {
    var i = n(335),
        r = n(337)(i);
    t.exports = r
}, function (t, e, n) {
    "use strict";
    n(1).a.event.special.destroyed = {
        remove: function (t) {
            t.handler && t.handler()
        }
    }
}, function (t, e, n) {
    "use strict";
    n.r(e), n.d(e, "default", (function () {
        return g
    }));
    var i = n(1),
        r = n(3),
        s = n.n(r),
        a = (n(133), n(11)),
        o = n.n(a),
        l = n(12),
        c = n.n(l),
        h = n(5),
        u = n.n(h),
        d = n(60),
        p = n.n(d),
        f = n(14),
        m = n(40);
    class g {
        static get Defaults() {
            return {
                formatter: "number"
            }
        }
        constructor(t, e) {
            const n = this.$container = Object(i.a)(t),
                r = n.find("input").not(".js-input-range-ignore");
            this.$inputsNumber = n.closest(".filter-item--range").find('[data-input-type="number"]'), this.inputs = c()(r.toArray(), t => Object(i.a)(t)), this.connectors = [], this.options = i.a.extend({
                step: parseFloat(r.eq(0).attr("step")) || 1
            }, this.getConstraints(), this.constructor.Defaults, e), this.handles = [], this.activeHandle = null, r.closest("form").on("reset", o()(this.updateUI.bind(this), 16)), this.createStructure()
        }
        getConstraints() {
            if (this.options) return this.options;
            {
                const t = this.inputs[0];
                return {
                    min: parseFloat(t.attr("min")) || 0,
                    max: parseFloat(t.attr("max")) || 0
                }
            }
        }
        createStructure() {
            const t = this.value(),
                e = g.formatter[this.options.formatter] || g.formatter.default,
                n = c()(t, (t, n) => Object(i.a)(e.handle(t, n)));
            this.$container.append(n), this.connectors = c()(n, t => t.filter(".js-connector")), this.handles = c()(n, t => t.filter(".js-handle")), this.texts = c()(n, t => t.filter(".js-text")), u()(this.handles, (t, e) => {
                t.draggable({
                    activationDistance: 0,
                    preventScroll: !0
                }).on("draggable:start", this.handleDragStart.bind(this, e)).on("draggable:move", this.handleDragMove.bind(this)).on("draggable:end", this.handleDragEnd.bind(this)).on("keydown", this.handleKey.bind(this, e))
            }), u()(this.inputs, t => {
                t.on("input change", this.updateUI.bind(this, null)).on("blur", this.checkValue.bind(this)).on("focus", () => {
                    "number" == this.inputs[0].attr("type") && this.inputs[0].select()
                }).on("mouseup", t => {
                    t.preventDefault()
                })
            }), this.$inputsNumber.on("input change", this.inputChangeHandler.bind(this)), this.$inputsNumber.on("change", this.setMinMaxValue.bind(this)), this.$container.on("input change", this.handlesChangeHandler.bind(this)), 1 === this.connectors.length && this.$container.addClass("form-control-range--single"), this.updateUI()
        }
        handlesChangeHandler() {
            this.updateInputNumberUI(Object(f.a)(this.$container))
        }
        inputChangeHandler() {
            const t = this.$inputsNumber,
                e = this.inputs,
                n = [];
            for (let e = 0; e < t.length; e++) {
                const i = t.eq(e),
                    r = this.normalizeValue(i.val());
                n.push(r)
            }
            n.sort((t, e) => t - e);
            for (let t = 0; t < n.length; t++) e[t].val(n[t]);
            Object(i.a)(document.activeElement).is(t) || this.updateInputNumberUI(n), this.updateUI(n)
        }
        setMinMaxValue(t) {
            const e = Object(i.a)(t.currentTarget);
            e.parent().hasClass("form-control--min") && this.normalizeValue(e.val()) < this.getMin() && e.val(this.getMin()), e.parent().hasClass("form-control--min") && this.normalizeValue(e.val()) > this.getMax() && e.val(this.getMax()), e.parent().hasClass("form-control--max") && this.normalizeValue(e.val()) > this.getMax() && e.val(this.getMax()), e.parent().hasClass("form-control--max") && this.normalizeValue(e.val()) < this.getMin() && e.val(this.getMin())
        }
        checkValue() {
            c()(this.inputs, t => {
                "" == t.val() ? (t.val(this.formatValue(t.attr("min") || 0)), t.trigger("change")) : parseFloat(t.val()) > parseFloat(t.attr("max")) && (t.val(this.formatValue(t.attr("max") || 0)), t.trigger("change"))
            })
        }
        value() {
            let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            const e = this.inputs,
                n = c()(e, t => t.val());
            if (null === t) return this.normalizeValue(n);
            {
                const r = this.normalizeValue(t);
                if (!p()(r, n)) {
                    let t = Object(i.a)();
                    u()(e, (e, n) => {
                        e.val(Math.round(r[n])), t = t.add(e)
                    }), t.change()
                }
            }
        }
        increase(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            const n = this.value();
            n[t] += this.options.step * e, this.value(n)
        }
        decrease(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            const n = this.value();
            n[t] -= this.options.step * e, this.value(n)
        }
        valueComponentToPercentage(t) {
            const e = this.getConstraints();
            return (t - e.min) / (e.max - e.min)
        }
        percentageToValue(t) {
            const e = this.getConstraints();
            return (e.max - e.min) * Math.max(0, Math.min(1, t)) + e.min
        }
        valueComponentToPx(t) {
            return this.valueComponentToPercentage(t) * this.$container.width()
        }
        pxToValueComponent(t) {
            const e = this.getConstraints(),
                n = this.options.step,
                i = Math.min(1, Math.max(0, t / this.$container.width()));
            let r = this.percentageToValue(i);
            return r !== e.min && r !== e.max && (r = Math.round(r / n) * n), this.normalizeValue([r])[0]
        }
        formatValue(t) {
            return Object(m.a)(this.normalizeValue(t), 0)
        }
        normalizeValue(t) {
            const e = this.getConstraints();
            let n = !1;
            Array.isArray(t) || (n = !0, t = [t]);
            const i = c()(t, t => {
                "string" == typeof t && (t = t.replace(/\s/g, ""));
                const n = parseFloat(t) || 0;
                return Math.min(e.max, Math.max(e.min, n))
            }).sort((t, e) => t > e ? 1 : t === e ? 0 : -1);
            return n ? i[0] : i
        }
        handleDragStart(t, e, n) {
            n.memory.lineOffset = 0, n.memory.lineWidth = this.$container.width(), n.memory.startValue = this.value()[t], n.memory.startOffset = this.valueComponentToPx(n.memory.startValue), this.activeHandle = t, this.handles[t].addClass("is-active")
        }
        handleDragMove(t, e) {
            const n = this.inputs,
                i = e.memory.startOffset + e.deltaXY[0],
                r = Math.round(this.pxToValueComponent(i)),
                s = this.activeHandle;
            n[s].val(r);
            const a = c()(n, t => parseFloat(t.val()));
            let o = a.indexOf(r);
            a.sort((t, e) => t > e ? 1 : t === e ? 0 : -1);
            let l = a.indexOf(r);
            o !== l && (u()(a, (t, e) => {
                n[e].val(t)
            }), this.activeHandle = l), n[s].change()
        }
        handleDragEnd() {
            const t = this.handles;
            for (var e = 0; e < t.length; ++e) t[e].removeClass("is-active")
        }
        handleKey(t, e) {
            33 === e.which || e.shiftKey && 39 === e.which ? (this.increase(t, 10), e.preventDefault()) : 34 === e.which || e.shiftKey && 37 === e.which ? (this.decrease(t, 10), e.preventDefault()) : 37 === e.which || 40 === e.which ? (this.decrease(t), e.preventDefault()) : 38 !== e.which && 39 !== e.which || (this.increase(t), e.preventDefault())
        }
        updateUI(t) {
            const e = g.formatter[this.options.formatter] || g.formatter.default;
            Array.isArray(t) && "number" == typeof t[0] && "number" == typeof t[1] || (t = this.value()), u()(this.handles, (e, n) => {
                let i = this.valueComponentToPercentage(t[n]);
                isNaN(i) && (i = n), e.css("transform", `translateX(${100 * i}%)`)
            }), u()(this.texts, (n, i) => {
                isNaN(t[i]) ? n.html("-") : n.html(e.text(t[i], i))
            }), u()(this.connectors, (e, n) => {
                const i = 0 === n ? this.getConstraints().min : t[n - 1],
                    r = t[n];
                let s = this.valueComponentToPercentage(i),
                    a = this.valueComponentToPercentage(r);
                isNaN(s) && (s = 0), isNaN(a) && (a = 1), e.css("transform", `translateX(${100 * s}%) scaleX(${a - s})`)
            })
        }
        updateInputNumberUI(t) {
            const e = this.$inputsNumber;
            for (let n = 0; n < t.length; n++) {
                const i = "number" == typeof t[n] ? t[n] : t[n].value,
                    r = this.formatValue(i);
                e.eq(n).val(r)
            }
        }
        setMin(t) {
            this.options.min !== t && (u()(this.inputs, e => e.attr("min", t)), this.options.min = t, this.updateUI(this.value()))
        }
        setMax(t) {
            this.options.max !== t && (u()(this.inputs, e => e.attr("max", t)), this.options.max = t, this.updateUI(this.value()))
        }
        getMax() {
            return this.options.max
        }
        getMin() {
            return this.options.min
        }
    }
    i.a.fn.range = s()(g, {
        api: ["instance", "value", "increase", "decrease", "setMin", "setMax", "getMax", "getMin"]
    }), g.formatter = i.a.fn.range.formatter = {
        default: {
            handle: function (t, e) {
                return `\n                <div class="form-control-range__connector form-control-range__connector--${e + 1} js-connector"></div>\n                <div class="form-control-range__handle js-handle" tabindex="-1">\n                    <button area-hidden="true" type="button" class="form-control-range__handle__pin"></button>\n                </div>\n            `
            },
            text: function (t, e) {
                return "" + Object(m.a)(t, 0)
            }
        }
    }
}, function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(1),
        r = n(3),
        s = n.n(r),
        a = n(11),
        o = n.n(a),
        l = n(15),
        c = n.n(l),
        h = (n(76), n(7)),
        u = n(14),
        d = n(35);
    i.a.fn.pageHistory = s()(class {
        constructor() {
            const t = this.entries = Object(d.read)("historyEntries") || [],
                e = this.getPageUrl();
            t.length && t[t.length - 1] === e || Object(d.save)("historyEntries", [].concat(t, e).slice(-15))
        }
        normalizeUrl(t) {
            return t.replace(/#.*$/)
        }
        getPageUrl() {
            return this.normalizeUrl(location.pathname + location.search)
        }
        isValidParent(t, e) {
            const n = this.entries;
            for (let i = n.length - 1; i >= 0; i--) {
                if (n[i] === t) return !0;
                {
                    let t = !1;
                    for (let r = 0; r < e.length; r++)
                        if ("string" == typeof e[r]) {
                            if (e[r] === n[i]) {
                                t = !0;
                                break
                            }
                        } else if (e[r] instanceof RegExp && n[i].match(e[r])) {
                            t = !0;
                            break
                        }
                    if (!t) return !1
                }
            }
            return !1
        }
    }), i.a.fn.filterFormSave = s()((function (t) {
        const e = Object(i.a)("form.js-ajax-filters-inline"),
            n = Object(i.a)("form.js-ajax-filters-modal"),
            r = e.add(n),
            s = Object(d.read)("filters");
        let a = location.pathname + location.search;
        s && s.values && s.url && (a === s.url || a.indexOf("visual-search/building") > -1) && requestAnimationFrame(() => {
            Object(u.d)(r, s.values), e.submit()
        });
        const l = function () {
            const t = function () {
                let t = Object(u.a)(n);
                return h.a.matches("md-up") && (t = Object(u.b)(t, Object(u.a)(e))), t
            }(),
                i = Object(u.c)(t);
            a = location.pathname + "?" + i, Object(d.save)("filters", {
                values: t,
                url: a
            }), history.pushState(t, "", a), c.a.history.current && (c.a.history.current.url = a)
        };
        e.on("change", "input[name], textarea[name], select[name]", o()(l, 60)).on("input", 'input[name][type="search"]', o()(l, 60)), n.on("submit", l).on("reset", o()(l, 60))
    })), i.a.fn.filterExclude = s()((function (t) {
        location.search && ~location.search.indexOf("exclude-reserved=on") && Object(i.a)("#exclude-reserved").prop("checked", "checked")
    })), i.a.fn.filterBack = s()((function (t) {
        if (Object(d.read)("filters")) {
            const e = Object(d.read)("filters").url;
            t.attr("href", e)
        }
    }))
}, function (t, e, n) {
    "use strict";
    n.r(e), n.d(e, "default", (function () {
        return d
    }));
    var i = n(2),
        r = n.n(i),
        s = n(3),
        a = n.n(s),
        o = n(12),
        l = n.n(o),
        c = n(5),
        h = n.n(c),
        u = (n(128), n(38), n(84), n(8));
    class d extends u.a {
        static get Defaults() {
            return r.a.extend({}, u.a.Defaults, {
                headingSelector: "[aria-controls]:not([data-accordion-heading-id]), [data-tabs-heading-id]",
                contentSelector: '[role="tabpanel"], [data-tabs-content-id]',
                arrowNextSelector: ".js-tabs-next",
                arrowPrevSelector: ".js-tabs-prev",
                counterSelector: ".js-tabs-counter",
                inputSelector: null,
                activeHeadingClassName: "is-active",
                selectedAttribute: "aria-selected",
                hiddenAttribute: "aria-hidden",
                animateHeight: !0,
                animationInRight: "tabs-in",
                animationInLeft: "tabs-in",
                animationOutRight: "tabs-out",
                animationOutLeft: "tabs-out",
                attrAnimationIn: "data-tabs-element-animation-in",
                attrAnimationOut: "data-tabs-element-animation-out",
                animatingInClassName: "tabs-contents__content--animating-in",
                animatingTopClassName: "tabs-contents__content--animating-top",
                quickNav: !1,
                revealReset: !0,
                changeHash: !1,
                counterExtended: !1,
                updateHash: !1,
                updateTheme: !1,
                contentOutside: !1,
                forceOpen: !1
            })
        }
        init() {
            const t = this.options,
                e = this.$container;
            this.$input = t.inputSelector ? r()(t.inputSelector) : r()(), this.$contents = this.getContents(), this.activeId = this.getActiveItemId(), this.hashReady = !1, this.animating = {}, this.isAnimating = !1, this.triggeredBy = null, this.$next = t.arrowNextSelector ? e.find(t.arrowNextSelector) : r()(), this.$prev = t.arrowPrevSelector ? e.find(t.arrowPrevSelector) : r()(), this.$counter = t.counterSelector ? e.find(t.counterSelector) : r()()
        }
        enable() {
            if (super.enable()) {
                this.activeId = this.getActiveItemId();
                const t = this.ns;
                if (this.$input.length) {
                    this.$input.on("change." + t, this.handleInputChange.bind(this));
                    const e = this.getIdFromInputValue(this.$input.val());
                    !e && "" !== e || this.activeId == e || this.open(e)
                }
                this.options.contentOutside ? r()("body").on(`click.${t} returnkey.${t}`, this.options.headingSelector, this.handleHeadingClick.bind(this)) : this.$container.on(`click.${t} returnkey.${t}`, this.options.headingSelector, this.handleHeadingClick.bind(this)), this.$next.on(`click.${t} returnkey.${t}`, this.next.bind(this)), this.$prev.on(`click.${t} returnkey.${t}`, this.prev.bind(this)), this.handleHashChange()
            }
        }
        disable() {
            if (super.disable()) {
                this.hashReady = !0;
                const t = this.ns;
                this.$container.add(this.$input).add(this.$next).add(this.$prev).off("." + t), r()("body").off("." + t)
            }
        }
        getCount() {
            const t = {};
            return this.getContents().filter((e, n) => {
                const i = this.getId(r()(n));
                return !(i in t) && (t[i] = !0, !0)
            }).length
        }
        next(t) {
            if (t && t.isDefaultPrevented()) return;
            const e = this.getContents(),
                n = (this.getIndex(this.activeId) + 1) % e.length,
                i = e.eq(n),
                r = this.getId(i);
            this.triggeredBy = "next", this.open(r)
        }
        prev(t) {
            if (t && t.isDefaultPrevented()) return;
            const e = this.getContents(),
                n = (this.getIndex(this.activeId) - 1 + e.length) % e.length,
                i = e.eq(n),
                r = this.getId(i);
            this.triggeredBy = "prev", this.open(r)
        }
        open(t) {
            const e = this.activeId;
            if (e !== t && (!this.isAnimating || this.options.quickNav) || this.options.forceOpen) {
                const n = r.a.Deferred();
                if (this.activeId = t, this.isAnimating = !0, this.updateCounter(), this.options.updateHash && (document.location.hash = t), this.animate(t, e).then(() => {
                    n.resolve()
                }), r.a.when(n).then(() => {
                    this.triggerEvents(!0, t, e)
                }), this.options.changeHash) {
                    const e = "#" + t;
                    e && (document.location.hash = e)
                }
            }
        }
        openByIndex(t) {
            const e = this.getContents().eq(t),
                n = this.getId(e);
            this.open(n)
        }
        swap(t) {
            const e = this.activeId;
            if (e !== t && (!this.isAnimating || this.options.quickNav)) {
                this.activeId = t;
                const n = this.getContent(t),
                    i = this.getContent(e);
                if (n.length && (n.attr(this.options.hiddenAttribute, !1), i.attr(this.options.hiddenAttribute, !0)), this.animateHeading(t, "in"), this.animateHeading(e, "out"), this.animateElements(n, "in", "right", r.a.Deferred().resolve()), this.animateElements(i, "out", "left", r.a.Deferred().resolve()), this.updateInput(t), this.updateCounter(), this.triggerEvents(!1, t, e), this.triggerEvents(!0, t, e), this.updateComponents(n), this.options.changeHash) {
                    const e = "#" + t;
                    e && (document.location.hash = e)
                }
            }
        }
        handleHashChange() {
            if (!this.hashReady && (this.hashReady = !0, document.location.hash)) {
                const t = document.location.hash.replace("#", "");
                t && this.hasContent(t) && this.open(t)
            }
        }
        handleHeadingClick(t) {
            if (t.isDefaultPrevented()) return;
            if (!r()(t.target).closest(`${this.options.arrowNextSelector}, ${this.options.arrowPrevSelector}`).length) {
                const e = r()(t.currentTarget).not(this.options.contentSelector),
                    n = this.getId(e),
                    i = e.is('[data-tabs-animate="false"]') ? "swap" : "open",
                    s = r()(t.target).closest('a[href]:not([href^="#"])');
                if (s && !s.is(e) && s.closest(e).length) return;
                if (void 0 !== n) {
                    if (this.$contents.length) {
                        if (!this.hasContent(n)) return
                    } else if (!this.$input.length) return;
                    (this.activeId !== n || this.options.forceOpen) && (this.$contents.length ? this.hasContent(n) && this[i](n) : this.$input.length && this[i](n)), t.preventDefault()
                }
            }
        }
        handleInputChange(t, e) {
            const n = this.getIdFromInputValue(this.$input.val());
            this.activeId !== n && (this.triggeredBy = e.triggeredBy || "", this.open(n))
        }
        getActiveItemId() {
            const t = this.options,
                e = this.getId(this.getHeadingByClassName(t.activeHeadingClassName));
            if (void 0 === e) {
                const e = this.$contents.filter((function () {
                    const e = r()(this).attr(t.hiddenAttribute);
                    return !e || "false" === e
                }));
                return this.getId(e)
            }
            return e
        }
        getHeadingByClassName(t) {
            if (t) {
                const e = "." + t.split(" ").join(".");
                return this.$container.find(this.options.headingSelector).not(this.options.contentSelector).filter(e)
            }
            return r()()
        }
        getId(t) {
            let e = t.attr("aria-controls");
            return void 0 === e && (e = t.attr("data-tabs-heading-id")), void 0 === e && (e = t.attr("data-tabs-content-id")), void 0 === e && (e = t.attr("id")), e
        }
        getIdFromInputValue(t) {
            return this.getId(this.getHeading(t)) || this.getId(this.getContent(t))
        }
        getInputValueFromId(t) {
            const e = this.getHeading(t);
            return e.attr("data-input-value") || this.getId(e) || this.getId(this.getContent(t))
        }
        getIndex(t) {
            return void 0 === t && t !== this.activeId ? this.getIndex(this.activeId) : this.$contents.index(this.getContent(t))
        }
        hasContent(t) {
            return !!this.getContent(t).length
        }
        getContents() {
            let t = null;
            return t = this.options.contentOutside ? r()(this.options.contentSelector) : this.$container.find(this.options.contentSelector), t.filter((function () {
                return 0 === r()(this).parent().closest(t).length
            }))
        }
        getContent(t) {
            return this.options.contentOutside ? t || "" === t ? String(t).match(/^[a-z0-9-_]+$/i) ? r()(`#${t}, [data-tabs-content-id="${t}"]`) : r()(`[data-tabs-content-id="${t}"]`) : r()() : t || "" === t ? String(t).match(/^[a-z0-9-_]+$/i) ? this.$contents.filter(`#${t}, [data-tabs-content-id="${t}"]`) : this.$contents.filter(`[data-tabs-content-id="${t}"]`) : r()()
        }
        getHeading(t) {
            return this.options.contentOutside ? t || "" === t ? r()('[aria-controls="' + t + '"], [data-tabs-heading-id="' + t + '"], [data-input-value="' + t + '"]').not(this.options.contentSelector) : r()() : t || "" === t ? this.$container.find('[aria-controls="' + t + '"], [data-tabs-heading-id="' + t + '"], [data-input-value="' + t + '"]').not(this.options.contentSelector) : r()()
        }
        updateInput(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
            const n = this.$input;
            if (n.length) {
                const i = this.getInputValueFromId(t) || t;
                n.val(i).trigger("change", {
                    triggeredBy: e
                })
            }
        }
        updateCounter() {
            const t = this.getIndex(this.activeId);
            if (this.options.counterExtended) {
                const e = this.$contents.length;
                e ? this.$counter.text(`${t + 1}/${e}`) : this.$counter.text("")
            } else this.$counter.text("" + (t + 1)).attr("data-side-trim-start", String(t + 1).slice(0, 1)).attr("data-side-trim-end", String(t + 1).slice(-1, 1))
        }
        animate(t, e) {
            const n = r.a.Deferred(),
                i = this.getIndex(e),
                s = this.getIndex(t),
                a = this.getCount(),
                o = this.triggeredBy;
            let l = s > i ? "right" : "left",
                c = s > i ? "left" : "right";
            s === a - 1 && 0 === i && "prev" === o ? (l = "left", c = "right") : i === a - 1 && 0 === s && "next" === o && (l = "right", c = "left"), this.finalizePromise && this.finalizePromise.resolve(), this.triggeredBy = "", this.finalizePromise = r.a.Deferred();
            const h = this.getAnimationName("in", l),
                u = this.getAnimationName("out", c),
                d = h ? this.getContent(t) : r()(),
                p = u ? this.getContent(e) : r()();
            let f = r()().add(d).add(p);
            return this.options.animateHeight && (f = f.add(this.$container)), "out" === this.animating[t] && (f = f.add(this.getContent(t))), f = f.add(this.getAnimatedElements(d, "in", l)), f = f.add(this.getAnimatedElements(d, "out", l)), f = f.add(this.getAnimatedElements(d, "in", c)), f = f.add(this.getAnimatedElements(d, "out", c)), f = f.add(this.getAnimatedElements(p, "in", l)), f = f.add(this.getAnimatedElements(p, "out", l)), f = f.add(this.getAnimatedElements(p, "in", c)), f = f.add(this.getAnimatedElements(p, "out", c)), f.transitionstop(() => {
                this.animating[t] = "in", this.animating[e] = "out", this.animateHeading(t, "in", l), this.animateHeading(e, "out", c), r.a.when(this.animateContent(t, "in", l), this.animateContent(e, "out", c), this.animateHeight(t, e, l)).then(() => {
                    this.finalizePromise.resolve(), this.finalizeContent(t, "in", l), this.finalizeContent(e, "out", c), this.finalizeHeight(t, e), this.isAnimating = !1, n.resolve()
                }), this.updateInput(t, o)
            }), n.promise()
        }
        animateHeading(t, e, n) {
            const i = t || "" === t ? this.getHeading(t) : r()();
            i.length && (this.options.activeHeadingClassName && i.toggleClass(this.options.activeHeadingClassName, "in" === e), "in" === e ? i.attr(this.options.selectedAttribute, "false") : i.attr(this.options.selectedAttribute, "true"))
        }
        animateContent(t, e, n) {
            const i = r.a.Deferred(),
                s = t || "" === t ? this.getContent(t) : r()();
            if (s.length) {
                const t = this.options.animatingInClassName,
                    a = l()(s.toArray(), i => {
                        const s = r()(i),
                            a = new r.a.Deferred,
                            o = new r.a.Deferred,
                            l = this.getAnimationName(e, n, s),
                            c = l.split(" ").join("--active ") + "--active",
                            h = l.split(" ").join("--inactive ") + "--inactive",
                            u = this.options.animatingTopClassName;
                        return l ? ("in" === e ? (r.a.fn.revealReset && this.options.revealReset && s.revealReset(), s.transition({
                            before: e => e.addClass(`animation ${l} ${h} ${t} ${u} disable-transitions`).attr(this.options.hiddenAttribute, !1),
                            transition: t => t.removeClass(h + " disable-transitions").addClass("" + c).attr(this.options.hiddenAttribute, !1),
                            after: () => a.resolve()
                        }, {
                            before: t => {
                                this.getAnimatedElements(t, e, n).addClass("is-invisible"), this.updateComponents(t)
                            },
                            transition: t => {
                                this.animateElements(t, e, n, this.finalizePromise).then(() => {
                                    o.resolve()
                                })
                            }
                        })) : s.transition({
                            before: t => t.addClass(`animation ${l} ${h} disable-transitions`).removeClass("" + u),
                            transition: t => t.removeClass(h + " disable-transitions").addClass("" + c),
                            after: () => a.resolve()
                        }, {
                            transition: t => {
                                this.animateElements(t, e, n, this.finalizePromise).then(() => {
                                    o.resolve()
                                })
                            }
                        }), r.a.when(a, o)) : (this.animateElements(s, e, n, r.a.Deferred().resolve()), "in" === e && r.a.fn.revealReset && this.options.revealReset && s.revealReset(), s.removeClass(u), a.resolve())
                    });
                r.a.when.apply(r.a, a).done(() => i.resolve())
            } else i.resolve();
            return i.promise()
        }
        finalizeContent(t, e, n) {
            const i = t ? this.getContent(t) : r()();
            if (i.length) {
                const s = this.options.animatingInClassName,
                    a = this.options.animatingTopClassName;
                i.each((t, i) => {
                    const o = r()(i),
                        l = this.getAnimationName(e, n, o),
                        c = l.split(" ").join("--active ") + "--active",
                        h = l.split(" ").join("--inactive ") + "--inactive";
                    "in" === e ? o.removeClass(`${l} ${h} ${c} ${s} ${a}`) : o.removeClass(`${l} ${h} ${c}`)
                }), "in" === e ? "in" === this.animating[t] && (this.animating[t] = !1) : t !== this.activeId && (i.attr(this.options.hiddenAttribute, !0), this.animating[t] = !1, "out" === this.animating[t] && (this.animating[t] = !1))
            }
        }
        animateHeight(t, e, n) {
            const i = t ? this.getContent(t) : r()(),
                s = e ? this.getContent(e) : r()(),
                a = (i.length ? i : s).parent();
            if (this.options.animateHeight) {
                const s = r.a.Deferred(),
                    o = this.getAnimatedElements(i, "in", n).not(".is-hidden"),
                    c = this.getAnimatedElements(i, "in", n).filter(".is-hidden");
                a.css("overflow", "hidden").addClass("tabs-height-test");
                const h = l()(a.toArray(), t => r()(t).height() || 0);
                let u = 0;
                return t && (i.css("overflow", "hidden"), i.css("display", "block"), o.css("display", "block"), c.removeClass("is-hidden")), this.triggerEvents(!1, t, e), t && (u = l()(a.toArray(), t => r()(t).find(i).height() || 0), i.css("overflow", "").css("display", ""), o.css("display", ""), c.addClass("is-hidden")), a.css("overflow", "").removeClass("tabs-height-test"), a.each((t, e) => {
                    if (h[t] !== u[t]) {
                        r()(e).transition({
                            before: e => e.css("height", h[t]).addClass("animation--height"),
                            transition: e => e.css("height", u[t]),
                            after: () => s.resolve()
                        })
                    } else s.resolve()
                }), s.promise()
            }
            return this.triggerEvents(!1, t, e), r.a.Deferred().resolve()
        }
        finalizeHeight(t, e) {
            if (this.options.animateHeight) {
                const n = t ? this.getContent(t) : r()(),
                    i = e ? this.getContent(e) : r()(),
                    s = (n.length ? n : i).parent();
                s.length && s.css("height", "").css("overflow", "").removeClass("animation--height")
            }
        }
        getAnimationName(t, e) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            const i = this.options;
            let r;
            if (n && n.length) {
                let i = "",
                    s = null;
                i = "in" === t ? "right" === e ? "data-tabs-animation-in-right" : "data-tabs-animation-in-left" : "right" === e ? "data-tabs-animation-out-right" : "data-tabs-animation-out-left", s = n.attr(i), void 0 !== s && (r = s)
            }
            return void 0 === r && (r = "in" === t ? "right" === e ? i.animationInRight : i.animationInLeft : "right" === e ? i.animationOutRight : i.animationOutLeft), "animation--" + r.split(" ").join(" animation--")
        }
        updateComponents(t) {
            r.a.fn.parallax && t.find('[data-plugin~="parallax"]').parallax("refresh"), r.a.fn.stickySlider && this.$container.is('[data-plugin~="stickySlider"]') && this.$container.stickySlider("refresh");
            const e = r()('[data-plugin~="popover"]');
            e.length && e.popover("update")
        }
        getAnimatedElements(t, e, n) {
            const i = this.options,
                r = "in" == e ? i.attrAnimationIn : i.attrAnimationOut;
            return t.find(`[${r}], [${r}-${n}]`)
        }
        animateElements(t, e, n, i) {
            const s = this.options,
                a = this.getAnimatedElements(t, e, n),
                o = "in" == e ? s.attrAnimationIn : s.attrAnimationOut,
                l = [];
            return a.length && h()(a.toArray(), t => {
                const s = r()(t),
                    a = s.attr(`${o}-${n}`) || s.attr(o),
                    c = parseFloat(s.attr(`${o}-${n}-delay`) || s.attr(o + "-delay")) || 0,
                    h = r.a.Deferred();
                l.push(h), s.transition({
                    delay: c,
                    before: () => {
                        "in" == e && this.updateComponents(s)
                    },
                    after: function (t) {
                        return t.resolve(), i
                    }.bind(this, h)
                }, a)
            }), "out" === e && t.trigger("tabelementschange"), l.length ? r.a.when.apply(r.a, l) : r.a.Deferred().resolve()
        }
        triggerEvents(t, e, n) {
            const i = e ? this.getContent(e) : this.getContent(n);
            t ? (i.trigger("changed.tabs", {
                id: e,
                previous: n
            }), i.trigger("opened.tabs", {
                id: e,
                previous: n
            }), i.trigger("closed.tabs", {
                id: e,
                previous: n
            }), i.trigger("appear")) : (i.trigger("change.tabs", {
                id: e,
                previous: n
            }), i.trigger("open.tabs", {
                id: e,
                previous: n
            }), i.trigger("close.tabs", {
                id: e,
                previous: n
            }), i.trigger("appear"))
        }
    }
    r.a.fn.tabs = a()(d, {
        api: ["open", "openByIndex", "swap", "getContent", "getContents", "getHeading", "getActiveItemId", "getCount", "getIndex", "hasContent", "next", "prev", "instance"]
    })
}, function (t, e, n) {
    var i = n(263)(n(320));
    t.exports = i
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return s
    }));
    var i = n(0),
        r = n(34);
    class s extends r.b {
        constructor(t, e) {
            super(), this.textureID = void 0 !== e ? e : "tDiffuse", t instanceof i.Nb ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = i.Vb.clone(t.uniforms), this.material = new i.Nb({
                name: void 0 !== t.name ? t.name : "unspecified",
                defines: Object.assign({}, t.defines),
                uniforms: this.uniforms,
                vertexShader: t.vertexShader,
                fragmentShader: t.fragmentShader
            })), this.fsQuad = new r.a(this.material)
        }
        render(t, e, n) {
            this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t))
        }
        dispose() {
            this.material.dispose(), this.fsQuad.dispose()
        }
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return s
    }));
    const i = [/(Googlebot\/|Googlebot-(Mobile|Image|News|Video)|Google-(Adwords-Instant|xrawler|Structured-Data-Testing-Tool|PhysicalWeb|Site-Verification|Certificates-Bridge|Read-Aloud)|Mediapartners-Google|Mediapartners \(Googlebot\)|APIs-Google|Google Favicon|Google Web Preview)/, /DuckDuckBot/, /(bingbot|BingPreview\/)/, /(Baiduspider|Baidu-YunGuanCe)/, /(Yahoo Link Preview|Y!J|Slurp)/, /Yandex(Bot|Images|AccessibilityBot|MobileBot|Metrika|Turbo|ImageResizer|Video|AdNet|Blogs|Calendar|Direct|Favicons|ForDomain|Market|Media|MobileScreenShotBot|News|OntoDB|Pagechecker|Partner|RCA|SearchShop|Sitelinks|SpravBot|Tracker|Vertis|Verticals|Webmaster|ScreenshotBot)/, /Yeti/, /Teoma/, /(Applebot|Facebot|facebookexternalhit|Twitterbot|TelegramBot|WhatsApp)/, /heritrix/];
    let r = null;

    function s() {
        if (null === r) {
            r = !1;
            for (let t = 0; t < i.length; t++)
                if (i[t].test(navigator.userAgent)) return r = !0, !0
        }
        return r
    }
}, function (t, e, n) {
    var i = n(45).Symbol;
    t.exports = i
}, function (t, e, n) {
    "use strict";
    var i = n(1);
    n(38), n(224);
    i.a.transition.sequences.title = i.a.transition.generateSequenceIn("title", {
        before: t => {
            t.splitLines()
        }
    }), i.a.transition.sequences["title-preloader"] = i.a.transition.generateSequenceIn("title-preloader", {
        before: t => {
            t.splitLines()
        }
    }), i.a.transition.sequences.text = i.a.transition.generateSequenceIn("text", {
        before: t => {
            t.splitLines()
        }
    }), i.a.transition.sequences["title-alt"] = i.a.transition.generateSequenceIn("title-alt", {
        before: t => {
            t.splitChars()
        }
    }), i.a.transition.sequences.fast = {
        before: t => t.addClass("animation--fast"),
        after: t => t.removeClass("animation--fast")
    }, i.a.transition.sequences.slow = {
        before: t => t.addClass("animation--slow"),
        after: t => t.removeClass("animation--slow")
    }, i.a.transition.sequences.block = {
        before: t => t.addClass("animation--block"),
        after: t => t.removeClass("animation--block")
    }
}, function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(1),
        r = n(3),
        s = n.n(r),
        a = n(11),
        o = n.n(a),
        l = n(14),
        c = n(40);
    i.a.fn.filterFormReset = s()((function (t) {
        const e = Object(i.a)("form.js-ajax-filters").length ? Object(i.a)("form.js-ajax-filters") : Object(i.a)(".js-filters"),
            n = Object(i.a)(".js-ajax-filters-modal"),
            r = e.find('[type="reset"]').add(".js-ajax-filters-reset"),
            s = Object(i.a)(".js-filter-reset"),
            a = e.closest(".modal").find('.js-modal-close:not([type="submit"])'),
            h = Object(i.a)(".js-ajax-filters-count"),
            u = e.closest(".modal");
        let d = Object(l.a)(e),
            p = Object(l.a)(n);

        function f() {
            const t = Object(l.a)(e);
            d = t;
            for (let e = t.length - 1; e >= 0; e--) t[e].resetIgnore ? t.splice(e, 1) : (t[e].value = t[e].defaultValue, "number" === t[e].type && (t[e].value = Object(c.a)(t[e].value, 0)));
            Object(l.d)(e, t), e.submit()
        }

        function m() {
            const t = Object(l.a)(e),
                n = {};
            let i = 0,
                r = !1;
            for (let e = 0; e < t.length; e++)
                if (!t[e].resetIgnore && t[e].hasNonDefaultValue) {
                    r = !0;
                    const s = t[e].name.replace(/\[.*$/, "");
                    s in n || (n[s] = !0, i++)
                } h.is(".btn") ? h.find(".btn__text").text(i) : h.text(i), h.toggleClass("is-hidden", 0 === i)
        }
        u.on("opened.modal", () => {
            d = Object(l.a)(e), p = Object(l.a)(n)
        }), a.on("click", t => {
            t.preventDefault();
            const e = Object(l.a)(n);
            for (let t = e.length - 1; t >= 0; t--) e[t].value = p[t].value;
            Object(l.d)(n, e)
        }), s.on("click returnkey", t => {
            t.preventDefault(), f()
        }), r.on("click returnkey", t => {
            t.preventDefault(), f()
        }), e.on("change input", o()(m, 16)), m()
    }))
}, function (t, e, n) {
    "use strict";
    n.r(e), n.d(e, "default", (function () {
        return b
    }));
    var i = n(1),
        r = n(3),
        s = n.n(r),
        a = n(98),
        o = n.n(a),
        l = n(39),
        c = n.n(l),
        h = n(9),
        u = n(7),
        d = (n(38), n(128), n(23));
    var p = n(251),
        f = n.n(p);
    class m {
        static get MarkerState() {
            return {
                disabled: !1,
                reserved: !1,
                clickable: !1,
                active: !1,
                visible: !1,
                highlighted: !1,
                direction: ""
            }
        }
        static get DefaultOptions() {
            return {
                markersVisible: !0,
                markerAnimationDelay: 0,
                markerAnimationShow: "fade-in",
                markerAnimationHide: "fade-out",
                markerClassDisabled: "plan-marker--disabled",
                markerClassReserved: "plan-marker--reserved",
                markerClassHighlighted: "plan-marker--highlighted",
                markerClassClickable: "plan-marker--clickable",
                markerClassActive: "plan-marker--active is-active",
                markerSelector: ".js-svg-plan-marker",
                markerHideBeforeRefresh: !1
            }
        }
        constructor(t, e) {
            this.options = $.extend({}, this.constructor.DefaultOptions, e), this.plan = t, this.markers = [], this.markersMap = {}
        }
        ready() {
            const t = this.plan.$container,
                e = this.markers,
                n = this.markersMap,
                i = t.find(this.options.markerSelector);
            for (let t = 0; t < i.length; t++) {
                const r = i.eq(t),
                    s = r.data("nr"),
                    a = $.extend({
                        nr: s,
                        element: r
                    }, this.constructor.MarkerState, {
                        disabled: r.hasClass(this.options.markerClassDisabled),
                        reserved: r.hasClass(this.options.markerClassReserved),
                        clickable: r.hasClass(this.options.markerClassClickable),
                        active: r.hasClass(this.options.markerClassActive),
                        visible: !r.hasClass("is-invisible") && !r.hasClass("is-invisible--js") && !r.hasClass("is-hidden")
                    });
                e.push(a), n[s] = a
            }
            i.on("mouseenter focusin show.popover-target", this.handleMouseOver.bind(this)).on("mouseleave focusout hide.popover-target", this.handleMouseOut.bind(this)).on("click returnkey", this.handleClick.bind(this)), this.options.markersVisible && this.setMarkersVisible(!0)
        }
        refresh() {
            const t = this.markers;
            let e = !1;
            for (let n = 0; n < t.length; n++) {
                const i = t[n],
                    r = i.element.get(0).getBoundingClientRect();
                this.options.markerHideBeforeRefresh && $(i.element.get(0)).css({
                    opacity: 1
                }), i.width === r.width && i.height == r.height || (i.width = r.width, i.height = r.height, e = !0)
            }
            return e
        }
        update() {
            const t = this.markers;
            for (let e = 0; e < t.length; e++) {
                const n = t[e],
                    i = ~~(n.x - n.width / 2),
                    r = ~~(n.y - n.height / 2);
                n.element.css("transform", `translate(${i}px, ${r}px)`)
            }
        }
        getMarkerElement(t) {
            return this.markersMap[t] ? this.markersMap[t].element : null
        }
        getMarker(t) {
            return this.markers[t] ? this.markers[t] : null
        }
        handleMouseOver(t) {
            const e = this.plan.getNr(t);
            this.plan.setState(e, {
                active: !0
            }), this.plan.$container.css("--opacity", 1)
        }
        handleMouseOut(t) {
            const e = this.plan.getNr(t);
            this.plan.setState(e, {
                active: !1
            }), this.plan.$container.css("--opacity", 0)
        }
        handleClick(t) {
            const e = this.plan.getNr(t),
                n = this.markersMap[e].element.find("a").addBack("a");
            n.length && !$(t.target).closest(n).length && n.get(0).click()
        }
        setState(t, e) {
            const n = this.markersMap[t];
            if (n) {
                const t = this.constructor.MarkerState;
                for (let i in e) {
                    if (i in t && n[i] !== e[i])
                        if ("direction" === i) n.element.removeClass("plan-marker--direction-" + n[i]), n.element.addClass("plan-marker--direction-" + e[i]);
                        else if ("visible" === i) n.element.transitionstop(() => {
                            n.element.transition(e[i] ? this.options.markerAnimationShow : this.options.markerAnimationHide)
                        });
                        else {
                            const t = this.options[`markerClass${i[0].toUpperCase()}${i.slice(1)}`];
                            t && n.element.toggleClass(t, !!e[i])
                        }
                    n[i] = e[i]
                }
            }
        }
        getState(t) {
            const e = this.markersMap[t];
            return e ? {
                disabled: e.disabled,
                reserved: e.reserved,
                clickable: e.clickable,
                active: e.active,
                visible: e.visible
            } : {}
        }
        getItemNumbers() {
            return this.markers.map(t => t.nr)
        }
        setMarkersVisible(t) {
            const e = this.options.markerAnimationDelay,
                n = this.markers,
                i = this.plan;
            let r = new Array(n.length).fill(0).map((n, i) => t ? i * e : 0);
            r = f()(r);
            for (let e = 0; e < n.length; e++) {
                const s = n[e],
                    a = i.setState.bind(i, s.nr, {
                        visible: t
                    });
                setTimeout(a, r[e])
            }
        }
    }
    var g = n(5),
        v = n.n(g);
    const y = {
        anchors: class {
            static get AnchorState() {
                return {
                    x: 0,
                    y: 0,
                    direction: !1
                }
            }
            static get DefaultOptions() {
                return {
                    anchorSelector: ".plan__svg__anchor",
                    streetsSelector: ".street__svg__anchor",
                    hoverableSelector: ".plan__svg__hoverable"
                }
            }
            constructor(t, e) {
                this.options = $.extend({}, this.constructor.DefaultOptions, e), this.plan = t, this.anchorsMap = {}, this.anchors = []
            }
            ready() {
                const t = this.plan.$container,
                    e = this.anchorsMap,
                    n = this.anchors;
                let i = t.find(this.options.anchorSelector);
                i.length || (i = t.find(this.options.hoverableSelector));
                for (let t = 0; t < i.length; t++) {
                    const r = i.eq(t).data("nr");
                    if (!e[r]) {
                        const t = i.filter(`[data-nr="${r}"]`),
                            s = $.extend({
                                nr: r,
                                elements: t
                            }, this.constructor.AnchorState, {
                                direction: t.data("direction")
                            });
                        e[r] = s, n.push(s)
                    }
                }
            }
            refresh() {
                const t = this.anchors,
                    e = this.plan.getContainerBox();
                let n = !1;
                for (let i = 0; i < t.length; i++) {
                    const r = t[i];
                    let s;
                    for (let t = 0; t < r.elements.length; t++) {
                        if (s = r.elements.get(t).getBoundingClientRect(), s.width || s.height || s.left || s.top) break
                    }
                    const a = r.x,
                        o = r.y;
                    r.x = s.left + s.width / 2 - e.left, r.y = s.top + s.height / 2 - e.top, (Math.abs(a - r.x) > .1 || Math.abs(o - r.y) > .1) && (n = !0)
                }
                let i = this.plan.$container.find(this.options.streetsSelector);
                if (i.length) {
                    const t = $(".js-plan-label");
                    let n;
                    for (let r = 0; r < i.length; r++) {
                        const s = i.get(r),
                            a = $(s).data("nr"),
                            o = t.filter(`[data-plan-label-anchor="${a}"]`);
                        n = s.getBoundingClientRect(), o.removeClass("is-hidden"), o.css({
                            top: n.top - e.top,
                            left: n.left - e.left
                        })
                    }
                }
                return n
            }
            getState(t) {
                const e = this.constructor.AnchorState,
                    n = this.anchorsMap[t],
                    i = {};
                if (n)
                    for (let t in e) i[t] = n[t];
                return i
            }
            getItemNumbers() {
                return this.anchors.map(t => t.nr)
            }
        },
        hoverables: class {
            static get HoverableState() {
                return {
                    disabled: !1,
                    reserved: !1,
                    clickable: !1,
                    active: !1
                }
            }
            static get DefaultOptions() {
                return {
                    hoverableClassDisabled: "plan__svg__hoverable--disabled",
                    hoverableClassStyledisabled: "plan__svg__hoverable--styledisabled",
                    hoverableClassReserved: "plan__svg__hoverable--reserved",
                    hoverableClassClickable: "plan__svg__hoverable--clickable",
                    hoverableClassActive: "plan__svg__hoverable--active",
                    hoverableSelector: ".plan__svg__hoverable"
                }
            }
            constructor(t, e) {
                this.options = $.extend({}, this.constructor.DefaultOptions, e), this.plan = t, this.hoverables = [], this.hoverablesMap = {}
            }
            ready() {
                const t = this.plan.$container,
                    e = this.hoverables = [],
                    n = this.hoverablesMap,
                    i = t.find(this.options.hoverableSelector),
                    r = this.options.hoverableClassStyledisabled;
                for (let s = 0; s < i.length; s++) {
                    const a = i.eq(s),
                        o = a.data("nr");
                    0 === t.find(`.plan-marker[data-nr="${o}"]`).length && a.addClass(r);
                    const l = $.extend({
                        nr: o,
                        element: a
                    }, this.constructor.HoverableState);
                    n[o] = l, e.push(l)
                }
                i.add(i.find("path")).on("mouseenter mouseleave focusin focusout click", this.passEventToMarker.bind(this))
            }
            passEventToMarker(t) {
                const e = this.plan.getPlugin("markers");
                if (e) {
                    const n = this.plan.getNr(t),
                        i = e.getMarkerElement(n);
                    if (i) {
                        const e = i.find("a").addBack("a");
                        e.length && ("click" === t.type ? e.get(0).click() : e.trigger(t.type))
                    }
                }
            }
            hasHoverable(t) {
                return !!this.hoverablesMap[t].element
            }
            setState(t, e) {
                const n = this.hoverablesMap[t],
                    i = this.constructor.HoverableState;
                if (n)
                    for (let t in e) {
                        if (t in i && n[t] !== e[t]) {
                            const i = this.options[`hoverableClass${t[0].toUpperCase()}${t.slice(1)}`];
                            i && n.element.toggleClass(i, !!e[t])
                        }
                        n[t] = e[t]
                    }
            }
            getState() {
                return {}
            }
            getItemNumbers() {
                return this.hoverables.map(t => t.nr)
            }
        },
        markers: m,
        markersTextLeft: class extends m {
            static get DefaultOptions() {
                return $.extend({}, m.DefaultOptions, {
                    markerAnimationDelay: 0,
                    markerAnimationShow: "marker-in",
                    markerAnimationHide: "marker-out"
                })
            }
            ready() {
                super.ready(), v()(this.markers, t => {
                    t.titleElement = t.element.find(".js-svg-plan-marker-title")
                })
            }
            update() {
                super.update();
                const t = this.markers;
                for (let e = 0; e < t.length; e++) {
                    const n = t[e],
                        i = ~~(n.x - n.width / 2);
                    n.titleElement.css("width", i + "px")
                }
            }
        },
        popovers: class {
            static get PopoversState() {
                return {
                    x: 0,
                    y: 0
                }
            }
            static get DefaultOptions() {
                return {
                    popoverSelector: ".popover",
                    popoverActiveClassName: "is-active"
                }
            }
            constructor(t, e) {
                this.options = $.extend({}, this.constructor.DefaultOptions, e), this.plan = t, this.$popovers = $()
            }
            ready() {
                const t = this.options.popoverSelector;
                this.$popovers = this.plan.$container.find(t).add(this.plan.$container.siblings(t))
            }
            update() {
                this.$popovers.filter("." + this.options.popoverActiveClassName).popover("update")
            }
            setMarkersVisible(t) {
                t || this.$popovers.filter("." + this.options.popoverActiveClassName).popover("hide")
            }
        }
    };
    class b {
        static get Defaults() {
            return {
                src: "",
                plugins: "anchors hoverables markers"
            }
        }
        constructor(t, e) {
            this.options = i.a.extend({}, this.constructor.Defaults, e), this.$container = t, this.$content = Object(i.a)(t.find(".js-svg-plan-content").get(0) || t), this.namespace = "svg-" + Object(h.a)(), this.$svg = null, this.isReady = !1, this.containerBox = null, this.pluginsMap = {}, this.plugins = [], Object(i.a)(window).on("resize." + this.namespace, this.refresh.bind(this)), Object(i.a)('[role="tablist"]').find("a").on("click", () => {
                setTimeout(this.refresh.bind(this), 100)
            }), this.inView = new d.a(t, {
                enter: this.refresh.bind(this)
            }), t.on("destroyed", this.destroy.bind(this)), this.load(this.getSource()).then(this.render.bind(this))
        }
        getSource() {
            const t = this.options.src;
            if ("string" == typeof t) return t;
            if (t && "object" == typeof t) {
                return t[Object.keys(t).reverse().find(t => u.a.matches(t + "-up"))]
            }
            return null
        }
        destroy() {
            this.inView.destroy(), Object(i.a)(document).add(window).off("." + this.namespace)
        }
        load(t) {
            return t ? i.a.ajax(t, {
                dataType: "text"
            }) : i.a.Deferred().reject()
        }
        render(t) {
            (this.$svg = Object(i.a)(t).filter("svg").addClass("plan__svg")).appendTo(this.$content), this.ready()
        }
        ready() {
            this.initPlugins(), this.callPlugins("ready"), this.$container.addClass("plan--ready"), this.isReady = !0, Object(i.a)(window).scroller("update"), this.refresh()
        }
        refresh() {
            if (this.isReady) {
                this.containerBox = this.$container.get(0).getBoundingClientRect(), this.svgBox = this.$svg.get(0).getBoundingClientRect();
                const t = this.callPlugins("refresh");
                for (let e = 0; e < t.length; e++)
                    if (t[e]) {
                        this.syncState(), this.callPlugins("update");
                        break
                    }
            }
        }
        getContainerBox() {
            return this.containerBox
        }
        getSVGBox() {
            return this.svgBox
        }
        getNr(t) {
            return t && t.closest ? t.closest("[data-nr]").data("nr") : Object(i.a)(t.currentTarget).closest("[data-nr]").data("nr")
        }
        initPlugins() {
            const t = this.options.plugins.split(" "),
                e = this.pluginsMap = {},
                n = this.plugins = [];
            for (let i = 0; i < t.length; i++) {
                const r = t[i];
                r && r in y && (e[r] = new y[r](this, this.options), n.push(e[r]))
            }
        }
        callPlugins(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            const n = this.plugins,
                i = [];
            for (let r = 0; r < n.length; r++) t in n[r] && i.push(n[r][t].apply(n[r], e));
            return i
        }
        getPlugin(t) {
            return this.pluginsMap[t] || null
        }
        setState(t, e) {
            this.plugins.forEach(n => {
                "setState" in n && n.setState(t, e)
            })
        }
        syncState() {
            const t = this.plugins;
            c()(o()(this.callPlugins("getItemNumbers"))).forEach(e => {
                const n = {};
                t.forEach(t => {
                    "getState" in t && i.a.extend(n, t.getState(e))
                }), this.callPlugins("setState", [e, n])
            })
        }
        setMarkersVisible(t) {
            this.callPlugins("setMarkersVisible", [t])
        }
    }
    i.a.fn.plan = s()(b)
}, function (t, e, n) {
    "use strict";
    n.r(e), n.d(e, "default", (function () {
        return y
    }));
    var i = n(2),
        r = n.n(i),
        s = n(15),
        a = n.n(s),
        o = n(3),
        l = n.n(o),
        c = n(11),
        h = n.n(c),
        u = n(6),
        d = n(9),
        p = n(32),
        f = n(14),
        m = n(89);
    n(30);
    let g = null,
        v = 0;
    class y {
        static get Defaults() {
            return {
                autoClose: !0,
                autoCloseIgnoreSelector: ".js-modal-ignore-auto-close",
                keyboardClose: !0,
                closeSelector: ".js-modal-close",
                className: "modal",
                classNameHidden: "is-hidden",
                classNameCustomScroll: "modal--with-scrollable-content",
                selectorCustomScroll: ".js-modal-scrollable-content",
                animationNameIn: "modal-in",
                animationNameOut: "modal-out",
                animationClassNameChange: "animation--delay",
                htmlScrollClassName: "with-modal",
                preventIOSScroll: !0,
                onePerPage: !0,
                resetFormOnClose: !0,
                resetRevealOnClose: !0,
                attachTriggers: !0,
                triggerActiveClassName: null,
                restoreFocus: !0,
                resetScroll: !1,
                showOverlay: !1
            }
        }
        constructor(t, e) {
            this.options = r.a.extend({}, this.constructor.Defaults, e), this.$container = t, this.$ignoreClick = t.find(this.options.autoCloseIgnoreSelector), this.$ignoreClick.length || (this.$ignoreClick = this.$container), this.namespace = Object(d.a)(), this.triggerNamespace = Object(d.a)(), this.visible = !t.hasClass(this.options.classNameHidden), this.$trigger = r()(), this.$focused = r()(), t.addClass(this.options.className), t.attr("tabindex", 0).attr("role", "dialog").attr("aria-hidden", this.visible ? "false" : "true"), this.$container.on("click", 'a[href*="#"]', this.handleHashLinkClick.bind(this)), this.$prevScrollableContent = null, this.$prevScrollableParent = null;
            const n = t.closest(".js-page-content").siblings(".js-modal");
            if (n.length && n.append(t), t.on("destroyed", this.destroy.bind(this)), this.visible && (v++, this.beforeModalShow(), this.afterModalShow()), this.options.attachTriggers) {
                const e = t.attr("id");
                e && (r()(document).on(`click.${this.triggerNamespace} returnkey.${this.triggerNamespace}`, `a[href="#${e}"]`, this.handleDocumentLinkClick.bind(this)), r()(document).on(`mousedown.${this.triggerNamespace} touchstart.${this.triggerNamespace}`, `a[href="#${e}"]`, this.loadImages.bind(this)))
            }
        }
        setOptions(t) {
            r.a.extend(this.options, t || {})
        }
        destroy() {
            this.visible && v--, this === g && (g = null), r()(document).off("." + this.namespace).off("." + this.triggerNamespace), this.visible && r()("html").removeClass(this.options.htmlScrollClassName), this.$trigger = r()()
        }
        getScrollableContent() {
            return this.$container.find(this.options.selectorCustomScroll)
        }
        update() {
            const t = r.a.fn.scroller && r.a.isCustomScroll && r.a.isCustomScroll();
            if (this.visible && t) {
                const t = this.getScrollableContent();
                if (t.length) {
                    const e = r()("body").scroller("getScrollableContent"),
                        n = e.scrollParent();
                    this.$prevScrollableContent = e, this.$prevScrollableParent = n, n.data("smooth-scroll-last-scroll", n.scrollTop()), this.options.resetScroll && t.data("smooth-scroll-last-scroll", 0), this.$container.addClass(this.options.classNameCustomScroll), r()("body").scroller("setScrollableContent", t)
                } else r()("body").scroller("setDisabled", !0)
            } else if (this.options.resetScroll) {
                this.$container.find(".js-scroll-parent").scrollTop(0)
            }
            if (this.updateScrollableContent(), this.updateComponents(), !this.visible && t) {
                const t = this.getScrollableContent();
                t.length ? (r()("body").scroller("unsetScrollableContent", t), this.$prevScrollableContent = null, this.$prevScrollableParent = null) : r()("body").scroller("setDisabled", !1)
            }
        }
        updateComponents() {
            this.visible && (r.a.fn.parallax && this.$container.find('[data-plugin~="parallax"]').app().parallax("refresh"), r.a.fn.reveal && (this.$container.reveal("instance") ? this.$container.revealReset() : this.$container.reveal()))
        }
        updateScrollableContent() {
            r()("html").toggleClass(this.options.htmlScrollClassName, v > 0).get(0).offsetWidth
        }
        beforeModalHide() { }
        beforeModalShow() {
            const t = this.options;
            t.triggerActiveClassName && this.$trigger.addClass(t.triggerActiveClassName), this.update(), this.$container.trigger("open.modal", {
                instance: this
            }), this.attachModalListeners()
        }
        afterModalHide() {
            if (this.options.animationClassNameChange && this.$container.removeClass(this.options.animationClassNameChange), this.$focused.length && this.options.restoreFocus && this.$focused.focus(), this.$focused = r()(), this.options.resetFormOnClose) {
                this.$container.find("form").each((t, e) => {
                    e.reset(), r()(e).find("input,textarea,select").not('[type="submit"],[type="button"]').change()
                })
            }
            this.update(), this.options.resetRevealOnClose && r.a.fn.revealReset && this.$container.revealReset(), this.$container.trigger("closed.modal", {
                instance: this
            })
        }
        afterModalShow() {
            if (setTimeout(() => {
                this.$container.css("z-index", "")
            }, 1e3), !r()(document.activeElement).is("input, textarea, select")) {
                const t = this.$container.find("[autofocus]").eq(0);
                t.length ? t.focus() : this.$container.focus()
            }
            1 === v && this.$container.trigger("opened.modal", {
                instance: this
            });
            if (r.a.fn.scroller && r.a.isCustomScroll && r.a.isCustomScroll()) {
                this.$container.find(this.options.selectorCustomScroll).length && r()("body").scroller("update")
            }
        }
        show(t) {
            if (!this.visible) {
                const e = this.options,
                    n = e.animationNameIn;
                this.$focused = r()(document.activeElement), this.$trigger = t || this.$trigger, this.visible = !0, v++, v > 1 && this.$container.css("z-index", (parseInt(this.$container.css("z-index")) || 0) + 1);
                const i = this.$trigger.data("modalValues");
                i && Object(f.d)(this.$container, i), e.onePerPage && (g && g.hide(), g = this), this.$container.transitionstop(() => {
                    this.$container.removeClass("is-hidden"), this.beforeModalShow(), this.$container.addClass("is-hidden"), this.options.showOverlay ? Object(m.b)(() => {
                        this.$container.removeClass("is-hidden"), this.$container.attr("aria-hidden", "false"), this.afterModalShow(), Object(m.a)()
                    }) : this.$container.transition(n, {
                        before: t => t.attr("aria-hidden", "false")
                    }, {
                        after: () => this.afterModalShow()
                    })
                })
            }
        }
        hide() {
            if (this.visible) {
                this === g && (g = null);
                const t = this.options,
                    e = t.animationNameOut;
                this.visible = !1, v--, this.$container.transitionstop(() => {
                    v > 0 && t.onePerPage && t.animationClassNameChange && this.$container.addClass(t.animationClassNameChange), this.$container.transition(e, {
                        before: () => this.beforeModalHide(),
                        after: t => t.attr("aria-hidden", "true")
                    }, {
                        after: () => this.afterModalHide()
                    }), t.triggerActiveClassName && this.$trigger.removeClass(t.triggerActiveClassName), this.$container.trigger("close.modal", {
                        instance: this
                    }), this.detachModalListeners()
                })
            }
        }
        attachModalListeners() {
            this.$container.on(`click.${this.namespace} returnkey.${this.namespace}`, this.options.closeSelector, h()(this.hide.bind(this), 60)), this.options.autoClose && r()(document).on("click." + this.namespace, this.handleDocumentClick.bind(this)), this.options.keyboardClose && r()(document).on("keydown." + this.namespace, this.handleDocumentKey.bind(this))
        }
        detachModalListeners() {
            this.$container.off("click." + this.namespace), r()(document).off(`click.${this.namespace} keydown.${this.namespace}`)
        }
        toggle(t) {
            this.visible ? this.hide() : this.show(t)
        }
        handleDocumentClick(t) {
            const e = r()(t.target);
            !e.closest("body").length || e.closest(this.$trigger).length || e.closest(this.$ignoreClick).length || this.hide()
        }
        handleDocumentKey(t) {
            27 !== t.which || r()(document.activeElement).is("input,textarea,select") || this.hide()
        }
        handleDocumentLinkClick(t) {
            t.isDefaultPrevented() || (t.preventDefault(), this.show(r()(t.currentTarget)))
        }
        loadImages() {
            if (r.a.fn.appear) {
                this.$container.find('picture[data-plugin*="appear"], img[data-plugin*="appear"]').appear("load")
            }
        }
        handleHashLinkClick(t) {
            if (!t.isDefaultPrevented()) {
                const e = r()(t.target).closest("a").attr("href").replace(/.*#/, "");
                if (e && Object(p.a)("#" + e)) {
                    const n = r()("#" + e);
                    if (n && n.length && 0 === n.closest(this.$container).length) {
                        const e = n.get(0).getBoundingClientRect();
                        if (e.width || e.height) {
                            const e = this.$prevScrollableParent || r()(window);
                            e && n.scrollParent().is(e) && (this.$container.one("closed.modal", () => {
                                e.scrollToElement(n)
                            }), this.$focused = r()(), this.hide(), t.preventDefault())
                        }
                    }
                }
            }
        }
    }
    r.a.fn.modal = l()(y, {
        api: ["show", "hide", "toggle", "instance"]
    }), r.a.fn.modalTrigger = l()((function (t, e) {
        const n = t.attr("href"),
            i = r.a.extend({
                target: n && n.match(/^#[a-z0-9][a-z0-9-_]*$/) ? n : "",
                event: "click returnkey",
                plugin: "modal",
                selector: null
            }, e);
        "mouseenter" !== i.event || u.a.hasHoverSupport() || (i.event = "click returnkey");
        let s = i.event;
        t.on(s, i.selector, e => {
            if (!e.isDefaultPrevented()) {
                e.preventDefault();
                r()(i.target).eq(0)[i.plugin]("toggle", t)
            }
        })
    })), r.a.fn.modalPage = l()((function (t, e) {
        const n = document.location.href,
            i = t.find(".js-modal-close");
        let r = i.attr("href");
        r && (r = r.replace(/#.*/, ""), i.attr("href", r)), t.on("click returnkey", ".js-modal-close", t => {
            t.preventDefault()
        }), t.on("close.modal", () => {
            if (r) {
                const t = a.a.history.size;
                for (let i = t - 1; i >= 0; i--)
                    if (a.a.history.get(i).url === n) {
                        a.a.history.remove(i), i === t - 1 && (window.history.replaceState({}, "", r), document.title = e.title);
                        break
                    }
            } else {
                a.a.history.remove();
                const t = a.a.history.get(a.a.history.size - 1);
                t && (window.history.replaceState({}, "", t.url), document.title = e.title)
            }
        })
    }))
}, function (t, e) {
    t.exports = "uniform vec3 diffuse;\nvarying float vOpacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n    #include <clipping_planes_fragment>\n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vec4( diffuse, vOpacity );\n    #include <logdepthbuf_fragment>\n    #include <map_particle_fragment>\n    #include <color_fragment>\n    #include <alphatest_fragment>\n    #include <alphahash_fragment>\n    outgoingLight = diffuseColor.rgb;\n    #include <opaque_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n}\n"
}, function (t, e, n) {
    "use strict";
    n.d(e, "b", (function () {
        return s
    })), n.d(e, "a", (function () {
        return a
    }));
    let i = null;

    function r() {
        return i || (i = $('<div class="page-overlay preloader ui-dark ui-background is-hidden" ><div class="preloader__pattern background background--cover"><div class="gradient-animation animation"></div><svg width="1442" height="721" viewBox="0 0 1442 721" fill="none" xmlns="http://www.w3.org/2000/svg"><defs><style>.cls-1{fill:none;stroke:#454545;stroke-miterlimit:10}</style></defs><polygon class="cls-1" points="241.54 313.79 241.54 648.91 241.38 649.09 73.66 481.35 241.38 313.63 241.54 313.79"/><polygon class="cls-1" points="409.1 481.35 241.54 648.91 241.54 313.79 409.1 481.35"/><path class="cls-1" d="M241.38,678.4L44.35,481.37H1.21l240.17,240.17.16-.16v-43.14l-.16.16h0Z"/><polygon class="cls-1" points="241.54 240.7 241.54 283.71 241.38 283.54 43.96 480.96 44.35 481.35 1.21 481.35 .88 481.04 241.38 240.54 241.54 240.7"/><polygon class="cls-1" points="481.55 481.35 241.54 721.36 241.54 678.23 438.41 481.35 481.55 481.35"/><polygon class="cls-1" points="481.88 481.04 481.55 481.35 438.41 481.35 438.8 480.96 241.54 283.71 241.54 240.7 481.88 481.04"/><polygon class="cls-1" points="722.04 314.21 722.04 649.32 721.88 649.5 554.16 481.76 721.88 314.04 722.04 314.21"/><polygon class="cls-1" points="889.6 481.76 722.04 649.32 722.04 314.21 889.6 481.76"/><path class="cls-1" d="M721.88,678.81l-197.03-197.03h-43.14l240.17,240.17.16-.16v-43.14l-.16.16h0Z"/><polygon class="cls-1" points="722.04 241.12 722.04 284.12 721.88 283.96 524.46 481.38 524.85 481.76 481.71 481.76 481.38 481.45 721.88 240.95 722.04 241.12"/><polygon class="cls-1" points="962.05 481.76 722.04 721.77 722.04 678.65 918.91 481.76 962.05 481.76"/><polygon class="cls-1" points="962.38 481.45 962.05 481.76 918.91 481.76 919.3 481.38 722.04 284.12 722.04 241.12 962.38 481.45"/><polygon class="cls-1" points="1202.04 314.54 1202.04 649.65 1201.88 649.83 1034.16 482.09 1201.88 314.37 1202.04 314.54"/><polygon class="cls-1" points="1369.6 482.09 1202.04 649.65 1202.04 314.54 1369.6 482.09"/><path class="cls-1" d="M1201.88,679.14l-197.03-197.03h-43.14l240.17,240.17.16-.16v-43.14l-.16.16h0Z"/><polygon class="cls-1" points="1202.04 241.44 1202.04 284.45 1201.88 284.29 1004.46 481.71 1004.85 482.09 961.71 482.09 961.38 481.78 1201.88 241.28 1202.04 241.44"/><polygon class="cls-1" points="1442.05 482.09 1202.04 722.1 1202.04 678.97 1398.91 482.09 1442.05 482.09"/><polygon class="cls-1" points="1442.38 481.78 1442.05 482.09 1398.91 482.09 1399.3 481.71 1202.04 284.45 1202.04 241.44 1442.38 481.78"/><path class="cls-1" d="M241.88,197.55L44.85.51H1.71l240.17,240.17.16-.16v-43.14l-.16.16h0Z"/><polygon class="cls-1" points="482.05 .5 242.04 240.51 242.04 197.38 438.91 .5 482.05 .5"/><path class="cls-1" d="M722.04,197.8L525.01.76h-43.14l240.17,240.17.16-.16v-43.14l-.16.16h0Z"/><polygon class="cls-1" points="962.21 .75 722.21 240.76 722.21 197.63 919.07 .75 962.21 .75"/><path class="cls-1" d="M1202.04,198.12L1005.01,1.09h-43.14l240.17,240.17.16-.16v-43.14l-.16.16h0Z"/><polygon class="cls-1" points="1442.21 1.08 1202.21 241.09 1202.21 197.96 1399.07 1.08 1442.21 1.08"/></svg></div></div>').appendTo("body")), i
    }

    function s(t) {
        r().transitionstop(e => {
            e.transition("fade-in fast", t)
        })
    }

    function a(t) {
        r().transitionstop(e => {
            e.transition("fade-out slow", t)
        })
    }
}, function (t, e, n) {
    var i = n(109),
        r = n(270),
        s = n(271),
        a = n(272),
        o = n(273),
        l = n(274);

    function c(t) {
        var e = this.__data__ = new i(t);
        this.size = e.size
    }
    c.prototype.clear = r, c.prototype.delete = s, c.prototype.get = a, c.prototype.has = o, c.prototype.set = l, t.exports = c
}, function (t, e, n) {
    var i = n(300),
        r = n(51),
        s = Object.prototype,
        a = s.hasOwnProperty,
        o = s.propertyIsEnumerable,
        l = i(function () {
            return arguments
        }()) ? i : function (t) {
            return r(t) && a.call(t, "callee") && !o.call(t, "callee")
        };
    t.exports = l
}, function (t, e, n) {
    (function (t) {
        var i = n(45),
            r = n(301),
            s = e && !e.nodeType && e,
            a = s && "object" == typeof t && t && !t.nodeType && t,
            o = a && a.exports === s ? i.Buffer : void 0,
            l = (o ? o.isBuffer : void 0) || r;
        t.exports = l
    }).call(this, n(117)(t))
}, function (t, e) {
    t.exports = function (t) {
        return function (e) {
            return t(e)
        }
    }
}, function (t, e, n) {
    var i = n(122);
    t.exports = function (t) {
        if ("string" == typeof t || i(t)) return t;
        var e = t + "";
        return "0" == e && 1 / t == -1 / 0 ? "-0" : e
    }
}, function (t, e, n) {
    var i = n(71),
        r = n(66),
        s = n(160),
        a = n(27);
    t.exports = function (t, e, n) {
        if (!a(n)) return !1;
        var o = typeof e;
        return !!("number" == o ? r(n) && s(e, n.length) : "string" == o && e in n) && i(n[e], t)
    }
}, , , function (t, e, n) {
    var i = n(223);
    t.exports = function (t) {
        return (null == t ? 0 : t.length) ? i(t, 1) : []
    }
}, , , , , , , , , function (t, e, n) {
    "use strict";
    n.r(e), n.d(e, "default", (function () {
        return R
    }));
    var i = n(1),
        r = n(15),
        s = n.n(r),
        a = n(141),
        o = n(5),
        l = n.n(o),
        c = n(47),
        h = n.n(c),
        u = n(11),
        d = n.n(u),
        p = n(3),
        f = n.n(p),
        m = (n(131), n(38), n(84), n(2)),
        g = n.n(m),
        v = n(22),
        y = n.n(v);
    const b = $.Deferred();
    let x = !1;

    function _(t) {
        if (!1 === x) {
            const e = t.data("recaptchaNonce");
            x = !0, $(`<script src="https://www.google.com/recaptcha/api.js?onload=recaptchaLoadCallback&render=explicit" ${e ? `nonce="${encodeURIComponent(e)}"` : ""} async defer><\/script>`).appendTo("body")
        }
        return b
    }

    function w(t) {
        const e = $.Deferred();
        return t.data("recaptchaPromise", e), _(t).done(e => {
            (function (t) {
                let e = t.data("recaptchaWidget");
                return e || (e = $.Deferred(), t.data("recaptchaWidget", e), _(t).done(n => {
                    const i = $("<div />").appendTo(t),
                        r = t.data("recaptcha2Key");
                    r || console.warn("Google recaptcha V2 site key is not set");
                    const s = n.render(i.get(0), {
                        sitekey: r,
                        size: "invisible",
                        callback: function () {
                            t.data("recaptchaPromise").resolve()
                        }
                    });
                    e.resolve(s)
                })), e
            })(t).done(t => {
                e.reset(t), e.execute(t)
            })
        }), e
    }
    window.recaptchaLoadCallback = function () {
        b.resolve(window.grecaptcha)
    };
    var S = n(54);
    g.a.fn.recaptcha = f()((function (t) {
        let e = 3;
        t.data("recaptcha3Key") ? Object(S.a)(t) : e = 2, requestAnimationFrame(() => {
            var n;
            l()((n = t, y()(g.a.app.getPlugins(n), t => {
                if (g.a.app.hasPluginDefined(n, t)) {
                    const e = n[t]("instance");
                    if (e && "addCustomValidator" in e && "addCustomResponseHandler" in e) return !0
                }
                return !1
            })), n => {
                t[n]("addCustomValidator", () => 2 === e ? w(t) : Object(S.c)(t)), t[n]("addCustomResponseHandler", (n, i) => {
                    !1 === i.recaptcha3 && 3 === e && (e = 2, Object(S.b)(t), t.submit())
                })
            })
        })
    }));
    n(375);
    const M = /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/;
    var E = n(21);
    const T = {
        7: /^(\(\d{3}\)|\d{3})[\s-]?\d{3}[\s-]?\d{2}[\s-]?\d{2}$/,
        unknown: function (t) {
            if (/^(\+\d)?[\d\s-()]+$/.test(t)) {
                const e = t.replace(/[^\d]/g, "").length;
                return "+" === t[0] ? e >= 7 : e >= 4
            }
            return !1
        }
    };

    function C(t, e) {
        return "function" == typeof e ? e(t) : e.test(t)
    }

    function A(t, e) {
        const n = E({
            countryCodeRequired: !1,
            countryCodeDefault: ""
        }, e),
            [i, r] = function (t) {
                const e = t.match(/^\+(\d{1,3}(-\d{3,4})?)\s(.*)$/);
                return e && e[1] in T ? [e[1], e[3]] : [null, t]
            }(t);
        if (i) {
            return C(r, T[i])
        }
        for (let e in T)
            if ("unknown" !== e) {
                const i = T[e];
                if ("+" === t[0] || !n.countryCodeRequired)
                    if (0 === t.indexOf("+" + e)) {
                        if (C(t.replace("+" + e, "").trim(), i)) return !0
                    } else if (0 === t.indexOf(e)) {
                        if (C(t.replace(e, "").trim(), i)) return !0
                    } else if (!n.countryCodeDefault || e === n.countryCodeDefault) {
                        if (C(t, i)) return !0
                    }
            } else if (!("+" !== t[0] && n.countryCodeRequired || "+" !== t[0] && n.countryCodeDefault && T[n.countryCodeDefault])) {
                const i = T[e];
                let r = t;
                if (n.countryCodeDefault && "+" !== t[0] && (r = "+" + n.countryCodeDefault + " " + t), C(r, i)) return !0
            }
        return !1
    }
    i.a.validator.methods.email = function (t, e) {
        return this.optional(e) || !("string" != typeof (n = t) || !M.test(n));
        var n
    }, i.a.validator.methods.tel = function (t, e) {
        return this.optional(e) || !!A(t, {
            countryCodeRequired: !1,
            countryCodeDefault: null
        })
    }, l()(i.a.validator.methods, (function (t, e) {
        i.a.validator.methods[e] = function () {
            return "string" == typeof arguments[0] && (arguments[0] = arguments[0].trim()), t.apply(this, arguments)
        }
    }));
    i.a.extend(i.a.validator.messages, {
        tel: "Please enter a valid phone number.",
        generic: "Connection error, please try again!",
        genericCode: "Error occured, please try again!"
    }, i.a.validator.messages, window.LOCALES && window.LOCALES.errors);
    class R {
        static get Defaults() {
            return {
                useAjax: !0,
                crossDomain: !1,
                successRedirectUrl: !1,
                successRedirectTransition: "fade",
                successRedirectMode: "auto",
                successReload: !1,
                autoSave: !1,
                animationIn: "fade-in",
                animationOut: "fade-out"
            }
        }
        constructor(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            this.options = i.a.extend({}, this.constructor.Defaults, e), this.$form = t, this.$errorMessage = t.find(".js-form-error-message"), this.customValidators = [], this.customResponseHandlers = [], this.isLoading = !1, this.formName = t.attr("name") || "", t.on("reset", this.reset.bind(this)), this.options.autoSave && t.on("change", d()(this.onsuccess.bind(this), 250)), i.a.fn.validate ? this.validator = t.validate(i.a.extend({
                submitHandler: this.onsuccess.bind(this),
                invalidHandler: this.onerror.bind(this),
                errorPlacement: this.errorPlacement.bind(this),
                highlight: this.errorHighlight.bind(this),
                unhighlight: this.errorUnhighlight.bind(this)
            }, this.getValidationOptions())) : t.on("submit", t => {
                this.options.useAjax && t.preventDefault(), this.onsuccess()
            })
        }
        getValidationOptions() {
            return {
                rules: {}
            }
        }
        getFormValues() {
            return this.$form.serializeObject()
        }
        getFormData() {
            return new FormData(this.$form.get(0))
        }
        reset() {
            const t = this.validator;
            t && (t.resetForm(), this.$form.find(`.form-control--${t.settings.errorClass}, .form-control--${t.settings.validClass}`).each((e, n) => {
                this.resetHighlight(n, t.settings.errorClass, t.settings.validClass)
            })), this.hideSuccessMessage(), this.hideGenericErrorMessage()
        }
        disable() {
            const t = this.$form;
            t.find("input, select, textarea").prop("readonly", !0).addClass("readonly"), t.find('button[type="submit"], input[type="submit"]').prop("disabled", !0)
        }
        enable() {
            const t = this.$form;
            t.find("input, select, textarea").prop("readonly", !1).removeClass("readonly"), t.find('button[type="submit"], input[type="submit"]').prop("disabled", !1)
        }
        onsuccess() {
            var t = this;
            if (this.isLoading) return;
            this.setLoading(!0);
            const e = this.$form;
            let n = !e.valid || e.valid();
            n = n ? this.validate() : i.a.Deferred().reject(), n.then(() => {
                this.setLoading(!1), this.hideGenericErrorMessage(), this.submit()
            }).catch((function () {
                for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++) n[r] = arguments[r];
                const s = h()(n, (t, e) => i.a.extend(t, e), {});
                i.a.isEmptyObject(s) || t.setErrors(s), t.showGenericErrorMessage(), t.hideSuccessMessage(), t.setLoading(!1)
            }))
        }
        onerror() {
            if (this.hideGenericErrorMessage(), this.validator.errorList.length) {
                Object(i.a)(this.validator.errorList[0].element).scrollIntoView()
            }
        }
        validate() {
            const t = this.customValidators,
                e = this.getFormValues();
            let n = [];
            for (let i = 0; i < t.length; i++) {
                let r = t[i](e, this);
                if (!r) {
                    n.push(Promise.reject());
                    break
                }
                if (r && r.then) n.push(r), r.catch(t => {
                    t && console.error(t)
                });
                else if (r && "object" == typeof r) {
                    n.push(Promise.reject(r));
                    break
                }
            }
            return Promise.all(n)
        }
        addCustomValidator(t) {
            this.customValidators.push(t)
        }
        setLoading(t) {
            this.isLoading = t
        }
        submit() {
            if (this.isLoading) return;
            const t = this.$form,
                e = this.getFormValues(),
                n = t.attr("action"),
                r = t.attr("method") || "GET",
                s = "post" !== r.toLowerCase();
            this.setLoading(!0), this.disable(), this.options.useAjax ? i.a.ajax({
                url: n,
                method: r,
                dataType: "json",
                crossDomain: this.options.crossDomain,
                contentType: !!s && "application/x-www-form-urlencoded; charset=UTF-8",
                processData: !!s,
                data: s ? e : this.getFormData()
            }).always(this.handleResponseComplete.bind(this)).done(this.handleResponseSuccess.bind(this, e)).fail(this.handleResponseFailure.bind(this, e)) : t.get(0).submit()
        }
        handleResponseComplete(t, e) {
            this.setLoading(!1), this.enable()
        }
        handleResponseSuccess(t, e) {
            if (e.status) l()(this.customResponseHandlers, n => {
                n(t, e, null, this)
            }), this.handleSuccess(t, e);
            else {
                let n = e.errors || e.error || [];
                "string" == typeof n && (n = [{
                    message: n
                }]), n && "object" == typeof n && !Array.isArray(n) && (n = [n]), l()(this.customResponseHandlers, i => {
                    i(t, e, n, this)
                }), this.handleErrorResponse(n)
            }
        }
        handleResponseFailure(t, e) {
            const n = e.status;
            let r;
            r = n >= 400 ? i.a.validator.messages.genericCode || "" : i.a.validator.messages.generic || "", l()(this.customResponseHandlers, n => {
                n(t, e, null, this)
            }), this.showGenericErrorMessage(r.replace("${code}", n))
        }
        handleErrorResponse(t) {
            const e = this.$form;
            let n = "";
            const i = h()(t, (t, i) => {
                if (i.id && i.id != this.formName) {
                    const n = this.getInputName(i.id);
                    e.find('[name="' + n + '"]').length ? t[n] = i.message : e.find('[name="' + i.id + '"]').length && (t[i.id] = i.message)
                } else n = i.message;
                return t
            }, {});
            n && this.showGenericErrorMessage(n), this.setErrors(i)
        }
        getInputName(t) {
            const e = this.formName;
            let n = t;
            return e && (n = e + "[" + t.replace(/^([^[]+)/, "$1]")), n
        }
        handleSuccess(t, e) {
            const n = this.options,
                r = n.successRedirectUrl || e.redirect,
                o = "auto" === n.successRedirectMode && a.a;
            if (r) this.setLoading(!0), o ? (this.disable(), s.a.cache.delete(r), s.a.go(r, Object(i.a)(`<a href="${r}" data-ajax-page-ignore-prefetch data-ajax-page-transition="${n.successRedirectTransition}"></a>`).get(0))) : document.location = r;
            else if (n.successReload) document.location.reload();
            else {
                this.showSuccessMessage(t, e);
                const n = new CustomEvent("submit:success", {
                    bubbles: !0,
                    detail: e
                });
                this.$form.get(0).dispatchEvent(n)
            }
        }
        addCustomResponseHandler(t) {
            this.customResponseHandlers.push(t)
        }
        errorPlacement(t, e) {
            e.closest(".form-control").after(t)
        }
        getErrorElement(t) {
            const e = Object(i.a)(t);
            return e.is("select") && e.next(".selectivity-input, .nice-select").length ? e.next() : e.closest(".form-control")
        }
        getLabelElement(t) {
            return Object(i.a)(t.form).find('label[for="' + t.id + '"]').not(".error")
        }
        resetHighlight(t, e, n) {
            const i = this.getErrorElement(t),
                r = this.getLabelElement(t),
                s = i.closest(".form-group, .form-row");
            i.removeClass("form-control--" + e).removeClass("form-control--" + n), r.removeClass("form-label--" + e), s.removeClass("has-error").removeClass("has-success"), this.triggerSizeChangeEvent()
        }
        errorHighlight(t, e, n) {
            const i = this.getErrorElement(t),
                r = this.getLabelElement(t),
                s = i.closest(".form-group, .form-row");
            i.addClass("form-control--" + e).removeClass("form-control--" + n), r.removeClass("form-label--" + e), s.removeClass("has-success").addClass("has-error"), this.triggerSizeChangeEvent()
        }
        errorUnhighlight(t, e, n) {
            const i = this.getErrorElement(t),
                r = this.getLabelElement(t),
                s = i.closest(".form-group, .form-row");
            i.removeClass("form-control--" + e).addClass("form-control--" + n), r.removeClass("form-label--" + e), s.removeClass("has-error").addClass("has-success"), this.triggerSizeChangeEvent()
        }
        showGenericErrorMessage(t) {
            this.$form.trigger("show-generic-error.ajax-form", {
                message: t
            }), this.$errorMessage.length && (this.$errorMessage.html(t).removeClass("is-hidden"), this.triggerSizeChangeEvent())
        }
        hideGenericErrorMessage() {
            this.$form.trigger("hide-generic-error.ajax-form"), this.$errorMessage.length && (this.$errorMessage.addClass("is-hidden"), this.triggerSizeChangeEvent())
        }
        setErrors(t) {
            this.validator && this.validator.showErrors(t)
        }
        transitionScreens(t, e) {
            const n = this.$form,
                i = t.css("overflow", "hidden").outerHeight(),
                r = e.removeClass("is-hidden").css("overflow", "hidden").outerHeight(),
                s = e.outerWidth();
            t.css("overflow", ""), e.addClass("is-hidden").css("overflow", "").outerHeight(), e.add(t).transitionstop(() => {
                e.transition(this.options.animationIn, {
                    before: t => t.addClass("animation--height").css("height", i),
                    transition: t => t.css("height", r),
                    after: t => t.removeClass("animation--height").css("height", "")
                });
                const a = "static" === n.css("position") ? "relative" : "",
                    o = [t.css("left"), t.css("right")],
                    l = "auto" === o[0] && "auto" === o[1] ? s : "";
                t.transition(this.options.animationOut, {
                    before: t => {
                        n.css({
                            position: a
                        }), t.css({
                            position: "absolute",
                            top: 0,
                            left: o[0],
                            right: o[1],
                            width: l
                        })
                    },
                    after: i => {
                        n.css({
                            position: "",
                            overflow: ""
                        }), i.css({
                            position: "",
                            left: "",
                            right: ""
                        }), e.attr("aria-hidden", !1), t.attr("aria-hidden", !0), this.triggerSizeChangeEvent()
                    }
                })
            })
        }
        showSuccessMessage() {
            const t = this.$form,
                e = t.find(".js-form-content"),
                n = t.find(".js-form-success");
            this.transitionScreens(e, n)
        }
        hideSuccessMessage() {
            const t = this.$form,
                e = t.find(".js-form-success"),
                n = t.find(".js-form-content");
            e.hasClass("is-hidden") || (e.addClass("is-hidden"), n.removeClass("is-hidden"), this.triggerSizeChangeEvent())
        }
        triggerSizeChangeEvent() {
            this.$form.trigger("appear")
        }
    }
    i.a.fn.ajaxForm = f()(R, {})
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return c
    }));
    var i = n(0),
        r = n(144),
        s = n(81),
        a = n(34);
    class o extends a.b {
        constructor(t, e) {
            super(), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1
        }
        render(t, e, n) {
            const i = t.getContext(),
                r = t.state;
            let s, a;
            r.buffers.color.setMask(!1), r.buffers.depth.setMask(!1), r.buffers.color.setLocked(!0), r.buffers.depth.setLocked(!0), this.inverse ? (s = 0, a = 1) : (s = 1, a = 0), r.buffers.stencil.setTest(!0), r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE), r.buffers.stencil.setFunc(i.ALWAYS, s, 4294967295), r.buffers.stencil.setClear(a), r.buffers.stencil.setLocked(!0), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), r.buffers.color.setLocked(!1), r.buffers.depth.setLocked(!1), r.buffers.color.setMask(!0), r.buffers.depth.setMask(!0), r.buffers.stencil.setLocked(!1), r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP), r.buffers.stencil.setLocked(!0)
        }
    }
    class l extends a.b {
        constructor() {
            super(), this.needsSwap = !1
        }
        render(t) {
            t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1)
        }
    }
    class c {
        constructor(t, e) {
            if (this.renderer = t, this._pixelRatio = t.getPixelRatio(), void 0 === e) {
                const n = t.getSize(new i.Zb);
                this._width = n.width, this._height = n.height, (e = new i.cc(this._width * this._pixelRatio, this._height * this._pixelRatio, {
                    type: i.I
                })).texture.name = "EffectComposer.rt1"
            } else this._width = e.width, this._height = e.height;
            this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new s.a(r.a), this.copyPass.material.blending = i.mb, this.clock = new i.n
        }
        swapBuffers() {
            const t = this.readBuffer;
            this.readBuffer = this.writeBuffer, this.writeBuffer = t
        }
        addPass(t) {
            this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
        }
        insertPass(t, e) {
            this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
        }
        removePass(t) {
            const e = this.passes.indexOf(t); - 1 !== e && this.passes.splice(e, 1)
        }
        isLastEnabledPass(t) {
            for (let e = t + 1; e < this.passes.length; e++)
                if (this.passes[e].enabled) return !1;
            return !0
        }
        render(t) {
            void 0 === t && (t = this.clock.getDelta());
            const e = this.renderer.getRenderTarget();
            let n = !1;
            for (let e = 0, i = this.passes.length; e < i; e++) {
                const i = this.passes[e];
                if (!1 !== i.enabled) {
                    if (i.renderToScreen = this.renderToScreen && this.isLastEnabledPass(e), i.render(this.renderer, this.writeBuffer, this.readBuffer, t, n), i.needsSwap) {
                        if (n) {
                            const e = this.renderer.getContext(),
                                n = this.renderer.state.buffers.stencil;
                            n.setFunc(e.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), n.setFunc(e.EQUAL, 1, 4294967295)
                        }
                        this.swapBuffers()
                    }
                    void 0 !== o && (i instanceof o ? n = !0 : i instanceof l && (n = !1))
                }
            }
            this.renderer.setRenderTarget(e)
        }
        reset(t) {
            if (void 0 === t) {
                const e = this.renderer.getSize(new i.Zb);
                this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, (t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            }
            this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
        }
        setSize(t, e) {
            this._width = t, this._height = e;
            const n = this._width * this._pixelRatio,
                i = this._height * this._pixelRatio;
            this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
            for (let t = 0; t < this.passes.length; t++) this.passes[t].setSize(n, i)
        }
        setPixelRatio(t) {
            this._pixelRatio = t, this.setSize(this._width, this._height)
        }
        dispose() {
            this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose()
        }
    }
}, function (t, e, n) {
    var i = n(265),
        r = n(266),
        s = n(267),
        a = n(268),
        o = n(269);

    function l(t) {
        var e = -1,
            n = null == t ? 0 : t.length;
        for (this.clear(); ++e < n;) {
            var i = t[e];
            this.set(i[0], i[1])
        }
    }
    l.prototype.clear = i, l.prototype.delete = r, l.prototype.get = s, l.prototype.has = a, l.prototype.set = o, t.exports = l
}, function (t, e, n) {
    var i = n(71);
    t.exports = function (t, e) {
        for (var n = t.length; n--;)
            if (i(t[n][0], e)) return n;
        return -1
    }
}, function (t, e, n) {
    var i = n(73),
        r = n(27);
    t.exports = function (t) {
        if (!r(t)) return !1;
        var e = i(t);
        return "[object Function]" == e || "[object GeneratorFunction]" == e || "[object AsyncFunction]" == e || "[object Proxy]" == e
    }
}, function (t, e) {
    var n;
    n = function () {
        return this
    }();
    try {
        n = n || new Function("return this")()
    } catch (t) {
        "object" == typeof window && (n = window)
    }
    t.exports = n
}, function (t, e, n) {
    var i = n(72)(Object, "create");
    t.exports = i
}, function (t, e, n) {
    var i = n(289);
    t.exports = function (t, e) {
        var n = t.__data__;
        return i(e) ? n["string" == typeof e ? "string" : "hash"] : n.map
    }
}, function (t, e, n) {
    var i = n(155),
        r = n(294),
        s = n(295);

    function a(t) {
        var e = -1,
            n = null == t ? 0 : t.length;
        for (this.__data__ = new i; ++e < n;) this.add(t[e])
    }
    a.prototype.add = a.prototype.push = r, a.prototype.has = s, t.exports = a
}, function (t, e) {
    t.exports = function (t, e) {
        return t.has(e)
    }
}, function (t, e) {
    t.exports = function (t) {
        return t.webpackPolyfill || (t.deprecate = function () { }, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, "loaded", {
            enumerable: !0,
            get: function () {
                return t.l
            }
        }), Object.defineProperty(t, "id", {
            enumerable: !0,
            get: function () {
                return t.i
            }
        }), t.webpackPolyfill = 1), t
    }
}, function (t, e, n) {
    var i = n(302),
        r = n(93),
        s = n(162),
        a = s && s.isTypedArray,
        o = a ? r(a) : i;
    t.exports = o
}, function (t, e) {
    var n = Object.prototype;
    t.exports = function (t) {
        var e = t && t.constructor;
        return t === ("function" == typeof e && e.prototype || n)
    }
}, function (t, e, n) {
    var i = n(305),
        r = n(154),
        s = n(306),
        a = n(210),
        o = n(307),
        l = n(73),
        c = n(200),
        h = c(i),
        u = c(r),
        d = c(s),
        p = c(a),
        f = c(o),
        m = l;
    (i && "[object DataView]" != m(new i(new ArrayBuffer(1))) || r && "[object Map]" != m(new r) || s && "[object Promise]" != m(s.resolve()) || a && "[object Set]" != m(new a) || o && "[object WeakMap]" != m(new o)) && (m = function (t) {
        var e = l(t),
            n = "[object Object]" == e ? t.constructor : void 0,
            i = n ? c(n) : "";
        if (i) switch (i) {
            case h:
                return "[object DataView]";
            case u:
                return "[object Map]";
            case d:
                return "[object Promise]";
            case p:
                return "[object Set]";
            case f:
                return "[object WeakMap]"
        }
        return e
    }), t.exports = m
}, function (t, e, n) {
    var i = n(26),
        r = n(164),
        s = n(310),
        a = n(165);
    t.exports = function (t, e) {
        return i(t) ? t : r(t, e) ? [t] : s(a(t))
    }
}, function (t, e, n) {
    var i = n(73),
        r = n(51);
    t.exports = function (t) {
        return "symbol" == typeof t || r(t) && "[object Symbol]" == i(t)
    }
}, function (t, e) {
    t.exports = function (t) {
        return t
    }
}, function (t, e, n) {
    var i = n(123),
        r = n(216),
        s = n(218);
    t.exports = function (t, e) {
        return s(r(t, e, i), t + "")
    }
}, function (t, e, n) {
    var i = n(66),
        r = n(51);
    t.exports = function (t) {
        return r(t) && i(t)
    }
}, function (t, e, n) {
    var i = n(219);
    t.exports = function (t, e, n) {
        "__proto__" == e && i ? i(t, e, {
            configurable: !0,
            enumerable: !0,
            value: n,
            writable: !0
        }) : t[e] = n
    }
}, function (t, e, n) {
    var i = n(124),
        r = n(95);
    t.exports = function (t) {
        return i((function (e, n) {
            var i = -1,
                s = n.length,
                a = s > 1 ? n[s - 1] : void 0,
                o = s > 2 ? n[2] : void 0;
            for (a = t.length > 3 && "function" == typeof a ? (s--, a) : void 0, o && r(n[0], n[1], o) && (a = s < 3 ? void 0 : a, s = 1), e = Object(e); ++i < s;) {
                var l = n[i];
                l && t(e, l, i, a)
            }
            return e
        }))
    }
}, function (t, e, n) {
    "use strict";
    n(1).a.event.special.returnkey = {
        delegateType: "keydown",
        bindType: "keydown",
        handle: function (t) {
            var e = t.handleObj,
                n = null;
            if (13 === t.which) return t.type = e.origType, n = e.handler.apply(this, arguments), t.type = e.type, n
        }
    }
}, function (t, e) {
    t.exports = function (t, e) {
        var n = -1,
            i = t.length;
        for (e || (e = Array(i)); ++n < i;) e[n] = t[n];
        return e
    }
}, function (t, e, n) {
    var i = n(73),
        r = n(171),
        s = n(51),
        a = Function.prototype,
        o = Object.prototype,
        l = a.toString,
        c = o.hasOwnProperty,
        h = l.call(Object);
    t.exports = function (t) {
        if (!s(t) || "[object Object]" != i(t)) return !1;
        var e = r(t);
        if (null === e) return !0;
        var n = c.call(e, "constructor") && e.constructor;
        return "function" == typeof n && n instanceof n && l.call(n) == h
    }
}, function (t, e, n) {
    "use strict";
    var i = n(1),
        r = n(12),
        s = n.n(r),
        a = n(5),
        o = n.n(a),
        l = n(27),
        c = n.n(l);
    const h = /\[([^[]*)\]/g;
    i.a.fn.serializeObject = function () {
        const t = this.filter("form, input, select, textarea"),
            e = this.not("form, input, select, textarea").find("input, select, textarea"),
            n = t.add(e).serializeArray(),
            r = {};
        return o()(n, t => {
            const e = t.name.replace(h, "§$1").split("§");
            ! function (t, e, n) {
                if (!c()(t)) return t;
                let i = -1,
                    r = e.length,
                    s = r - 1,
                    a = t;
                for (; null != a && ++i < r;) {
                    let t = e[i],
                        r = n;
                    if (i != s) {
                        const n = a[t],
                            s = "" === e[i + 1];
                        r = c()(n) ? n : s ? [] : {}
                    }
                    Array.isArray(a) ? t ? a[parseInt(t, 10)] = r : a.push(r) : a[t] = r, a = a[t]
                }
            }(r, e, t.value)
        }),
            function t(e) {
                if (i.a.isPlainObject(e)) {
                    const n = Object.keys(e);
                    if (n.length) {
                        o()(e, (n, r) => {
                            i.a.isPlainObject(n) && (e[r] = t(n))
                        });
                        for (let t = 0; t < n.length; t++)
                            if (-1 === n.indexOf(String(t))) return e;
                        return s()(e, t => t)
                    }
                }
                return e
            }(r)
    }
}, function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(1),
        r = n(3),
        s = n.n(r),
        a = n(0),
        o = n(16),
        l = n(25),
        c = n(19),
        h = n(36);
    const u = [0, Math.PI / 180 * -90, 0];
    class d extends l.a {
        static get Defaults() {
            return i.a.extend(!0, {}, l.a.Defaults, {
                lazy: !1,
                debug: !1,
                mouseTracking: !0,
                scrollTracking: !0,
                camera: {
                    position: [0, 11, 47],
                    rotation: [-.444, -0, 0],
                    fov: 90,
                    near: .1,
                    far: 1e3
                },
                cameraOrbitControls: !1
            })
        }
        init() {
            this.progress = new a.Tb(1), this.speed = new a.Tb(1e3), super.init()
        }
        initGUI() {
            super.initGUI(), this.gui && (this.gui.add({
                showText: !0
            }, "showText").onChange(t => {
                Object(i.a)(".js-visualization-lines-text").css("opacity", t ? 1 : 0)
            }), this.gui.add(this.progress, "value", 0, 2).name("progress"), this.gui.add(this.speed, "value", 0, 2e3).name("inverse speed"))
        }
        initScene() {
            const t = this.scene = new a.Kb;
            this.lines = [new c.a({
                curve: h.a,
                loops: 2.7,
                direction: -1,
                radius: 30,
                scale: [1, .75, 1],
                lineWidth: .25,
                offset: .07,
                length: .92,
                colorNormal: new a.o(1, 101 / 255, 36 / 255),
                colorLight: new a.o(1, 101 / 255, 36 / 255),
                colorDark: new a.o(1, 38 / 255, 0),
                rotation: u,
                position: new a.ac(0, 0, 0),
                gui: this.gui,
                camera: this.camera,
                progress: this.progress,
                speed: this.speed,
                varyingLoops: 8,
                varyingLoopOffset: .1,
                varyingMin: .75,
                varyingMax: 1,
                edgeRadius: .05,
                blurCoeficient: 0,
                blurPower: 3,
                particles: 4e3,
                particleSize: this.getParticleSize()
            }), new c.a({
                curve: h.a,
                loops: 2.7,
                direction: -1,
                radius: 30,
                scale: [1, .75, 1],
                lineWidth: 1,
                offset: .725,
                length: .2,
                colorNormal: new a.o(1, 119 / 255, 46 / 255),
                colorLight: new a.o(1, 119 / 255, 46 / 255),
                colorDark: new a.o(1, 38 / 255, 0),
                rotation: u,
                position: new a.ac(0, 2, 0),
                gui: this.gui,
                camera: this.camera,
                progress: this.progress,
                speed: this.speed,
                blurCoeficient: 0,
                blurPower: 5.25,
                edgeRadius: .5,
                edgeAlignment: "bottom"
            }), new c.a({
                curve: h.a,
                loops: 2.7,
                direction: -1,
                radius: 30,
                scale: [1, .75, 1],
                lineWidth: .45,
                colorNormal: new a.o(1, 130 / 255, 46 / 255),
                colorLight: new a.o(1, 130 / 255, 46 / 255),
                colorDark: new a.o(1, 38 / 255, 0),
                offset: .58,
                length: .11,
                rotation: u,
                position: new a.ac(0, -.75, 0),
                gui: this.gui,
                camera: this.camera,
                progress: this.progress,
                speed: this.speed,
                blurCoeficient: .1,
                blurPower: 8,
                edgeRadius: .5
            }), new c.a({
                curve: h.a,
                loops: 2.7,
                direction: -1,
                radius: 30,
                scale: [1, .75, 1],
                lineWidth: .6,
                colorNormal: new a.o(1, 119 / 255, 46 / 255),
                colorLight: new a.o(1, 119 / 255, 46 / 255),
                colorDark: new a.o(1, 38 / 255, 0),
                offset: .245,
                length: .05,
                rotation: u,
                position: new a.ac(0, -1.25, 0),
                gui: this.gui,
                camera: this.camera,
                progress: this.progress,
                speed: this.speed,
                blurCoeficient: -.1,
                blurPower: 10,
                edgeRadius: .5
            })], this.lines.forEach(e => t.add(e.getMesh()))
        }
        getParticleSize() {
            return this.size.width / 880 * 50
        }
        onMouseMove(t) { }
        onMouseMoveAnimated(t) {
            this.lines.forEach(e => {
                e.rotation.y = u[1] - .2 * (t.x - .5)
            })
        }
        onResize() {
            if (this.lines) {
                const t = this.getParticleSize();
                this.lines.forEach(e => {
                    e.setParticleSize(t)
                })
            }
        }
        onScroll(t) {
            if (this.progress) {
                const e = Object(o.a)(t, .1, .6, 0, 1);
                this.progress.value = e
            }
        }
        onTick(t) {
            this.lines.forEach(e => e.update(t))
        }
    }
    i.a.fn.visualizationLines = s()(d)
}, function (t, e, n) {
    "use strict";
    var i = n(2),
        r = n.n(i),
        s = n(3),
        a = n.n(s),
        o = n(9);
    const l = ["touchstart", "mousedown", "pointerdown", "MSPointerDown"],
        c = ["touchmove", "mousemove", "pointermove", "MSPointerMove"],
        h = ["touchend", "mouseup", "pointerup", "MSPointerUp"],
        u = {
            touchstart: 1,
            touchmove: 1,
            touchend: 1,
            mousedown: 2,
            mousemove: 2,
            mouseup: 2,
            pointerdown: 3,
            pointermove: 3,
            pointerup: 3,
            MSPointerDown: 3,
            MSPointerMove: 3,
            MSPointerUp: 3
        };
    r.a.fn.draggable = a()(class {
        static get Defaults() {
            return {
                preventDefault: !0,
                preventScroll: !1,
                clickCancelDistance: 5,
                activationDistance: 10,
                activationDuration: 300,
                ignoreSelector: null
            }
        }
        constructor(t, e) {
            const n = this.$container = r()(t);
            this.options = r.a.extend({}, this.constructor.Defaults, e), this.ns = Object(o.a)(), this.enabled = !0, this.initiated = !1, this.moved = !1, this.memory = {}, n.on("dragstart", this.preventElementDrag.bind(this)), n.on(l.join(" "), this.handleDragStart.bind(this))
        }
        preventElementDrag(t) {
            t.preventDefault()
        }
        handleDragStart(t) {
            if (!this.enabled || this.initiated) return;
            if (this.options.ignoreSelector && r()(t.target).closest(this.options.ignoreSelector).length) return;
            if (("mousedown" === t.type || "pointerdown" === t.type) && 1 !== t.which) return;
            const e = r()(document),
                n = this.getInputPosition(t),
                i = this.ns;
            this.initiated = u[t.type], this.moved = !1, this.startTime = performance.now(), this.canceled = !1, this.memory = {}, this.startXY = n, this.lastXY = n, this.deltaXY = [0, 0], e.onpassive(c.join(`.${i} `) + "." + i, this.handleDragMove.bind(this), {
                passive: !1
            }), e.on(h.join(`.${i} `) + "." + i, this.handleDragEnd.bind(this)), this.$container.on("click." + i, "a", this.handleClick.bind(this));
            const s = r.a.Event("draggable:beforeStart");
            this.triggerEvent(s), s.isDefaultPrevented() ? this.canceled = !0 : this.options.activationDistance || this.handleDragMove(t)
        }
        handleDragMove(t) {
            if (!this.enabled) return;
            const e = performance.now(),
                n = this.getInputPosition(t);
            let i = this.startXY,
                s = [n[0] - i[0], n[1] - i[1]];
            if (!this.moved && !this.canceled) {
                const t = this.options;
                if (e - this.startXY > t.activationDuration) this.startTime = e, this.startXY = this.lastXY = i = n, s = [0, 0];
                else if (e - this.startXY <= t.activationDuration && s[0] < t.activationDistance && s[1] < t.activationDistance) return;
                const a = r.a.Event("draggable:start");
                this.triggerEvent(a), a.isDefaultPrevented() && (this.canceled = !0)
            }
            this.canceled || (this.lastXY = n, this.deltaXY = s, this.moved = !0, this.triggerEvent("draggable:move"), "touchmove" === t.type && !t.passive && this.options.preventScroll && t.preventDefault())
        }
        handleDragEnd(t) {
            if (!this.enabled) return;
            const e = r()(document),
                n = this.ns;
            if (e.offpassive(c.join(`.${n} `) + "." + n, null, {
                passive: !1
            }), e.off(h.join(`.${n} `) + "." + n), this.moved && !this.canceled) {
                const e = this.getInputPosition(t),
                    n = this.startXY,
                    i = [e[0] - n[0], e[1] - n[1]];
                this.lastXY = e, this.deltaXY = i, this.options.preventDefault && t.preventDefault(), this.triggerEvent("draggable:end")
            }
            this.moved && !this.canceled && this.options.preventDefault ? setTimeout(() => {
                this.$container.off("click." + n, "a")
            }, 120) : this.$container.off("click." + n, "a"), this.memory = {}, this.canceled = !1, this.moved = !1, this.initiated = !1
        }
        handleClick(t) {
            Math.max(Math.abs(this.deltaXY[0]), Math.abs(this.deltaXY[1])) > this.options.clickCancelDistance && (t.preventDefault(), t.stopPropagation()), this.$container.off("click." + this.ns, "a")
        }
        getInputPosition(t) {
            const e = (t = t.originalEvent ? t.originalEvent : t).touches ? t.touches[0] : t;
            return e ? [e.pageX, e.pageY] : this.lastXY
        }
        triggerEvent(t) {
            this.$container.triggerHandler(t, {
                xy: this.lastXY,
                startXY: this.startXY,
                deltaXY: this.deltaXY,
                memory: this.memory
            })
        }
    })
}, function (t, e, n) {
    "use strict";
    n.r(e), n.d(e, "default", (function () {
        return s
    }));
    var i = n(3),
        r = n.n(i);
    class s {
        static get Defaults() {
            return {}
        }
        constructor(t) {
            this.$container = t, this.$elements = this.$container.find("[data-filter-plan-id]"), this.$checkboxes = this.$container.find('input[type="checkbox"]'), this.$tabs = this.$container.find(".js-filter-plan-button"), this.$elements.on("click", this.handleClick.bind(this)), this.$tabs.on("click", this.handleTabClick.bind(this)), this.$elements.on("mouseenter mouseleave", this.handleHover.bind(this)), this.$tabs.on("mouseenter mouseleave", this.handleHover.bind(this)), this.$checkboxes.on("change", this.updateStyles.bind(this)), this.$checkboxes.each((t, e) => {
                this.testActive($(e))
            })
        }
        updateStyles(t) {
            const e = $(t.currentTarget),
                n = e.val(),
                i = e.data("filter-plan-input-stage"),
                r = this.$container.find(`[data-filter-plan-input-stage=${i}]`);
            let s = 0;
            const a = this.$container.find(`a[data-filter-plan-stage=${i}]`),
                o = this.$container.find(`[data-filter-plan-id=${n}]`);
            e.prop("checked") ? o.addClass("is-active") : o.removeClass("is-active"), r.each((t, e) => {
                $(e).prop("checked") && (s += 1)
            }), r.length === s ? a.addClass("is-active") : a.removeClass("is-active")
        }
        handleClick(t) {
            const e = $(t.currentTarget),
                n = e.data("filter-plan-id"),
                i = this.$container.find(`input[value=${n}]`);
            e.hasClass("is-active") ? i.prop("checked", !1).trigger("change") : i.prop("checked", !0).trigger("change"), this.resetHighlight(t)
        }
        handleTabClick(t) {
            const e = $(t.currentTarget),
                n = e.data("filter-plan-stage"),
                i = this.$container.find(`input[data-filter-plan-input-stage=${n}]`),
                r = this.$container.find(`a[data-filter-plan-stage=${n}]`);
            e.hasClass("is-active") ? (i.prop("checked", !1).trigger("change"), r.removeClass("is-active")) : (i.prop("checked", !0).trigger("change"), r.addClass("is-active"))
        }
        handleHover(t) {
            const e = $(t.currentTarget),
                n = e.data("filter-plan-stage");
            let i = "";
            i = e.is("a") ? this.$container.find(`[data-filter-plan-stage=${n}]`) : this.$container.find(`a[data-filter-plan-stage=${n}]`), "mouseenter" == t.type ? i.addClass("js-hovered") : i.removeClass("js-hovered")
        }
        resetHighlight(t) {
            const e = $(t.currentTarget);
            if (!1 === e.prop("checked")) {
                this.$elements.toArray().filter(t => "" + $(t).data("filter-plan-id") == "" + e.val()).forEach(t => {
                    $(t).removeClass("is-active")
                })
            }
        }
        testActive(t) {
            t.prop("checked") && this.$container.find(`[data-filter-plan-id=${t.val()}]`).addClass("is-active")
        }
    }
    $.fn.filterPlan = r()(s)
}, function (t, e, n) {
    "use strict";
    n.r(e), n.d(e, "default", (function () {
        return M
    }));
    var i = n(1),
        r = n(3),
        s = n.n(r),
        a = "function" == typeof Float32Array;

    function o(t, e) {
        return 1 - 3 * e + 3 * t
    }

    function l(t, e) {
        return 3 * e - 6 * t
    }

    function c(t) {
        return 3 * t
    }

    function h(t, e, n) {
        return ((o(e, n) * t + l(e, n)) * t + c(e)) * t
    }

    function u(t, e, n) {
        return 3 * o(e, n) * t * t + 2 * l(e, n) * t + c(e)
    }

    function d(t) {
        return t
    }

    function p(t, e, n, i) {
        if (!(0 <= t && t <= 1 && 0 <= n && n <= 1)) throw new Error("bezier x values must be in [0, 1] range");
        if (t === e && n === i) return d;
        for (var r = a ? new Float32Array(11) : new Array(11), s = 0; s < 11; ++s) r[s] = h(.1 * s, t, n);

        function o(e) {
            for (var i = 0, s = 1; 10 !== s && r[s] <= e; ++s) i += .1;
            --s;
            var a = i + .1 * ((e - r[s]) / (r[s + 1] - r[s])),
                o = u(a, t, n);
            return o >= .001 ? function (t, e, n, i) {
                for (var r = 0; r < 4; ++r) {
                    var s = u(e, n, i);
                    if (0 === s) return e;
                    e -= (h(e, n, i) - t) / s
                }
                return e
            }(e, a, t, n) : 0 === o ? a : function (t, e, n, i, r) {
                var s, a, o = 0;
                do {
                    (s = h(a = e + (n - e) / 2, i, r) - t) > 0 ? n = a : e = a
                } while (Math.abs(s) > 1e-7 && ++o < 10);
                return a
            }(e, i, i + .1, t, n)
        }
        return function (t) {
            return 0 === t || 1 === t ? t : h(o(t), e, i)
        }
    }
    var f = {
        easeCarousel: p(.6, 0, .1, 1),
        easeFreeCarousel: t => 1 + --t * t * t * t * t,
        easeOut: p(0, 0, .58, 1)
    },
        m = n(7),
        g = n(6),
        v = (n(59), n(8));
    n(369);
    var y = function (t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const n = "data-keen-slider-moves",
            i = "data-keen-slider-v";
        let r, s, a, o, l, c, h, u, d, p, f, m, g, v, y, b, w, S, M, E, T, C, A, R, P, L, O, D, I, k, N, U, z, F, $ = [],
            B = null,
            H = !1,
            j = !1,
            V = 0,
            G = [];

        function W(t, e, n) {
            let i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
            t.addEventListener(e, n, i), $.push([t, e, n, i])
        }

        function q(t) {
            if (!S || M !== Z(t) || !ot()) return;
            const e = Q(t).x;
            if (!et(t) && R) return Y(t);
            R && (Ht(), E = e, R = !1), t.cancelable && t.preventDefault();
            const i = E - e;
            P += Math.abs(i), !L && P > 5 && (L = !0, r.setAttribute(n, !0)), It(A(i, Xt) * (ct() ? -1 : 1), t.timeStamp), E = e
        }

        function X(t) {
            S || !ot() || tt(t.target) || (S = !0, R = !0, M = Z(t), L = !1, P = 0, et(t), pt(), w = p, E = Q(t).x, It(0, t.timeStamp), st("dragStart"))
        }

        function Y(t) {
            S && M === Z(t, !0) && (r.removeAttribute(n), S = !1, gt(), st("dragEnd"))
        }

        function K(t) {
            return t.changedTouches
        }

        function Z(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            const n = e ? K(t) : J(t);
            return n ? n[0] ? n[0].identifier : "error" : "default"
        }

        function J(t) {
            return t.targetTouches
        }

        function Q(t) {
            const e = J(t);
            return {
                x: ut() ? e ? e[0].screenY : t.pageY : e ? e[0].screenX : t.pageX,
                timestamp: t.timeStamp
            }
        }

        function tt(t) {
            return t.hasAttribute(b.preventEvent)
        }

        function et(t) {
            const e = J(t);
            if (!e) return !0;
            const n = e[0],
                i = ut() ? n.clientY : n.clientX,
                r = ut() ? n.clientX : n.clientY,
                s = void 0 !== T && void 0 !== C && Math.abs(C - r) <= Math.abs(T - i);
            return T = i, C = r, s
        }

        function nt(t) {
            ot() && S && t.preventDefault()
        }

        function it() {
            W(window, "orientationchange", Rt), W(window, "resize", () => At()), W(r, "dragstart", (function (t) {
                ot() && t.preventDefault()
            })), W(r, "mousedown", X), W(b.cancelOnLeave ? r : window, "mousemove", q), b.cancelOnLeave && W(r, "mouseleave", Y), W(window, "mouseup", Y), W(r, "touchstart", X, {
                passive: !0
            }), W(r, "touchmove", q, {
                passive: !1
            }), W(r, "touchend", Y, {
                passive: !0
            }), W(r, "touchcancel", Y, {
                passive: !0
            }), W(window, "wheel", nt, {
                passive: !1
            })
        }

        function rt() {
            $.forEach(t => {
                t[0].removeEventListener(t[1], t[2], t[3])
            }), $ = []
        }

        function st(t) {
            b[t] && b[t](Xt)
        }

        function at() {
            return b.centered
        }

        function ot() {
            return void 0 !== s ? s : b.controls
        }

        function lt() {
            return b.loop && a > 1
        }

        function ct() {
            return b.rtl
        }

        function ht() {
            return !b.loop && b.rubberband
        }

        function ut() {
            return !!b.vertical
        }

        function dt() {
            O = window.requestAnimationFrame(ft)
        }

        function pt() {
            O && (window.cancelAnimationFrame(O), O = null), D = null
        }

        function ft(t) {
            D || (D = t);
            const e = t - D;
            let n = mt(e);
            if (e >= k) return It(I - U, !1), F ? F() : void st("afterChange");
            const i = kt(n);
            if (0 === i || lt() || ht() || z) {
                if (0 !== i && ht() && !z) return _t(Math.sign(i));
                U += n, It(n, !1), dt()
            } else It(n - i, !1)
        }

        function mt(t) {
            return I * N(t / k) - U
        }

        function gt() {
            switch (st("beforeChange"), b.mode) {
                case "free":
                    bt();
                    break;
                case "free-snap":
                    xt();
                    break;
                case "snap":
                default:
                    vt()
            }
        }

        function vt() {
            yt((1 === h && 0 !== f ? w : p) + Math.sign(f))
        }

        function yt(t, e) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : b.duration,
                i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : b.easing;
            !0 === s ? s = t => 1 - Math.pow(1 - t, 2) : !1 === s && (s = t => 1 + --t * t * t * t * t), wt(Ft(t = zt(t, i, r)), n, s, e)
        }

        function bt() {
            if (0 === g) return !(!kt(0) || lt()) && yt(p);
            const t = b.friction / Math.pow(Math.abs(g), -.5);
            wt(Math.pow(g, 2) / t * Math.sign(g), 6 * Math.abs(g / t), (function (t) {
                return b.easing ? 1 - Math.pow(1 - t, 2) : 1 - Math.pow(1 - t, 5)
            }))
        }

        function xt() {
            if (0 === g) return yt(p);
            const t = b.friction / Math.pow(Math.abs(g), -.5),
                e = Math.pow(g, 2) / t * Math.sign(g),
                n = 6 * Math.abs(g / t),
                i = (V + e) / (c / h);
            wt((-1 === f ? Math.floor(i) : Math.ceil(i)) * (c / h) - V, n, (function (t) {
                return b.easing ? 1 - Math.pow(1 - t, 2) : 1 - Math.pow(1 - t, 5)
            }))
        }

        function _t() {
            if (pt(), 0 === g) return yt(p, !0);
            const t = .04 / Math.pow(Math.abs(g), -.5),
                e = Math.pow(g, 2) / t * Math.sign(g),
                n = function (t) {
                    return --t * t * t + 1
                },
                i = g;
            wt(e, 3 * Math.abs(i / t), n, !0, () => {
                wt(Ft(zt(p)), 500, n, !0)
            })
        }

        function wt(t, e, n, i, r) {
            isNaN(t) || (pt(), I = t, U = 0, k = e, N = n, z = i, F = r, D = null, dt())
        }

        function St(e) {
            let n = x(t);
            n.length && (r = n[0], At(e), it(), st("mounted"))
        }

        function Mt() {
            const t = e.breakpoints || [];
            let n;
            for (let e in t) window.matchMedia(e).matches && (n = e);
            if (n === B) return !0;
            B = n;
            const i = B ? t[B] : e;
            i.breakpoints && B && delete i.breakpoints, b = Object.assign({}, qt, e, i), H = !0, d = null, st("optionsChanged"), Ct()
        }

        function Et(t) {
            if ("function" == typeof t) return t();
            const e = b.autoAdjustSlidesPerView;
            e || (a = Math.max(t, a));
            const n = lt() && e ? a - 1 : a;
            return _(t, 1, Math.max(n, 1))
        }

        function Tt() {
            Mt(), j = !0, st("created")
        }

        function Ct(t, n) {
            t && (e = t), n && (B = null), Pt(), St(n)
        }

        function At(t) {
            const e = window.innerWidth;
            if (!Mt() || e === d && !t) return;
            d = e;
            const n = b.slides;
            "number" == typeof n ? (l = null, a = n) : (l = x(n, r), a = l ? l.length : 0);
            const s = b.dragSpeed;
            A = "function" == typeof s ? s : t => t * s, c = ut() ? r.offsetHeight : r.offsetWidth, h = Et(b.slidesPerView), u = _(b.spacing, 0, c / (h - 1) - 1), c += u, o = at() ? (c / 2 - c / h / 2) / c : 0, Ot();
            const f = !j || H && b.resetSlide ? b.initial : p;
            Wt(lt() ? f : Nt(f)), ut() && r.setAttribute(i, !0), H = !1
        }

        function Rt(t) {
            At(), setTimeout(At, 500), setTimeout(At, 2e3)
        }

        function Pt() {
            rt(), Dt(), r && r.hasAttribute(i) && r.removeAttribute(i), st("destroyed")
        }

        function Lt() {
            l && l.forEach((t, e) => {
                const n = v[e].distance * c - e * (c / h - u / h - u / h * (h - 1)),
                    i = ut() ? `translateY(${n}px)` : `translateX(${n}px)`;
                t.style.transform = i, t.style["-webkit-transform"] = i
            })
        }

        function Ot() {
            l && l.forEach(t => {
                const e = `calc(${100 / h}% - ${u / h * (h - 1)}px)`;
                ut() ? (t.style["min-height"] = e, t.style["max-height"] = e) : (t.style["min-width"] = e, t.style["max-width"] = e)
            })
        }

        function Dt() {
            if (!l) return;
            let t = ["transform", "-webkit-transform"];
            t = ut ? [...t, "min-height", "max-height"] : [...t, "min-width", "max-width"], l.forEach(e => {
                t.forEach(t => {
                    e.style.removeProperty(t)
                })
            })
        }

        function It(t) {
            let e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Date.now();
            isNaN(t) || (Bt(t, n), e && (t = Vt(t)), V += t, jt())
        }

        function kt(t) {
            const e = c * (a - 1 * (at() ? 1 : h)) / h,
                n = V + t;
            return n > e ? n - e : n < 0 ? n : 0
        }

        function Nt(t) {
            return _(t, 0, a - 1 - (at() ? 0 : h - 1))
        }

        function Ut() {
            const t = Math.abs(y),
                e = V < 0 ? 1 - t : t;
            return {
                direction: f,
                progressTrack: e,
                progressSlides: e * a / (a - 1),
                positions: v,
                position: V,
                speed: g,
                relativeSlide: (p % a + a) % a,
                absoluteSlide: p,
                size: a,
                slidesPerView: h,
                widthOrHeight: c
            }
        }

        function zt(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            return lt() ? e ? $t(t, n) : t : Nt(t)
        }

        function Ft(t) {
            return isNaN(c) ? 0 : -(-c / h * t + V)
        }

        function $t(t, e) {
            const n = (p % a + a) % a,
                i = n < (t = (t % a + a) % a) ? -n - a + t : -(n - t),
                r = n > t ? a - n + t : t - n,
                s = e ? Math.abs(i) <= r ? i : r : t < n ? i : r;
            return p + s
        }

        function Bt(t, e) {
            clearTimeout(m);
            const n = Math.sign(t);
            if (n !== f && Ht(), f = n, G.push({
                distance: t,
                time: e
            }), m = setTimeout(() => {
                G = [], g = 0
            }, 50), G = G.slice(-6), G.length <= 1 || 0 === f) return g = 0;
            const i = G.slice(0, -1).reduce((t, e) => t + e.distance, 0),
                r = G[G.length - 1].time,
                s = G[0].time;
            g = _(i / (r - s), -10, 10)
        }

        function Ht() {
            G = []
        }

        function jt() {
            y = lt() ? V % (c * a / h) / (c * a / h) : V / (c * a / h), Gt();
            const t = [];
            for (let e = 0; e < a; e++) {
                let n = (1 / a * e - (y < 0 && lt() ? y + 1 : y)) * a / h + o;
                lt() && (n += n > (a - 1) / h ? -a / h : n < -a / h + 1 ? a / h : 0);
                const i = 1 / h,
                    r = n + i,
                    s = r < i ? r / i : r > 1 ? 1 - (r - 1) * h / 1 : 1;
                t.push({
                    portion: s < 0 || s > 1 ? 0 : s,
                    distance: ct() ? -1 * n + 1 - i : n
                })
            }
            v = t, Lt(), st("move")
        }

        function Vt(t) {
            if (lt()) return t;
            const e = kt(t);
            if (!ht()) return t - e;
            if (0 === e) return t;
            return t * (n = e / c, (1 - Math.abs(n)) * (1 - Math.abs(n)));
            var n
        }

        function Gt() {
            const t = Math.round(V / (c / h));
            t !== p && (!lt() && (t < 0 || t > a - 1) || (p = t, st("slideChanged")))
        }

        function Wt(t) {
            st("beforeChange"), It(Ft(t), !1), st("afterChange")
        }
        const qt = {
            autoAdjustSlidesPerView: !0,
            centered: !1,
            breakpoints: null,
            controls: !0,
            dragSpeed: 1,
            friction: .0025,
            loop: !1,
            initial: 0,
            duration: 500,
            easing: !0,
            nextPrevDuration: 500,
            nextPrevEasing: !0,
            preventEvent: "data-keen-slider-pe",
            slides: ".keen-slider__slide",
            vertical: !1,
            resetSlide: !1,
            slidesPerView: 1,
            spacing: 0,
            mode: "snap",
            rtl: !1,
            rubberband: !0,
            cancelOnLeave: !0
        },
            Xt = {
                controls: t => {
                    s = t
                },
                destroy: Pt,
                refresh(t) {
                    Ct(t, !0)
                },
                next() {
                    yt(p + 1, !0, b.nextPrevDuration, !1, !1, b.nextPrevEasing)
                },
                prev() {
                    yt(p - 1, !0, b.nextPrevDuration, !1, !1, b.nextPrevEasing)
                },
                moveToSlide(t, e) {
                    yt(t, !0, e)
                },
                moveToSlideRelative(t) {
                    yt(t, !0, arguments.length > 2 ? arguments[2] : void 0, !0, arguments.length > 1 && void 0 !== arguments[1] && arguments[1])
                },
                resize() {
                    At(!0)
                },
                details: () => Ut(),
                options() {
                    const t = Object.assign({}, b);
                    return delete t.breakpoints, t
                }
            };
        return Tt(), Xt
    };

    function b(t) {
        return Array.prototype.slice.call(t)
    }

    function x(t) {
        let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document;
        return "function" == typeof t ? b(t()) : "string" == typeof t ? b(e.querySelectorAll(t)) : t instanceof HTMLElement != !1 ? [t] : t instanceof NodeList != !1 ? t : []
    }

    function _(t, e, n) {
        return Math.min(Math.max(t, e), n)
    }

    function w(t) {
        if (t && "object" == typeof t) {
            const e = {};
            for (let n in t)
                if ("xs-up" === n) e["(min-width:0px)"] = t[n];
                else {
                    e[m.a.getCSSQuery(n)] = t[n]
                } return e
        }
        return t
    }
    const S = {
        loop: {
            update(t, e, n) {
                const i = t.progressTrack,
                    r = t.size,
                    s = (a = t.spacing, m.a.matches("md-up") ? a * Math.min(1, window.innerWidth / 1200) : a);
                var a;
                const o = n.width() + parseInt(n.css("padding-left"), 10) + parseInt(n.css("padding-right"), 10);
                let l = e - i * r;
                l < -1.5 ? l += r : r > 1 && l > r - 1.5 && (l -= r);
                const c = e * o,
                    h = l * (o + s);
                n.css({
                    transform: `translate3d(${h - c}px, 0px, 0px)`
                })
            }
        },
        fadeLeft: {
            update(t, e, n) {
                const i = t.positions[e].distance * t.slidesPerView,
                    r = i < 0 ? Math.max(0, 1 - 2.5 * Math.abs(i)) : 1;
                n.css({
                    opacity: r
                })
            }
        },
        fadeSides: {
            update(t, e, n) {
                const i = t.positions[e].distance * t.slidesPerView,
                    r = 0 != i ? Math.max(0, 1 - 2.5 * Math.abs(i)) : 1;
                n.css({
                    opacity: r
                })
            }
        },
        imageMove: {
            setup(t) {
                const e = $(t.find(".js-picture-crop").get(0) || t),
                    n = t.find(".js-picture-wrapper");
                return {
                    maxOffset: n.get(0).offsetWidth - e.get(0).offsetWidth,
                    $pictureWrapper: n
                }
            },
            update(t, e, n, i) {
                const r = t.progressTrack,
                    s = t.size;
                let a = e - r * s;
                a < -1.5 ? a += s : s > 1 && a > s - 1.5 && (a -= s);
                const o = (Math.max(-1.5, Math.min(1.5, a)) + 1.5) / 3,
                    l = i.maxOffset * o * -1;
                i.$pictureWrapper.css("transform", `translateX(${l}px)`)
            }
        },
        cardOverlay: {
            update(t, e, n) {
                const i = t.slidesPerView;
                if (1 === i) {
                    const r = t.progressTrack,
                        s = t.widthOrHeight,
                        a = t.size,
                        o = (s - t.spacing) / i,
                        l = function (t) {
                            let e = t.data("info");
                            e || (e = {
                                image: t.find("picture"),
                                content: t.find(".card__overlay")
                            }, t.data("info", e));
                            return e
                        }(n);
                    let c = e - r * a;
                    c < 1 - a ? c += a : c > 2 && (c -= a);
                    const h = o - (Math.ceil(c) - c) * o;
                    let u = (c - e) * o,
                        d = 0,
                        p = 0,
                        f = 1;
                    c <= 0 ? (u = (Math.ceil(c) - e) * o, f = 0) : (d = -.5 * h, p = -1 * h), n.css({
                        transform: `translateX(${u}px)`,
                        zIndex: f
                    }), l.image.css({
                        transform: `translateX(${d}px)`
                    }), l.content.css({
                        transform: `translateX(${p}px)`
                    })
                } else console.warn('"cardOverlay" carousel effect works only if there is 1 item per slide')
            }
        },
        blank: {
            update(t) {
                const e = t.slidesPerView,
                    n = t.progressTrack,
                    i = t.widthOrHeight,
                    r = t.size,
                    s = (i - t.spacing) / e;
                this.$items.each((t, e) => {
                    let i = t - n * r;
                    i < 1 - r ? i += r : i > 2 && (i -= r);
                    let a = (i - t) * s;
                    $(e).css({
                        transform: `translateX(${a}px)`,
                        zIndex: 1
                    })
                })
            }
        }
    };
    class M extends v.a {
        static get Defaults() {
            return i.a.extend({}, v.a.Defaults, {
                thumbnailsSelector: ".js-carousel-thumbnail",
                listSelector: ".js-carousel-list",
                pictureSelector: ".js-carousel-picture",
                itemSelector: ".js-carousel-item",
                counterSelector: ".js-carousel-counter",
                nextSelector: ".js-carousel-next",
                prevSelector: ".js-carousel-prev",
                slidesPerView: 1,
                loop: !1,
                controls: !0,
                breakpoints: null,
                centered: !1,
                effects: null,
                preservePosition: !1,
                duration: 1e3,
                moveDuration: 1200,
                spacing: 0,
                easing: "easeFreeCarousel",
                nextPrevEasing: "easeCarousel"
            })
        }
        init() {
            const t = this.$container;
            "string" == typeof this.options.easing && f[this.options.easing] && (this.options.easing = f[this.options.easing]), "string" == typeof this.options.nextPrevEasing && f[this.options.nextPrevEasing] && (this.options.nextPrevEasing = f[this.options.nextPrevEasing]), this.$carousel = t.findElement(this.options.listSelector) || t, this.$thumbnails = t.findElement(this.options.thumbnailsSelector) || Object(i.a)(), this.$counter = t.findElement(this.options.counterSelector) || Object(i.a)(), this.$next = t.findElement(this.options.nextSelector) || Object(i.a)(), this.$prev = t.findElement(this.options.prevSelector) || Object(i.a)(), this.$items = t.findElement(this.options.itemSelector) || Object(i.a)(), this.$images = t.findElement(this.options.pictureSelector) || Object(i.a)(), this.effects = "string" == typeof this.options.effects ? this.options.effects.split(" ") : Array.isArray(this.options.effects) ? this.options.effects : [], this.effects = this.effects.filter(t => t in S), this.effectData = [], this.onReadyMoveToIndex = null, this.$parents = t.parent().closest("[data-plugin*='accordion'], [data-plugin*='tabs'], [data-plugin*='modal']")
        }
        initEffect() {
            this.effectData.forEach(t => {
                t.itemData.forEach(t => {
                    t.teardown && t.teardown()
                })
            }), this.effectData = this.effects.map(t => {
                const e = S[t],
                    n = this.$items,
                    i = {
                        effect: e,
                        itemData: []
                    };
                if (e && e.setup)
                    for (let t = 0; t < n.length; t++) {
                        const r = e.setup.call(this, n.eq(t));
                        i.itemData.push({
                            data: r,
                            teardown: e.teardown ? e.teardown.bind(this, n.eq(t), r) : null
                        })
                    }
                return i
            })
        }
        enable() {
            if (super.enable()) {
                const t = this.options,
                    e = this.$carousel,
                    n = this.ns,
                    r = this.$container.height();
                if (this.resolveOptions(), this.$container.removeClass("carousel--not-ready").addClass("carousel--ready"), this.initEffect(), this.slider = new y(e.get(0), {
                    slides: t.itemSelector,
                    loop: t.loop,
                    controls: t.controls,
                    slidesPerView: t.slidesPerView,
                    centered: t.centered,
                    autoAdjustSlidesPerView: !1,
                    breakpoints: w(t.breakpoints),
                    slideChanged: this.updateNavigation.bind(this),
                    move: this.move.bind(this),
                    duration: t.duration,
                    nextPrevDuration: t.nextPrevDuration,
                    easing: this.options.easing,
                    nextPrevEasing: this.options.nextPrevEasing
                }), this.onReadyMoveToIndex && this.slider.moveToSlide(this.onReadyMoveToIndex, 0), t.preservePosition) {
                    const t = localStorage.getItem(this.$container.get(0).id + "-index"),
                        e = t ? parseInt(t, 10) : 0;
                    e && this.slider.moveToSlide(e, 0)
                }
                return this.$thumbnails.on("click", this.handleThumbnailClick.bind(this)), this.$items.on("click", this.handleItemClick.bind(this)), this.$parents.on(`opened.accordion.${n} change.tabs.${n} open.modal.${n}`, this.update.bind(this)), e.plugins(), this.$next.removeClass("is-hidden").on(`returnkey.${n} mousedown.${n}`, this.next.bind(this)), this.$prev.removeClass("is-hidden").on(`returnkey.${n} mousedown.${n}`, this.prev.bind(this)), this.updateNavigation(), Object(i.a)(window).on("resize." + n, () => {
                    this.resolveOptions(), this.initEffect()
                }), r !== this.$container.height() && e.trigger("appear"), !0
            }
        }
        disable() {
            if (super.disable()) {
                const t = this.ns,
                    e = this.$container,
                    n = this.$carousel,
                    i = this.$carousel.find(this.options.itemSelector);
                return e.addClass("carousel--not-ready").removeClass("carousel--ready"), n.add(window).add(this.$parents).add(e).add(this.$prev).add(this.$next).off("." + t), this.slider.destroy(), i.css("min-width", "").css("max-width", "").css("transform", ""), !0
            }
        }
        update() {
            this.slider && (this.slider.refresh(), this.slider.resize(), isNaN(this.slider.details().relativeSlide) && this.slider.moveToSlide(0, 0), this.updateNavigation())
        }
        prev() {
            this.slider.prev(), this.triggerEvent("prev.carousel")
        }
        next() {
            this.slider.next(), this.triggerEvent("next.carousel")
        }
        open(t) {
            this.enabled ? this.slider.moveToSlide(t) : this.onReadyMoveToIndex = t
        }
        swap(t) {
            this.enabled ? this.slider.moveToSlide(t, 0) : this.onReadyMoveToIndex = t
        }
        updateNavigation() {
            if (!this.slider) return;
            const t = this.options,
                e = this.slider.details(),
                n = e.relativeSlide,
                i = e.size;
            this.$prev.toggleClass("is-disabled", !t.loop && 0 === n), this.$next.toggleClass("is-disabled", !t.loop && n === i - e.slidesPerView), this.$prev.add(this.$next).toggleClass("is-invisible", i <= e.slidesPerView), this.$counter.text(n + 1), this.$thumbnails.removeClass("is-active").eq(n).addClass("is-active"), this.options.preservePosition && localStorage.setItem(this.$container.get(0).id + "-index", n), this.triggerEvent("change.carousel")
        }
        triggerEvent(t) {
            if (this.slider) {
                const e = this.slider.details(),
                    n = e.relativeSlide,
                    i = e.size;
                this.$container.trigger(t, {
                    index: n,
                    count: i
                })
            }
        }
        resolveOptions() {
            const t = this.originalOptions || (this.originalOptions = this.options),
                e = t.breakpoints,
                n = this.options = i.a.extend({}, t);
            for (let t in e) "touch" !== t || g.a.hasHoverSupport() ? ("hover" === t && g.a.hasHoverSupport() || m.a.matches(t)) && i.a.extend(n, e[t]) : i.a.extend(n, e[t])
        }
        move(t) {
            const e = this.effectData,
                n = e.length;
            e.forEach((e, r) => {
                const s = e.effect,
                    a = e.itemData;
                if (s.update) {
                    const e = this.$items,
                        n = t.details();
                    n.spacing = this.options.spacing || 0, n.screenWidth = Object(i.a)(window).width() || 0;
                    for (let t = 0; t < e.length; t++) s.update.call(this, n, t, e.eq(t), a[t] ? a[t].data : {})
                }
                r === n - 1 && this.triggerEvent("move.carousel")
            })
        }
        handleThumbnailClick(t) {
            const e = this.$thumbnails.index(t.currentTarget);
            this.slider.moveToSlide(e)
        }
        handleItemClick(t) {
            const e = this.$items.index(t.currentTarget),
                n = this.slider.details(),
                i = (e - n.relativeSlide + n.size) % n.size;
            (i < 0 || i >= n.slidesPerView) && this.slider.moveToSlideRelative(e, !0)
        }
        lock() {
            this.slider.controls(!1)
        }
        unlock() {
            this.slider.controls(!0)
        }
    }
    i.a.fn.carousel = s()(M, {
        api: ["open", "swap", "next", "prev", "instance", "init", "enable", "update", "updateNavigation", "lock", "unlock", "move"]
    }), i.a.fn.carousel.effects = S
}, function (t, e, n) {
    "use strict";
    n.r(e), n.d(e, "default", (function () {
        return g
    }));
    var i = n(2),
        r = n.n(i),
        s = n(3),
        a = n.n(s),
        o = n(7),
        l = n(9),
        c = n(6),
        h = n(11),
        u = n.n(h);
    class d {
        constructor(t) {
            this.ui = t, this.$container = t.$container, this.options = t.options
        }
        destroy() { }
        initAPI() { }
        testAPI() {
            return !0
        }
        setMute(t) { }
        play() { }
        pause() { }
        setPosition(t) { }
        getDuration() {
            return Promise.resolve(0)
        }
        setCurrentTime(t) { }
        getPaused() {
            return Promise.resolve(!0)
        }
        eventPlay() {
            this.ui.handlePlay()
        }
        eventPause() {
            this.ui.handlePause()
        }
        eventUpdate(t) {
            this.ui.handleCurrentTimeChange(t)
        }
    }
    class p extends d {
        initAPI() {
            this.waitingDocumentInteraction = !1, this.$container.append('<script fetchpriority="low" src="https://player.vimeo.com/api/player.js" async defer><\/script>')
        }
        testAPI() {
            return !(!window.Vimeo || !window.Vimeo.Player)
        }
        embed(t) {
            const e = this.$container,
                n = e.find("iframe"),
                i = Object(l.a)();
            n.get(0) ? this.$video = e.find(".video-embed__inner") : this.$video = r()(`<div class="video-embed__inner" id="${i}"></div>`).appendTo(e);
            const s = this.options.autoplay,
                a = !this.options.controls && this.options.nativeControls,
                o = this.options.background;
            this.player = new Vimeo.Player(n.get(0) || i, {
                id: this.options.id,
                width: t.width,
                height: t.height,
                byline: !1,
                portrait: !1,
                title: !1,
                loop: this.options.loop,
                controls: !!a,
                background: !!o,
                autoplay: s,
                muted: o,
                pip: !o
            }), this.$video.css({
                "aspect-ratio": this.options.ratioWidth + "/" + this.options.ratioHeight
            }), o && this.player.setVolume(0), this.setPosition(t), this.player.on("error", this.handlePlayError.bind(this)), this.player.on("play", this.eventPlay.bind(this)), this.player.on("pause", this.eventPause.bind(this)), this.player.on("timeupdate", t => {
                this.eventUpdate({
                    percent: t.percent
                })
            }), this.shouldPlay && (this.shouldPlay = !1, this.play())
        }
        setMute(t) {
            this.player.setVolume(t ? 0 : 1)
        }
        play() {
            this.shouldPlay = !0, this.player && this.player.play()
        }
        pause() {
            this.shouldPlay = !1, this.player && this.player.pause()
        }
        setPosition(t) {
            this.$video.css({
                width: t.width ? t.width + "px" : "",
                height: t.height ? t.height + "px" : "",
                left: t.x ? ~~t.x + "px" : "",
                top: t.y ? ~~t.y + "px" : ""
            })
        }
        getDuration() {
            return this.player.getDuration()
        }
        setCurrentTime(t) {
            this.player.setCurrentTime(t)
        }
        getPaused() {
            return this.player.getPaused()
        }
        handlePlayError(t) {
            if ("NotAllowedError" === t.name && this.shouldPlay && !this.waitingDocumentInteraction) {
                this.waitingDocumentInteraction = !0;
                const t = this.ui.ns;
                r()(document).one(`touchstart.${t} mousedown.${t}`, () => {
                    this.waitingDocumentInteraction = !1, this.play()
                })
            }
        }
        destroy() {
            r()(document).off(`touchstart.${this.ui.ns} mousedown.${this.ui.ns}`)
        }
    }
    class f extends d {
        destroy() {
            this.progressTimer && (clearInterval(this.progressTimer), this.progressTimer = null)
        }
        initAPI() {
            this.$container.append('<script fetchpriority="low" src="https://www.youtube.com/iframe_api" async defer><\/script>')
        }
        testAPI() {
            return !(!window.YT || !window.YT.Player)
        }
        embed(t) {
            const e = this.$container,
                n = e.find("iframe"),
                i = Object(l.a)();
            n.get(0) ? this.$video = e.find(".video-embed__inner") : this.$video = r()(`<div class="video-embed__inner" id="${i}"></div>`).appendTo(e), this.player = window.player = new YT.Player(n.get(0) || i, {
                height: t.width,
                width: t.height,
                videoId: this.options.id,
                playerVars: {
                    controls: this.options.controls ? 0 : 1,
                    playsinline: 1,
                    rel: 0,
                    showinfo: 0,
                    fs: 0
                },
                events: {
                    onStateChange: this.onPlayerStateChange.bind(this)
                }
            }), this.shouldPlay && (this.shouldPlay = !1, this.play())
        }
        handleProgress() {
            this.eventUpdate({
                percent: this.player.getCurrentTime() / this.player.getDuration()
            })
        }
        handlePlay() {
            this.progressTimer = setInterval(this.handleProgress.bind(this, 250)), this.eventPlay()
        }
        handlePause() {
            clearInterval(this.progressTimer), this.progressTimer = null, this.eventPause()
        }
        onPlayerStateChange(t) {
            t.data === YT.PlayerState.PLAYING ? this.handlePlay() : t.data !== YT.PlayerState.PAUSED && t.data !== YT.PlayerState.ENDED && t.data !== YT.PlayerState.CUED || this.handlePause()
        }
        setMute(t) {
            t ? this.player.muted() : this.player.unmuted()
        }
        play() {
            this.player && this.player.playVideo ? this.player.playVideo() : this.shouldPlay = !0
        }
        pause() {
            this.player && this.player.pauseVideo && this.player.pauseVideo()
        }
        setPosition(t) {
            this.$video.css({
                width: t.width ? t.width + "px" : "",
                height: t.width ? "100%" : "",
                left: t.x ? ~~t.x + "px" : "",
                top: t.y ? ~~t.y + "px" : ""
            })
        }
        getDuration() {
            return Promise.resolve(this.player && this.player.getDuration ? this.player.getDuration() : 0)
        }
        setCurrentTime(t) {
            this.player && this.player.seekTo && this.player.seekTo(t)
        }
        getPaused() {
            const t = this.player.getPlayerState();
            return Promise.resolve(t === YT.PlayerState.PAUSED || t === YT.PlayerState.ENDED || t === YT.PlayerState.CUED)
        }
    }
    class m extends d {
        destroy() {
            this.progressTimer && (clearInterval(this.progressTimer), this.progressTimer = null)
        }
        embed(t) {
            const e = this.$container;
            e.find("video").get(0) ? this.$video = e.find(".video-embed__inner") : (this.$video = r()(`\n                <video class="video-embed__inner" width="${t.width}" height="${t.height}">\n                    <source src="${this.options.id}" type="${function (t) { const e = t.match(/\.([a-z0-9]+)$/); if (e) return "video/" + e[1] }(this.options.id)}" />\n                </video>\n            `), this.$video.appendTo(e)), this.$video.on("play", this.handlePlay.bind(this)), this.$video.on("pause", this.handlePause.bind(this))
        }
        handleProgress() {
            this.eventUpdate({
                percent: this.$video.get(0).currentTime / this.$video.get(0).duration
            })
        }
        handlePlay() {
            this.progressTimer = setInterval(this.handleProgress.bind(this, 250)), this.eventPlay()
        }
        handlePause() {
            clearInterval(this.progressTimer), this.progressTimer = null, this.eventPause()
        }
        setMute(t) {
            this.$video.get(0).muted = t
        }
        play() {
            this.$video.get(0).play()
        }
        pause() {
            this.$video.get(0).pause()
        }
        setPosition(t) {
            this.$video.css({
                width: t.width ? t.width + "px" : "",
                height: t.width ? "100%" : "",
                left: t.x ? ~~t.x + "px" : "",
                top: t.y ? ~~t.y + "px" : ""
            })
        }
        getDuration() {
            return Promise.resolve(this.$video.get(0).duration)
        }
        setCurrentTime(t) {
            this.$video.get(0).currentTime = t
        }
        getPaused() {
            return Promise.resolve(this.$video.get(0).paused)
        }
    }
    class g {
        static get Defaults() {
            return {
                id: null,
                type: "",
                controls: !1,
                nativeControls: !1,
                background: !1,
                subtitles: !1,
                autoplay: !1,
                loop: !1,
                ratioWidth: 1280,
                ratioHeight: 800,
                sizeX: "contain",
                sizeY: "contain",
                breakpoints: null
            }
        }
        constructor(t, e) {
            this.options = r.a.extend(!0, {}, this.constructor.Defaults, e), this.$container = t, this.ns = Object(l.a)(), this.$play = t.find(".js-video-embed-play"), this.$pause = t.find(".js-video-embed-pause"), this.$mute = t.find(".js-video-embed-mute"), this.$panel = t.find(".js-video-embed-panel"), this.$time = t.find(".js-video-embed-time"), this.$placeholder = t.find(".js-video-embed-placeholder"), this.$fullscreen = t.find(".js-video-embed-fullscreen"), this.$modalClose = t.closest(".modal").find(".js-modal-close"), this.cover = t.hasClass("video-embed--cover"), this.progressDragging = !1, this.isHiddenPanel = !0, this.isMuted = !1, this.timerPanel = null, this.isFullscreen = !1, this.handleResize = u()(this.handleResize.bind(this), 60), this.resolveOptions(), this.initializeAPI(), this.apiReady(this.embed.bind(this)), t.on("destroyed", this.destroy.bind(this)), t.on("mousemove", this.showPanel.bind(this))
        }
        resolveOptions() {
            const t = this.originalOptions || (this.originalOptions = this.options),
                e = t.breakpoints,
                n = this.options = r.a.extend({}, t);
            for (let t in e) "touch" === t ? c.a.hasHoverSupport() || r.a.extend(n, e[t]) : "hover" === t ? c.a.hasHoverSupport() && r.a.extend(n, e[t]) : o.a.matches(t + "-up") && r.a.extend(n, e[t]);
            n.background && (n.autoplay = !0), this.$play.toggleClass("is-hidden", !n.controls), this.$pause.toggleClass("is-hidden", !n.controls), this.$mute.toggleClass("is-hidden", !n.controls), this.$fullscreen.toggleClass("is-hidden", !n.controls), this.$panel.toggleClass("is-hidden", !n.controls), this.$container.toggleClass("video-embed--controls", !!n.controls), this.$container.toggleClass("video-embed--native-controls", !!n.nativeControls)
        }
        destroy() {
            this.$events && (this.$events.off("." + this.ns), this.$events = null), this.api && (this.api.destroy(), this.api = null), clearTimeout(this.timerPanel)
        }
        initializeAPI() {
            "vimeo" === this.options.type ? this.api = new p(this) : "youtube" === this.options.type ? this.api = new f(this) : "" === this.options.type && (this.api = new m(this)), this.$container.inview({
                destroyOnEnter: !0,
                enter: () => {
                    this.api.testAPI() || this.api.initAPI()
                }
            })
        }
        apiReady(t) {
            const e = () => {
                this.api.testAPI() ? t() : setTimeout(e, 60)
            };
            e()
        }
        embed() {
            const t = this.getPosition(),
                e = this.$container.closest(".modal");
            this.api.embed(t), this.$mute.on("click", this.toggleMute.bind(this)), this.$play.on("click", this.toggleVideo.bind(this)), this.$pause.on("click", this.toggleVideo.bind(this)), this.$fullscreen.on("click", this.toggleFullscreen.bind(this)), e.on("closed.modal", this.closeFullscreen.bind(this));
            const n = this.$container.closest(".carousel"),
                i = r()(window);
            n.on("change.carousel", this.pauseVideo.bind(this)), i.on("resize." + this.ns, this.handleResize), this.$events = n.add(r()(window)), this.options.controls && this.createProgressBar(), this.options.autoplay && this.options.background && this.playVideo(), this.isMuted || this.api.setMute(!1)
        }
        toggleMute() {
            this.isMuted ? (this.$container.removeClass("video-embed--muted"), this.api.setMute(!1), this.isMuted = !1) : (this.$container.addClass("video-embed--muted"), this.api.setMute(!0), this.isMuted = !0)
        }
        handleMute(t) {
            this.$container.toggleClass("video-embed--muted", 0 === t.volume)
        }
        toggleFullscreen() {
            const t = this.$container.closest(".modal");
            this.isFullscreen ? (t.removeClass("modal--fullscreen"), this.$container.removeClass("video-embed--fullscreen"), this.isFullscreen = !1) : (t.addClass("modal--fullscreen"), this.$container.addClass("video-embed--fullscreen"), this.isFullscreen = !0)
        }
        closeFullscreen() {
            const t = this.$container.closest(".modal");
            this.isFullscreen && (t.removeClass("modal--fullscreen"), this.$container.removeClass("video-embed--fullscreen"), this.isFullscreen = !1), this.api && (this.api.pause(), this.api.setCurrentTime(0))
        }
        toggleVideo() {
            this.api.getPaused().then(t => {
                t ? this.playVideo() : this.pauseVideo()
            })
        }
        playVideo() {
            this.$placeholder.remove(), this.api.play()
        }
        pauseVideo() {
            this.api.pause()
        }
        getPosition() {
            return this.$fullscreen ? o.a.matches("md-up") ? this.getVideoPosition(window.innerWidth, window.innerHeight) : {
                width: "",
                height: "",
                left: "",
                top: ""
            } : this.cover ? this.getVideoPosition(this.$container.width(), this.$container.height()) : this.getVideoPosition(window.innerWidth, window.innerHeight)
        }
        handleResize() {
            this.api.setPosition(this.getPosition())
        }
        handlePlay() {
            this.$container.addClass("video-embed--playing"), r()("html").addClass("video-playing")
        }
        handlePause() {
            this.$container.removeClass("video-embed--playing"), r()("html").removeClass("video-playing")
        }
        getVideoPosition(t, e) {
            const n = this.options.sizeX,
                i = this.options.sizeY;
            let r = this.options.ratioWidth,
                s = this.options.ratioHeight,
                a = r / s;
            return r = t, s = r / a, ("cover" === i && s < e || "contain" === i && s > e) && (s = e, r = s * a, ("contain" === n && r > t || "cover" === n && r < t) && (r = t, s = r / a)), {
                height: s,
                width: r,
                x: (t - r) / 2,
                y: (e - s) / 2
            }
        }
        createProgressBar() {
            const t = this.$container,
                e = r()('\n            <div class="video-embed__panel__progress__progress-bar">\n                <div class="text--tiny text--color-heading video-embed__panel__progress__progress-bar__hover">\n                </div>\n                <div class="video-embed__panel__progress__progress-bar__inner">\n                </div>\n\n            </div>\n        '),
                n = r()('\n            <div class="video-embed__panel__timer__text leading-trim">\n                <span class="js-timer">00:00</span>\n            </div>\n        ');
            t.find(".js-video-progress-bar-place").append(e), t.find(".js-video-timer-place").append(n), this.$progress = e, this.$progressInner = e.find(".video-embed__panel__progress__progress-bar__inner"), this.$progressText = t.find(".video-embed__panel__timer__text"), this.$progressHover = t.find(".video-embed__panel__progress__progress-bar__hover"), this.$timerPlace = this.$container.find(".js-video-timer-place"), this.$videoCircle = this.$container.find(".js-video-circle"), this.updateProgressBar(), e.on("mousedown touchstart", this.handleProgressClickStart.bind(this)), e.on("mousemove", this.handleMouseOver.bind(this))
        }
        handleCurrentTimeChange(t) {
            this.progressDragging || this.updateProgressBar(t.percent)
        }
        setProgressBar() {
            const t = this.$progress.width(),
                e = this.$progressInner.width();
            this.$progress.css("width", t - e / 2 - 118 + "px")
        }
        updateProgressBar(t) {
            const e = this.$progressInner,
                n = this.$progressText;
            e && e.length && (e.css("left", -100 * (1 - t) + "%"), this.$timerPlace.css("left", 100 * t + "%"), this.$videoCircle.css("left", 100 * t + "%"), this.api.getDuration().then(e => {
                const i = e * t,
                    r = ~~(i / 60),
                    s = ~~(i % 60),
                    a = ~~(e / 60),
                    o = ~~(e % 60),
                    l = `${r < 10 ? "0" : ""}${r}`,
                    c = `${s < 10 ? "0" : ""}${s}`;
                n.html(`${l}:${c}`), r == a && s == o && (this.pauseVideo(), this.api.setCurrentTime(0))
            }))
        }
        handleProgressClickStart(t) {
            const e = "mousedown" === t.type ? "mousemove" : "touchmove",
                n = "mousedown" === t.type ? "mouseup" : "touchend";
            t.preventDefault(), r()(document).on(`${e}.${this.ns}`, this.handleProgressClick.bind(this)), r()(document).on(`${n}.${this.ns}`, this.handleProgressClickStop.bind(this)), this.$progress.addClass("video-embed__progress-bar--disable-animation"), this.$container.addClass("video-embed--dragging"), this.progressDragging = !0, this.handleProgressClick(t)
        }
        handleProgressClickStop() {
            r()(document).off("." + this.ns), this.progressDragging = !1, this.$container.removeClass("video-embed--dragging"), setTimeout(() => {
                this.$progress.removeClass("video-embed__progress-bar--disable-animation")
            }, 60)
        }
        handleProgressClick(t) {
            const e = "mousemove" === t.type || "mousedown" === t.type ? t.clientX : t.originalEvent.touches[0].clientX,
                n = this.$progress.get(0).getBoundingClientRect(),
                i = Math.min(1, Math.max(0, (e - n.left) / n.width));
            this.updateProgressBar(i), this.api.getDuration().then(t => {
                this.api.setCurrentTime(t * i)
            })
        }
        showPanel() {
            this.isHiddenPanel && (this.$panel.removeClass("video-embed__panel--hidden"), this.$modalClose.length && this.$modalClose.hasClass("is-hidden") && this.$modalClose.transitionstop(t => {
                t.transition("fade-in fast")
            }), this.isHiddenPanel = !1, clearTimeout(this.timerPanel), this.timerPanel = setTimeout(this.hidePanel.bind(this), 3e3))
        }
        hidePanel() {
            this.isHiddenPanel || (this.$container.hasClass("video-embed--playing") && (this.$panel.addClass("video-embed__panel--hidden"), this.$modalClose.length && !this.$modalClose.hasClass("is-hidden") && this.$modalClose.transitionstop(t => {
                t.transition("fade-out fast")
            })), this.isHiddenPanel = !0)
        }
        handleMouseOver(t) {
            this.$progressHover.css("--mouseX", t.offsetX + "px");
            const e = "mousemove" === t.type || "mousedown" === t.type ? t.clientX : t.originalEvent.touches[0].clientX,
                n = this.$progress.get(0).getBoundingClientRect(),
                i = Math.min(1, Math.max(0, (e - n.left) / n.width));
            this.api.getDuration().then(t => {
                const e = t * i,
                    n = ~~(e / 60),
                    s = ~~(e % 60),
                    a = `${n < 10 ? "0" : ""}${n}:${s < 10 ? "0" : ""}${s}`;
                r()(".js-hover-current-time").text(a)
            })
        }
    }
    r.a.fn.videoEmbed = a()(g, {
        api: ["playVideo", "pauseVideo"]
    })
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return d
    }));
    var i = n(1),
        r = n(3),
        s = n.n(r),
        a = n(5),
        o = n.n(a),
        l = n(140),
        c = n.n(l),
        h = (n(76), n(6)),
        u = n(9);
    class d {
        static get Defaults() {
            return {
                enter: null,
                leave: null,
                destroyOnEnter: !1,
                destroyOnLeave: !1,
                threshold: 0,
                distance: 0
            }
        }
        constructor(t, e) {
            const n = this.options = i.a.extend({}, this.constructor.Defaults, e);
            this.$container = t, this.isIntersecting = null, this.ns = Object(u.a)(), this.enter = "function" == typeof n.enter ? [n.enter] : [], this.leave = "function" == typeof n.leave ? [n.leave] : [], t.on("destroyed." + this.ns, this.destroy.bind(this)), this.createObserver()
        }
        setOptions(t) {
            t && "function" == typeof t.enter && (this.enter.push(t.enter), this.isIntersecting && t.enter(this.$container), this.createObserver()), t && "function" == typeof t.leave && this.leave.push(t.leave)
        }
        createObserver() {
            if (!this.observer) {
                const t = this.$container,
                    e = this.options;
                this.observer = new IntersectionObserver(this.handleIntersection.bind(this), {
                    rootMargin: "number" == typeof e.distance ? e.distance + "px 0px" : e.distance,
                    threshold: e.threshold
                }), this.observer.observe(t.get(0))
            }
        }
        destroy() {
            if (this.observer) {
                const t = this.observer;
                this.observer = null, this.isIntersecting = null, this.$container.data("inview") === this && this.$container.removeData("inview"), t.disconnect()
            }
        }
        handleIntersection(t) {
            let e = c()(t, {
                isIntersecting: !0
            });
            e || !h.a.isEdge() && !h.a.isIE() || o()(t, t => {
                const n = t.boundingClientRect,
                    i = t.rootBounds;
                n.width && n.height && (n.top > 0 && n.top < i.height || n.top + n.height > 0 && n.top + n.height < i.height || n.top < 0 && n.top + n.height > i.height) && (n.left > 0 && n.left < i.width || n.left + n.width > 0 && n.left + n.width < i.width || n.left < 0 && n.left + n.width > i.width) && (e = !0)
            }), this.isIntersecting !== e && (this.isIntersecting = e, e && this.options.enter ? o()(this.enter, t => t(this.$container)) : !e && this.options.leave && o()(this.leave, t => t(this.$container)), (e && this.options.destroyOnEnter || !e && this.options.destroyOnLeave) && this.destroy())
        }
    }
    i.a.fn.inview = s()(d, {
        namespace: "inview"
    })
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return l
    })), n.d(e, "b", (function () {
        return o
    }));
    var i = n(21),
        r = n.n(i),
        s = n(62);
    const a = {
        variantFlipOrder: {
            start: "smea",
            middle: "msea",
            end: "emsa"
        },
        positionFlipOrder: {
            top: "tbrl",
            right: "rltb",
            bottom: "btrl",
            left: "lrbt"
        },
        position: "bottom",
        margin: [8, 8]
    },
        o = (t, e, n) => {
            const i = r()({
                container: document.documentElement.getBoundingClientRect()
            }, a, n);
            "function" == typeof i.container && (i.container = n.container(t, e, n)), "number" == typeof i.margin && (i.margin = [i.margin, i.margin]);
            const {
                container: o,
                margin: l,
                position: c,
                variantFlipOrder: h,
                positionFlipOrder: u
            } = i, d = Object(s.a)(e), p = t.getBoundingClientRect();
            let f = e.getBoundingClientRect();
            f = {
                x: f.left - d.x,
                y: f.top - d.y,
                left: f.left - d.x,
                top: f.top - d.y,
                width: f.width,
                height: f.height
            };
            const m = {
                t: p.top - f.height - l[1],
                b: p.bottom + l[1],
                r: p.right + l[0],
                l: p.left - f.width - l[0]
            },
                g = {
                    vs: p.left,
                    vm: p.left + p.width / 2 + -f.width / 2,
                    ve: p.left + p.width - f.width,
                    va: 0,
                    hs: p.top,
                    hm: p.bottom - p.height / 2 - f.height / 2,
                    he: p.bottom - f.height,
                    ha: 0
                },
                [v, y = "middle"] = c.split("-"),
                b = u[v],
                x = h[y];
            let _ = null;
            const {
                top: w,
                left: S,
                bottom: M,
                right: E
            } = o;
            for (const t of b) {
                let n = !0;
                const i = "t" === t || "b" === t,
                    r = m[t],
                    [s, a] = i ? ["top", "left"] : ["left", "top"],
                    [l, c] = i ? [f.height, f.width] : [f.width, f.height],
                    [h, u] = i ? [M, E] : [E, M],
                    [d, v] = i ? [w, S] : [S, w];
                if (r < d || r + l > h) {
                    if (_) continue;
                    n = !1
                }
                for (const l of x) {
                    let h, d = !0;
                    "a" === l ? (h = g[(i ? "v" : "h") + y[0]], h < v ? h = v : h + c > u && (h = u - c)) : h = g[(i ? "v" : "h") + l];
                    const m = {
                        pos: t + l,
                        popBox: f,
                        refBox: p,
                        containerBox: o,
                        x: i ? h - f[a] : r - f[s],
                        y: i ? r - f[s] : h - f[a]
                    };
                    if ((h < v || h + c > u) && (d = !1), e.style.transform = `translate(${~~m.x}px, ${~~m.y}px)`, n && d) return m;
                    (!_ || n || d) && (_ = m)
                }
            }
            return _
        },
        l = (t, e, n) => {
            const i = "object" != typeof t || t instanceof HTMLElement ? r()({
                reference: t,
                popper: e
            }, n) : t;
            return {
                update() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i;
                    const {
                        reference: e,
                        popper: n
                    } = Object.assign(i, t);
                    if (!n || !e) throw new Error("Popper- or reference-element missing.");
                    return o(e, n, i)
                }
            }
        }
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return c
    }));
    var i = n(9),
        r = n(7),
        s = n(6),
        a = n(23),
        o = n(28);
    const l = {
        enableMq: null,
        enableHover: !0,
        enableTouch: !0,
        enableOnlyInView: !1,
        enableSmoothScroll: !0,
        enableNotSmoothScroll: !0,
        enableReducedMotion: !0,
        enableMobileSafari: !0
    };

    function c(t, e, n) {
        e = Object.assign({}, l, e);
        const c = Object(i.a)(),
            h = s.a.hasHoverSupport(),
            u = o.a,
            d = e.enableReducedMotion || !s.a.isReducedMotion(),
            p = h && e.enableHover || !h && e.enableTouch,
            f = u && e.enableSmoothScroll || !u && e.enableNotSmoothScroll,
            m = e.enableMobileSafari || r.a.matches("md-up") || !s.a.isSafari();
        let g = null,
            v = [],
            y = !e.enableOnlyInView,
            b = !0,
            x = n || {};
        const _ = {
            enabled: null,
            dynamic: !1,
            check: () => { },
            destroy: () => { },
            setCallbacks: t => {
                x = t || {}, _.check()
            }
        };
        if (m && d && p && f) {
            const n = _.check = () => {
                b && y ? !0 !== _.enabled && x.enable && (_.enabled = !0, x.enable()) : !1 !== _.enabled && x.disable && (_.enabled = !1, x.disable())
            };
            e.enableMq && (_.dynamic = !0, b = !1, v = [r.a.enter(e.enableMq, () => {
                b = !0, n()
            }), r.a.leave(e.enableMq, () => {
                b = !1, n()
            })]), e.enableOnlyInView && (_.dynamic = !0, g = new a.a(t, {
                enter: () => {
                    y = !0, n()
                },
                leave: () => {
                    y = !1, n()
                }
            })), _.destroy = () => {
                _.check = () => { }, _.enabled && x.disable && (_.enabled = !1, x.disable()), g && (g.destroy(), g = null), v.forEach(t => t()), v = [], x = {}, t.off("destroyed." + c)
            }, t.on("destroyed." + c, _.destroy), n()
        }
        return _
    }
}, function (t, e, n) {
    var i = n(202),
        r = n(56),
        s = n(346),
        a = n(26),
        o = n(95);
    t.exports = function (t, e, n) {
        var l = a(t) ? i : s;
        return n && o(t, e, n) && (e = void 0), l(t, r(e, 3))
    }
}, function (t, e, n) {
    "use strict";
    var i = n(6),
        r = n(7),
        s = n(42);
    e.a = s.d && r.a.matches("md-up") && !i.a.isReducedMotion() && !i.a.isBitrix()
}, function (t, e, n) {
    "use strict";
    e.a = function (t, e) {
        var n, i, r = parseInt(t);
        return "ru" == document.documentElement.lang && (r %= 100), e && e.length ? (i = r % 10, n = 0 === r ? e[0] : 1 === i && 11 !== r ? e[1] : i >= 2 && i <= 4 && 12 !== r && 13 !== r && 14 !== r || void 0 === e[3] || null === e[3] ? e[2] : e[3], String(n).replace(/%count%/g, t)) : String(t)
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return s
    }));
    var i = n(0),
        r = n(34);
    class s extends r.b {
        constructor(t, e, n, r, s) {
            super(), this.scene = t, this.camera = e, this.overrideMaterial = n, this.clearColor = r, this.clearAlpha = void 0 !== s ? s : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new i.o
        }
        render(t, e, n) {
            const i = t.autoClear;
            let r, s;
            t.autoClear = !1, void 0 !== this.overrideMaterial && (s = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (t.getClearColor(this._oldClearColor), r = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : n), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor && t.setClearColor(this._oldClearColor, r), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = s), t.autoClear = i
        }
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return i
    }));
    const i = {
        name: "CopyShader",
        uniforms: {
            tDiffuse: {
                value: null
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
        fragmentShader: "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"
    }
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return h
    }));
    var i = n(0);
    const r = {
        type: "change"
    },
        s = {
            type: "start"
        },
        a = {
            type: "end"
        },
        o = new i.Eb,
        l = new i.sb,
        c = Math.cos(70 * i.cb.DEG2RAD);
    class h extends i.z {
        constructor(t, e) {
            super(), this.object = t, this.domElement = e, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new i.ac, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
                LEFT: "ArrowLeft",
                UP: "ArrowUp",
                RIGHT: "ArrowRight",
                BOTTOM: "ArrowDown"
            }, this.mouseButtons = {
                LEFT: i.ab.ROTATE,
                MIDDLE: i.ab.DOLLY,
                RIGHT: i.ab.PAN
            }, this.touches = {
                ONE: i.Qb.ROTATE,
                TWO: i.Qb.DOLLY_PAN
            }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () {
                return p.phi
            }, this.getAzimuthalAngle = function () {
                return p.theta
            }, this.getDistance = function () {
                return this.object.position.distanceTo(this.target)
            }, this.listenToKeyEvents = function (t) {
                t.addEventListener("keydown", Q), this._domElementKeyEvents = t
            }, this.stopListenToKeyEvents = function () {
                this._domElementKeyEvents.removeEventListener("keydown", Q), this._domElementKeyEvents = null
            }, this.saveState = function () {
                n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom
            }, this.reset = function () {
                n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(r), n.update(), u = h.NONE
            }, this.update = function () {
                const e = new i.ac,
                    s = (new i.yb).setFromUnitVectors(t.up, new i.ac(0, 1, 0)),
                    a = s.clone().invert(),
                    v = new i.ac,
                    y = new i.yb,
                    b = new i.ac,
                    x = 2 * Math.PI;
                return function () {
                    const _ = n.object.position;
                    e.copy(_).sub(n.target), e.applyQuaternion(s), p.setFromVector3(e), n.autoRotate && u === h.NONE && O(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), n.enableDamping ? (p.theta += f.theta * n.dampingFactor, p.phi += f.phi * n.dampingFactor) : (p.theta += f.theta, p.phi += f.phi);
                    let w = n.minAzimuthAngle,
                        S = n.maxAzimuthAngle;
                    isFinite(w) && isFinite(S) && (w < -Math.PI ? w += x : w > Math.PI && (w -= x), S < -Math.PI ? S += x : S > Math.PI && (S -= x), p.theta = w <= S ? Math.max(w, Math.min(S, p.theta)) : p.theta > (w + S) / 2 ? Math.max(w, p.theta) : Math.min(S, p.theta)), p.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, p.phi)), p.makeSafe(), !0 === n.enableDamping ? n.target.addScaledVector(g, n.dampingFactor) : n.target.add(g), n.zoomToCursor && A || n.object.isOrthographicCamera ? p.radius = $(p.radius) : p.radius = $(p.radius * m), e.setFromSpherical(p), e.applyQuaternion(a), _.copy(n.target).add(e), n.object.lookAt(n.target), !0 === n.enableDamping ? (f.theta *= 1 - n.dampingFactor, f.phi *= 1 - n.dampingFactor, g.multiplyScalar(1 - n.dampingFactor)) : (f.set(0, 0, 0), g.set(0, 0, 0));
                    let M = !1;
                    if (n.zoomToCursor && A) {
                        let r = null;
                        if (n.object.isPerspectiveCamera) {
                            const t = e.length();
                            r = $(t * m);
                            const i = t - r;
                            n.object.position.addScaledVector(T, i), n.object.updateMatrixWorld()
                        } else if (n.object.isOrthographicCamera) {
                            const t = new i.ac(C.x, C.y, 0);
                            t.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / m)), n.object.updateProjectionMatrix(), M = !0;
                            const s = new i.ac(C.x, C.y, 0);
                            s.unproject(n.object), n.object.position.sub(s).add(t), n.object.updateMatrixWorld(), r = e.length()
                        } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
                        null !== r && (this.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(r).add(n.object.position) : (o.origin.copy(n.object.position), o.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(o.direction)) < c ? t.lookAt(n.target) : (l.setFromNormalAndCoplanarPoint(n.object.up, n.target), o.intersectPlane(l, n.target))))
                    } else n.object.isOrthographicCamera && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / m)), n.object.updateProjectionMatrix(), M = !0);
                    return m = 1, A = !1, !!(M || v.distanceToSquared(n.object.position) > d || 8 * (1 - y.dot(n.object.quaternion)) > d || b.distanceToSquared(n.target) > 0) && (n.dispatchEvent(r), v.copy(n.object.position), y.copy(n.object.quaternion), b.copy(n.target), M = !1, !0)
                }
            }(), this.dispose = function () {
                n.domElement.removeEventListener("contextmenu", tt), n.domElement.removeEventListener("pointerdown", Y), n.domElement.removeEventListener("pointercancel", Z), n.domElement.removeEventListener("wheel", J), n.domElement.removeEventListener("pointermove", K), n.domElement.removeEventListener("pointerup", Z), null !== n._domElementKeyEvents && (n._domElementKeyEvents.removeEventListener("keydown", Q), n._domElementKeyEvents = null)
            };
            const n = this,
                h = {
                    NONE: -1,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2,
                    TOUCH_ROTATE: 3,
                    TOUCH_PAN: 4,
                    TOUCH_DOLLY_PAN: 5,
                    TOUCH_DOLLY_ROTATE: 6
                };
            let u = h.NONE;
            const d = 1e-6,
                p = new i.Pb,
                f = new i.Pb;
            let m = 1;
            const g = new i.ac,
                v = new i.Zb,
                y = new i.Zb,
                b = new i.Zb,
                x = new i.Zb,
                _ = new i.Zb,
                w = new i.Zb,
                S = new i.Zb,
                M = new i.Zb,
                E = new i.Zb,
                T = new i.ac,
                C = new i.Zb;
            let A = !1;
            const R = [],
                P = {};

            function L() {
                return Math.pow(.95, n.zoomSpeed)
            }

            function O(t) {
                f.theta -= t
            }

            function D(t) {
                f.phi -= t
            }
            const I = function () {
                const t = new i.ac;
                return function (e, n) {
                    t.setFromMatrixColumn(n, 0), t.multiplyScalar(-e), g.add(t)
                }
            }(),
                k = function () {
                    const t = new i.ac;
                    return function (e, i) {
                        !0 === n.screenSpacePanning ? t.setFromMatrixColumn(i, 1) : (t.setFromMatrixColumn(i, 0), t.crossVectors(n.object.up, t)), t.multiplyScalar(e), g.add(t)
                    }
                }(),
                N = function () {
                    const t = new i.ac;
                    return function (e, i) {
                        const r = n.domElement;
                        if (n.object.isPerspectiveCamera) {
                            const s = n.object.position;
                            t.copy(s).sub(n.target);
                            let a = t.length();
                            a *= Math.tan(n.object.fov / 2 * Math.PI / 180), I(2 * e * a / r.clientHeight, n.object.matrix), k(2 * i * a / r.clientHeight, n.object.matrix)
                        } else n.object.isOrthographicCamera ? (I(e * (n.object.right - n.object.left) / n.object.zoom / r.clientWidth, n.object.matrix), k(i * (n.object.top - n.object.bottom) / n.object.zoom / r.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1)
                    }
                }();

            function U(t) {
                n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? m /= t : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
            }

            function z(t) {
                n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? m *= t : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
            }

            function F(e) {
                if (!n.zoomToCursor) return;
                A = !0;
                const i = n.domElement.getBoundingClientRect(),
                    r = e.clientX - i.left,
                    s = e.clientY - i.top,
                    a = i.width,
                    o = i.height;
                C.x = r / a * 2 - 1, C.y = -s / o * 2 + 1, T.set(C.x, C.y, 1).unproject(t).sub(t.position).normalize()
            }

            function $(t) {
                return Math.max(n.minDistance, Math.min(n.maxDistance, t))
            }

            function B(t) {
                v.set(t.clientX, t.clientY)
            }

            function H(t) {
                x.set(t.clientX, t.clientY)
            }

            function j() {
                if (1 === R.length) v.set(R[0].pageX, R[0].pageY);
                else {
                    const t = .5 * (R[0].pageX + R[1].pageX),
                        e = .5 * (R[0].pageY + R[1].pageY);
                    v.set(t, e)
                }
            }

            function V() {
                if (1 === R.length) x.set(R[0].pageX, R[0].pageY);
                else {
                    const t = .5 * (R[0].pageX + R[1].pageX),
                        e = .5 * (R[0].pageY + R[1].pageY);
                    x.set(t, e)
                }
            }

            function G() {
                const t = R[0].pageX - R[1].pageX,
                    e = R[0].pageY - R[1].pageY,
                    n = Math.sqrt(t * t + e * e);
                S.set(0, n)
            }

            function W(t) {
                if (1 == R.length) y.set(t.pageX, t.pageY);
                else {
                    const e = nt(t),
                        n = .5 * (t.pageX + e.x),
                        i = .5 * (t.pageY + e.y);
                    y.set(n, i)
                }
                b.subVectors(y, v).multiplyScalar(n.rotateSpeed);
                const e = n.domElement;
                O(2 * Math.PI * b.x / e.clientHeight), D(2 * Math.PI * b.y / e.clientHeight), v.copy(y)
            }

            function q(t) {
                if (1 === R.length) _.set(t.pageX, t.pageY);
                else {
                    const e = nt(t),
                        n = .5 * (t.pageX + e.x),
                        i = .5 * (t.pageY + e.y);
                    _.set(n, i)
                }
                w.subVectors(_, x).multiplyScalar(n.panSpeed), N(w.x, w.y), x.copy(_)
            }

            function X(t) {
                const e = nt(t),
                    i = t.pageX - e.x,
                    r = t.pageY - e.y,
                    s = Math.sqrt(i * i + r * r);
                M.set(0, s), E.set(0, Math.pow(M.y / S.y, n.zoomSpeed)), U(E.y), S.copy(M)
            }

            function Y(t) {
                !1 !== n.enabled && (0 === R.length && (n.domElement.setPointerCapture(t.pointerId), n.domElement.addEventListener("pointermove", K), n.domElement.addEventListener("pointerup", Z)), function (t) {
                    R.push(t)
                }(t), "touch" === t.pointerType ? function (t) {
                    switch (et(t), R.length) {
                        case 1:
                            switch (n.touches.ONE) {
                                case i.Qb.ROTATE:
                                    if (!1 === n.enableRotate) return;
                                    j(), u = h.TOUCH_ROTATE;
                                    break;
                                case i.Qb.PAN:
                                    if (!1 === n.enablePan) return;
                                    V(), u = h.TOUCH_PAN;
                                    break;
                                default:
                                    u = h.NONE
                            }
                            break;
                        case 2:
                            switch (n.touches.TWO) {
                                case i.Qb.DOLLY_PAN:
                                    if (!1 === n.enableZoom && !1 === n.enablePan) return;
                                    n.enableZoom && G(), n.enablePan && V(), u = h.TOUCH_DOLLY_PAN;
                                    break;
                                case i.Qb.DOLLY_ROTATE:
                                    if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                                    n.enableZoom && G(), n.enableRotate && j(), u = h.TOUCH_DOLLY_ROTATE;
                                    break;
                                default:
                                    u = h.NONE
                            }
                            break;
                        default:
                            u = h.NONE
                    }
                    u !== h.NONE && n.dispatchEvent(s)
                }(t) : function (t) {
                    let e;
                    switch (t.button) {
                        case 0:
                            e = n.mouseButtons.LEFT;
                            break;
                        case 1:
                            e = n.mouseButtons.MIDDLE;
                            break;
                        case 2:
                            e = n.mouseButtons.RIGHT;
                            break;
                        default:
                            e = -1
                    }
                    switch (e) {
                        case i.ab.DOLLY:
                            if (!1 === n.enableZoom) return;
                            ! function (t) {
                                F(t), S.set(t.clientX, t.clientY)
                            }(t), u = h.DOLLY;
                            break;
                        case i.ab.ROTATE:
                            if (t.ctrlKey || t.metaKey || t.shiftKey) {
                                if (!1 === n.enablePan) return;
                                H(t), u = h.PAN
                            } else {
                                if (!1 === n.enableRotate) return;
                                B(t), u = h.ROTATE
                            }
                            break;
                        case i.ab.PAN:
                            if (t.ctrlKey || t.metaKey || t.shiftKey) {
                                if (!1 === n.enableRotate) return;
                                B(t), u = h.ROTATE
                            } else {
                                if (!1 === n.enablePan) return;
                                H(t), u = h.PAN
                            }
                            break;
                        default:
                            u = h.NONE
                    }
                    u !== h.NONE && n.dispatchEvent(s)
                }(t))
            }

            function K(t) {
                !1 !== n.enabled && ("touch" === t.pointerType ? function (t) {
                    switch (et(t), u) {
                        case h.TOUCH_ROTATE:
                            if (!1 === n.enableRotate) return;
                            W(t), n.update();
                            break;
                        case h.TOUCH_PAN:
                            if (!1 === n.enablePan) return;
                            q(t), n.update();
                            break;
                        case h.TOUCH_DOLLY_PAN:
                            if (!1 === n.enableZoom && !1 === n.enablePan) return;
                            ! function (t) {
                                n.enableZoom && X(t), n.enablePan && q(t)
                            }(t), n.update();
                            break;
                        case h.TOUCH_DOLLY_ROTATE:
                            if (!1 === n.enableZoom && !1 === n.enableRotate) return;
                            ! function (t) {
                                n.enableZoom && X(t), n.enableRotate && W(t)
                            }(t), n.update();
                            break;
                        default:
                            u = h.NONE
                    }
                }(t) : function (t) {
                    switch (u) {
                        case h.ROTATE:
                            if (!1 === n.enableRotate) return;
                            ! function (t) {
                                y.set(t.clientX, t.clientY), b.subVectors(y, v).multiplyScalar(n.rotateSpeed);
                                const e = n.domElement;
                                O(2 * Math.PI * b.x / e.clientHeight), D(2 * Math.PI * b.y / e.clientHeight), v.copy(y), n.update()
                            }(t);
                            break;
                        case h.DOLLY:
                            if (!1 === n.enableZoom) return;
                            ! function (t) {
                                M.set(t.clientX, t.clientY), E.subVectors(M, S), E.y > 0 ? U(L()) : E.y < 0 && z(L()), S.copy(M), n.update()
                            }(t);
                            break;
                        case h.PAN:
                            if (!1 === n.enablePan) return;
                            ! function (t) {
                                _.set(t.clientX, t.clientY), w.subVectors(_, x).multiplyScalar(n.panSpeed), N(w.x, w.y), x.copy(_), n.update()
                            }(t)
                    }
                }(t))
            }

            function Z(t) {
                ! function (t) {
                    delete P[t.pointerId];
                    for (let e = 0; e < R.length; e++)
                        if (R[e].pointerId == t.pointerId) return void R.splice(e, 1)
                }(t), 0 === R.length && (n.domElement.releasePointerCapture(t.pointerId), n.domElement.removeEventListener("pointermove", K), n.domElement.removeEventListener("pointerup", Z)), n.dispatchEvent(a), u = h.NONE
            }

            function J(t) {
                !1 !== n.enabled && !1 !== n.enableZoom && u === h.NONE && (t.preventDefault(), n.dispatchEvent(s), function (t) {
                    F(t), t.deltaY < 0 ? z(L()) : t.deltaY > 0 && U(L()), n.update()
                }(t), n.dispatchEvent(a))
            }

            function Q(t) {
                !1 !== n.enabled && !1 !== n.enablePan && function (t) {
                    let e = !1;
                    switch (t.code) {
                        case n.keys.UP:
                            t.ctrlKey || t.metaKey || t.shiftKey ? D(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : N(0, n.keyPanSpeed), e = !0;
                            break;
                        case n.keys.BOTTOM:
                            t.ctrlKey || t.metaKey || t.shiftKey ? D(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : N(0, -n.keyPanSpeed), e = !0;
                            break;
                        case n.keys.LEFT:
                            t.ctrlKey || t.metaKey || t.shiftKey ? O(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : N(n.keyPanSpeed, 0), e = !0;
                            break;
                        case n.keys.RIGHT:
                            t.ctrlKey || t.metaKey || t.shiftKey ? O(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : N(-n.keyPanSpeed, 0), e = !0
                    }
                    e && (t.preventDefault(), n.update())
                }(t)
            }

            function tt(t) {
                !1 !== n.enabled && t.preventDefault()
            }

            function et(t) {
                let e = P[t.pointerId];
                void 0 === e && (e = new i.Zb, P[t.pointerId] = e), e.set(t.pageX, t.pageY)
            }

            function nt(t) {
                const e = t.pointerId === R[0].pointerId ? R[1] : R[0];
                return P[e.pointerId]
            }
            n.domElement.addEventListener("contextmenu", tt), n.domElement.addEventListener("pointerdown", Y), n.domElement.addEventListener("pointercancel", Z), n.domElement.addEventListener("wheel", J, {
                passive: !1
            }), this.update()
        }
    }
}, , function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return o
    }));
    var i = n(0),
        r = n(34),
        s = n(144);
    const a = {
        shaderID: "luminosityHighPass",
        uniforms: {
            tDiffuse: {
                value: null
            },
            luminosityThreshold: {
                value: 1
            },
            smoothWidth: {
                value: 1
            },
            defaultColor: {
                value: new i.o(0)
            },
            defaultOpacity: {
                value: 0
            }
        },
        vertexShader: "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
        fragmentShader: "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}"
    };
    class o extends r.b {
        constructor(t, e, n, o) {
            super(), this.strength = void 0 !== e ? e : 1, this.radius = n, this.threshold = o, this.resolution = void 0 !== t ? new i.Zb(t.x, t.y) : new i.Zb(256, 256), this.clearColor = new i.o(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
            let l = Math.round(this.resolution.x / 2),
                c = Math.round(this.resolution.y / 2);
            this.renderTargetBright = new i.cc(l, c, {
                type: i.I
            }), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
            for (let t = 0; t < this.nMips; t++) {
                const e = new i.cc(l, c, {
                    type: i.I
                });
                e.texture.name = "UnrealBloomPass.h" + t, e.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(e);
                const n = new i.cc(l, c, {
                    type: i.I
                });
                n.texture.name = "UnrealBloomPass.v" + t, n.texture.generateMipmaps = !1, this.renderTargetsVertical.push(n), l = Math.round(l / 2), c = Math.round(c / 2)
            }
            const h = a;
            this.highPassUniforms = i.Vb.clone(h.uniforms), this.highPassUniforms.luminosityThreshold.value = o, this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new i.Nb({
                uniforms: this.highPassUniforms,
                vertexShader: h.vertexShader,
                fragmentShader: h.fragmentShader
            }), this.separableBlurMaterials = [];
            const u = [3, 5, 7, 9, 11];
            l = Math.round(this.resolution.x / 2), c = Math.round(this.resolution.y / 2);
            for (let t = 0; t < this.nMips; t++) this.separableBlurMaterials.push(this.getSeperableBlurMaterial(u[t])), this.separableBlurMaterials[t].uniforms.invSize.value = new i.Zb(1 / l, 1 / c), l = Math.round(l / 2), c = Math.round(c / 2);
            this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = e, this.compositeMaterial.uniforms.bloomRadius.value = .1;
            this.compositeMaterial.uniforms.bloomFactors.value = [1, .8, .6, .4, .2], this.bloomTintColors = [new i.ac(1, 1, 1), new i.ac(1, 1, 1), new i.ac(1, 1, 1), new i.ac(1, 1, 1), new i.ac(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
            const d = s.a;
            this.copyUniforms = i.Vb.clone(d.uniforms), this.blendMaterial = new i.Nb({
                uniforms: this.copyUniforms,
                vertexShader: d.vertexShader,
                fragmentShader: d.fragmentShader,
                blending: i.b,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0
            }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new i.o, this.oldClearAlpha = 1, this.basic = new i.fb, this.fsQuad = new r.a(null)
        }
        dispose() {
            for (let t = 0; t < this.renderTargetsHorizontal.length; t++) this.renderTargetsHorizontal[t].dispose();
            for (let t = 0; t < this.renderTargetsVertical.length; t++) this.renderTargetsVertical[t].dispose();
            this.renderTargetBright.dispose();
            for (let t = 0; t < this.separableBlurMaterials.length; t++) this.separableBlurMaterials[t].dispose();
            this.compositeMaterial.dispose(), this.blendMaterial.dispose(), this.basic.dispose(), this.fsQuad.dispose()
        }
        setSize(t, e) {
            let n = Math.round(t / 2),
                r = Math.round(e / 2);
            this.renderTargetBright.setSize(n, r);
            for (let t = 0; t < this.nMips; t++) this.renderTargetsHorizontal[t].setSize(n, r), this.renderTargetsVertical[t].setSize(n, r), this.separableBlurMaterials[t].uniforms.invSize.value = new i.Zb(1 / n, 1 / r), n = Math.round(n / 2), r = Math.round(r / 2)
        }
        render(t, e, n, i, r) {
            t.getClearColor(this._oldClearColor), this.oldClearAlpha = t.getClearAlpha();
            const s = t.autoClear;
            t.autoClear = !1, t.setClearColor(this.clearColor, 0), r && t.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = n.texture, t.setRenderTarget(null), t.clear(), this.fsQuad.render(t)), this.highPassUniforms.tDiffuse.value = n.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, t.setRenderTarget(this.renderTargetBright), t.clear(), this.fsQuad.render(t);
            let a = this.renderTargetBright;
            for (let e = 0; e < this.nMips; e++) this.fsQuad.material = this.separableBlurMaterials[e], this.separableBlurMaterials[e].uniforms.colorTexture.value = a.texture, this.separableBlurMaterials[e].uniforms.direction.value = o.BlurDirectionX, t.setRenderTarget(this.renderTargetsHorizontal[e]), t.clear(), this.fsQuad.render(t), this.separableBlurMaterials[e].uniforms.colorTexture.value = this.renderTargetsHorizontal[e].texture, this.separableBlurMaterials[e].uniforms.direction.value = o.BlurDirectionY, t.setRenderTarget(this.renderTargetsVertical[e]), t.clear(), this.fsQuad.render(t), a = this.renderTargetsVertical[e];
            this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, t.setRenderTarget(this.renderTargetsHorizontal[0]), t.clear(), this.fsQuad.render(t), this.fsQuad.material = this.blendMaterial, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, r && t.state.buffers.stencil.setTest(!0), this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(n), this.fsQuad.render(t)), t.setClearColor(this._oldClearColor, this.oldClearAlpha), t.autoClear = s
        }
        getSeperableBlurMaterial(t) {
            const e = [];
            for (let n = 0; n < t; n++) e.push(.39894 * Math.exp(-.5 * n * n / (t * t)) / t);
            return new i.Nb({
                defines: {
                    KERNEL_RADIUS: t
                },
                uniforms: {
                    colorTexture: {
                        value: null
                    },
                    invSize: {
                        value: new i.Zb(.5, .5)
                    },
                    direction: {
                        value: new i.Zb(.5, .5)
                    },
                    gaussianCoefficients: {
                        value: e
                    }
                },
                vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
                fragmentShader: "#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 invSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"
            })
        }
        getCompositeMaterial(t) {
            return new i.Nb({
                defines: {
                    NUM_MIPS: t
                },
                uniforms: {
                    blurTexture1: {
                        value: null
                    },
                    blurTexture2: {
                        value: null
                    },
                    blurTexture3: {
                        value: null
                    },
                    blurTexture4: {
                        value: null
                    },
                    blurTexture5: {
                        value: null
                    },
                    bloomStrength: {
                        value: 1
                    },
                    bloomFactors: {
                        value: null
                    },
                    bloomTintColors: {
                        value: null
                    },
                    bloomRadius: {
                        value: 0
                    }
                },
                vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
                fragmentShader: "varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}"
            })
        }
    }
    o.BlurDirectionX = new i.Zb(1, 0), o.BlurDirectionY = new i.Zb(0, 1)
}, function (t, e, n) {
    "use strict";
    n.d(e, "a", (function () {
        return a
    }));
    var i = n(0),
        r = n(34);
    const s = {
        uniforms: {
            tDiffuse: {
                value: null
            },
            toneMappingExposure: {
                value: 1
            }
        },
        vertexShader: "\n\t\tprecision highp float;\n\n\t\tuniform mat4 modelViewMatrix;\n\t\tuniform mat4 projectionMatrix;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
        fragmentShader: "\n\t\n\t\tprecision highp float;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\t" + i.Lb.tonemapping_pars_fragment + i.Lb.colorspace_pars_fragment + "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\n\t\t\t// tone mapping\n\n\t\t\t#ifdef LINEAR_TONE_MAPPING\n\n\t\t\t\tgl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( REINHARD_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( CINEON_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = OptimizedCineonToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( ACES_FILMIC_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );\n\n\t\t\t#endif\n\n\t\t\t// color space\n\n\t\t\t#ifdef SRGB_COLOR_SPACE\n\n\t\t\t\tgl_FragColor = LinearTosRGB( gl_FragColor );\n\n\t\t\t#endif\n\n\t\t}"
    };
    class a extends r.b {
        constructor() {
            super();
            const t = s;
            this.uniforms = i.Vb.clone(t.uniforms), this.material = new i.Db({
                uniforms: this.uniforms,
                vertexShader: t.vertexShader,
                fragmentShader: t.fragmentShader
            }), this.fsQuad = new r.a(this.material), this._outputColorSpace = null, this._toneMapping = null
        }
        render(t, e, n) {
            this.uniforms.tDiffuse.value = n.texture, this.uniforms.toneMappingExposure.value = t.toneMappingExposure, this._outputColorSpace === t.outputColorSpace && this._toneMapping === t.toneMapping || (this._outputColorSpace = t.outputColorSpace, this._toneMapping = t.toneMapping, this.material.defines = {}, this._outputColorSpace == i.Jb && (this.material.defines.SRGB_COLOR_SPACE = ""), this._toneMapping === i.W ? this.material.defines.LINEAR_TONE_MAPPING = "" : this._toneMapping === i.Hb ? this.material.defines.REINHARD_TONE_MAPPING = "" : this._toneMapping === i.l ? this.material.defines.CINEON_TONE_MAPPING = "" : this._toneMapping === i.a && (this.material.defines.ACES_FILMIC_TONE_MAPPING = ""), this.material.needsUpdate = !0), !0 === this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t))
        }
        dispose() {
            this.material.dispose(), this.fsQuad.dispose()
        }
    }
}, function (t, e, n) {
    var i = n(389),
        r = n(223),
        s = n(56),
        a = n(124),
        o = n(125),
        l = n(227),
        c = a((function (t, e) {
            var n = l(e);
            return o(n) && (n = void 0), o(t) ? i(t, r(e, 1, o, !0), s(n, 2)) : []
        }));
    t.exports = c
}, , , , , function (t, e, n) {
    var i = n(72)(n(45), "Map");
    t.exports = i
}, function (t, e, n) {
    var i = n(281),
        r = n(288),
        s = n(290),
        a = n(291),
        o = n(292);

    function l(t) {
        var e = -1,
            n = null == t ? 0 : t.length;
        for (this.clear(); ++e < n;) {
            var i = t[e];
            this.set(i[0], i[1])
        }
    }
    l.prototype.clear = i, l.prototype.delete = r, l.prototype.get = s, l.prototype.has = a, l.prototype.set = o, t.exports = l
}, function (t, e, n) {
    var i = n(293),
        r = n(51);
    t.exports = function t(e, n, s, a, o) {
        return e === n || (null == e || null == n || !r(e) && !r(n) ? e != e && n != n : i(e, n, s, a, t, o))
    }
}, function (t, e) {
    t.exports = function (t) {
        var e = -1,
            n = Array(t.size);
        return t.forEach((function (t) {
            n[++e] = t
        })), n
    }
}, function (t, e) {
    t.exports = function (t, e) {
        for (var n = -1, i = e.length, r = t.length; ++n < i;) t[r + n] = e[n];
        return t
    }
}, function (t, e, n) {
    var i = n(206),
        r = n(207),
        s = Object.prototype.propertyIsEnumerable,
        a = Object.getOwnPropertySymbols,
        o = a ? function (t) {
            return null == t ? [] : (t = Object(t), i(a(t), (function (e) {
                return s.call(t, e)
            })))
        } : r;
    t.exports = o
}, function (t, e) {
    var n = /^(?:0|[1-9]\d*)$/;
    t.exports = function (t, e) {
        var i = typeof t;
        return !!(e = null == e ? 9007199254740991 : e) && ("number" == i || "symbol" != i && n.test(t)) && t > -1 && t % 1 == 0 && t < e
    }
}, function (t, e) {
    t.exports = function (t) {
        return "number" == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991
    }
}, function (t, e, n) {
    (function (t) {
        var i = n(199),
            r = e && !e.nodeType && e,
            s = r && "object" == typeof t && t && !t.nodeType && t,
            a = s && s.exports === r && i.process,
            o = function () {
                try {
                    var t = s && s.require && s.require("util").types;
                    return t || a && a.binding && a.binding("util")
                } catch (t) { }
            }();
        t.exports = o
    }).call(this, n(117)(t))
}, function (t, e, n) {
    var i = n(121),
        r = n(94);
    t.exports = function (t, e) {
        for (var n = 0, s = (e = i(e, t)).length; null != t && n < s;) t = t[r(e[n++])];
        return n && n == s ? t : void 0
    }
}, function (t, e, n) {
    var i = n(26),
        r = n(122),
        s = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        a = /^\w*$/;
    t.exports = function (t, e) {
        if (i(t)) return !1;
        var n = typeof t;
        return !("number" != n && "symbol" != n && "boolean" != n && null != t && !r(t)) || (a.test(t) || !s.test(t) || null != e && t in Object(e))
    }
}, function (t, e, n) {
    var i = n(313);
    t.exports = function (t) {
        return null == t ? "" : i(t)
    }
}, function (t, e, n) {
    var i = n(326);
    t.exports = function (t, e) {
        return !!(null == t ? 0 : t.length) && i(t, e, 0) > -1
    }
}, function (t, e) {
    t.exports = function (t, e, n) {
        for (var i = -1, r = null == t ? 0 : t.length; ++i < r;)
            if (n(e, t[i])) return !0;
        return !1
    }
}, function (t, e, n) {
    var i = n(336)();
    t.exports = i
}, function (t, e, n) {
    var i = n(126),
        r = n(71),
        s = Object.prototype.hasOwnProperty;
    t.exports = function (t, e, n) {
        var a = t[e];
        s.call(t, e) && r(a, n) && (void 0 !== n || e in t) || i(t, e, n)
    }
}, function (t, e, n) {
    (function (t) {
        var i = n(45),
            r = e && !e.nodeType && e,
            s = r && "object" == typeof t && t && !t.nodeType && t,
            a = s && s.exports === r ? i.Buffer : void 0,
            o = a ? a.allocUnsafe : void 0;
        t.exports = function (t, e) {
            if (e) return t.slice();
            var n = t.length,
                i = o ? o(n) : new t.constructor(n);
            return t.copy(i), i
        }
    }).call(this, n(117)(t))
}, function (t, e, n) {
    var i = n(209)(Object.getPrototypeOf, Object);
    t.exports = i
}, function (t, e, n) {
    var i = n(203);
    t.exports = function (t) {
        var e = new t.constructor(t.byteLength);
        return new i(e).set(new i(t)), e
    }
}, function (t, e, n) {
    var i = n(172);
    t.exports = function (t, e) {
        var n = e ? i(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.length)
    }
}, function (t, e, n) {
    var i = n(359),
        r = n(171),
        s = n(119);
    t.exports = function (t) {
        return "function" != typeof t.constructor || s(t) ? {} : i(r(t))
    }
}, function (t, e) {
    $.fn.scrollParent = function () {
        const t = $.isCustomScroll();
        return function t(e, n) {
            const i = e.css("position"),
                r = "absolute" === i;
            if ("fixed" === i) return $(window);
            const s = e.parent().closest("[data-scroll-section]");
            if (s.length) return t(s);
            {
                let t = e;
                for (; t && t[0];) {
                    if (t[0] === document || t[0] === document.body || t[0] === window) return $(window);
                    if (t.hasClass("js-scroll-parent-ignore") || "svg" === t.get(0).localName) {
                        t = t.parent();
                        continue
                    }
                    if (t.hasClass("js-scroll-parent")) return t;
                    if (t.hasClass("section")) {
                        t = t.parent();
                        continue
                    }
                    if (r && "static" === t.css("position")) {
                        t = t.parent();
                        continue
                    }
                    const e = t.css("overflowY");
                    if ("auto" === e || "scroll" === e) return t;
                    if (n && "hidden" === e && t[0].scrollHeight > t[0].clientHeight) return t;
                    t = t.parent()
                }
                return $(window)
            }
        }(this.eq(0), t)
    }
}, , , , , , , , , , function (t, e, n) {
    "use strict";
    n.r(e), n.d(e, "loadVideo", (function () {
        return l
    }));
    var i = n(2),
        r = n.n(i),
        s = n(3),
        a = n.n(s),
        o = n(23);

    function l(t) {
        if (t.data("video-is-loading")) return;
        t.data("video-is-loading", !0);
        const e = r()();
        t.find("source").each((function () {
            r()(this).attr("src", r()(this).attr("src") || r()(this).data("src"))
        }));
        const n = t.next(),
            i = t.parent();
        e.append(t), t.attr("autoplay", "autoplay"), n.length ? n.before(t) : i.append(t), t.get(0).readyState !== HTMLMediaElement.HAVE_ENOUGH_DATA && t.get(0).load()
    }
    r.a.fn.videoAutoPlay = a()((function (t, e) {
        let {
            inview: n = !1
        } = e;

        function i() {
            l(t), t.get(0).currentTime = 0, t.get(0).play()
        }
        n || 0 === n ? this.inview = new o.a(t, {
            enter: i,
            destroyOnEnter: !0,
            threshold: "number" == typeof n ? n : .5
        }) : "complete" === document.readyState ? i() : r()(window).on("load", i)
    }))
}, function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(1),
        r = n(3),
        s = n.n(r),
        a = n(23),
        o = n(8);
    const l = {
        hideCount: 0,
        update() {
            Object(i.a)(".header").toggleClass("header--hidden", this.hideCount > 0)
        },
        hide() {
            this.hideCount++, this.update()
        },
        show() {
            this.hideCount--, this.update()
        }
    };
    class c extends o.a {
        init() {
            this.isHidden = !1
        }
        enable() {
            super.enable() && (this.inView = new a.a(this.$container, {
                enter: this.hide.bind(this),
                leave: this.show.bind(this),
                distance: "0px 0px -100% 0px"
            }))
        }
        disable() {
            super.disable() && (this.inView.destroy(), this.show())
        }
        hide() {
            this.isHidden || (this.isHidden = !0, l.hide())
        }
        show() {
            this.isHidden && (this.isHidden = !1, l.show())
        }
    }
    i.a.fn.hideHeader = s()(c)
}, , , , , , function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(1),
        r = n(3),
        s = n.n(r);

    function a(t) {
        const e = (t || "").replace(/^#/, ""),
            n = e ? "#" + e : "";
        window.history.replaceState(window.history.state, document.title, document.location.pathname + document.location.search + n)
    }
    i.a.fn.modalHash = s()(class {
        static get Defaults() {
            return {}
        }
        constructor(t, e) {
            this.options = i.a.extend({}, this.constructor.Defaults, e), this.$container = t, t.on("open.modal", this.handleModalOpen.bind(this)), t.on("close.modal", this.handleModalClose.bind(this)), this.checkHash()
        }
        handleModalOpen() {
            const t = this.$container.attr("id");
            t && a(t)
        }
        handleModalClose() {
            const t = document.location.hash.replace("#", "");
            t && this.$container.attr("id") == t && a(null)
        }
        checkHash() {
            const t = document.location.hash,
                e = () => {
                    const e = t.replace("#", "");
                    e && !this.visible && this.$container.attr("id") == e && this.$container.modal("show")
                };
            t && ("complete" !== document.readyState ? Object(i.a)(window).on("load", e) : e())
        }
    })
}, function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(44);
    e.default = i.a.extend({
        name: "modal-in",
        animationName: "modal-in",
        config: {
            preserveStylesheets: !0
        },
        before(t) {
            i.a.before.call(this, t), t.current.title = document.title
        },
        beforeEnter(t) {
            t.preserveStylesheets = !0, $(t.next.container).addClass("page-transition-content"), $(t.next.container).find(".js-page-content").remove(), this.$currentModals = $(t.next.container).find(".js-modal .modal");
            const e = this.getNextModal(),
                n = e.attr("data-plugin");
            e.attr("data-plugin", n + " modalPage").attr("data-modal-page-title", t.current.title), e.find(".modal__close").addClass("js-modal-close")
        },
        enter(t) {
            i.a.enter.call(this, t);
            const e = $(t.current.container).find(".js-modal .modal").not('[aria-hidden="true"]');
            if (e.length) {
                const t = this.getNextModal();
                t.find(".modal__background").addClass("is-hidden"), e.on("closed.modal", () => {
                    t.find(".modal__background").removeClass("is-hidden")
                }), e.modal({
                    animationNameOut: "modal-out-fake slow"
                }), e.modal("hide")
            }
        },
        after(t) {
            const e = $(t.current.container),
                n = $(t.next.container),
                i = e.find(".js-modal"),
                r = n.find(".js-modal");
            i.children().filter((t, e) => {
                const n = $(e).attr("id");
                return n && 0 === r.find("#" + n).length
            }).prependTo(r), i.remove(), e.children().prependTo(n), n.removeClass("page-transition-content"), e.remove(), this.afterUpdateScrollable(t)
        },
        afterUpdateScrollable(t) {
            const e = $(t.current.container),
                n = $(t.next.container);
            if ($.fn.scroller) {
                const t = Math.round($(window).scrollTop()),
                    i = n.find(".js-page-content-wrapper").addBack(".js-page-content-wrapper"),
                    r = e.find(".js-page-content-wrapper").addBack(".js-page-content-wrapper");
                $("body").scroller("setScrollableContent", i), $("body").scroller("unsetScrollableContent", r), $(window).scrollTop(t)
            }
            this.getNextModal().attr("aria-hidden", "false").transition(this.animationName)
        },
        getNextModal() {
            const t = this.$currentModals;
            return t.not('[aria-hidden="true"]').length ? t.not('[aria-hidden="true"]') : t.eq(0)
        }
    })
}, function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(44);
    e.default = i.a.extend({
        name: "fade",
        showAboveTheFoldImages(t) {
            $(t.next.container).find('[data-plugin~="appear"]').filter("picture, img").filter((function () {
                const t = this.getBoundingClientRect();
                return t.top < window.innerHeight && t.top + t.height > 0 && t.left < window.innerWidth && t.left + t.width > 0
            })).appear("show")
        },
        initializeAboveTheFoldPlugins(t) {
            $(t.next.container).find("[data-plugin]").filter((function () {
                const t = this.getBoundingClientRect();
                return t.top < window.innerHeight && t.top + t.height > 0 && t.left < window.innerWidth && t.left + t.width > 0
            })).app()
        },
        enter(t) {
            return i.a.enter.call(this, t), this.showAboveTheFoldImages(t), this.afterUpdateScrollable(t), this.initializeAboveTheFoldPlugins(t), new Promise(e => {
                $(t.next.container).transition("fade-in", e)
            })
        }
    })
}, , function (t, e, n) {
    t.exports = function () {
        "use strict";
        var t = document,
            e = t.createTextNode.bind(t);

        function n(t, e, n) {
            t.style.setProperty(e, n)
        }

        function i(t, e) {
            return t.appendChild(e)
        }

        function r(e, n, r, s) {
            var a = t.createElement("span");
            return n && (a.className = n), r && (!s && a.setAttribute("data-" + n, r), a.textContent = r), e && i(e, a) || a
        }

        function s(t, e) {
            return t.getAttribute("data-" + e)
        }

        function a(e, n) {
            return e && 0 != e.length ? e.nodeName ? [e] : [].slice.call(e[0].nodeName ? e : (n || t).querySelectorAll(e)) : []
        }

        function o(t) {
            for (var e = []; t--;) e[t] = [];
            return e
        }

        function l(t, e) {
            t && t.some(e)
        }

        function c(t) {
            return function (e) {
                return t[e]
            }
        }
        var h = {};

        function u(t, e, n, i) {
            return {
                by: t,
                depends: e,
                key: n,
                split: i
            }
        }

        function d(t) {
            return function t(e, n, i) {
                var r = i.indexOf(e);
                if (-1 == r) i.unshift(e), l(h[e].depends, (function (n) {
                    t(n, e, i)
                }));
                else {
                    var s = i.indexOf(n);
                    i.splice(r, 1), i.splice(s, 0, e)
                }
                return i
            }(t, 0, []).map(c(h))
        }

        function p(t) {
            h[t.by] = t
        }

        function f(t, n, s, o, c) {
            t.normalize();
            var h = [],
                u = document.createDocumentFragment();
            o && h.push(t.previousSibling);
            var d = [];
            return a(t.childNodes).some((function (t) {
                if (!t.tagName || t.hasChildNodes()) {
                    if (t.childNodes && t.childNodes.length) return d.push(t), void h.push.apply(h, f(t, n, s, o, c));
                    var i = t.wholeText || "",
                        a = i.trim();
                    a.length && (" " === i[0] && d.push(e(" ")), l(a.split(s), (function (t, e) {
                        e && c && d.push(r(u, "whitespace", " ", c));
                        var i = r(u, n, t);
                        h.push(i), d.push(i)
                    })), " " === i[i.length - 1] && d.push(e(" ")))
                } else d.push(t)
            })), l(d, (function (t) {
                i(u, t)
            })), t.innerHTML = "", i(t, u), h
        }
        var m = u("words", 0, "word", (function (t) {
            return f(t, "word", /\s+/, 0, 1)
        })),
            g = u("chars", ["words"], "char", (function (t, e, n) {
                var i = [];
                return l(n.words, (function (t, n) {
                    i.push.apply(i, f(t, "char", "", e.whitespace && n))
                })), i
            }));

        function v(t) {
            var e = (t = t || {}).key;
            return a(t.target || "[data-splitting]").map((function (i) {
                var r = i["🍌"];
                if (!t.force && r) return r;
                r = i["🍌"] = {
                    el: i
                };
                var a = d(t.by || s(i, "splitting") || "chars"),
                    o = function (t, e) {
                        for (var n in e) t[n] = e[n];
                        return t
                    }({}, t);
                return l(a, (function (t) {
                    if (t.split) {
                        var s = t.by,
                            a = (e ? "-" + e : "") + t.key,
                            c = t.split(i, o, r);
                        a && function (t, e, i) {
                            var r = "--" + e,
                                s = r + "-index";
                            l(i, (function (t, e) {
                                Array.isArray(t) ? l(t, (function (t) {
                                    n(t, s, e)
                                })) : n(t, s, e)
                            })), n(t, r + "-total", i.length)
                        }(i, a, c), r[s] = c, i.classList.add(s)
                    }
                })), i.classList.add("splitting"), r
            }))
        }

        function y(t, e, n) {
            var i = a(e.matching || t.children, t),
                r = {};
            return l(i, (function (t) {
                var e = Math.round(t[n]);
                (r[e] || (r[e] = [])).push(t)
            })), Object.keys(r).map(Number).sort(b).map(c(r))
        }

        function b(t, e) {
            return t - e
        }
        v.html = function (t) {
            var e = (t = t || {}).target = r();
            return e.innerHTML = t.content, v(t), e.outerHTML
        }, v.add = p;
        var x = u("lines", ["words"], "line", (function (t, e, n) {
            return y(t, {
                matching: n.words
            }, "offsetTop")
        })),
            _ = u("items", 0, "item", (function (t, e) {
                return a(e.matching || t.children, t)
            })),
            w = u("rows", 0, "row", (function (t, e) {
                return y(t, e, "offsetTop")
            })),
            S = u("cols", 0, "col", (function (t, e) {
                return y(t, e, "offsetLeft")
            })),
            M = u("grid", ["rows", "cols"]),
            E = u("layout", 0, 0, (function (t, e) {
                var o = e.rows = +(e.rows || s(t, "rows") || 1),
                    l = e.columns = +(e.columns || s(t, "columns") || 1);
                if (e.image = e.image || s(t, "image") || t.currentSrc || t.src, e.image) {
                    var c = a("img", t)[0];
                    e.image = c && (c.currentSrc || c.src)
                }
                e.image && n(t, "background-image", "url(" + e.image + ")");
                for (var h = o * l, u = [], d = r(0, "cell-grid"); h--;) {
                    var p = r(d, "cell");
                    r(p, "cell-inner"), u.push(p)
                }
                return i(t, d), u
            })),
            T = u("cellRows", ["layout"], "row", (function (t, e, n) {
                var i = e.rows,
                    r = o(i);
                return l(n.layout, (function (t, e, n) {
                    r[Math.floor(e / (n.length / i))].push(t)
                })), r
            })),
            C = u("cellColumns", ["layout"], "col", (function (t, e, n) {
                var i = e.columns,
                    r = o(i);
                return l(n.layout, (function (t, e) {
                    r[e % i].push(t)
                })), r
            })),
            A = u("cells", ["cellRows", "cellColumns"], "cell", (function (t, e, n) {
                return n.layout
            }));
        return p(m), p(g), p(x), p(_), p(w), p(S), p(M), p(E), p(T), p(C), p(A), v
    }()
}, , function (t, e, n) {
    var i = n(90),
        r = n(156);
    t.exports = function (t, e, n, s) {
        var a = n.length,
            o = a,
            l = !s;
        if (null == t) return !o;
        for (t = Object(t); a--;) {
            var c = n[a];
            if (l && c[2] ? c[1] !== t[c[0]] : !(c[0] in t)) return !1
        }
        for (; ++a < o;) {
            var h = (c = n[a])[0],
                u = t[h],
                d = c[1];
            if (l && c[2]) {
                if (void 0 === u && !(h in t)) return !1
            } else {
                var p = new i;
                if (s) var f = s(u, d, h, t, e, p);
                if (!(void 0 === f ? r(d, u, 3, s, p) : f)) return !1
            }
        }
        return !0
    }
}, function (t, e, n) {
    (function (e) {
        var n = "object" == typeof e && e && e.Object === Object && e;
        t.exports = n
    }).call(this, n(112))
}, function (t, e) {
    var n = Function.prototype.toString;
    t.exports = function (t) {
        if (null != t) {
            try {
                return n.call(t)
            } catch (t) { }
            try {
                return t + ""
            } catch (t) { }
        }
        return ""
    }
}, function (t, e, n) {
    var i = n(115),
        r = n(202),
        s = n(116);
    t.exports = function (t, e, n, a, o, l) {
        var c = 1 & n,
            h = t.length,
            u = e.length;
        if (h != u && !(c && u > h)) return !1;
        var d = l.get(t),
            p = l.get(e);
        if (d && p) return d == e && p == t;
        var f = -1,
            m = !0,
            g = 2 & n ? new i : void 0;
        for (l.set(t, e), l.set(e, t); ++f < h;) {
            var v = t[f],
                y = e[f];
            if (a) var b = c ? a(y, v, f, e, t, l) : a(v, y, f, t, e, l);
            if (void 0 !== b) {
                if (b) continue;
                m = !1;
                break
            }
            if (g) {
                if (!r(e, (function (t, e) {
                    if (!s(g, e) && (v === t || o(v, t, n, a, l))) return g.push(e)
                }))) {
                    m = !1;
                    break
                }
            } else if (v !== y && !o(v, y, n, a, l)) {
                m = !1;
                break
            }
        }
        return l.delete(t), l.delete(e), m
    }
}, function (t, e) {
    t.exports = function (t, e) {
        for (var n = -1, i = null == t ? 0 : t.length; ++n < i;)
            if (e(t[n], n, t)) return !0;
        return !1
    }
}, function (t, e, n) {
    var i = n(45).Uint8Array;
    t.exports = i
}, function (t, e, n) {
    var i = n(205),
        r = n(159),
        s = n(57);
    t.exports = function (t) {
        return i(t, s, r)
    }
}, function (t, e, n) {
    var i = n(158),
        r = n(26);
    t.exports = function (t, e, n) {
        var s = e(t);
        return r(t) ? s : i(s, n(t))
    }
}, function (t, e) {
    t.exports = function (t, e) {
        for (var n = -1, i = null == t ? 0 : t.length, r = 0, s = []; ++n < i;) {
            var a = t[n];
            e(a, n, t) && (s[r++] = a)
        }
        return s
    }
}, function (t, e) {
    t.exports = function () {
        return []
    }
}, function (t, e, n) {
    var i = n(299),
        r = n(91),
        s = n(26),
        a = n(92),
        o = n(160),
        l = n(118),
        c = Object.prototype.hasOwnProperty;
    t.exports = function (t, e) {
        var n = s(t),
            h = !n && r(t),
            u = !n && !h && a(t),
            d = !n && !h && !u && l(t),
            p = n || h || u || d,
            f = p ? i(t.length, String) : [],
            m = f.length;
        for (var g in t) !e && !c.call(t, g) || p && ("length" == g || u && ("offset" == g || "parent" == g) || d && ("buffer" == g || "byteLength" == g || "byteOffset" == g) || o(g, m)) || f.push(g);
        return f
    }
}, function (t, e) {
    t.exports = function (t, e) {
        return function (n) {
            return t(e(n))
        }
    }
}, function (t, e, n) {
    var i = n(72)(n(45), "Set");
    t.exports = i
}, function (t, e, n) {
    var i = n(212),
        r = n(57);
    t.exports = function (t) {
        for (var e = r(t), n = e.length; n--;) {
            var s = e[n],
                a = t[s];
            e[n] = [s, a, i(a)]
        }
        return e
    }
}, function (t, e, n) {
    var i = n(27);
    t.exports = function (t) {
        return t == t && !i(t)
    }
}, function (t, e) {
    t.exports = function (t, e) {
        return function (n) {
            return null != n && (n[t] === e && (void 0 !== e || t in Object(n)))
        }
    }
}, function (t, e) {
    t.exports = function (t, e, n, i) {
        for (var r = t.length, s = n + (i ? 1 : -1); i ? s-- : ++s < r;)
            if (e(t[s], s, t)) return s;
        return -1
    }
}, function (t, e, n) {
    var i = n(323),
        r = n(27),
        s = n(122),
        a = /^[-+]0x[0-9a-f]+$/i,
        o = /^0b[01]+$/i,
        l = /^0o[0-7]+$/i,
        c = parseInt;
    t.exports = function (t) {
        if ("number" == typeof t) return t;
        if (s(t)) return NaN;
        if (r(t)) {
            var e = "function" == typeof t.valueOf ? t.valueOf() : t;
            t = r(e) ? e + "" : e
        }
        if ("string" != typeof t) return 0 === t ? t : +t;
        t = i(t);
        var n = o.test(t);
        return n || l.test(t) ? c(t.slice(2), n ? 2 : 8) : a.test(t) ? NaN : +t
    }
}, function (t, e, n) {
    var i = n(217),
        r = Math.max;
    t.exports = function (t, e, n) {
        return e = r(void 0 === e ? t.length - 1 : e, 0),
            function () {
                for (var s = arguments, a = -1, o = r(s.length - e, 0), l = Array(o); ++a < o;) l[a] = s[e + a];
                a = -1;
                for (var c = Array(e + 1); ++a < e;) c[a] = s[a];
                return c[e] = n(l), i(t, this, c)
            }
    }
}, function (t, e) {
    t.exports = function (t, e, n) {
        switch (n.length) {
            case 0:
                return t.call(e);
            case 1:
                return t.call(e, n[0]);
            case 2:
                return t.call(e, n[0], n[1]);
            case 3:
                return t.call(e, n[0], n[1], n[2])
        }
        return t.apply(e, n)
    }
}, function (t, e, n) {
    var i = n(329),
        r = n(331)(i);
    t.exports = r
}, function (t, e, n) {
    var i = n(72),
        r = function () {
            try {
                var t = i(Object, "defineProperty");
                return t({}, "", {}), t
            } catch (t) { }
        }();
    t.exports = r
}, function (t, e, n) {
    var i, r, s;
    /*!
     * jquery-app <https://github.com/kasparsz/jquery-app>
     *
     * Copyright (c) 2016-2020, Kaspars Zuks.
     * Licensed under the MIT License.
     */
    r = [n(2)], void 0 === (s = "function" == typeof (i = function (t) {
        var e = /(\s*,\s*|\s+)/,
            n = /[^a-z]/;
        t.app = {
            settings: {
                namespace: "plugin",
                namespaceOptions: !0,
                debug: !1
            },
            call: function (e, n, i) {
                void 0 === n && (n = t.app.settings), void 0 === i && (i = null);
                var r = t(e),
                    s = i || t.app.getPlugins(r, n),
                    a = r.data("jQueryAppData");
                a || r.data("jQueryAppData", a = {}), s.forEach((function (i) {
                    if (a[i]) n.debug && "error" !== n.debug && console.log('$.app skipped plugin "%s" on %o because it already has been called previously', i, e);
                    else {
                        a[i] = !0;
                        var s = t.app.getPluginOptions(r, i, n);
                        r[i](s), n.debug && "error" !== n.debug && console.log('$.app called plugin "%s" on %o with options %O', i, e, s)
                    }
                }))
            },
            getPlugins: function (n, i) {
                return void 0 === i && (i = t.app.settings), (t(n).data(i.namespace) || "").split(e).filter((function (e) {
                    if (e.trim()) {
                        if ("function" == typeof t.fn[e]) return !0;
                        i.debug && console.error('$.app coundn\'t find jQuery plugin "%s" declared on element %o', e, t(n).get(0))
                    }
                    return !1
                }))
            },
            getPluginOptions: function (e, i, r) {
                void 0 === r && (r = t.app.settings);
                var s = {},
                    a = t(e).data();
                if (r.namespaceOptions)
                    for (var o in a) {
                        var l = a[o];
                        if (o === i) t.extend(s, t.isPlainObject(l) ? l : {});
                        else if (0 === o.indexOf(i) && o.substr(i.length, 1).match(n)) {
                            var c = o.substr(i.length);
                            s[c = c[0].toLowerCase() + c.substr(1)] = l
                        }
                    } else t.extend(s, a);
                return s
            },
            hasPluginDefined: function (e, n, i) {
                return void 0 === i && (i = t.app.settings), -1 !== t.app.getPlugins(e, i).indexOf(n)
            },
            hasPlugin: function (e, n) {
                var i = t(e).data("jQueryAppData");
                return !(!i || !i[n])
            }
        }, t.fn.app = function (e, n) {
            Array.isArray(e) && (n = e, e = {});
            var i = t.extend({}, t.app.settings, e),
                r = "[data-" + i.namespace + "]";
            return this.find(r).addBack(r).each((function (e, r) {
                return t.app.call(r, i, n)
            })), this
        }
    }) ? i.apply(e, r) : i) || (t.exports = s)
}, function (t, e) {
    t.exports = function (t, e) {
        for (var n = -1, i = null == t ? 0 : t.length; ++n < i && !1 !== e(t[n], n, t););
        return t
    }
}, function (t, e, n) {
    "use strict";
    var i = n(1),
        r = n(9);
    const s = /(-?[\d.]+)(ms|s)/g;

    function a(t) {
        let e = 0;
        return t && String(t).replace(s, (t, n, i) => {
            let r = parseFloat(n) || 0;
            "s" === i && (r *= 1e3), e = Math.max(e, r)
        }), e
    }
    i.a.fn.transitionduration = function (t) {
        let e = a(Object(i.a)(this).css("transition-duration"));
        e && (e += a(Object(i.a)(this).css("transition-delay")));
        let n = a(Object(i.a)(this).css("animation-duration"));
        return n && (n += a(Object(i.a)(this).css("animation-delay"))), Math.max(e, n, t || 0, 0)
    }, i.a.fn.transitionend = function () {
        return Promise.all(this.toArray().map((function (t) {
            return new Promise(e => {
                const n = Object(i.a)(t),
                    s = "transitionstop." + Object(r.a)(),
                    a = n.transitionduration(),
                    o = setTimeout(() => {
                        n.off(s), e()
                    }, a + 16);
                n.on(s, (function (t) {
                    n.is(t.target) && (clearTimeout(o), n.off(s), e())
                }))
            })
        })))
    }, i.a.fn.animationend = function () {
        const t = this.toArray().map(t => new Promise(e => {
            const n = Object(i.a)(t),
                s = Object(r.a)(),
                a = "webkitAnimationStart." + s + " animationstart." + s,
                o = "webkitAnimationEnd." + s + " animationend." + s;
            let l = 0;
            n.on(a, t => {
                "infinite" !== Object(i.a)(t.target).css("animationIterationCount") && l++
            }), n.on(o, (function () {
                l--, l <= 0 && (n.off(a).off(o), e())
            }))
        }));
        return Promise.all(t)
    }
}, function (t, e, n) {
    var i = n(158),
        r = n(341);
    t.exports = function t(e, n, s, a, o) {
        var l = -1,
            c = e.length;
        for (s || (s = r), o || (o = []); ++l < c;) {
            var h = e[l];
            n > 0 && s(h) ? n > 1 ? t(h, n - 1, s, a, o) : i(o, h) : a || (o[o.length] = h)
        }
        return o
    }
}, function (t, e, n) {
    "use strict";
    var i = n(1),
        r = n(5),
        s = n.n(r),
        a = n(3),
        o = n.n(a),
        l = n(196),
        c = n.n(l);

    function h(t) {
        let e = t.get(0).innerHTML;
        return -1 !== e.indexOf("&nbsp;") && (e = e.replace(/[^\s\t\r\n><]+&nbsp;[^\s\t\r\n><]+/g, t => `<span class="text-nowrap">${t}</span>`), e = e.replace(/> </g, '><span class="whitespace"> </span><'), t.get(0).innerHTML = e), t
    }

    function u(t) {
        const e = t.add(t.find("*"));
        for (let t = e.length - 1; t >= 0; t--) {
            const n = e[t].childNodes;
            for (let t = 0; t < n.length; t++) {
                const e = n[t];
                e.nodeType === Node.TEXT_NODE && -1 !== e.textContent.indexOf("-") && Object(i.a)(e).replaceWith(e.textContent.split("-").join("<span>-</span>"))
            }
        }
        return t
    }
    i.a.fn.splitChars = o()((function (t) {
        const e = t.addClass("splitting").html();
        c()({
            target: u(h(t)).get(0),
            by: "chars"
        }), this.destroy = function () {
            t.removeData("split-lines").html(e)
        }
    }), {
        namespace: "split-lines"
    }), i.a.fn.splitLines = o()((function (t) {
        if (t.hasClass("splitting")) this.destroy = function () { };
        else {
            const e = t.addClass("splitting").html(),
                n = c()({
                    target: u(h(t)).get(0),
                    by: "lines"
                });
            s()(n, t => {
                t.lines.forEach((t, e) => {
                    Object(i.a)(t).data("line-index", e)
                })
            }),
                function (t) {
                    const e = t.find("nobr");
                    for (let t = 0; t < e.length; t++) {
                        const n = e.get(t).childNodes,
                            i = n[n.length - 1];
                        if (i && i.textContent && " " === i.textContent.substr(-1)) {
                            document.createTextNode(" ").after(e.get(t)), i.textContent = i.textContent.substr(0, i.textContent.length - 1)
                        }
                    }
                }(t), this.destroy = function () {
                    t.removeData("split-lines").html(e)
                }
        }
    }), {
        namespace: "split-lines"
    })
}, function (t, e, n) {
    var i = n(158),
        r = n(171),
        s = n(159),
        a = n(207),
        o = Object.getOwnPropertySymbols ? function (t) {
            for (var e = []; t;) i(e, s(t)), t = r(t);
            return e
        } : a;
    t.exports = o
}, function (t, e, n) {
    var i = n(205),
        r = n(225),
        s = n(67);
    t.exports = function (t) {
        return i(t, s, r)
    }
}, function (t, e) {
    t.exports = function (t) {
        var e = null == t ? 0 : t.length;
        return e ? t[e - 1] : void 0
    }
}, function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(1),
        r = n(3),
        s = n.n(r),
        a = (n(30), n(9)),
        o = n(23);
    i.a.fn.svgLength = s()(class {
        constructor(t) {
            this.$container = t, this.$svg = t.closest("svg"), this.$button = t.closest(".btn"), this.ns = Object(a.a)(), this.size = 0, t.on("destroyed", this.destroy.bind(this)), this.$button.length ? (this.observer = new ResizeObserver(this.update.bind(this)), this.observer.observe(this.$button.get(0))) : this.inview = new o.a(this.$svg, {
                enter: this.update.bind(this)
            }), this.update()
        }
        destroy() {
            this.inview && this.inview.destroy(), this.observer && (this.observer.disconnect(), this.observer = null)
        }
        update(t) {
            const e = this.$container,
                n = e.get(0);
            try {
                const i = n.getTotalLength();
                i && i !== this.size && (this.size = i, e.css("--path-length", i + .5 + "px"), e.removeAttr("pathLength"));
                let r = "inherit",
                    s = "inherit";
                if (t && t[0]) {
                    const e = 2;
                    r = t[0].borderBoxSize[0].inlineSize - e + "px", s = t[0].borderBoxSize[0].blockSize - e + "px"
                }
                e.css("width", r), e.css("height", s), requestAnimationFrame(() => {
                    e.css("width", ""), e.css("height", "")
                })
            } catch (t) { }
        }
    })
}, function (t, e, n) {
    var i = n(73),
        r = n(51),
        s = n(130);
    t.exports = function (t) {
        if (!r(t)) return !1;
        var e = i(t);
        return "[object Error]" == e || "[object DOMException]" == e || "string" == typeof t.message && "string" == typeof t.name && !s(t)
    }
}, function (t, e, n) {
    var i = n(74);
    t.exports = function (t, e) {
        return i(e, (function (e) {
            return t[e]
        }))
    }
}, function (t, e) {
    t.exports = /<%=([\s\S]+?)%>/g
}, function (t, e, n) {
    var i = n(426);
    t.exports = function (t, e) {
        var n = -1,
            r = t.length,
            s = r - 1;
        for (e = void 0 === e ? r : e; ++n < e;) {
            var a = i(n, s),
                o = t[a];
            t[a] = t[n], t[n] = o
        }
        return t.length = e, t
    }
}, function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(1),
        r = n(7),
        s = n(3),
        a = n.n(s),
        o = n(82);
    n(23), n(38), n(84);

    function l(t, e) {
        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "",
            i = t.attr(e),
            r = i || n;
        return "number" == typeof n && "number" != typeof r ? r = parseFloat(r) : "boolean" == typeof n && "string" == typeof i && (r = "" === r || "true" === r), r
    }
    Object(o.a)() && Object(i.a)(document.documentElement).addClass("js-no-reveal");
    i.a.fn.reveal = a()(class {
        static get Defaults() {
            return {
                groupDistance: -100,
                elementDistance: -100,
                groupThreshold: .5,
                elementThreshold: 0,
                staggerDelay: 180,
                delay: 30,
                enableMq: "md-up"
            }
        }
        constructor(t, e) {
            this.options = i.a.extend({}, this.constructor.Defaults, e), this.$container = t, this.update()
        }
        update() {
            Object(o.a)() || this.updateWhenReady()
        }
        updateWhenReady() {
            i.a.fontsready ? i.a.fontsready.then(this.refresh.bind(this)) : this.refresh()
        }
        refresh() {
            const t = this.$container;
            !this.options.enableMq || r.a.matches(this.options.enableMq) ? (t.find("[data-reveal-group]").addBack("[data-reveal-group]").each((t, e) => {
                this.attachGroup(Object(i.a)(e))
            }), t.find("[data-reveal]").addBack("[data-reveal]").not("[data-reveal-group] [data-reveal]").each((t, e) => {
                this.attachElement(Object(i.a)(e))
            })) : t.find("[data-reveal]").each((function () {
                Object(i.a)(this).attr("data-reveal-old", Object(i.a)(this).attr("data-reveal")), Object(i.a)(this).removeAttr("data-reveal")
            }))
        }
        attachGroup(t) {
            const e = l(t, "data-reveal-distance", this.options.groupDistance),
                n = l(t, "data-reveal-threshold", this.options.groupThreshold),
                i = l(t, "data-reveal-repeat", !1);
            t.inview("instance") || t.inview({
                distance: e,
                threshold: n,
                enter: this.animateGroup.bind(this),
                leave: i ? this.hideGroup.bind(this) : null,
                destroyOnEnter: !i
            })
        }
        attachElement(t) {
            const e = l(t, "data-reveal-distance", this.options.elementDistance),
                n = l(t, "data-reveal-threshold", this.options.elementThreshold),
                i = l(t, "data-reveal-repeat", !1);
            t.inview("instance") || t.inview({
                distance: e,
                threshold: n,
                enter: this.animateElement.bind(this),
                leave: i ? this.hideElement.bind(this) : null,
                destroyOnEnter: !i
            })
        }
        animateGroup(t) {
            const e = t.find("[data-reveal]"),
                n = {
                    delay: l(t, "data-reveal-delay", this.options.delay),
                    repeat: l(t, "data-reveal-repeat", !1)
                };
            e.each((t, e) => {
                this.animateElement(Object(i.a)(e), n)
            })
        }
        hideGroup(t) {
            t.find("[data-reveal]").removeAttr("data-reveal-visible")
        }
        animateElement(t) {
            let e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const n = l(t, "data-reveal", ""),
                r = l(t, "data-reveal-delay", this.options.delay),
                s = l(t, "data-reveal-duration", this.options.duration),
                a = l(t, "data-reveal-stagger", 0) * this.options.staggerDelay,
                o = l(t, "data-reveal-repeat", !1),
                c = (e.delay || 0) + r + a;
            if (i.a.fn.appear) {
                t.find('img[data-plugin*="appear"]').addBack('img[data-plugin*="appear"]').appear("show")
            }
            e.repeat || o ? t.attr("data-reveal-visible", !0) : (t.attr("data-reveal-old", t.attr("data-reveal")), t.removeAttr("data-reveal"));
            const h = n.split(" ").concat([{
                delay: c,
                duration: s
            }]);
            t.transition.apply(t, h)
        }
        hideElement(t) {
            t.removeAttr("data-reveal-visible")
        }
    }, {
        api: ["instance", "update"]
    }), i.a.fn.revealReset = function () {
        if (Object(o.a)()) return;
        let t = Object(i.a)();
        return this.find("[data-reveal-old]").addBack("[data-reveal-old]").each((function () {
            Object(i.a)(this).attr("data-reveal", Object(i.a)(this).attr("data-reveal-old"))
        })), this.each((function () {
            let e = Object(i.a)(this);
            for (; e.length && !i.a.app.hasPluginDefined(e, "reveal") && !e.reveal("instance");) e = e.parent();
            e.length && (t = t.add(e), 1 === t.length && requestAnimationFrame(() => {
                t.reveal("update")
            }))
        })), this
    }
}, function (t, e, n) {
    var i = n(74),
        r = n(325),
        s = n(124),
        a = n(332),
        o = s((function (t) {
            var e = i(t, a);
            return e.length && e[0] === t[0] ? r(e) : []
        }));
    t.exports = o
}, function (t, e) {
    t.exports = "uniform sampler2D baseTexture;\nuniform sampler2D bloomTexture;\n\nvarying vec2 vUv;\n\nfloat toneMappingExposure = 1.0;\n\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\nvec3 RRTAndODTFit( vec3 v ) {\n    vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n    vec3 b = v * ( 2.983729 * v + 0.4329510 ) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFilmicToneMapping( vec3 color ) {\n    // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n    const mat3 ACESInputMat = mat3(\n        vec3( 0.5, 0.5, 0.5 ), // transposed from source\n        vec3( 0.5, 0.5, 0.5 ),\n        vec3( 0.5, 0.5, 0.5 )\n    );\n\n    // ODT_SAT => XYZ => D60_2_D65 => sRGB\n    const mat3 ACESOutputMat = mat3(\n        vec3(  1, 1, 1 ), // transposed from source\n        vec3( 1,  1, 1 ),\n        vec3( 1, 1,  1 )\n    );\n\n    color *= toneMappingExposure;\n\n    color = ACESInputMat * color;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit( color );\n\n    color = ACESOutputMat * color;\n\n    // Clamp to [0, 1]\n    return clamp(color, 0.0, 1.0);\n}\n\nvec3 CustomToneMapping ( vec3 color ) {\n    return color;\n}\n\n\nvoid main() {\n    vec4 base_color = texture2D(baseTexture, vUv);\n    vec4 bloom_color = texture2D(bloomTexture, vUv);\n\n    // Adjusted\n    float lum = 0.2 * bloom_color.r * bloom_color.g * bloom_color.b;\n    float alpha = max(base_color.a, lum);\n\n    vec3 color = base_color.rgb + bloom_color.rgb;\n        vec3 toneMapped = ACESFilmicToneMapping(color);\n\n        gl_FragColor = vec4(mix(color, toneMapped, 1.0 - base_color.a), alpha);\n    }\n"
}, function (t, e) {
    t.exports = "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n"
}, function (t, e) {
    t.exports = "uniform vec3 uCameraPosition;\nuniform float uTime;\n\n// 1. Fade out in the begining and in the end\n// varying vec2 vUv;\n\n// 2.d Alpha glow calculated in vertex shader\nuniform float uCoeficient;\nuniform float uPower;\nvarying float vAlpha;\n\n// 4. Progress opacity\nuniform float uProgress;\nuniform float uSpeed;\n\n\nfloat Y_MIN = -10.0;\nfloat Y_MAX = 15.0;\n\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvoid main() {\n    // 0. Position\n    vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\n    gl_Position = projectionMatrix * modelViewPosition;\n\n    // 1. Fade out in the begining and in the end\n    // vUv = uv;\n\n    // 2.d. Glow - Alpha glow calculated in vertex shader\n    float alphaGlow = 1.0;\n\n    if (uPower > 0.0) {\n        vec3 vVertexNormal = normalize(normalMatrix * normal);\n        vec3 vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n\n        vec3 worldCameraToVertex = vVertexWorldPosition - uCameraPosition;\n        vec3 viewCameraToVertex = normalize((viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz);\n        float alphaValue = clamp(uCoeficient + dot(vVertexNormal, viewCameraToVertex), 0.0, 1.0);\n        alphaGlow = clamp(pow(alphaValue, uPower), 0.0, 1.0);\n    }\n\n    // 3. Time based opacity\n    float noiseAlpha = noise(vec2(position.y * 2.0 + uTime / uSpeed, 1.0));\n    float timeAlpha = noiseAlpha * 0.5 + 0.5;\n\n\n    // 4. Progress opacity\n    float viewportPositionY = (position.y - Y_MIN) / (Y_MAX - Y_MIN);\n    float progressAlpha = 1.0;\n\n    if (uProgress <= 1.0) {\n        // uProgress: 0 -> 1\n        progressAlpha = smoothstep(1.0 - uProgress, 1.1 - uProgress, viewportPositionY);\n    } else {\n        progressAlpha = smoothstep(uProgress - 1.0, uProgress - 0.9, 1.0 - viewportPositionY);\n    }\n\n    vAlpha = clamp(alphaGlow * timeAlpha * progressAlpha, 0.0, 1.0);\n}\n\n"
}, function (t, e) {
    t.exports = "uniform float size;\nuniform float scale;\nuniform float opacity;\nuniform float uCount;\nvarying float vOpacity;\n\n// 4. Progress opacity\nuniform float uProgress;\nuniform float uSpeed;\n\n// 5. Time animation\nuniform float uTime;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n    varying vec2 vUv;\n    uniform mat3 uvTransform;\n#endif\n\nfloat Y_MIN = -10.0;\nfloat Y_MAX = 15.0;\n\nfloat rand2(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand2(ip),rand2(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand2(ip+vec2(0.0,1.0)),rand2(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvoid main() {\n    #ifdef USE_POINTS_UV\n        vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n    #endif\n    #include <color_vertex>\n    #include <morphcolor_vertex>\n    #include <begin_vertex>\n    #include <morphtarget_vertex>\n    #include <project_vertex>\n\n    gl_PointSize = size;\n\n    #ifdef USE_SIZEATTENUATION\n        bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n        if ( isPerspective ) {\n            gl_PointSize *= ( scale / - mvPosition.z );\n        }\n    #endif\n\n    // 2. Fade out start/end\n    float index = float(gl_VertexID) / uCount;\n    // float startEndOpacity = smoothstep(0.1, 0.2, index) * smoothstep(0.1, 0.2, 1.0 - index);\n    float startEndOpacity = 1.0;\n\n    // 3. Fade out on sides\n    vec4 clipSpace = projectionMatrix * mvPosition;\n    vec3 viewSpace = clipSpace.xyz / clipSpace.w;\n    float sideOpacity = smoothstep(0.2, 1.0, 1.0 - abs(viewSpace.x));\n\n    // 4. Progress opacity\n    float viewportPositionY = (position.y - Y_MIN) / (Y_MAX - Y_MIN);\n    float progressOpacity = 1.0;\n\n    if (uProgress <= 1.0) {\n        // uProgress: 0 -> 1\n        progressOpacity = smoothstep(1.0 - uProgress, 1.1 - uProgress, viewportPositionY);\n    } else {\n        progressOpacity = smoothstep(uProgress - 1.0, uProgress - 0.9, 1.0 - viewportPositionY);\n    }\n\n    // Add variation to the point size\n    float variation = (sin(index * 863.1274160392) + 1.0) * 0.5; // [0, 1]\n    gl_PointSize = (gl_PointSize + variation * gl_PointSize) * 0.5;\n\n    // Opacity depending on point size\n    float pointScale = gl_PointSize / size;\n    float pointSizeOpacity = clamp(pointScale * 10.0, 0.25, 1.0);\n\n    // 5. Time animation\n    float animatedOpacity = noise(vec2(index * 86.31274160392 + uTime / uSpeed, 1.0)) * 0.8 + 0.2;\n\n    vOpacity = opacity * sideOpacity * progressOpacity * startEndOpacity * pointSizeOpacity * animatedOpacity;\n\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n    #include <worldpos_vertex>\n    #include <fog_vertex>\n}\n"
}, function (t, e, n) {
    ! function () {
        "use strict";
        t.exports = {
            polyfill: function () {
                var t = window,
                    e = document;
                if (!("scrollBehavior" in e.documentElement.style) || !0 === t.__forceSmoothScrollPolyfill__) {
                    var n, i = t.HTMLElement || t.Element,
                        r = {
                            scroll: t.scroll || t.scrollTo,
                            scrollBy: t.scrollBy,
                            elementScroll: i.prototype.scroll || o,
                            scrollIntoView: i.prototype.scrollIntoView
                        },
                        s = t.performance && t.performance.now ? t.performance.now.bind(t.performance) : Date.now,
                        a = (n = t.navigator.userAgent, new RegExp(["MSIE ", "Trident/", "Edge/"].join("|")).test(n) ? 1 : 0);
                    t.scroll = t.scrollTo = function () {
                        void 0 !== arguments[0] && (!0 !== l(arguments[0]) ? f.call(t, e.body, void 0 !== arguments[0].left ? ~~arguments[0].left : t.scrollX || t.pageXOffset, void 0 !== arguments[0].top ? ~~arguments[0].top : t.scrollY || t.pageYOffset) : r.scroll.call(t, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : t.scrollX || t.pageXOffset, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : t.scrollY || t.pageYOffset))
                    }, t.scrollBy = function () {
                        void 0 !== arguments[0] && (l(arguments[0]) ? r.scrollBy.call(t, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : 0, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : 0) : f.call(t, e.body, ~~arguments[0].left + (t.scrollX || t.pageXOffset), ~~arguments[0].top + (t.scrollY || t.pageYOffset)))
                    }, i.prototype.scroll = i.prototype.scrollTo = function () {
                        if (void 0 !== arguments[0])
                            if (!0 !== l(arguments[0])) {
                                var t = arguments[0].left,
                                    e = arguments[0].top;
                                f.call(this, this, void 0 === t ? this.scrollLeft : ~~t, void 0 === e ? this.scrollTop : ~~e)
                            } else {
                                if ("number" == typeof arguments[0] && void 0 === arguments[1]) throw new SyntaxError("Value could not be converted");
                                r.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left : "object" != typeof arguments[0] ? ~~arguments[0] : this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top : void 0 !== arguments[1] ? ~~arguments[1] : this.scrollTop)
                            }
                    }, i.prototype.scrollBy = function () {
                        void 0 !== arguments[0] && (!0 !== l(arguments[0]) ? this.scroll({
                            left: ~~arguments[0].left + this.scrollLeft,
                            top: ~~arguments[0].top + this.scrollTop,
                            behavior: arguments[0].behavior
                        }) : r.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop))
                    }, i.prototype.scrollIntoView = function () {
                        if (!0 !== l(arguments[0])) {
                            var n = d(this),
                                i = n.getBoundingClientRect(),
                                s = this.getBoundingClientRect();
                            n !== e.body ? (f.call(this, n, n.scrollLeft + s.left - i.left, n.scrollTop + s.top - i.top), "fixed" !== t.getComputedStyle(n).position && t.scrollBy({
                                left: i.left,
                                top: i.top,
                                behavior: "smooth"
                            })) : t.scrollBy({
                                left: s.left,
                                top: s.top,
                                behavior: "smooth"
                            })
                        } else r.scrollIntoView.call(this, void 0 === arguments[0] || arguments[0])
                    }
                }

                function o(t, e) {
                    this.scrollLeft = t, this.scrollTop = e
                }

                function l(t) {
                    if (null === t || "object" != typeof t || void 0 === t.behavior || "auto" === t.behavior || "instant" === t.behavior) return !0;
                    if ("object" == typeof t && "smooth" === t.behavior) return !1;
                    throw new TypeError("behavior member of ScrollOptions " + t.behavior + " is not a valid value for enumeration ScrollBehavior.")
                }

                function c(t, e) {
                    return "Y" === e ? t.clientHeight + a < t.scrollHeight : "X" === e ? t.clientWidth + a < t.scrollWidth : void 0
                }

                function h(e, n) {
                    var i = t.getComputedStyle(e, null)["overflow" + n];
                    return "auto" === i || "scroll" === i
                }

                function u(t) {
                    var e = c(t, "Y") && h(t, "Y"),
                        n = c(t, "X") && h(t, "X");
                    return e || n
                }

                function d(t) {
                    for (; t !== e.body && !1 === u(t);) t = t.parentNode || t.host;
                    return t
                }

                function p(e) {
                    var n, i, r, a, o = (s() - e.startTime) / 468;
                    a = o = o > 1 ? 1 : o, n = .5 * (1 - Math.cos(Math.PI * a)), i = e.startX + (e.x - e.startX) * n, r = e.startY + (e.y - e.startY) * n, e.method.call(e.scrollable, i, r), i === e.x && r === e.y || t.requestAnimationFrame(p.bind(t, e))
                }

                function f(n, i, a) {
                    var l, c, h, u, d = s();
                    n === e.body ? (l = t, c = t.scrollX || t.pageXOffset, h = t.scrollY || t.pageYOffset, u = r.scroll) : (l = n, c = n.scrollLeft, h = n.scrollTop, u = o), p({
                        scrollable: l,
                        method: u,
                        startTime: d,
                        startX: c,
                        startY: h,
                        x: i,
                        y: a
                    })
                }
            }
        }
    }()
}, function (t, e, n) {
    "use strict";
    var i = n(376),
        r = n(377),
        s = n(378).Lethargy,
        a = n(379),
        o = (n(380), n(381)),
        l = "virtualscroll";
    t.exports = f;
    var c = 37,
        h = 38,
        u = 39,
        d = 40,
        p = 32;

    function f(t) {
        o(this, "_onWheel", "_onMouseWheel", "_onTouchStart", "_onTouchMove", "_onKeyDown"), this.el = window, t && t.el && (this.el = t.el, delete t.el), this.options = i({
            mouseMultiplier: 1,
            touchMultiplier: 2,
            firefoxMultiplier: 15,
            keyStep: 120,
            preventTouch: !1,
            unpreventTouchClass: "vs-touchmove-allowed",
            limitInertia: !1,
            useKeyboard: !0,
            useTouch: !0
        }, t), this.options.limitInertia && (this._lethargy = new s), this._emitter = new r, this._event = {
            y: 0,
            x: 0,
            deltaX: 0,
            deltaY: 0
        }, this.touchStartX = null, this.touchStartY = null, this.bodyTouchAction = null, void 0 !== this.options.passive && (this.listenerOptions = {
            passive: this.options.passive
        })
    }
    f.prototype._notify = function (t) {
        var e = this._event;
        e.x += e.deltaX, e.y += e.deltaY, this._emitter.emit(l, {
            x: e.x,
            y: e.y,
            deltaX: e.deltaX,
            deltaY: e.deltaY,
            originalEvent: t
        })
    }, f.prototype._onWheel = function (t) {
        var e = this.options;
        if (!this._lethargy || !1 !== this._lethargy.check(t)) {
            var n = this._event;
            n.deltaX = t.wheelDeltaX || -1 * t.deltaX, n.deltaY = t.wheelDeltaY || -1 * t.deltaY, a.isFirefox && 1 == t.deltaMode && (n.deltaX *= e.firefoxMultiplier, n.deltaY *= e.firefoxMultiplier), n.deltaX *= e.mouseMultiplier, n.deltaY *= e.mouseMultiplier, this._notify(t)
        }
    }, f.prototype._onMouseWheel = function (t) {
        if (!this.options.limitInertia || !1 !== this._lethargy.check(t)) {
            var e = this._event;
            e.deltaX = t.wheelDeltaX ? t.wheelDeltaX : 0, e.deltaY = t.wheelDeltaY ? t.wheelDeltaY : t.wheelDelta, this._notify(t)
        }
    }, f.prototype._onTouchStart = function (t) {
        var e = t.targetTouches ? t.targetTouches[0] : t;
        this.touchStartX = e.pageX, this.touchStartY = e.pageY
    }, f.prototype._onTouchMove = function (t) {
        var e = this.options;
        e.preventTouch && !t.target.classList.contains(e.unpreventTouchClass) && t.preventDefault();
        var n = this._event,
            i = t.targetTouches ? t.targetTouches[0] : t;
        n.deltaX = (i.pageX - this.touchStartX) * e.touchMultiplier, n.deltaY = (i.pageY - this.touchStartY) * e.touchMultiplier, this.touchStartX = i.pageX, this.touchStartY = i.pageY, this._notify(t)
    }, f.prototype._onKeyDown = function (t) {
        var e = this._event;
        e.deltaX = e.deltaY = 0;
        var n = window.innerHeight - 40;
        switch (t.keyCode) {
            case c:
            case h:
                e.deltaY = this.options.keyStep;
                break;
            case u:
            case d:
                e.deltaY = -this.options.keyStep;
                break;
            case p && t.shiftKey:
                e.deltaY = n;
                break;
            case p:
                e.deltaY = -n;
                break;
            default:
                return
        }
        this._notify(t)
    }, f.prototype._bind = function () {
        a.hasWheelEvent && this.el.addEventListener("wheel", this._onWheel, this.listenerOptions), a.hasMouseWheelEvent && this.el.addEventListener("mousewheel", this._onMouseWheel, this.listenerOptions), a.hasTouch && this.options.useTouch && (this.el.addEventListener("touchstart", this._onTouchStart, this.listenerOptions), this.el.addEventListener("touchmove", this._onTouchMove, this.listenerOptions)), a.hasPointer && a.hasTouchWin && (this.bodyTouchAction = document.body.style.msTouchAction, document.body.style.msTouchAction = "none", this.el.addEventListener("MSPointerDown", this._onTouchStart, !0), this.el.addEventListener("MSPointerMove", this._onTouchMove, !0)), a.hasKeyDown && this.options.useKeyboard && document.addEventListener("keydown", this._onKeyDown)
    }, f.prototype._unbind = function () {
        a.hasWheelEvent && this.el.removeEventListener("wheel", this._onWheel), a.hasMouseWheelEvent && this.el.removeEventListener("mousewheel", this._onMouseWheel), a.hasTouch && (this.el.removeEventListener("touchstart", this._onTouchStart), this.el.removeEventListener("touchmove", this._onTouchMove)), a.hasPointer && a.hasTouchWin && (document.body.style.msTouchAction = this.bodyTouchAction, this.el.removeEventListener("MSPointerDown", this._onTouchStart, !0), this.el.removeEventListener("MSPointerMove", this._onTouchMove, !0)), a.hasKeyDown && this.options.useKeyboard && document.removeEventListener("keydown", this._onKeyDown)
    }, f.prototype.on = function (t, e) {
        this._emitter.on(l, t, e);
        var n = this._emitter.e;
        n && n[l] && 1 === n[l].length && this._bind()
    }, f.prototype.off = function (t, e) {
        this._emitter.off(l, t, e);
        var n = this._emitter.e;
        (!n[l] || n[l].length <= 0) && this._unbind()
    }, f.prototype.reset = function () {
        var t = this._event;
        t.x = 0, t.y = 0
    }, f.prototype.destroy = function () {
        this._emitter.off(), this._unbind()
    }
}, function (t, e) {
    var n = "function" == typeof Float32Array;

    function i(t, e) {
        return 1 - 3 * e + 3 * t
    }

    function r(t, e) {
        return 3 * e - 6 * t
    }

    function s(t) {
        return 3 * t
    }

    function a(t, e, n) {
        return ((i(e, n) * t + r(e, n)) * t + s(e)) * t
    }

    function o(t, e, n) {
        return 3 * i(e, n) * t * t + 2 * r(e, n) * t + s(e)
    }

    function l(t) {
        return t
    }
    t.exports = function (t, e, i, r) {
        if (!(0 <= t && t <= 1 && 0 <= i && i <= 1)) throw new Error("bezier x values must be in [0, 1] range");
        if (t === e && i === r) return l;
        for (var s = n ? new Float32Array(11) : new Array(11), c = 0; c < 11; ++c) s[c] = a(.1 * c, t, i);

        function h(e) {
            for (var n = 0, r = 1; 10 !== r && s[r] <= e; ++r) n += .1;
            --r;
            var l = n + .1 * ((e - s[r]) / (s[r + 1] - s[r])),
                c = o(l, t, i);
            return c >= .001 ? function (t, e, n, i) {
                for (var r = 0; r < 4; ++r) {
                    var s = o(e, n, i);
                    if (0 === s) return e;
                    e -= (a(e, n, i) - t) / s
                }
                return e
            }(e, l, t, i) : 0 === c ? l : function (t, e, n, i, r) {
                var s, o, l = 0;
                do {
                    (s = a(o = e + (n - e) / 2, i, r) - t) > 0 ? n = o : e = o
                } while (Math.abs(s) > 1e-7 && ++l < 10);
                return o
            }(e, n, n + .1, t, i)
        }
        return function (t) {
            return 0 === t ? 0 : 1 === t ? 1 : a(h(t), e, r)
        }
    }
}, function (t, e, n) {
    var i = n(390),
        r = n(391),
        s = n(230),
        a = n(392),
        o = n(393),
        l = n(229),
        c = n(95),
        h = n(57),
        u = n(231),
        d = n(394),
        p = n(165),
        f = /\b__p \+= '';/g,
        m = /\b(__p \+=) '' \+/g,
        g = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
        v = /[()=,{}\[\]\/\s]/,
        y = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
        b = /($^)/,
        x = /['\n\r\u2028\u2029\\]/g,
        _ = Object.prototype.hasOwnProperty;
    t.exports = function (t, e, n) {
        var w = d.imports._.templateSettings || d;
        n && c(t, e, n) && (e = void 0), t = p(t), e = i({}, e, w, a);
        var S, M, E = i({}, e.imports, w.imports, a),
            T = h(E),
            C = s(E, T),
            A = 0,
            R = e.interpolate || b,
            P = "__p += '",
            L = RegExp((e.escape || b).source + "|" + R.source + "|" + (R === u ? y : b).source + "|" + (e.evaluate || b).source + "|$", "g"),
            O = _.call(e, "sourceURL") ? "//# sourceURL=" + (e.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
        t.replace(L, (function (e, n, i, r, s, a) {
            return i || (i = r), P += t.slice(A, a).replace(x, o), n && (S = !0, P += "' +\n__e(" + n + ") +\n'"), s && (M = !0, P += "';\n" + s + ";\n__p += '"), i && (P += "' +\n((__t = (" + i + ")) == null ? '' : __t) +\n'"), A = a + e.length, e
        })), P += "';\n";
        var D = _.call(e, "variable") && e.variable;
        if (D) {
            if (v.test(D)) throw new Error("Invalid `variable` option passed into `_.template`")
        } else P = "with (obj) {\n" + P + "\n}\n";
        P = (M ? P.replace(f, "") : P).replace(m, "$1").replace(g, "$1;"), P = "function(" + (D || "obj") + ") {\n" + (D ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (S ? ", __e = _.escape" : "") + (M ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + P + "return __p\n}";
        var I = r((function () {
            return Function(T, O + "return " + P).apply(void 0, C)
        }));
        if (I.source = P, l(I)) throw I;
        return I
    }
}, , , , , , , , , function (t, e, n) {
    var i = n(425),
        r = n(427),
        s = n(26);
    t.exports = function (t) {
        return (s(t) ? i : r)(t)
    }
}, , , , , , , , , , , function (t, e, n) {
    "serviceWorker" in navigator && window.addEventListener("load", () => {
        navigator.serviceWorker.register("assets/javascripts/sw.js")
    })
}, function (t, e, n) {
    var i = n(56),
        r = n(66),
        s = n(57);
    t.exports = function (t) {
        return function (e, n, a) {
            var o = Object(e);
            if (!r(e)) {
                var l = i(n, 3);
                e = s(e), n = function (t) {
                    return l(o[t], t, o)
                }
            }
            var c = t(e, n, a);
            return c > -1 ? o[l ? e[c] : c] : void 0
        }
    }
}, function (t, e, n) {
    var i = n(198),
        r = n(211),
        s = n(213);
    t.exports = function (t) {
        var e = r(t);
        return 1 == e.length && e[0][2] ? s(e[0][0], e[0][1]) : function (n) {
            return n === t || i(n, t, e)
        }
    }
}, function (t, e) {
    t.exports = function () {
        this.__data__ = [], this.size = 0
    }
}, function (t, e, n) {
    var i = n(110),
        r = Array.prototype.splice;
    t.exports = function (t) {
        var e = this.__data__,
            n = i(e, t);
        return !(n < 0) && (n == e.length - 1 ? e.pop() : r.call(e, n, 1), --this.size, !0)
    }
}, function (t, e, n) {
    var i = n(110);
    t.exports = function (t) {
        var e = this.__data__,
            n = i(e, t);
        return n < 0 ? void 0 : e[n][1]
    }
}, function (t, e, n) {
    var i = n(110);
    t.exports = function (t) {
        return i(this.__data__, t) > -1
    }
}, function (t, e, n) {
    var i = n(110);
    t.exports = function (t, e) {
        var n = this.__data__,
            r = i(n, t);
        return r < 0 ? (++this.size, n.push([t, e])) : n[r][1] = e, this
    }
}, function (t, e, n) {
    var i = n(109);
    t.exports = function () {
        this.__data__ = new i, this.size = 0
    }
}, function (t, e) {
    t.exports = function (t) {
        var e = this.__data__,
            n = e.delete(t);
        return this.size = e.size, n
    }
}, function (t, e) {
    t.exports = function (t) {
        return this.__data__.get(t)
    }
}, function (t, e) {
    t.exports = function (t) {
        return this.__data__.has(t)
    }
}, function (t, e, n) {
    var i = n(109),
        r = n(154),
        s = n(155);
    t.exports = function (t, e) {
        var n = this.__data__;
        if (n instanceof i) {
            var a = n.__data__;
            if (!r || a.length < 199) return a.push([t, e]), this.size = ++n.size, this;
            n = this.__data__ = new s(a)
        }
        return n.set(t, e), this.size = n.size, this
    }
}, function (t, e, n) {
    var i = n(111),
        r = n(278),
        s = n(27),
        a = n(200),
        o = /^\[object .+?Constructor\]$/,
        l = Function.prototype,
        c = Object.prototype,
        h = l.toString,
        u = c.hasOwnProperty,
        d = RegExp("^" + h.call(u).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    t.exports = function (t) {
        return !(!s(t) || r(t)) && (i(t) ? d : o).test(a(t))
    }
}, function (t, e, n) {
    var i = n(83),
        r = Object.prototype,
        s = r.hasOwnProperty,
        a = r.toString,
        o = i ? i.toStringTag : void 0;
    t.exports = function (t) {
        var e = s.call(t, o),
            n = t[o];
        try {
            t[o] = void 0;
            var i = !0
        } catch (t) { }
        var r = a.call(t);
        return i && (e ? t[o] = n : delete t[o]), r
    }
}, function (t, e) {
    var n = Object.prototype.toString;
    t.exports = function (t) {
        return n.call(t)
    }
}, function (t, e, n) {
    var i, r = n(279),
        s = (i = /[^.]+$/.exec(r && r.keys && r.keys.IE_PROTO || "")) ? "Symbol(src)_1." + i : "";
    t.exports = function (t) {
        return !!s && s in t
    }
}, function (t, e, n) {
    var i = n(45)["__core-js_shared__"];
    t.exports = i
}, function (t, e) {
    t.exports = function (t, e) {
        return null == t ? void 0 : t[e]
    }
}, function (t, e, n) {
    var i = n(282),
        r = n(109),
        s = n(154);
    t.exports = function () {
        this.size = 0, this.__data__ = {
            hash: new i,
            map: new (s || r),
            string: new i
        }
    }
}, function (t, e, n) {
    var i = n(283),
        r = n(284),
        s = n(285),
        a = n(286),
        o = n(287);

    function l(t) {
        var e = -1,
            n = null == t ? 0 : t.length;
        for (this.clear(); ++e < n;) {
            var i = t[e];
            this.set(i[0], i[1])
        }
    }
    l.prototype.clear = i, l.prototype.delete = r, l.prototype.get = s, l.prototype.has = a, l.prototype.set = o, t.exports = l
}, function (t, e, n) {
    var i = n(113);
    t.exports = function () {
        this.__data__ = i ? i(null) : {}, this.size = 0
    }
}, function (t, e) {
    t.exports = function (t) {
        var e = this.has(t) && delete this.__data__[t];
        return this.size -= e ? 1 : 0, e
    }
}, function (t, e, n) {
    var i = n(113),
        r = Object.prototype.hasOwnProperty;
    t.exports = function (t) {
        var e = this.__data__;
        if (i) {
            var n = e[t];
            return "__lodash_hash_undefined__" === n ? void 0 : n
        }
        return r.call(e, t) ? e[t] : void 0
    }
}, function (t, e, n) {
    var i = n(113),
        r = Object.prototype.hasOwnProperty;
    t.exports = function (t) {
        var e = this.__data__;
        return i ? void 0 !== e[t] : r.call(e, t)
    }
}, function (t, e, n) {
    var i = n(113);
    t.exports = function (t, e) {
        var n = this.__data__;
        return this.size += this.has(t) ? 0 : 1, n[t] = i && void 0 === e ? "__lodash_hash_undefined__" : e, this
    }
}, function (t, e, n) {
    var i = n(114);
    t.exports = function (t) {
        var e = i(this, t).delete(t);
        return this.size -= e ? 1 : 0, e
    }
}, function (t, e) {
    t.exports = function (t) {
        var e = typeof t;
        return "string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== t : null === t
    }
}, function (t, e, n) {
    var i = n(114);
    t.exports = function (t) {
        return i(this, t).get(t)
    }
}, function (t, e, n) {
    var i = n(114);
    t.exports = function (t) {
        return i(this, t).has(t)
    }
}, function (t, e, n) {
    var i = n(114);
    t.exports = function (t, e) {
        var n = i(this, t),
            r = n.size;
        return n.set(t, e), this.size += n.size == r ? 0 : 1, this
    }
}, function (t, e, n) {
    var i = n(90),
        r = n(201),
        s = n(296),
        a = n(298),
        o = n(120),
        l = n(26),
        c = n(92),
        h = n(118),
        u = "[object Object]",
        d = Object.prototype.hasOwnProperty;
    t.exports = function (t, e, n, p, f, m) {
        var g = l(t),
            v = l(e),
            y = g ? "[object Array]" : o(t),
            b = v ? "[object Array]" : o(e),
            x = (y = "[object Arguments]" == y ? u : y) == u,
            _ = (b = "[object Arguments]" == b ? u : b) == u,
            w = y == b;
        if (w && c(t)) {
            if (!c(e)) return !1;
            g = !0, x = !1
        }
        if (w && !x) return m || (m = new i), g || h(t) ? r(t, e, n, p, f, m) : s(t, e, y, n, p, f, m);
        if (!(1 & n)) {
            var S = x && d.call(t, "__wrapped__"),
                M = _ && d.call(e, "__wrapped__");
            if (S || M) {
                var E = S ? t.value() : t,
                    T = M ? e.value() : e;
                return m || (m = new i), f(E, T, n, p, m)
            }
        }
        return !!w && (m || (m = new i), a(t, e, n, p, f, m))
    }
}, function (t, e) {
    t.exports = function (t) {
        return this.__data__.set(t, "__lodash_hash_undefined__"), this
    }
}, function (t, e) {
    t.exports = function (t) {
        return this.__data__.has(t)
    }
}, function (t, e, n) {
    var i = n(83),
        r = n(203),
        s = n(71),
        a = n(201),
        o = n(297),
        l = n(157),
        c = i ? i.prototype : void 0,
        h = c ? c.valueOf : void 0;
    t.exports = function (t, e, n, i, c, u, d) {
        switch (n) {
            case "[object DataView]":
                if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return !1;
                t = t.buffer, e = e.buffer;
            case "[object ArrayBuffer]":
                return !(t.byteLength != e.byteLength || !u(new r(t), new r(e)));
            case "[object Boolean]":
            case "[object Date]":
            case "[object Number]":
                return s(+t, +e);
            case "[object Error]":
                return t.name == e.name && t.message == e.message;
            case "[object RegExp]":
            case "[object String]":
                return t == e + "";
            case "[object Map]":
                var p = o;
            case "[object Set]":
                var f = 1 & i;
                if (p || (p = l), t.size != e.size && !f) return !1;
                var m = d.get(t);
                if (m) return m == e;
                i |= 2, d.set(t, e);
                var g = a(p(t), p(e), i, c, u, d);
                return d.delete(t), g;
            case "[object Symbol]":
                if (h) return h.call(t) == h.call(e)
        }
        return !1
    }
}, function (t, e) {
    t.exports = function (t) {
        var e = -1,
            n = Array(t.size);
        return t.forEach((function (t, i) {
            n[++e] = [i, t]
        })), n
    }
}, function (t, e, n) {
    var i = n(204),
        r = Object.prototype.hasOwnProperty;
    t.exports = function (t, e, n, s, a, o) {
        var l = 1 & n,
            c = i(t),
            h = c.length;
        if (h != i(e).length && !l) return !1;
        for (var u = h; u--;) {
            var d = c[u];
            if (!(l ? d in e : r.call(e, d))) return !1
        }
        var p = o.get(t),
            f = o.get(e);
        if (p && f) return p == e && f == t;
        var m = !0;
        o.set(t, e), o.set(e, t);
        for (var g = l; ++u < h;) {
            var v = t[d = c[u]],
                y = e[d];
            if (s) var b = l ? s(y, v, d, e, t, o) : s(v, y, d, t, e, o);
            if (!(void 0 === b ? v === y || a(v, y, n, s, o) : b)) {
                m = !1;
                break
            }
            g || (g = "constructor" == d)
        }
        if (m && !g) {
            var x = t.constructor,
                _ = e.constructor;
            x == _ || !("constructor" in t) || !("constructor" in e) || "function" == typeof x && x instanceof x && "function" == typeof _ && _ instanceof _ || (m = !1)
        }
        return o.delete(t), o.delete(e), m
    }
}, function (t, e) {
    t.exports = function (t, e) {
        for (var n = -1, i = Array(t); ++n < t;) i[n] = e(n);
        return i
    }
}, function (t, e, n) {
    var i = n(73),
        r = n(51);
    t.exports = function (t) {
        return r(t) && "[object Arguments]" == i(t)
    }
}, function (t, e) {
    t.exports = function () {
        return !1
    }
}, function (t, e, n) {
    var i = n(73),
        r = n(161),
        s = n(51),
        a = {};
    a["[object Float32Array]"] = a["[object Float64Array]"] = a["[object Int8Array]"] = a["[object Int16Array]"] = a["[object Int32Array]"] = a["[object Uint8Array]"] = a["[object Uint8ClampedArray]"] = a["[object Uint16Array]"] = a["[object Uint32Array]"] = !0, a["[object Arguments]"] = a["[object Array]"] = a["[object ArrayBuffer]"] = a["[object Boolean]"] = a["[object DataView]"] = a["[object Date]"] = a["[object Error]"] = a["[object Function]"] = a["[object Map]"] = a["[object Number]"] = a["[object Object]"] = a["[object RegExp]"] = a["[object Set]"] = a["[object String]"] = a["[object WeakMap]"] = !1, t.exports = function (t) {
        return s(t) && r(t.length) && !!a[i(t)]
    }
}, function (t, e, n) {
    var i = n(119),
        r = n(304),
        s = Object.prototype.hasOwnProperty;
    t.exports = function (t) {
        if (!i(t)) return r(t);
        var e = [];
        for (var n in Object(t)) s.call(t, n) && "constructor" != n && e.push(n);
        return e
    }
}, function (t, e, n) {
    var i = n(209)(Object.keys, Object);
    t.exports = i
}, function (t, e, n) {
    var i = n(72)(n(45), "DataView");
    t.exports = i
}, function (t, e, n) {
    var i = n(72)(n(45), "Promise");
    t.exports = i
}, function (t, e, n) {
    var i = n(72)(n(45), "WeakMap");
    t.exports = i
}, function (t, e, n) {
    var i = n(156),
        r = n(309),
        s = n(314),
        a = n(164),
        o = n(212),
        l = n(213),
        c = n(94);
    t.exports = function (t, e) {
        return a(t) && o(e) ? l(c(t), e) : function (n) {
            var a = r(n, t);
            return void 0 === a && a === e ? s(n, t) : i(e, a, 3)
        }
    }
}, function (t, e, n) {
    var i = n(163);
    t.exports = function (t, e, n) {
        var r = null == t ? void 0 : i(t, e);
        return void 0 === r ? n : r
    }
}, function (t, e, n) {
    var i = n(311),
        r = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
        s = /\\(\\)?/g,
        a = i((function (t) {
            var e = [];
            return 46 === t.charCodeAt(0) && e.push(""), t.replace(r, (function (t, n, i, r) {
                e.push(i ? r.replace(s, "$1") : n || t)
            })), e
        }));
    t.exports = a
}, function (t, e, n) {
    var i = n(312);
    t.exports = function (t) {
        var e = i(t, (function (t) {
            return 500 === n.size && n.clear(), t
        })),
            n = e.cache;
        return e
    }
}, function (t, e, n) {
    var i = n(155);

    function r(t, e) {
        if ("function" != typeof t || null != e && "function" != typeof e) throw new TypeError("Expected a function");
        var n = function () {
            var i = arguments,
                r = e ? e.apply(this, i) : i[0],
                s = n.cache;
            if (s.has(r)) return s.get(r);
            var a = t.apply(this, i);
            return n.cache = s.set(r, a) || s, a
        };
        return n.cache = new (r.Cache || i), n
    }
    r.Cache = i, t.exports = r
}, function (t, e, n) {
    var i = n(83),
        r = n(74),
        s = n(26),
        a = n(122),
        o = i ? i.prototype : void 0,
        l = o ? o.toString : void 0;
    t.exports = function t(e) {
        if ("string" == typeof e) return e;
        if (s(e)) return r(e, t) + "";
        if (a(e)) return l ? l.call(e) : "";
        var n = e + "";
        return "0" == n && 1 / e == -1 / 0 ? "-0" : n
    }
}, function (t, e, n) {
    var i = n(315),
        r = n(316);
    t.exports = function (t, e) {
        return null != t && r(t, e, i)
    }
}, function (t, e) {
    t.exports = function (t, e) {
        return null != t && e in Object(t)
    }
}, function (t, e, n) {
    var i = n(121),
        r = n(91),
        s = n(26),
        a = n(160),
        o = n(161),
        l = n(94);
    t.exports = function (t, e, n) {
        for (var c = -1, h = (e = i(e, t)).length, u = !1; ++c < h;) {
            var d = l(e[c]);
            if (!(u = null != t && n(t, d))) break;
            t = t[d]
        }
        return u || ++c != h ? u : !!(h = null == t ? 0 : t.length) && o(h) && a(d, h) && (s(t) || r(t))
    }
}, function (t, e, n) {
    var i = n(318),
        r = n(319),
        s = n(164),
        a = n(94);
    t.exports = function (t) {
        return s(t) ? i(a(t)) : r(t)
    }
}, function (t, e) {
    t.exports = function (t) {
        return function (e) {
            return null == e ? void 0 : e[t]
        }
    }
}, function (t, e, n) {
    var i = n(163);
    t.exports = function (t) {
        return function (e) {
            return i(e, t)
        }
    }
}, function (t, e, n) {
    var i = n(214),
        r = n(56),
        s = n(321),
        a = Math.max;
    t.exports = function (t, e, n) {
        var o = null == t ? 0 : t.length;
        if (!o) return -1;
        var l = null == n ? 0 : s(n);
        return l < 0 && (l = a(o + l, 0)), i(t, r(e, 3), l)
    }
}, function (t, e, n) {
    var i = n(322);
    t.exports = function (t) {
        var e = i(t),
            n = e % 1;
        return e == e ? n ? e - n : e : 0
    }
}, function (t, e, n) {
    var i = n(215);
    t.exports = function (t) {
        return t ? (t = i(t)) === 1 / 0 || t === -1 / 0 ? 17976931348623157e292 * (t < 0 ? -1 : 1) : t == t ? t : 0 : 0 === t ? t : 0
    }
}, function (t, e, n) {
    var i = n(324),
        r = /^\s+/;
    t.exports = function (t) {
        return t ? t.slice(0, i(t) + 1).replace(r, "") : t
    }
}, function (t, e) {
    var n = /\s/;
    t.exports = function (t) {
        for (var e = t.length; e-- && n.test(t.charAt(e)););
        return e
    }
}, function (t, e, n) {
    var i = n(115),
        r = n(166),
        s = n(167),
        a = n(74),
        o = n(93),
        l = n(116),
        c = Math.min;
    t.exports = function (t, e, n) {
        for (var h = n ? s : r, u = t[0].length, d = t.length, p = d, f = Array(d), m = 1 / 0, g = []; p--;) {
            var v = t[p];
            p && e && (v = a(v, o(e))), m = c(v.length, m), f[p] = !n && (e || u >= 120 && v.length >= 120) ? new i(p && v) : void 0
        }
        v = t[0];
        var y = -1,
            b = f[0];
        t: for (; ++y < u && g.length < m;) {
            var x = v[y],
                _ = e ? e(x) : x;
            if (x = n || 0 !== x ? x : 0, !(b ? l(b, _) : h(g, _, n))) {
                for (p = d; --p;) {
                    var w = f[p];
                    if (!(w ? l(w, _) : h(t[p], _, n))) continue t
                }
                b && b.push(_), g.push(x)
            }
        }
        return g
    }
}, function (t, e, n) {
    var i = n(214),
        r = n(327),
        s = n(328);
    t.exports = function (t, e, n) {
        return e == e ? s(t, e, n) : i(t, r, n)
    }
}, function (t, e) {
    t.exports = function (t) {
        return t != t
    }
}, function (t, e) {
    t.exports = function (t, e, n) {
        for (var i = n - 1, r = t.length; ++i < r;)
            if (t[i] === e) return i;
        return -1
    }
}, function (t, e, n) {
    var i = n(330),
        r = n(219),
        s = n(123),
        a = r ? function (t, e) {
            return r(t, "toString", {
                configurable: !0,
                enumerable: !1,
                value: i(e),
                writable: !0
            })
        } : s;
    t.exports = a
}, function (t, e) {
    t.exports = function (t) {
        return function () {
            return t
        }
    }
}, function (t, e) {
    var n = Date.now;
    t.exports = function (t) {
        var e = 0,
            i = 0;
        return function () {
            var r = n(),
                s = 16 - (r - i);
            if (i = r, s > 0) {
                if (++e >= 800) return arguments[0]
            } else e = 0;
            return t.apply(void 0, arguments)
        }
    }
}, function (t, e, n) {
    var i = n(125);
    t.exports = function (t) {
        return i(t) ? t : []
    }
}, function (t, e, n) {
    ! function () {
        "use strict";

        function t(t) {
            var e = !0,
                n = !1,
                i = null,
                r = {
                    text: !0,
                    search: !0,
                    url: !0,
                    tel: !0,
                    email: !0,
                    password: !0,
                    number: !0,
                    date: !0,
                    month: !0,
                    week: !0,
                    time: !0,
                    datetime: !0,
                    "datetime-local": !0
                };

            function s(t) {
                return !!(t && t !== document && "HTML" !== t.nodeName && "BODY" !== t.nodeName && "classList" in t && "contains" in t.classList)
            }

            function a(t) {
                t.classList.contains("focus-visible") || (t.classList.add("focus-visible"), t.setAttribute("data-focus-visible-added", ""))
            }

            function o(t) {
                e = !1
            }

            function l() {
                document.addEventListener("mousemove", c), document.addEventListener("mousedown", c), document.addEventListener("mouseup", c), document.addEventListener("pointermove", c), document.addEventListener("pointerdown", c), document.addEventListener("pointerup", c), document.addEventListener("touchmove", c), document.addEventListener("touchstart", c), document.addEventListener("touchend", c)
            }

            function c(t) {
                t.target.nodeName && "html" === t.target.nodeName.toLowerCase() || (e = !1, document.removeEventListener("mousemove", c), document.removeEventListener("mousedown", c), document.removeEventListener("mouseup", c), document.removeEventListener("pointermove", c), document.removeEventListener("pointerdown", c), document.removeEventListener("pointerup", c), document.removeEventListener("touchmove", c), document.removeEventListener("touchstart", c), document.removeEventListener("touchend", c))
            }
            document.addEventListener("keydown", (function (n) {
                n.metaKey || n.altKey || n.ctrlKey || (s(t.activeElement) && a(t.activeElement), e = !0)
            }), !0), document.addEventListener("mousedown", o, !0), document.addEventListener("pointerdown", o, !0), document.addEventListener("touchstart", o, !0), document.addEventListener("visibilitychange", (function (t) {
                "hidden" === document.visibilityState && (n && (e = !0), l())
            }), !0), l(), t.addEventListener("focus", (function (t) {
                var n, i, o;
                s(t.target) && (e || (n = t.target, i = n.type, "INPUT" === (o = n.tagName) && r[i] && !n.readOnly || "TEXTAREA" === o && !n.readOnly || n.isContentEditable)) && a(t.target)
            }), !0), t.addEventListener("blur", (function (t) {
                var e;
                s(t.target) && (t.target.classList.contains("focus-visible") || t.target.hasAttribute("data-focus-visible-added")) && (n = !0, window.clearTimeout(i), i = window.setTimeout((function () {
                    n = !1
                }), 100), (e = t.target).hasAttribute("data-focus-visible-added") && (e.classList.remove("focus-visible"), e.removeAttribute("data-focus-visible-added")))
            }), !0), t.nodeType === Node.DOCUMENT_FRAGMENT_NODE && t.host ? t.host.setAttribute("data-js-focus-visible", "") : t.nodeType === Node.DOCUMENT_NODE && (document.documentElement.classList.add("js-focus-visible"), document.documentElement.setAttribute("data-js-focus-visible", ""))
        }
        if ("undefined" != typeof window && "undefined" != typeof document) {
            var e;
            window.applyFocusVisiblePolyfill = t;
            try {
                e = new CustomEvent("focus-visible-polyfill-ready")
            } catch (t) {
                (e = document.createEvent("CustomEvent")).initCustomEvent("focus-visible-polyfill-ready", !1, !1, {})
            }
            window.dispatchEvent(e)
        }
        "undefined" != typeof document && t(document)
    }()
}, function (t, e, n) {
    var i = n(75),
        r = n(66);
    t.exports = function (t, e) {
        var n = -1,
            s = r(t) ? Array(t.length) : [];
        return i(t, (function (t, i, r) {
            s[++n] = e(t, i, r)
        })), s
    }
}, function (t, e, n) {
    var i = n(168),
        r = n(57);
    t.exports = function (t, e) {
        return t && i(t, e, r)
    }
}, function (t, e) {
    t.exports = function (t) {
        return function (e, n, i) {
            for (var r = -1, s = Object(e), a = i(e), o = a.length; o--;) {
                var l = a[t ? o : ++r];
                if (!1 === n(s[l], l, s)) break
            }
            return e
        }
    }
}, function (t, e, n) {
    var i = n(66);
    t.exports = function (t, e) {
        return function (n, r) {
            if (null == n) return n;
            if (!i(n)) return t(n, r);
            for (var s = n.length, a = e ? s : -1, o = Object(n);
                (e ? a-- : ++a < s) && !1 !== r(o[a], a, o););
            return n
        }
    }
}, function (t, e, n) {
    var i = n(75);
    t.exports = function (t, e) {
        var n = [];
        return i(t, (function (t, i, r) {
            e(t, i, r) && n.push(t)
        })), n
    }
}, function (t, e, n) {
    var i = n(221),
        r = n(75),
        s = n(340),
        a = n(26);
    t.exports = function (t, e) {
        return (a(t) ? i : r)(t, s(e))
    }
}, function (t, e, n) {
    var i = n(123);
    t.exports = function (t) {
        return "function" == typeof t ? t : i
    }
}, function (t, e, n) {
    var i = n(83),
        r = n(91),
        s = n(26),
        a = i ? i.isConcatSpreadable : void 0;
    t.exports = function (t) {
        return s(t) || r(t) || !!(a && t && t[a])
    }
}, function (t, e, n) {
    var i = n(45);
    t.exports = function () {
        return i.Date.now()
    }
}, function (t, e, n) {
    var i = n(115),
        r = n(166),
        s = n(167),
        a = n(116),
        o = n(344),
        l = n(157);
    t.exports = function (t, e, n) {
        var c = -1,
            h = r,
            u = t.length,
            d = !0,
            p = [],
            f = p;
        if (n) d = !1, h = s;
        else if (u >= 200) {
            var m = e ? null : o(t);
            if (m) return l(m);
            d = !1, h = a, f = new i
        } else f = e ? [] : p;
        t: for (; ++c < u;) {
            var g = t[c],
                v = e ? e(g) : g;
            if (g = n || 0 !== g ? g : 0, d && v == v) {
                for (var y = f.length; y--;)
                    if (f[y] === v) continue t;
                e && f.push(v), p.push(g)
            } else h(f, v, n) || (f !== p && f.push(v), p.push(g))
        }
        return p
    }
}, function (t, e, n) {
    var i = n(210),
        r = n(345),
        s = n(157),
        a = i && 1 / s(new i([, -0]))[1] == 1 / 0 ? function (t) {
            return new i(t)
        } : r;
    t.exports = a
}, function (t, e) {
    t.exports = function () { }
}, function (t, e, n) {
    var i = n(75);
    t.exports = function (t, e) {
        var n;
        return i(t, (function (t, i, r) {
            return !(n = e(t, i, r))
        })), !!n
    }
}, function (t, e, n) {
    var i = n(90),
        r = n(221),
        s = n(169),
        a = n(348),
        o = n(349),
        l = n(170),
        c = n(129),
        h = n(352),
        u = n(353),
        d = n(204),
        p = n(226),
        f = n(120),
        m = n(354),
        g = n(355),
        v = n(174),
        y = n(26),
        b = n(92),
        x = n(360),
        _ = n(27),
        w = n(362),
        S = n(57),
        M = n(67),
        E = {};
    E["[object Arguments]"] = E["[object Array]"] = E["[object ArrayBuffer]"] = E["[object DataView]"] = E["[object Boolean]"] = E["[object Date]"] = E["[object Float32Array]"] = E["[object Float64Array]"] = E["[object Int8Array]"] = E["[object Int16Array]"] = E["[object Int32Array]"] = E["[object Map]"] = E["[object Number]"] = E["[object Object]"] = E["[object RegExp]"] = E["[object Set]"] = E["[object String]"] = E["[object Symbol]"] = E["[object Uint8Array]"] = E["[object Uint8ClampedArray]"] = E["[object Uint16Array]"] = E["[object Uint32Array]"] = !0, E["[object Error]"] = E["[object Function]"] = E["[object WeakMap]"] = !1, t.exports = function t(e, n, T, C, A, R) {
        var P, L = 1 & n,
            O = 2 & n,
            D = 4 & n;
        if (T && (P = A ? T(e, C, A, R) : T(e)), void 0 !== P) return P;
        if (!_(e)) return e;
        var I = y(e);
        if (I) {
            if (P = m(e), !L) return c(e, P)
        } else {
            var k = f(e),
                N = "[object Function]" == k || "[object GeneratorFunction]" == k;
            if (b(e)) return l(e, L);
            if ("[object Object]" == k || "[object Arguments]" == k || N && !A) {
                if (P = O || N ? {} : v(e), !L) return O ? u(e, o(P, e)) : h(e, a(P, e))
            } else {
                if (!E[k]) return A ? e : {};
                P = g(e, k, L)
            }
        }
        R || (R = new i);
        var U = R.get(e);
        if (U) return U;
        R.set(e, P), w(e) ? e.forEach((function (i) {
            P.add(t(i, n, T, i, e, R))
        })) : x(e) && e.forEach((function (i, r) {
            P.set(r, t(i, n, T, r, e, R))
        }));
        var z = I ? void 0 : (D ? O ? p : d : O ? M : S)(e);
        return r(z || e, (function (i, r) {
            z && (i = e[r = i]), s(P, r, t(i, n, T, r, e, R))
        })), P
    }
}, function (t, e, n) {
    var i = n(58),
        r = n(57);
    t.exports = function (t, e) {
        return t && i(e, r(e), t)
    }
}, function (t, e, n) {
    var i = n(58),
        r = n(67);
    t.exports = function (t, e) {
        return t && i(e, r(e), t)
    }
}, function (t, e, n) {
    var i = n(27),
        r = n(119),
        s = n(351),
        a = Object.prototype.hasOwnProperty;
    t.exports = function (t) {
        if (!i(t)) return s(t);
        var e = r(t),
            n = [];
        for (var o in t) ("constructor" != o || !e && a.call(t, o)) && n.push(o);
        return n
    }
}, function (t, e) {
    t.exports = function (t) {
        var e = [];
        if (null != t)
            for (var n in Object(t)) e.push(n);
        return e
    }
}, function (t, e, n) {
    var i = n(58),
        r = n(159);
    t.exports = function (t, e) {
        return i(t, r(t), e)
    }
}, function (t, e, n) {
    var i = n(58),
        r = n(225);
    t.exports = function (t, e) {
        return i(t, r(t), e)
    }
}, function (t, e) {
    var n = Object.prototype.hasOwnProperty;
    t.exports = function (t) {
        var e = t.length,
            i = new t.constructor(e);
        return e && "string" == typeof t[0] && n.call(t, "index") && (i.index = t.index, i.input = t.input), i
    }
}, function (t, e, n) {
    var i = n(172),
        r = n(356),
        s = n(357),
        a = n(358),
        o = n(173);
    t.exports = function (t, e, n) {
        var l = t.constructor;
        switch (e) {
            case "[object ArrayBuffer]":
                return i(t);
            case "[object Boolean]":
            case "[object Date]":
                return new l(+t);
            case "[object DataView]":
                return r(t, n);
            case "[object Float32Array]":
            case "[object Float64Array]":
            case "[object Int8Array]":
            case "[object Int16Array]":
            case "[object Int32Array]":
            case "[object Uint8Array]":
            case "[object Uint8ClampedArray]":
            case "[object Uint16Array]":
            case "[object Uint32Array]":
                return o(t, n);
            case "[object Map]":
                return new l;
            case "[object Number]":
            case "[object String]":
                return new l(t);
            case "[object RegExp]":
                return s(t);
            case "[object Set]":
                return new l;
            case "[object Symbol]":
                return a(t)
        }
    }
}, function (t, e, n) {
    var i = n(172);
    t.exports = function (t, e) {
        var n = e ? i(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.byteLength)
    }
}, function (t, e) {
    var n = /\w*$/;
    t.exports = function (t) {
        var e = new t.constructor(t.source, n.exec(t));
        return e.lastIndex = t.lastIndex, e
    }
}, function (t, e, n) {
    var i = n(83),
        r = i ? i.prototype : void 0,
        s = r ? r.valueOf : void 0;
    t.exports = function (t) {
        return s ? Object(s.call(t)) : {}
    }
}, function (t, e, n) {
    var i = n(27),
        r = Object.create,
        s = function () {
            function t() { }
            return function (e) {
                if (!i(e)) return {};
                if (r) return r(e);
                t.prototype = e;
                var n = new t;
                return t.prototype = void 0, n
            }
        }();
    t.exports = s
}, function (t, e, n) {
    var i = n(361),
        r = n(93),
        s = n(162),
        a = s && s.isMap,
        o = a ? r(a) : i;
    t.exports = o
}, function (t, e, n) {
    var i = n(120),
        r = n(51);
    t.exports = function (t) {
        return r(t) && "[object Map]" == i(t)
    }
}, function (t, e, n) {
    var i = n(363),
        r = n(93),
        s = n(162),
        a = s && s.isSet,
        o = a ? r(a) : i;
    t.exports = o
}, function (t, e, n) {
    var i = n(120),
        r = n(51);
    t.exports = function (t) {
        return r(t) && "[object Set]" == i(t)
    }
}, function (t, e, n) {
    var i = n(121),
        r = n(227),
        s = n(365),
        a = n(94);
    t.exports = function (t, e) {
        return e = i(e, t), null == (t = s(t, e)) || delete t[a(r(e))]
    }
}, function (t, e, n) {
    var i = n(163),
        r = n(366);
    t.exports = function (t, e) {
        return e.length < 2 ? t : i(t, r(e, 0, -1))
    }
}, function (t, e) {
    t.exports = function (t, e, n) {
        var i = -1,
            r = t.length;
        e < 0 && (e = -e > r ? 0 : r + e), (n = n > r ? r : n) < 0 && (n += r), r = e > n ? 0 : n - e >>> 0, e >>>= 0;
        for (var s = Array(r); ++i < r;) s[i] = t[i + e];
        return s
    }
}, function (t, e, n) {
    var i = n(130);
    t.exports = function (t) {
        return i(t) ? void 0 : t
    }
}, function (t, e, n) {
    var i = n(98),
        r = n(216),
        s = n(218);
    t.exports = function (t) {
        return s(r(t, void 0, i), t + "")
    }
}, function (t, e) {
    Math.sign || (Math.sign = function (t) {
        return (t > 0) - (t < 0) || +t
    })
}, function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(193);
    e.default = i.default.extend({
        name: "modal-fade",
        animationName: "fade-in"
    })
}, function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(194);
    e.default = i.default.extend({
        name: "tabs",
        config: {
            preserveScroll: !0
        }
    })
}, function (t, e, n) {
    "use strict";
    n.r(e);
    var i = n(80),
        r = n.n(i),
        s = n(44),
        a = n(33);
    n(61);
    const o = {
        default: {
            selector: ".js-preloader",
            call(t, e) {
                const n = this.getElement(),
                    i = this.getPlugin();
                i && n[i] && n[i](t, e)
            },
            init() {
                this.call({
                    autoPreload: !1,
                    autoHide: !1
                })
            },
            getPlugin() {
                const t = $.app.getPlugins(this.getElement());
                return r()(t, t => -1 !== t.indexOf("preloader")) || t[0]
            },
            getElement() {
                let t = $(this.selector).not(".modal " + this.selector);
                if (!t.length) {
                    const e = this.selector.replace(/\[.*?\]/g, "").replace(/\(.*?\)/g, "").replace(/#[a-z0-9-_]+/g, " ").replace(/\./g, " ").trim();
                    t = $(`<div class="${e} preloader"><div class="preloader__content"></div></div>`).appendTo("body")
                }
                return t
            }
        }
    };
    o.landing = Object.assign({}, o.default, {
        selector: ".js-preloader-landing"
    }), o.map3D = Object.assign({}, o.default, {
        selector: ".js-preloader-3d-map"
    }), e.default = s.a.extend({
        name: "loader",
        leave(t) {
            s.a.leave.call(this, t);
            const e = this.preloader = this.getPreloader(t);
            return new Promise(t => {
                e.getElement().on("opened.preloader", t), e.init(), e.call("show")
            })
        },
        afterLeave(t) {
            s.a.afterLeave.call(this, t);
            this.preloader.call({
                content: t.next.container
            })
        },
        enter(t) {
            s.a.enter.call(this, t);
            const e = this.preloader;
            return new Promise(t => {
                e.getElement().one("complete.preloader", t), e.call("preload")
            }).then(() => new Promise(t => {
                e.call("hide"), t()
            }))
        },
        getPreloader(t) {
            let e = $(t.current.container).find("[data-page-preloader]").data("pagePreloader");
            return "landing" === e && a.a.get("introSeen") && (e = null), o[e] ? o[e] : "/3d-map" === t.next.url.path ? o.map3D : o.default
        }
    })
}, function (t, e) {
    t.exports = function (t, e, n, i) {
        var r = -1,
            s = null == t ? 0 : t.length;
        for (i && s && (n = t[++r]); ++r < s;) n = e(n, t[r], r, t);
        return n
    }
}, function (t, e) {
    t.exports = function (t, e, n, i, r) {
        return r(t, (function (t, r, s) {
            n = i ? (i = !1, t) : e(n, t, r, s)
        })), n
    }
}, function (t, e, n) {
    var i, r, s;
    /*!
     * jQuery Validation Plugin v1.19.5
     *
     * https://jqueryvalidation.org/
     *
     * Copyright (c) 2022 Jörn Zaefferer
     * Released under the MIT license
     */
    r = [n(2)], void 0 === (s = "function" == typeof (i = function (t) {
        t.extend(t.fn, {
            validate: function (e) {
                if (this.length) {
                    var n = t.data(this[0], "validator");
                    return n || (this.attr("novalidate", "novalidate"), n = new t.validator(e, this[0]), t.data(this[0], "validator", n), n.settings.onsubmit && (this.on("click.validate", ":submit", (function (e) {
                        n.submitButton = e.currentTarget, t(this).hasClass("cancel") && (n.cancelSubmit = !0), void 0 !== t(this).attr("formnovalidate") && (n.cancelSubmit = !0)
                    })), this.on("submit.validate", (function (e) {
                        function i() {
                            var i, r;
                            return n.submitButton && (n.settings.submitHandler || n.formSubmitted) && (i = t("<input type='hidden'/>").attr("name", n.submitButton.name).val(t(n.submitButton).val()).appendTo(n.currentForm)), !(n.settings.submitHandler && !n.settings.debug) || (r = n.settings.submitHandler.call(n, n.currentForm, e), i && i.remove(), void 0 !== r && r)
                        }
                        return n.settings.debug && e.preventDefault(), n.cancelSubmit ? (n.cancelSubmit = !1, i()) : n.form() ? n.pendingRequest ? (n.formSubmitted = !0, !1) : i() : (n.focusInvalid(), !1)
                    }))), n)
                }
                e && e.debug && window.console && console.warn("Nothing selected, can't validate, returning nothing.")
            },
            valid: function () {
                var e, n, i;
                return t(this[0]).is("form") ? e = this.validate().form() : (i = [], e = !0, n = t(this[0].form).validate(), this.each((function () {
                    (e = n.element(this) && e) || (i = i.concat(n.errorList))
                })), n.errorList = i), e
            },
            rules: function (e, n) {
                var i, r, s, a, o, l, c = this[0],
                    h = void 0 !== this.attr("contenteditable") && "false" !== this.attr("contenteditable");
                if (null != c && (!c.form && h && (c.form = this.closest("form")[0], c.name = this.attr("name")), null != c.form)) {
                    if (e) switch (r = (i = t.data(c.form, "validator").settings).rules, s = t.validator.staticRules(c), e) {
                        case "add":
                            t.extend(s, t.validator.normalizeRule(n)), delete s.messages, r[c.name] = s, n.messages && (i.messages[c.name] = t.extend(i.messages[c.name], n.messages));
                            break;
                        case "remove":
                            return n ? (l = {}, t.each(n.split(/\s/), (function (t, e) {
                                l[e] = s[e], delete s[e]
                            })), l) : (delete r[c.name], s)
                    }
                    return (a = t.validator.normalizeRules(t.extend({}, t.validator.classRules(c), t.validator.attributeRules(c), t.validator.dataRules(c), t.validator.staticRules(c)), c)).required && (o = a.required, delete a.required, a = t.extend({
                        required: o
                    }, a)), a.remote && (o = a.remote, delete a.remote, a = t.extend(a, {
                        remote: o
                    })), a
                }
            }
        });
        var e, n = function (t) {
            return t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
        };
        t.extend(t.expr.pseudos || t.expr[":"], {
            blank: function (e) {
                return !n("" + t(e).val())
            },
            filled: function (e) {
                var i = t(e).val();
                return null !== i && !!n("" + i)
            },
            unchecked: function (e) {
                return !t(e).prop("checked")
            }
        }), t.validator = function (e, n) {
            this.settings = t.extend(!0, {}, t.validator.defaults, e), this.currentForm = n, this.init()
        }, t.validator.format = function (e, n) {
            return 1 === arguments.length ? function () {
                var n = t.makeArray(arguments);
                return n.unshift(e), t.validator.format.apply(this, n)
            } : (void 0 === n || (arguments.length > 2 && n.constructor !== Array && (n = t.makeArray(arguments).slice(1)), n.constructor !== Array && (n = [n]), t.each(n, (function (t, n) {
                e = e.replace(new RegExp("\\{" + t + "\\}", "g"), (function () {
                    return n
                }))
            }))), e)
        }, t.extend(t.validator, {
            defaults: {
                messages: {},
                groups: {},
                rules: {},
                errorClass: "error",
                pendingClass: "pending",
                validClass: "valid",
                errorElement: "label",
                focusCleanup: !1,
                focusInvalid: !0,
                errorContainer: t([]),
                errorLabelContainer: t([]),
                onsubmit: !0,
                ignore: ":hidden",
                ignoreTitle: !1,
                onfocusin: function (t) {
                    this.lastActive = t, this.settings.focusCleanup && (this.settings.unhighlight && this.settings.unhighlight.call(this, t, this.settings.errorClass, this.settings.validClass), this.hideThese(this.errorsFor(t)))
                },
                onfocusout: function (t) {
                    this.checkable(t) || !(t.name in this.submitted) && this.optional(t) || this.element(t)
                },
                onkeyup: function (e, n) {
                    9 === n.which && "" === this.elementValue(e) || -1 !== t.inArray(n.keyCode, [16, 17, 18, 20, 35, 36, 37, 38, 39, 40, 45, 144, 225]) || (e.name in this.submitted || e.name in this.invalid) && this.element(e)
                },
                onclick: function (t) {
                    t.name in this.submitted ? this.element(t) : t.parentNode.name in this.submitted && this.element(t.parentNode)
                },
                highlight: function (e, n, i) {
                    "radio" === e.type ? this.findByName(e.name).addClass(n).removeClass(i) : t(e).addClass(n).removeClass(i)
                },
                unhighlight: function (e, n, i) {
                    "radio" === e.type ? this.findByName(e.name).removeClass(n).addClass(i) : t(e).removeClass(n).addClass(i)
                }
            },
            setDefaults: function (e) {
                t.extend(t.validator.defaults, e)
            },
            messages: {
                required: "This field is required.",
                remote: "Please fix this field.",
                email: "Please enter a valid email address.",
                url: "Please enter a valid URL.",
                date: "Please enter a valid date.",
                dateISO: "Please enter a valid date (ISO).",
                number: "Please enter a valid number.",
                digits: "Please enter only digits.",
                equalTo: "Please enter the same value again.",
                maxlength: t.validator.format("Please enter no more than {0} characters."),
                minlength: t.validator.format("Please enter at least {0} characters."),
                rangelength: t.validator.format("Please enter a value between {0} and {1} characters long."),
                range: t.validator.format("Please enter a value between {0} and {1}."),
                max: t.validator.format("Please enter a value less than or equal to {0}."),
                min: t.validator.format("Please enter a value greater than or equal to {0}."),
                step: t.validator.format("Please enter a multiple of {0}.")
            },
            autoCreateRanges: !1,
            prototype: {
                init: function () {
                    this.labelContainer = t(this.settings.errorLabelContainer), this.errorContext = this.labelContainer.length && this.labelContainer || t(this.currentForm), this.containers = t(this.settings.errorContainer).add(this.settings.errorLabelContainer), this.submitted = {}, this.valueCache = {}, this.pendingRequest = 0, this.pending = {}, this.invalid = {}, this.reset();
                    var e, n = this.currentForm,
                        i = this.groups = {};

                    function r(e) {
                        var i = void 0 !== t(this).attr("contenteditable") && "false" !== t(this).attr("contenteditable");
                        if (!this.form && i && (this.form = t(this).closest("form")[0], this.name = t(this).attr("name")), n === this.form) {
                            var r = t.data(this.form, "validator"),
                                s = "on" + e.type.replace(/^validate/, ""),
                                a = r.settings;
                            a[s] && !t(this).is(a.ignore) && a[s].call(r, this, e)
                        }
                    }
                    t.each(this.settings.groups, (function (e, n) {
                        "string" == typeof n && (n = n.split(/\s/)), t.each(n, (function (t, n) {
                            i[n] = e
                        }))
                    })), e = this.settings.rules, t.each(e, (function (n, i) {
                        e[n] = t.validator.normalizeRule(i)
                    })), t(this.currentForm).on("focusin.validate focusout.validate keyup.validate", ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], [type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox'], [contenteditable], [type='button']", r).on("click.validate", "select, option, [type='radio'], [type='checkbox']", r), this.settings.invalidHandler && t(this.currentForm).on("invalid-form.validate", this.settings.invalidHandler)
                },
                form: function () {
                    return this.checkForm(), t.extend(this.submitted, this.errorMap), this.invalid = t.extend({}, this.errorMap), this.valid() || t(this.currentForm).triggerHandler("invalid-form", [this]), this.showErrors(), this.valid()
                },
                checkForm: function () {
                    this.prepareForm();
                    for (var t = 0, e = this.currentElements = this.elements(); e[t]; t++) this.check(e[t]);
                    return this.valid()
                },
                element: function (e) {
                    var n, i, r = this.clean(e),
                        s = this.validationTargetFor(r),
                        a = this,
                        o = !0;
                    return void 0 === s ? delete this.invalid[r.name] : (this.prepareElement(s), this.currentElements = t(s), (i = this.groups[s.name]) && t.each(this.groups, (function (t, e) {
                        e === i && t !== s.name && (r = a.validationTargetFor(a.clean(a.findByName(t)))) && r.name in a.invalid && (a.currentElements.push(r), o = a.check(r) && o)
                    })), n = !1 !== this.check(s), o = o && n, this.invalid[s.name] = !n, this.numberOfInvalids() || (this.toHide = this.toHide.add(this.containers)), this.showErrors(), t(e).attr("aria-invalid", !n)), o
                },
                showErrors: function (e) {
                    if (e) {
                        var n = this;
                        t.extend(this.errorMap, e), this.errorList = t.map(this.errorMap, (function (t, e) {
                            return {
                                message: t,
                                element: n.findByName(e)[0]
                            }
                        })), this.successList = t.grep(this.successList, (function (t) {
                            return !(t.name in e)
                        }))
                    }
                    this.settings.showErrors ? this.settings.showErrors.call(this, this.errorMap, this.errorList) : this.defaultShowErrors()
                },
                resetForm: function () {
                    t.fn.resetForm && t(this.currentForm).resetForm(), this.invalid = {}, this.submitted = {}, this.prepareForm(), this.hideErrors();
                    var e = this.elements().removeData("previousValue").removeAttr("aria-invalid");
                    this.resetElements(e)
                },
                resetElements: function (t) {
                    var e;
                    if (this.settings.unhighlight)
                        for (e = 0; t[e]; e++) this.settings.unhighlight.call(this, t[e], this.settings.errorClass, ""), this.findByName(t[e].name).removeClass(this.settings.validClass);
                    else t.removeClass(this.settings.errorClass).removeClass(this.settings.validClass)
                },
                numberOfInvalids: function () {
                    return this.objectLength(this.invalid)
                },
                objectLength: function (t) {
                    var e, n = 0;
                    for (e in t) void 0 !== t[e] && null !== t[e] && !1 !== t[e] && n++;
                    return n
                },
                hideErrors: function () {
                    this.hideThese(this.toHide)
                },
                hideThese: function (t) {
                    t.not(this.containers).text(""), this.addWrapper(t).hide()
                },
                valid: function () {
                    return 0 === this.size()
                },
                size: function () {
                    return this.errorList.length
                },
                focusInvalid: function () {
                    if (this.settings.focusInvalid) try {
                        t(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").trigger("focus").trigger("focusin")
                    } catch (t) { }
                },
                findLastActive: function () {
                    var e = this.lastActive;
                    return e && 1 === t.grep(this.errorList, (function (t) {
                        return t.element.name === e.name
                    })).length && e
                },
                elements: function () {
                    var e = this,
                        n = {};
                    return t(this.currentForm).find("input, select, textarea, [contenteditable]").not(":submit, :reset, :image, :disabled").not(this.settings.ignore).filter((function () {
                        var i = this.name || t(this).attr("name"),
                            r = void 0 !== t(this).attr("contenteditable") && "false" !== t(this).attr("contenteditable");
                        return !i && e.settings.debug && window.console && console.error("%o has no name assigned", this), r && (this.form = t(this).closest("form")[0], this.name = i), !(this.form !== e.currentForm || i in n || !e.objectLength(t(this).rules()) || (n[i] = !0, 0))
                    }))
                },
                clean: function (e) {
                    return t(e)[0]
                },
                errors: function () {
                    var e = this.settings.errorClass.split(" ").join(".");
                    return t(this.settings.errorElement + "." + e, this.errorContext)
                },
                resetInternals: function () {
                    this.successList = [], this.errorList = [], this.errorMap = {}, this.toShow = t([]), this.toHide = t([])
                },
                reset: function () {
                    this.resetInternals(), this.currentElements = t([])
                },
                prepareForm: function () {
                    this.reset(), this.toHide = this.errors().add(this.containers)
                },
                prepareElement: function (t) {
                    this.reset(), this.toHide = this.errorsFor(t)
                },
                elementValue: function (e) {
                    var n, i, r = t(e),
                        s = e.type,
                        a = void 0 !== r.attr("contenteditable") && "false" !== r.attr("contenteditable");
                    return "radio" === s || "checkbox" === s ? this.findByName(e.name).filter(":checked").val() : "number" === s && void 0 !== e.validity ? e.validity.badInput ? "NaN" : r.val() : (n = a ? r.text() : r.val(), "file" === s ? "C:\\fakepath\\" === n.substr(0, 12) ? n.substr(12) : (i = n.lastIndexOf("/")) >= 0 || (i = n.lastIndexOf("\\")) >= 0 ? n.substr(i + 1) : n : "string" == typeof n ? n.replace(/\r/g, "") : n)
                },
                check: function (e) {
                    e = this.validationTargetFor(this.clean(e));
                    var n, i, r, s, a = t(e).rules(),
                        o = t.map(a, (function (t, e) {
                            return e
                        })).length,
                        l = !1,
                        c = this.elementValue(e);
                    for (i in "function" == typeof a.normalizer ? s = a.normalizer : "function" == typeof this.settings.normalizer && (s = this.settings.normalizer), s && (c = s.call(e, c), delete a.normalizer), a) {
                        r = {
                            method: i,
                            parameters: a[i]
                        };
                        try {
                            if ("dependency-mismatch" === (n = t.validator.methods[i].call(this, c, e, r.parameters)) && 1 === o) {
                                l = !0;
                                continue
                            }
                            if (l = !1, "pending" === n) return void (this.toHide = this.toHide.not(this.errorsFor(e)));
                            if (!n) return this.formatAndAdd(e, r), !1
                        } catch (t) {
                            throw this.settings.debug && window.console && console.log("Exception occurred when checking element " + e.id + ", check the '" + r.method + "' method.", t), t instanceof TypeError && (t.message += ".  Exception occurred when checking element " + e.id + ", check the '" + r.method + "' method."), t
                        }
                    }
                    if (!l) return this.objectLength(a) && this.successList.push(e), !0
                },
                customDataMessage: function (e, n) {
                    return t(e).data("msg" + n.charAt(0).toUpperCase() + n.substring(1).toLowerCase()) || t(e).data("msg")
                },
                customMessage: function (t, e) {
                    var n = this.settings.messages[t];
                    return n && (n.constructor === String ? n : n[e])
                },
                findDefined: function () {
                    for (var t = 0; t < arguments.length; t++)
                        if (void 0 !== arguments[t]) return arguments[t]
                },
                defaultMessage: function (e, n) {
                    "string" == typeof n && (n = {
                        method: n
                    });
                    var i = this.findDefined(this.customMessage(e.name, n.method), this.customDataMessage(e, n.method), !this.settings.ignoreTitle && e.title || void 0, t.validator.messages[n.method], "<strong>Warning: No message defined for " + e.name + "</strong>"),
                        r = /\$?\{(\d+)\}/g;
                    return "function" == typeof i ? i = i.call(this, n.parameters, e) : r.test(i) && (i = t.validator.format(i.replace(r, "{$1}"), n.parameters)), i
                },
                formatAndAdd: function (t, e) {
                    var n = this.defaultMessage(t, e);
                    this.errorList.push({
                        message: n,
                        element: t,
                        method: e.method
                    }), this.errorMap[t.name] = n, this.submitted[t.name] = n
                },
                addWrapper: function (t) {
                    return this.settings.wrapper && (t = t.add(t.parent(this.settings.wrapper))), t
                },
                defaultShowErrors: function () {
                    var t, e, n;
                    for (t = 0; this.errorList[t]; t++) n = this.errorList[t], this.settings.highlight && this.settings.highlight.call(this, n.element, this.settings.errorClass, this.settings.validClass), this.showLabel(n.element, n.message);
                    if (this.errorList.length && (this.toShow = this.toShow.add(this.containers)), this.settings.success)
                        for (t = 0; this.successList[t]; t++) this.showLabel(this.successList[t]);
                    if (this.settings.unhighlight)
                        for (t = 0, e = this.validElements(); e[t]; t++) this.settings.unhighlight.call(this, e[t], this.settings.errorClass, this.settings.validClass);
                    this.toHide = this.toHide.not(this.toShow), this.hideErrors(), this.addWrapper(this.toShow).show()
                },
                validElements: function () {
                    return this.currentElements.not(this.invalidElements())
                },
                invalidElements: function () {
                    return t(this.errorList).map((function () {
                        return this.element
                    }))
                },
                showLabel: function (e, n) {
                    var i, r, s, a, o = this.errorsFor(e),
                        l = this.idOrName(e),
                        c = t(e).attr("aria-describedby");
                    o.length ? (o.removeClass(this.settings.validClass).addClass(this.settings.errorClass), o.html(n)) : (i = o = t("<" + this.settings.errorElement + ">").attr("id", l + "-error").addClass(this.settings.errorClass).html(n || ""), this.settings.wrapper && (i = o.hide().show().wrap("<" + this.settings.wrapper + "/>").parent()), this.labelContainer.length ? this.labelContainer.append(i) : this.settings.errorPlacement ? this.settings.errorPlacement.call(this, i, t(e)) : i.insertAfter(e), o.is("label") ? o.attr("for", l) : 0 === o.parents("label[for='" + this.escapeCssMeta(l) + "']").length && (s = o.attr("id"), c ? c.match(new RegExp("\\b" + this.escapeCssMeta(s) + "\\b")) || (c += " " + s) : c = s, t(e).attr("aria-describedby", c), (r = this.groups[e.name]) && (a = this, t.each(a.groups, (function (e, n) {
                        n === r && t("[name='" + a.escapeCssMeta(e) + "']", a.currentForm).attr("aria-describedby", o.attr("id"))
                    }))))), !n && this.settings.success && (o.text(""), "string" == typeof this.settings.success ? o.addClass(this.settings.success) : this.settings.success(o, e)), this.toShow = this.toShow.add(o)
                },
                errorsFor: function (e) {
                    var n = this.escapeCssMeta(this.idOrName(e)),
                        i = t(e).attr("aria-describedby"),
                        r = "label[for='" + n + "'], label[for='" + n + "'] *";
                    return i && (r = r + ", #" + this.escapeCssMeta(i).replace(/\s+/g, ", #")), this.errors().filter(r)
                },
                escapeCssMeta: function (t) {
                    return void 0 === t ? "" : t.replace(/([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, "\\$1")
                },
                idOrName: function (t) {
                    return this.groups[t.name] || (this.checkable(t) ? t.name : t.id || t.name)
                },
                validationTargetFor: function (e) {
                    return this.checkable(e) && (e = this.findByName(e.name)), t(e).not(this.settings.ignore)[0]
                },
                checkable: function (t) {
                    return /radio|checkbox/i.test(t.type)
                },
                findByName: function (e) {
                    return t(this.currentForm).find("[name='" + this.escapeCssMeta(e) + "']")
                },
                getLength: function (e, n) {
                    switch (n.nodeName.toLowerCase()) {
                        case "select":
                            return t("option:selected", n).length;
                        case "input":
                            if (this.checkable(n)) return this.findByName(n.name).filter(":checked").length
                    }
                    return e.length
                },
                depend: function (t, e) {
                    return !this.dependTypes[typeof t] || this.dependTypes[typeof t](t, e)
                },
                dependTypes: {
                    boolean: function (t) {
                        return t
                    },
                    string: function (e, n) {
                        return !!t(e, n.form).length
                    },
                    function: function (t, e) {
                        return t(e)
                    }
                },
                optional: function (e) {
                    var n = this.elementValue(e);
                    return !t.validator.methods.required.call(this, n, e) && "dependency-mismatch"
                },
                startRequest: function (e) {
                    this.pending[e.name] || (this.pendingRequest++, t(e).addClass(this.settings.pendingClass), this.pending[e.name] = !0)
                },
                stopRequest: function (e, n) {
                    this.pendingRequest--, this.pendingRequest < 0 && (this.pendingRequest = 0), delete this.pending[e.name], t(e).removeClass(this.settings.pendingClass), n && 0 === this.pendingRequest && this.formSubmitted && this.form() && 0 === this.pendingRequest ? (t(this.currentForm).trigger("submit"), this.submitButton && t("input:hidden[name='" + this.submitButton.name + "']", this.currentForm).remove(), this.formSubmitted = !1) : !n && 0 === this.pendingRequest && this.formSubmitted && (t(this.currentForm).triggerHandler("invalid-form", [this]), this.formSubmitted = !1)
                },
                previousValue: function (e, n) {
                    return n = "string" == typeof n && n || "remote", t.data(e, "previousValue") || t.data(e, "previousValue", {
                        old: null,
                        valid: !0,
                        message: this.defaultMessage(e, {
                            method: n
                        })
                    })
                },
                destroy: function () {
                    this.resetForm(), t(this.currentForm).off(".validate").removeData("validator").find(".validate-equalTo-blur").off(".validate-equalTo").removeClass("validate-equalTo-blur").find(".validate-lessThan-blur").off(".validate-lessThan").removeClass("validate-lessThan-blur").find(".validate-lessThanEqual-blur").off(".validate-lessThanEqual").removeClass("validate-lessThanEqual-blur").find(".validate-greaterThanEqual-blur").off(".validate-greaterThanEqual").removeClass("validate-greaterThanEqual-blur").find(".validate-greaterThan-blur").off(".validate-greaterThan").removeClass("validate-greaterThan-blur")
                }
            },
            classRuleSettings: {
                required: {
                    required: !0
                },
                email: {
                    email: !0
                },
                url: {
                    url: !0
                },
                date: {
                    date: !0
                },
                dateISO: {
                    dateISO: !0
                },
                number: {
                    number: !0
                },
                digits: {
                    digits: !0
                },
                creditcard: {
                    creditcard: !0
                }
            },
            addClassRules: function (e, n) {
                e.constructor === String ? this.classRuleSettings[e] = n : t.extend(this.classRuleSettings, e)
            },
            classRules: function (e) {
                var n = {},
                    i = t(e).attr("class");
                return i && t.each(i.split(" "), (function () {
                    this in t.validator.classRuleSettings && t.extend(n, t.validator.classRuleSettings[this])
                })), n
            },
            normalizeAttributeRule: function (t, e, n, i) {
                /min|max|step/.test(n) && (null === e || /number|range|text/.test(e)) && (i = Number(i), isNaN(i) && (i = void 0)), i || 0 === i ? t[n] = i : e === n && "range" !== e && (t["date" === e ? "dateISO" : n] = !0)
            },
            attributeRules: function (e) {
                var n, i, r = {},
                    s = t(e),
                    a = e.getAttribute("type");
                for (n in t.validator.methods) "required" === n ? ("" === (i = e.getAttribute(n)) && (i = !0), i = !!i) : i = s.attr(n), this.normalizeAttributeRule(r, a, n, i);
                return r.maxlength && /-1|2147483647|524288/.test(r.maxlength) && delete r.maxlength, r
            },
            dataRules: function (e) {
                var n, i, r = {},
                    s = t(e),
                    a = e.getAttribute("type");
                for (n in t.validator.methods) "" === (i = s.data("rule" + n.charAt(0).toUpperCase() + n.substring(1).toLowerCase())) && (i = !0), this.normalizeAttributeRule(r, a, n, i);
                return r
            },
            staticRules: function (e) {
                var n = {},
                    i = t.data(e.form, "validator");
                return i.settings.rules && (n = t.validator.normalizeRule(i.settings.rules[e.name]) || {}), n
            },
            normalizeRules: function (e, n) {
                return t.each(e, (function (i, r) {
                    if (!1 !== r) {
                        if (r.param || r.depends) {
                            var s = !0;
                            switch (typeof r.depends) {
                                case "string":
                                    s = !!t(r.depends, n.form).length;
                                    break;
                                case "function":
                                    s = r.depends.call(n, n)
                            }
                            s ? e[i] = void 0 === r.param || r.param : (t.data(n.form, "validator").resetElements(t(n)), delete e[i])
                        }
                    } else delete e[i]
                })), t.each(e, (function (t, i) {
                    e[t] = "function" == typeof i && "normalizer" !== t ? i(n) : i
                })), t.each(["minlength", "maxlength"], (function () {
                    e[this] && (e[this] = Number(e[this]))
                })), t.each(["rangelength", "range"], (function () {
                    var t;
                    e[this] && (Array.isArray(e[this]) ? e[this] = [Number(e[this][0]), Number(e[this][1])] : "string" == typeof e[this] && (t = e[this].replace(/[\[\]]/g, "").split(/[\s,]+/), e[this] = [Number(t[0]), Number(t[1])]))
                })), t.validator.autoCreateRanges && (null != e.min && null != e.max && (e.range = [e.min, e.max], delete e.min, delete e.max), null != e.minlength && null != e.maxlength && (e.rangelength = [e.minlength, e.maxlength], delete e.minlength, delete e.maxlength)), e
            },
            normalizeRule: function (e) {
                if ("string" == typeof e) {
                    var n = {};
                    t.each(e.split(/\s/), (function () {
                        n[this] = !0
                    })), e = n
                }
                return e
            },
            addMethod: function (e, n, i) {
                t.validator.methods[e] = n, t.validator.messages[e] = void 0 !== i ? i : t.validator.messages[e], n.length < 3 && t.validator.addClassRules(e, t.validator.normalizeRule(e))
            },
            methods: {
                required: function (e, n, i) {
                    if (!this.depend(i, n)) return "dependency-mismatch";
                    if ("select" === n.nodeName.toLowerCase()) {
                        var r = t(n).val();
                        return r && r.length > 0
                    }
                    return this.checkable(n) ? this.getLength(e, n) > 0 : null != e && e.length > 0
                },
                email: function (t, e) {
                    return this.optional(e) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(t)
                },
                url: function (t, e) {
                    return this.optional(e) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:(?:[^\]\[?\/<~#`!@$^&*()+=}|:";',>{ ]|%[0-9A-Fa-f]{2})+(?::(?:[^\]\[?\/<~#`!@$^&*()+=}|:";',>{ ]|%[0-9A-Fa-f]{2})*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(t)
                },
                date: (e = !1, function (t, n) {
                    return e || (e = !0, this.settings.debug && window.console && console.warn("The `date` method is deprecated and will be removed in version '2.0.0'.\nPlease don't use it, since it relies on the Date constructor, which\nbehaves very differently across browsers and locales. Use `dateISO`\ninstead or one of the locale specific methods in `localizations/`\nand `additional-methods.js`.")), this.optional(n) || !/Invalid|NaN/.test(new Date(t).toString())
                }),
                dateISO: function (t, e) {
                    return this.optional(e) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(t)
                },
                number: function (t, e) {
                    return this.optional(e) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(t)
                },
                digits: function (t, e) {
                    return this.optional(e) || /^\d+$/.test(t)
                },
                minlength: function (t, e, n) {
                    var i = Array.isArray(t) ? t.length : this.getLength(t, e);
                    return this.optional(e) || i >= n
                },
                maxlength: function (t, e, n) {
                    var i = Array.isArray(t) ? t.length : this.getLength(t, e);
                    return this.optional(e) || i <= n
                },
                rangelength: function (t, e, n) {
                    var i = Array.isArray(t) ? t.length : this.getLength(t, e);
                    return this.optional(e) || i >= n[0] && i <= n[1]
                },
                min: function (t, e, n) {
                    return this.optional(e) || t >= n
                },
                max: function (t, e, n) {
                    return this.optional(e) || t <= n
                },
                range: function (t, e, n) {
                    return this.optional(e) || t >= n[0] && t <= n[1]
                },
                step: function (e, n, i) {
                    var r, s = t(n).attr("type"),
                        a = "Step attribute on input type " + s + " is not supported.",
                        o = new RegExp("\\b" + s + "\\b"),
                        l = function (t) {
                            var e = ("" + t).match(/(?:\.(\d+))?$/);
                            return e && e[1] ? e[1].length : 0
                        },
                        c = function (t) {
                            return Math.round(t * Math.pow(10, r))
                        },
                        h = !0;
                    if (s && !o.test(["text", "number", "range"].join())) throw new Error(a);
                    return r = l(i), (l(e) > r || c(e) % c(i) != 0) && (h = !1), this.optional(n) || h
                },
                equalTo: function (e, n, i) {
                    var r = t(i);
                    return this.settings.onfocusout && r.not(".validate-equalTo-blur").length && r.addClass("validate-equalTo-blur").on("blur.validate-equalTo", (function () {
                        t(n).valid()
                    })), e === r.val()
                },
                remote: function (e, n, i, r) {
                    if (this.optional(n)) return "dependency-mismatch";
                    r = "string" == typeof r && r || "remote";
                    var s, a, o, l = this.previousValue(n, r);
                    return this.settings.messages[n.name] || (this.settings.messages[n.name] = {}), l.originalMessage = l.originalMessage || this.settings.messages[n.name][r], this.settings.messages[n.name][r] = l.message, i = "string" == typeof i && {
                        url: i
                    } || i, o = t.param(t.extend({
                        data: e
                    }, i.data)), l.old === o ? l.valid : (l.old = o, s = this, this.startRequest(n), (a = {})[n.name] = e, t.ajax(t.extend(!0, {
                        mode: "abort",
                        port: "validate" + n.name,
                        dataType: "json",
                        data: a,
                        context: s.currentForm,
                        success: function (t) {
                            var i, a, o, c = !0 === t || "true" === t;
                            s.settings.messages[n.name][r] = l.originalMessage, c ? (o = s.formSubmitted, s.resetInternals(), s.toHide = s.errorsFor(n), s.formSubmitted = o, s.successList.push(n), s.invalid[n.name] = !1, s.showErrors()) : (i = {}, a = t || s.defaultMessage(n, {
                                method: r,
                                parameters: e
                            }), i[n.name] = l.message = a, s.invalid[n.name] = !0, s.showErrors(i)), l.valid = c, s.stopRequest(n, c)
                        }
                    }, i)), "pending")
                }
            }
        });
        var i, r = {};
        return t.ajaxPrefilter ? t.ajaxPrefilter((function (t, e, n) {
            var i = t.port;
            "abort" === t.mode && (r[i] && r[i].abort(), r[i] = n)
        })) : (i = t.ajax, t.ajax = function (e) {
            var n = ("mode" in e ? e : t.ajaxSettings).mode,
                s = ("port" in e ? e : t.ajaxSettings).port;
            return "abort" === n ? (r[s] && r[s].abort(), r[s] = i.apply(this, arguments), r[s]) : i.apply(this, arguments)
        }), t
    }) ? i.apply(e, r) : i) || (t.exports = s)
}, function (t, e, n) {
    "use strict";
    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    var i = Object.getOwnPropertySymbols,
        r = Object.prototype.hasOwnProperty,
        s = Object.prototype.propertyIsEnumerable;

    function a(t) {
        if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(t)
    }
    t.exports = function () {
        try {
            if (!Object.assign) return !1;
            var t = new String("abc");
            if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1;
            for (var e = {}, n = 0; n < 10; n++) e["_" + String.fromCharCode(n)] = n;
            if ("0123456789" !== Object.getOwnPropertyNames(e).map((function (t) {
                return e[t]
            })).join("")) return !1;
            var i = {};
            return "abcdefghijklmnopqrst".split("").forEach((function (t) {
                i[t] = t
            })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, i)).join("")
        } catch (t) {
            return !1
        }
    }() ? Object.assign : function (t, e) {
        for (var n, o, l = a(t), c = 1; c < arguments.length; c++) {
            for (var h in n = Object(arguments[c])) r.call(n, h) && (l[h] = n[h]);
            if (i) {
                o = i(n);
                for (var u = 0; u < o.length; u++) s.call(n, o[u]) && (l[o[u]] = n[o[u]])
            }
        }
        return l
    }
}, function (t, e) {
    function n() { }
    n.prototype = {
        on: function (t, e, n) {
            var i = this.e || (this.e = {});
            return (i[t] || (i[t] = [])).push({
                fn: e,
                ctx: n
            }), this
        },
        once: function (t, e, n) {
            var i = this;

            function r() {
                i.off(t, r), e.apply(n, arguments)
            }
            return r._ = e, this.on(t, r, n)
        },
        emit: function (t) {
            for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, r = n.length; i < r; i++) n[i].fn.apply(n[i].ctx, e);
            return this
        },
        off: function (t, e) {
            var n = this.e || (this.e = {}),
                i = n[t],
                r = [];
            if (i && e)
                for (var s = 0, a = i.length; s < a; s++) i[s].fn !== e && i[s].fn._ !== e && r.push(i[s]);
            return r.length ? n[t] = r : delete n[t], this
        }
    }, t.exports = n
}, function (t, e, n) {
    (function () {
        (null !== e ? e : this).Lethargy = function () {
            function t(t, e, n, i) {
                this.stability = null != t ? Math.abs(t) : 8, this.sensitivity = null != e ? 1 + Math.abs(e) : 100, this.tolerance = null != n ? 1 + Math.abs(n) : 1.1, this.delay = null != i ? i : 150, this.lastUpDeltas = function () {
                    var t, e, n;
                    for (n = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--) n.push(null);
                    return n
                }.call(this), this.lastDownDeltas = function () {
                    var t, e, n;
                    for (n = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--) n.push(null);
                    return n
                }.call(this), this.deltasTimestamp = function () {
                    var t, e, n;
                    for (n = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--) n.push(null);
                    return n
                }.call(this)
            }
            return t.prototype.check = function (t) {
                var e;
                return null != (t = t.originalEvent || t).wheelDelta ? e = t.wheelDelta : null != t.deltaY ? e = -40 * t.deltaY : null == t.detail && 0 !== t.detail || (e = -40 * t.detail), this.deltasTimestamp.push(Date.now()), this.deltasTimestamp.shift(), e > 0 ? (this.lastUpDeltas.push(e), this.lastUpDeltas.shift(), this.isInertia(1)) : (this.lastDownDeltas.push(e), this.lastDownDeltas.shift(), this.isInertia(-1))
            }, t.prototype.isInertia = function (t) {
                var e, n, i, r, s, a, o;
                return null === (e = -1 === t ? this.lastDownDeltas : this.lastUpDeltas)[0] ? t : !(this.deltasTimestamp[2 * this.stability - 2] + this.delay > Date.now() && e[0] === e[2 * this.stability - 1]) && (i = e.slice(0, this.stability), n = e.slice(this.stability, 2 * this.stability), o = i.reduce((function (t, e) {
                    return t + e
                })), s = n.reduce((function (t, e) {
                    return t + e
                })), a = o / i.length, r = s / n.length, Math.abs(a) < Math.abs(r * this.tolerance) && this.sensitivity < Math.abs(r) && t)
            }, t.prototype.showLastUpDeltas = function () {
                return this.lastUpDeltas
            }, t.prototype.showLastDownDeltas = function () {
                return this.lastDownDeltas
            }, t
        }()
    }).call(this)
}, function (t, e, n) {
    "use strict";
    t.exports = {
        hasWheelEvent: "onwheel" in document,
        hasMouseWheelEvent: "onmousewheel" in document,
        hasTouch: "ontouchstart" in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,
        hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
        hasPointer: !!window.navigator.msPointerEnabled,
        hasKeyDown: "onkeydown" in document,
        isFirefox: navigator.userAgent.indexOf("Firefox") > -1
    }
}, function (t, e, n) {
    "use strict";
    t.exports = function (t) {
        return JSON.parse(JSON.stringify(t))
    }
}, function (t, e, n) {
    "use strict";
    var i = Object.prototype.toString,
        r = Object.prototype.hasOwnProperty;

    function s(t, e) {
        return function () {
            return t.apply(e, arguments)
        }
    }
    t.exports = function (t) {
        if (!t) return console.warn("bindAll requires at least one argument.");
        var e = Array.prototype.slice.call(arguments, 1);
        if (0 === e.length)
            for (var n in t) r.call(t, n) && "function" == typeof t[n] && "[object Function]" == i.call(t[n]) && e.push(n);
        for (var a = 0; a < e.length; a++) {
            var o = e[a];
            t[o] = s(t[o], t)
        }
    }
}, function (t, e) {
    if (window.IntersectionObserver && IntersectionObserver.prototype._monitorIntersections) {
        const t = IntersectionObserver.prototype._monitorIntersections,
            e = IntersectionObserver.prototype._unmonitorIntersections;
        IntersectionObserver.prototype._monitorIntersections = function () {
            this._monitoringIntersections || this.POLL_INTERVAL || ($(window).on("scroll", this._checkForIntersections), t.call(this))
        }, IntersectionObserver.prototype._unmonitorIntersections = function () {
            this._monitoringIntersections && ($(window).off("scroll", this._checkForIntersections), e.call(this))
        }
    }
}, function (t, e) {
    $.extend($.fn.parallax.patterns, {
        block: function (t) {
            const e = t.blockMultiplier || 1;
            return {
                clamp: !0,
                "parallax-100-50": {
                    transform: `translateY(${5 * e}vmax)`
                },
                "parallax-0-50": {
                    transform: `translateY(${-5 * e}vmax)`
                }
            }
        }
    })
}, function (t, e) {
    $.extend($.fn.parallax.patterns, {
        imageMove: {
            clamp: !0,
            enableMq: "md-up",
            measureSelector: "picture",
            parallax: function () {
                const t = this.$container.height();
                return {
                    "parallax-100-0": {
                        transform: "translateY(0%)"
                    },
                    "parallax-0-100": {
                        transform: `translateY(${(t - this.$measure.height()) / t * 100}%)`
                    }
                }
            }
        },
        imageMoveAlt: {
            clamp: !0,
            enableMq: "md-up",
            measureSelector: "picture",
            parallax: function () {
                const t = this.$container.height();
                return {
                    "parallax-100-0": {
                        transform: "translateY(0%)"
                    },
                    "parallax-0-100": {
                        transform: `translateY(${-((t - this.$measure.height()) / t * 100)}%)`
                    }
                }
            }
        },
        imageMoveFullscreen: {
            clamp: !0,
            enableMq: "md-up",
            measureSelector: "picture",
            "parallax-100-0": {
                transform: "translateY(-25%)"
            },
            "parallax-0-100": {
                transform: "translateY(25%)"
            }
        },
        imageScale: {
            clamp: !0,
            enableMq: null,
            measureSelector: "picture",
            "parallax-100-0": {
                transform: "scale(1.1)"
            },
            "parallax-0-100": {
                transform: "scale(1)"
            }
        }
    })
}, function (t, e) {
    $.extend($.fn.parallax.patterns, {
        sectionOut: {
            enableMq: "md-up",
            enableTouch: !1,
            clamp: !0,
            easing: "easeSectionInverse",
            "parallax-100-100": {
                transform: "translateY(calc(var(--lvh) * 0))"
            },
            "parallax--50-100": {
                transform: "translateY(calc(var(--lvh) * 70))"
            }
        },
        sectionOutSticky: {
            enableMq: "md-up",
            enableTouch: !1,
            clamp: !0,
            easing: "easeSection",
            "parallax-100-100": {
                transform: "translateY(calc(var(--lvh) * 0))"
            },
            "parallax--50-100": {
                transform: "translateY(calc(var(--lvh) * 70))"
            }
        },
        sectionOutApartment: {
            enableMq: "md-up",
            enableTouch: !1,
            clamp: !0,
            easing: "easeSectionInverse",
            "parallax-0-0": {
                transform: "translateY(calc(var(--lvh) * 0))"
            },
            "parallax-0-100": {
                transform: "translateY(calc(var(--lvh) * 20))"
            }
        },
        sectionElement: {
            enableMq: "md-up",
            clamp: !0,
            parallax: function () {
                const t = this.options.sectionElementOffset || 10;
                return {
                    "parallax-100-0": {
                        transform: `translateY(calc(var(--lvh) * ${t}))`
                    },
                    "parallax-0-100": {
                        transform: `translateY(calc(var(--lvh) * -${t}))`
                    }
                }
            }
        },
        "section-shade": {
            measureSelector: ".shade-container",
            clamp: !0,
            "parallax-100-100": {
                opacity: 0
            },
            "parallax--50-100": {
                opacity: 1
            }
        },
        "section-shade-apartment": {
            measureSelector: ".shade-container",
            clamp: !0,
            "parallax-0-0": {
                opacity: 0
            },
            "parallax-0-100": {
                opacity: .6
            }
        }
    })
}, function (t, e) {
    $.extend($.fn.parallax.patterns, {
        "slider-text": {
            measureSelector: ".section",
            "parallax-50-0": {
                transform: "translateY(calc(var(--lvh) * 20))"
            },
            "parallax-50-50": {
                transform: "translateY(calc(var(--lvh) * 0))"
            }
        },
        "slider-image": {
            measureSelector: ".section",
            "parallax-50-0": {
                transform: "translateY(calc(var(--lvh) * 10))"
            },
            "parallax-50-50": {
                transform: "translateY(calc(var(--lvh) * 0))"
            }
        }
    })
}, function (t, e) {
    $.extend($.fn.parallax.patterns, {
        footer: {
            enableMq: "md-up",
            enableTouch: !1,
            clamp: !0,
            "parallax-100-0": {
                transform: "translateY(-50%)"
            },
            "parallax-100-100": {
                transform: "translateY(0%)"
            }
        }
    })
}, function (t, e) {
    $.extend($.fn.parallax.patterns, {
        "gradient-animation": {
            enableMq: "md-up",
            clamp: !0,
            measureSelector: ".js-gradient-animation",
            "parallax-100-0": {
                transform: "translateY(0%)"
            },
            "parallax-0-100": {
                transform: "translateY(-35%)"
            }
        },
        "gradient-location-inforgraphic": {
            enableMq: null,
            clamp: !1,
            "parallax-0-0": {
                transform: "translateY(0%)"
            },
            "parallax-0-100": {
                transform: "translateY(-100%)"
            }
        },
        "gradient-developer-benefits": {
            enableMq: null,
            clamp: !1,
            "parallax-100-0": {
                transform: "translateY(0%)"
            },
            "parallax-0-100": {
                transform: "translateY(-100%)"
            }
        }
    })
}, function (t, e, n) {
    var i = n(115),
        r = n(166),
        s = n(167),
        a = n(74),
        o = n(93),
        l = n(116);
    t.exports = function (t, e, n, c) {
        var h = -1,
            u = r,
            d = !0,
            p = t.length,
            f = [],
            m = e.length;
        if (!p) return f;
        n && (e = a(e, o(n))), c ? (u = s, d = !1) : e.length >= 200 && (u = l, d = !1, e = new i(e));
        t: for (; ++h < p;) {
            var g = t[h],
                v = null == n ? g : n(g);
            if (g = c || 0 !== g ? g : 0, d && v == v) {
                for (var y = m; y--;)
                    if (e[y] === v) continue t;
                f.push(g)
            } else u(e, v, c) || f.push(g)
        }
        return f
    }
}, function (t, e, n) {
    var i = n(58),
        r = n(127),
        s = n(67),
        a = r((function (t, e, n, r) {
            i(e, s(e), t, r)
        }));
    t.exports = a
}, function (t, e, n) {
    var i = n(217),
        r = n(124),
        s = n(229),
        a = r((function (t, e) {
            try {
                return i(t, void 0, e)
            } catch (t) {
                return s(t) ? t : new Error(t)
            }
        }));
    t.exports = a
}, function (t, e, n) {
    var i = n(71),
        r = Object.prototype,
        s = r.hasOwnProperty;
    t.exports = function (t, e, n, a) {
        return void 0 === t || i(t, r[n]) && !s.call(a, n) ? e : t
    }
}, function (t, e) {
    var n = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
    };
    t.exports = function (t) {
        return "\\" + n[t]
    }
}, function (t, e, n) {
    var i = n(31),
        r = {
            escape: n(397),
            evaluate: n(398),
            interpolate: n(231),
            variable: "",
            imports: {
                _: {
                    escape: i
                }
            }
        };
    t.exports = r
}, function (t, e, n) {
    var i = n(396)({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
    });
    t.exports = i
}, function (t, e) {
    t.exports = function (t) {
        return function (e) {
            return null == t ? void 0 : t[e]
        }
    }
}, function (t, e) {
    t.exports = /<%-([\s\S]+?)%>/g
}, function (t, e) {
    t.exports = /<%([\s\S]+?)%>/g
}, , , , , , , , , , , , , , , , , , , , , , , , , , , function (t, e, n) {
    var i = n(129),
        r = n(232);
    t.exports = function (t) {
        return r(i(t))
    }
}, function (t, e) {
    var n = Math.floor,
        i = Math.random;
    t.exports = function (t, e) {
        return t + n(i() * (e - t + 1))
    }
}, function (t, e, n) {
    var i = n(232),
        r = n(428);
    t.exports = function (t) {
        return i(r(t))
    }
}, function (t, e, n) {
    var i = n(230),
        r = n(57);
    t.exports = function (t) {
        return null == t ? [] : i(t, r(t))
    }
}]);

let deferredPrompt;

window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    document.getElementById('install-button').style.display = 'block';
});

document.getElementById('install-button').addEventListener('click', async () => {
    deferredPrompt.prompt();
    const { outcome } = await deferredPrompt.userChoice;
    deferredPrompt = null;
});

window.addEventListener('appinstalled', () => {
    document.getElementById('install-button').style.display = 'none';
    deferredPrompt = null;
});        